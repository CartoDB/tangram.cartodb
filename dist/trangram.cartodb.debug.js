(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.TangramCarto = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.CCSS = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = _dereq_('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":420}],2:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":43}],3:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":44}],4:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

var _from = _dereq_("../core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};
},{"../core-js/array/from":2}],5:[function(_dereq_,module,exports){

},{}],6:[function(_dereq_,module,exports){
(function (tree) {

tree.functions = {
    rgb: function (r, g, b) {
        return this.rgba(r, g, b, 1.0);
    },
    rgba: function (r, g, b, a) {
        var rgb = [r, g, b].map(function (c) { return number(c); });
        a = number(a);
        if (rgb.some(isNaN) || isNaN(a)) return null;
        return new tree.Color(rgb, a);
    },
    // Only require val
    stop: function (val) {
        var color, mode;
        if (arguments.length > 1) color = arguments[1];
        if (arguments.length > 2) mode = arguments[2];

        return {
            is: 'tag',
            val: val,
            color: color,
            mode: mode,
            toString: function(env) {
                return '\n\t<stop value="' + val.ev(env) + '"' +
                    (color ? ' color="' + color.ev(env) + '" ' : '') +
                    (mode ? ' mode="' + mode.ev(env) + '" ' : '') +
                    '/>';
            }
        };
    },
    hsl: function (h, s, l) {
        return this.hsla(h, s, l, 1.0);
    },
    hsla: function (h, s, l, a) {
        h = (number(h) % 360) / 360;
        s = number(s); l = number(l); a = number(a);
        if ([h, s, l, a].some(isNaN)) return null;

        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            m1 = l * 2 - m2;

        return this.rgba(hue(h + 1/3) * 255,
                         hue(h)       * 255,
                         hue(h - 1/3) * 255,
                         a);

        function hue(h) {
            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
            if      (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
            else if (h * 2 < 1) return m2;
            else if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
            else                return m1;
        }
    },
    hue: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().h));
    },
    saturation: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().s * 100), '%');
    },
    lightness: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().l * 100), '%');
    },
    alpha: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(color.toHSL().a);
    },
    saturate: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.s += amount.value / 100;
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    desaturate: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.s -= amount.value / 100;
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    lighten: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.l += amount.value / 100;
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    darken: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.l -= amount.value / 100;
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    fadein: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.a += amount.value / 100;
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    fadeout: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.a -= amount.value / 100;
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    spin: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();
        var hue = (hsl.h + amount.value) % 360;

        hsl.h = hue < 0 ? 360 + hue : hue;

        return hsla(hsl);
    },
    replace: function (entity, a, b) {
        if (entity.is === 'field') {
            return entity.toString + '.replace(' + a.toString() + ', ' + b.toString() + ')';
        } else {
            return entity.replace(a, b);
        }
    },
    //
    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein
    // http://sass-lang.com
    //
    mix: function (color1, color2, weight) {
        var p = weight.value / 100.0;
        var w = p * 2 - 1;
        var a = color1.toHSL().a - color2.toHSL().a;

        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;

        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
                   color1.rgb[1] * w1 + color2.rgb[1] * w2,
                   color1.rgb[2] * w1 + color2.rgb[2] * w2];

        var alpha = color1.alpha * p + color2.alpha * (1 - p);

        return new tree.Color(rgb, alpha);
    },
    greyscale: function (color) {
        return this.desaturate(color, new tree.Dimension(100));
    },
    '%': function (quoted /* arg, arg, ...*/) {
        var args = Array.prototype.slice.call(arguments, 1),
            str = quoted.value;

        for (var i = 0; i < args.length; i++) {
            str = str.replace(/%s/,    args[i].value)
                     .replace(/%[da]/, args[i].toString());
        }
        str = str.replace(/%%/g, '%');
        return new tree.Quoted(str);
    }
};

var image_filter_functors = [
    'emboss', 'blur', 'gray', 'sobel', 'edge-detect',
    'x-gradient', 'y-gradient', 'sharpen'];

for (var i = 0; i < image_filter_functors.length; i++) {
    var f = image_filter_functors[i];
    tree.functions[f] = (function(f) {
        return function() {
            return new tree.ImageFilter(f);
        };
    })(f);
}

tree.functions['agg-stack-blur'] = function(x, y) {
    return new tree.ImageFilter('agg-stack-blur', [x, y]);
};

tree.functions['scale-hsla'] = function(h0,h1,s0,s1,l0,l1,a0,a1) {
    return new tree.ImageFilter('scale-hsla', [h0,h1,s0,s1,l0,l1,a0,a1]);
};

function hsla(h) {
    return tree.functions.hsla(h.h, h.s, h.l, h.a);
}

function number(n) {
    if (n instanceof tree.Dimension) {
        return parseFloat(n.unit == '%' ? n.value / 100 : n.value);
    } else if (typeof(n) === 'number') {
        return n;
    } else {
        return NaN;
    }
}

function clamp(val) {
    return Math.min(1, Math.max(0, val));
}

})(_dereq_('./tree'));

},{"./tree":12}],7:[function(_dereq_,module,exports){
(function (process,__dirname){
var util = _dereq_('util'),
    fs = _dereq_('fs'),
    path = _dereq_('path');


function getVersion() {
    if (process.browser) {
        return _dereq_('../../package.json').version.split('.');
    } else if (parseInt(process.version.split('.')[1], 10) > 4) {
        return _dereq_('../../package.json').version.split('.');
    } else {
        // older node
        var package_json = JSON.parse(fs.readFileSync(path.join(__dirname,'../../package.json')));
        return package_json.version.split('.');
    }
}

var carto = {
    version: getVersion(),
    Parser: _dereq_('./parser').Parser,
    Renderer: _dereq_('./renderer').Renderer,
    tree: _dereq_('./tree'),
    RendererJS: _dereq_('./renderer_js'),
    default_reference: _dereq_('./torque-reference'),

    // @TODO
    writeError: function(ctx, options) {
        var message = '';
        var extract = ctx.extract;
        var error = [];

        options = options || {};

        if (options.silent) { return; }

        options.indent = options.indent || '';

        if (!('index' in ctx) || !extract) {
            return util.error(options.indent + (ctx.stack || ctx.message));
        }

        if (typeof(extract[0]) === 'string') {
            error.push(stylize((ctx.line - 1) + ' ' + extract[0], 'grey'));
        }

        if (extract[1] === '' && typeof extract[2] === 'undefined') {
            extract[1] = '¶';
        }
        error.push(ctx.line + ' ' + extract[1].slice(0, ctx.column) +
            stylize(stylize(extract[1][ctx.column], 'bold') +
            extract[1].slice(ctx.column + 1), 'yellow'));

        if (typeof(extract[2]) === 'string') {
            error.push(stylize((ctx.line + 1) + ' ' + extract[2], 'grey'));
        }
        error = options.indent + error.join('\n' + options.indent) + '\033[0m\n';

        message = options.indent + message + stylize(ctx.message, 'red');
        if (ctx.filename) (message += stylize(' in ', 'red') + ctx.filename);

        util.error(message, error);

        if (ctx.callLine) {
            util.error(stylize('from ', 'red') + (ctx.filename || ''));
            util.error(stylize(ctx.callLine, 'grey') + ' ' + ctx.callExtract);
        }
        if (ctx.stack) { util.error(stylize(ctx.stack, 'red')); }
    }
};

_dereq_('./tree/call');
_dereq_('./tree/color');
_dereq_('./tree/comment');
_dereq_('./tree/definition');
_dereq_('./tree/dimension');
_dereq_('./tree/element');
_dereq_('./tree/expression');
_dereq_('./tree/filterset');
_dereq_('./tree/filter');
_dereq_('./tree/field');
_dereq_('./tree/keyword');
_dereq_('./tree/layer');
_dereq_('./tree/literal');
_dereq_('./tree/operation');
_dereq_('./tree/quoted');
_dereq_('./tree/imagefilter');
_dereq_('./tree/reference');
_dereq_('./tree/rule');
_dereq_('./tree/ruleset');
_dereq_('./tree/selector');
_dereq_('./tree/style');
_dereq_('./tree/url');
_dereq_('./tree/value');
_dereq_('./tree/variable');
_dereq_('./tree/zoom');
_dereq_('./tree/invalid');
_dereq_('./tree/fontset');
_dereq_('./tree/frame_offset');
_dereq_('./functions');

for (var k in carto) { exports[k] = carto[k]; }

// Stylize a string
function stylize(str, style) {
    var styles = {
        'bold' : [1, 22],
        'inverse' : [7, 27],
        'underline' : [4, 24],
        'yellow' : [33, 39],
        'green' : [32, 39],
        'red' : [31, 39],
        'grey' : [90, 39]
    };
    return '\033[' + styles[style][0] + 'm' + str +
           '\033[' + styles[style][1] + 'm';
}

}).call(this,_dereq_('_process'),"/node_modules/carto/lib/carto")

},{"../../package.json":41,"./functions":6,"./parser":8,"./renderer":9,"./renderer_js":10,"./torque-reference":11,"./tree":12,"./tree/call":13,"./tree/color":14,"./tree/comment":15,"./tree/definition":16,"./tree/dimension":17,"./tree/element":18,"./tree/expression":19,"./tree/field":20,"./tree/filter":21,"./tree/filterset":22,"./tree/fontset":23,"./tree/frame_offset":24,"./tree/imagefilter":25,"./tree/invalid":26,"./tree/keyword":27,"./tree/layer":28,"./tree/literal":29,"./tree/operation":30,"./tree/quoted":31,"./tree/reference":32,"./tree/rule":33,"./tree/ruleset":34,"./tree/selector":35,"./tree/style":36,"./tree/url":37,"./tree/value":38,"./tree/variable":39,"./tree/zoom":40,"_process":105,"fs":5,"path":104,"util":420}],8:[function(_dereq_,module,exports){
(function (global){
var carto = exports,
    tree = _dereq_('./tree'),
    _ = global._ || _dereq_('underscore');

//    Token matching is done with the `$` function, which either takes
//    a terminal string or regexp, or a non-terminal function to call.
//    It also takes care of moving all the indices forwards.
carto.Parser = function Parser(env) {
    var input,       // LeSS input string
        i,           // current index in `input`
        j,           // current chunk
        temp,        // temporarily holds a chunk's state, for backtracking
        memo,        // temporarily holds `i`, when backtracking
        furthest,    // furthest index the parser has gone to
        chunks,      // chunkified input
        current,     // index of current chunk, in `input`
        parser;

    var that = this;

    // This function is called after all files
    // have been imported through `@import`.
    var finish = function() {};

    function save()    {
        temp = chunks[j];
        memo = i;
        current = i;
    }
    function restore() {
        chunks[j] = temp;
        i = memo;
        current = i;
    }

    function sync() {
        if (i > current) {
            chunks[j] = chunks[j].slice(i - current);
            current = i;
        }
    }
    //
    // Parse from a token, regexp or string, and move forward if match
    //
    function $(tok) {
        var match, args, length, c, index, endIndex, k;

        // Non-terminal
        if (tok instanceof Function) {
            return tok.call(parser.parsers);
        // Terminal
        // Either match a single character in the input,
        // or match a regexp in the current chunk (chunk[j]).
        } else if (typeof(tok) === 'string') {
            match = input.charAt(i) === tok ? tok : null;
            length = 1;
            sync();
        } else {
            sync();

            match = tok.exec(chunks[j]);
            if (match) {
                length = match[0].length;
            } else {
                return null;
            }
        }

        // The match is confirmed, add the match length to `i`,
        // and consume any extra white-space characters (' ' || '\n')
        // which come after that. The reason for this is that LeSS's
        // grammar is mostly white-space insensitive.
        if (match) {
            var mem = i += length;
            endIndex = i + chunks[j].length - length;

            while (i < endIndex) {
                c = input.charCodeAt(i);
                if (! (c === 32 || c === 10 || c === 9)) { break; }
                i++;
            }
            chunks[j] = chunks[j].slice(length + (i - mem));
            current = i;

            if (chunks[j].length === 0 && j < chunks.length - 1) { j++; }

            if (typeof(match) === 'string') {
                return match;
            } else {
                return match.length === 1 ? match[0] : match;
            }
        }
    }

    // Same as $(), but don't change the state of the parser,
    // just return the match.
    function peek(tok) {
        if (typeof(tok) === 'string') {
            return input.charAt(i) === tok;
        } else {
            return !!tok.test(chunks[j]);
        }
    }

    function extractErrorLine(style, errorIndex) {
        return (style.slice(0, errorIndex).match(/\n/g) || '').length + 1;
    }


    // Make an error object from a passed set of properties.
    // Accepted properties:
    // - `message`: Text of the error message.
    // - `filename`: Filename where the error occurred.
    // - `index`: Char. index where the error occurred.
    function makeError(err) {
        var einput;
        var errorTemplate;

        _.defaults(err, {
            index: furthest,
            filename: env.filename,
            message: 'Parse error.',
            line: 0,
            column: -1
        });

        if (err.filename && that.env.inputs && that.env.inputs[err.filename]) {
            einput = that.env.inputs[err.filename];
        } else {
            einput = input;
        }

        err.line = extractErrorLine(einput, err.index);
        for (var n = err.index; n >= 0 && einput.charAt(n) !== '\n'; n--) {
            err.column++;
        }
        errorTemplate = _.template('<%=filename%>:<%=line%>:<%=column%> <%=message%>');
        return new Error(errorTemplate(err));
    }

    this.env = env = env || {};
    this.env.filename = this.env.filename || null;
    this.env.inputs = this.env.inputs || {};

    // The Parser
    parser = {

        extractErrorLine: extractErrorLine,
        //
        // Parse an input string into an abstract syntax tree.
        // Throws an error on parse errors.
        parse: function(str) {
            var root, start, end, zone, line, lines, buff = [], c, error = null;

            i = j = current = furthest = 0;
            chunks = [];
            input = str.replace(/\r\n/g, '\n');
            if (env.filename) {
                that.env.inputs[env.filename] = input;
            }

            var early_exit = false;

            // Split the input into chunks.
            chunks = (function (chunks) {
                var j = 0,
                    skip = /(?:@\{[\w-]+\}|[^"'`\{\}\/\(\)\\])+/g,
                    comment = /\/\*(?:[^*]|\*+[^\/*])*\*+\/|\/\/.*/g,
                    string = /"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'|`((?:[^`]|\\.)*)`/g,
                    level = 0,
                    match,
                    chunk = chunks[0],
                    inParam;

                for (var i = 0, c, cc; i < input.length;) {
                    skip.lastIndex = i;
                    if (match = skip.exec(input)) {
                        if (match.index === i) {
                            i += match[0].length;
                            chunk.push(match[0]);
                        }
                    }
                    c = input.charAt(i);
                    comment.lastIndex = string.lastIndex = i;

                    if (match = string.exec(input)) {
                        if (match.index === i) {
                            i += match[0].length;
                            chunk.push(match[0]);
                            continue;
                        }
                    }

                    if (!inParam && c === '/') {
                        cc = input.charAt(i + 1);
                        if (cc === '/' || cc === '*') {
                            if (match = comment.exec(input)) {
                                if (match.index === i) {
                                    i += match[0].length;
                                    chunk.push(match[0]);
                                    continue;
                                }
                            }
                        }
                    }

                    switch (c) {
                        case '{': if (! inParam) { level ++;        chunk.push(c);                           break; }
                        case '}': if (! inParam) { level --;        chunk.push(c); chunks[++j] = chunk = []; break; }
                        case '(': if (! inParam) { inParam = true;  chunk.push(c);                           break; }
                        case ')': if (  inParam) { inParam = false; chunk.push(c);                           break; }
                        default:                                    chunk.push(c);
                    }

                    i++;
                }
                if (level !== 0) {
                    error = {
                        index: i - 1,
                        type: 'Parse',
                        message: (level > 0) ? "missing closing `}`" : "missing opening `{`"
                    };
                }

                return chunks.map(function (c) { return c.join(''); });
            })([[]]);

            if (error) {
                throw makeError(error);
            }

            // Start with the primary rule.
            // The whole syntax tree is held under a Ruleset node,
            // with the `root` property set to true, so no `{}` are
            // output.
            root = new tree.Ruleset([], $(this.parsers.primary));
            root.root = true;

            // Get an array of Ruleset objects, flattened
            // and sorted according to specificitySort
            root.toList = (function() {
                var line, lines, column;
                return function(env) {
                    env.error = function(e) {
                        if (!env.errors) env.errors = new Error('');
                        if (env.errors.message) {
                            env.errors.message += '\n' + makeError(e).message;
                        } else {
                            env.errors.message = makeError(e).message;
                        }
                    };
                    env.frames = env.frames || [];


                    // call populates Invalid-caused errors
                    var definitions = this.flatten([], [], env);
                    definitions.sort(specificitySort);
                    return definitions;
                };
            })();

            // Sort rules by specificity: this function expects selectors to be
            // split already.
            //
            // Written to be used as a .sort(Function);
            // argument.
            //
            // [1, 0, 0, 467] > [0, 0, 1, 520]
            var specificitySort = function(a, b) {
                var as = a.specificity;
                var bs = b.specificity;

                if (as[0] != bs[0]) return bs[0] - as[0];
                if (as[1] != bs[1]) return bs[1] - as[1];
                if (as[2] != bs[2]) return bs[2] - as[2];
                return bs[3] - as[3];
            };

            return root;
        },

        // Here in, the parsing rules/functions
        //
        // The basic structure of the syntax tree generated is as follows:
        //
        //   Ruleset ->  Rule -> Value -> Expression -> Entity
        //
        //  In general, most rules will try to parse a token with the `$()` function, and if the return
        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
        //  first, before parsing, that's when we use `peek()`.
        parsers: {
            // The `primary` rule is the *entry* and *exit* point of the parser.
            // The rules here can appear at any level of the parse tree.
            //
            // The recursive nature of the grammar is an interplay between the `block`
            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
            // as represented by this simplified grammar:
            //
            //     primary  →  (ruleset | rule)+
            //     ruleset  →  selector+ block
            //     block    →  '{' primary '}'
            //
            // Only at one point is the primary rule not called from the
            // block rule: at the root level.
            primary: function() {
                var node, root = [];

                while ((node = $(this.rule) || $(this.ruleset) ||
                               $(this.comment)) ||
                               $(/^[\s\n]+/) || (node = $(this.invalid))) {
                    if (node) root.push(node);
                }
                return root;
            },

            invalid: function () {
                var chunk = $(/^[^;\n]*[;\n]/);

                // To fail gracefully, match everything until a semicolon or linebreak.
                if (chunk) {
                    return new tree.Invalid(chunk, memo);
                }
            },

            // We create a Comment node for CSS comments `/* */`,
            // but keep the LeSS comments `//` silent, by just skipping
            // over them.
            comment: function() {
                var comment;

                if (input.charAt(i) !== '/') return;

                if (input.charAt(i + 1) === '/') {
                    return new tree.Comment($(/^\/\/.*/), true);
                } else if (comment = $(/^\/\*(?:[^*]|\*+[^\/*])*\*+\/\n?/)) {
                    return new tree.Comment(comment);
                }
            },

            // Entities are tokens which can be found inside an Expression
            entities: {

                // A string, which supports escaping " and ' "milky way" 'he\'s the one!'
                quoted: function() {
                    if (input.charAt(i) !== '"' && input.charAt(i) !== "'") return;
                    var str = $(/^"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'/);
                    if (str) {
                        return new tree.Quoted(str[1] || str[2]);
                    }
                },

                // A reference to a Mapnik field, like [NAME]
                // Behind the scenes, this has the same representation, but Carto
                // needs to be careful to warn when unsupported operations are used.
                field: function() {
                    if (! $('[')) return;
                    var field_name = $(/(^[^\]]+)/);
                    if (! $(']')) return;
                    if (field_name) return new tree.Field(field_name[1]);
                },

                // This is a comparison operator
                comparison: function() {
                    var str = $(/^=~|=|!=|<=|>=|<|>/);
                    if (str) {
                        return str;
                    }
                },

                // A catch-all word, such as: hard-light
                // These can start with either a letter or a dash (-),
                // and then contain numbers, underscores, and letters.
                keyword: function() {
                    var k = $(/^[A-Za-z-]+[A-Za-z-0-9_]*/);
                    if (k) { return new tree.Keyword(k); }
                },

                // A function call like rgb(255, 0, 255)
                // The arguments are parsed with the `entities.arguments` parser.
                call: function() {
                    var name, args;

                    if (!(name = /^([\w\-]+|%)\(/.exec(chunks[j]))) return;

                    name = name[1];

                    if (name === 'url') {
                        // url() is handled by the url parser instead
                        return null;
                    } else {
                        i += name.length;
                    }

                    $('('); // Parse the '(' and consume whitespace.

                    args = $(this.entities['arguments']);

                    if (!$(')')) return;

                    if (name) {
                        return new tree.Call(name, args, i);
                    }
                },
                // Arguments are comma-separated expressions
                'arguments': function() {
                    var args = [], arg;

                    while (arg = $(this.expression)) {
                        args.push(arg);
                        if (! $(',')) { break; }
                    }

                    return args;
                },
                literal: function() {
                    return $(this.entities.dimension) ||
                        $(this.entities.keywordcolor) ||
                        $(this.entities.hexcolor) ||
                        $(this.entities.quoted);
                },

                // Parse url() tokens
                //
                // We use a specific rule for urls, because they don't really behave like
                // standard function calls. The difference is that the argument doesn't have
                // to be enclosed within a string, so it can't be parsed as an Expression.
                url: function() {
                    var value;

                    if (input.charAt(i) !== 'u' || !$(/^url\(/)) return;
                    value = $(this.entities.quoted) || $(this.entities.variable) ||
                            $(/^[\-\w%@$\/.&=:;#+?~]+/) || '';
                    if (! $(')')) {
                        return new tree.Invalid(value, memo, 'Missing closing ) in URL.');
                    } else {
                        return new tree.URL((typeof value.value !== 'undefined' ||
                            value instanceof tree.Variable) ?
                            value : new tree.Quoted(value));
                    }
                },

                // A Variable entity, such as `@fink`, in
                //
                //     width: @fink + 2px
                //
                // We use a different parser for variable definitions,
                // see `parsers.variable`.
                variable: function() {
                    var name, index = i;

                    if (input.charAt(i) === '@' && (name = $(/^@[\w-]+/))) {
                        return new tree.Variable(name, index, env.filename);
                    }
                },

                hexcolor: function() {
                    var rgb;
                    if (input.charAt(i) === '#' && (rgb = $(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/))) {
                        return new tree.Color(rgb[1]);
                    }
                },

                keywordcolor: function() {
                    var rgb = chunks[j].match(/^[a-z]+/);
                    if (rgb && rgb[0] in tree.Reference.data.colors) {
                        return new tree.Color(tree.Reference.data.colors[$(/^[a-z]+/)]);
                    }
                },

                // A Dimension, that is, a number and a unit. The only
                // unit that has an effect is %
                dimension: function() {
                    var c = input.charCodeAt(i);
                    if ((c > 57 || c < 45) || c === 47) return;
                    var value = $(/^(-?\d*\.?\d+(?:[eE][-+]?\d+)?)(\%|\w+)?/);
                    if (value) {
                        return new tree.Dimension(value[1], value[2], memo);
                    }
                }

            },

            // The variable part of a variable definition.
            // Used in the `rule` parser. Like @fink:
            variable: function() {
                var name;

                if (input.charAt(i) === '@' && (name = $(/^(@[\w-]+)\s*:/))) {
                    return name[1];
                }
            },

            // Entities are the smallest recognized token,
            // and can be found inside a rule's value.
            entity: function() {
                return $(this.entities.call) ||
                    $(this.entities.literal) ||
                    $(this.entities.field) ||
                    $(this.entities.variable) ||
                    $(this.entities.url) ||
                    $(this.entities.keyword);
            },

            // A Rule terminator. Note that we use `peek()` to check for '}',
            // because the `block` rule will be expecting it, but we still need to make sure
            // it's there, if ';' was ommitted.
            end: function() {
                return $(';') || peek('}');
            },

            // Elements are the building blocks for Selectors. They consist of
            // an element name, such as a tag a class, or `*`.
            element: function() {
                var e = $(/^(?:[.#][\w\-]+|\*|Map)/);
                if (e) return new tree.Element(e);
            },

            // Attachments allow adding multiple lines, polygons etc. to an
            // object. There can only be one attachment per selector.
            attachment: function() {
                var s = $(/^::([\w\-]+(?:\/[\w\-]+)*)/);
                if (s) return s[1];
            },

            // Selectors are made out of one or more Elements, see above.
            selector: function() {
                var a, attachment,
                    e, elements = [],
                    f, filters = new tree.Filterset(),
                    z, zooms = [],
                    frame_offset = tree.FrameOffset.none;
                    segments = 0, conditions = 0;

                while (
                        (e = $(this.element)) ||
                        (z = $(this.zoom)) ||
                        (fo = $(this.frame_offset)) ||
                        (f = $(this.filter)) ||
                        (a = $(this.attachment))
                    ) {
                    segments++;
                    if (e) {
                        elements.push(e);
                    } else if (z) {
                        zooms.push(z);
                        conditions++;
                    } else if (fo) {
                        frame_offset = fo;
                        conditions++;
                    } else if (f) {
                        var err = filters.add(f);
                        if (err) {
                            throw makeError({
                                message: err,
                                index: i - 1
                            });
                        }
                        conditions++;
                    } else if (attachment) {
                        throw makeError({
                            message: 'Encountered second attachment name.',
                            index: i - 1
                        });
                    } else {
                        attachment = a;
                    }

                    var c = input.charAt(i);
                    if (c === '{' || c === '}' || c === ';' || c === ',') { break; }
                }

                if (segments) {
                    return new tree.Selector(filters, zooms, frame_offset, elements, attachment, conditions, memo);
                }
            },

            filter: function() {
                save();
                var key, op, val;
                if (! $('[')) return;
                if (key = $(/^[a-zA-Z0-9\-_]+/) ||
                    $(this.entities.quoted) ||
                    $(this.entities.variable) ||
                    $(this.entities.keyword) ||
                    $(this.entities.field)) {
                    // TODO: remove at 1.0.0
                    if (key instanceof tree.Quoted) {
                        key = new tree.Field(key.toString());
                    }
                    if ((op = $(this.entities.comparison)) &&
                        (val = $(this.entities.quoted) ||
                             $(this.entities.variable) ||
                             $(this.entities.dimension) ||
                             $(this.entities.keyword) ||
                             $(this.entities.field))) {
                        if (! $(']')) {
                            throw makeError({
                                message: 'Missing closing ] of filter.',
                                index: memo - 1
                            });
                        }
                        if (!key.is) key = new tree.Field(key);
                        return new tree.Filter(key, op, val, memo, env.filename);
                    }
                }
            },

            frame_offset: function() {
                save();
                var op, val;
                if ($(/^\[\s*frame-offset/g) &&
                    (op = $(this.entities.comparison)) &&
                    (val = $(/^\d+/)) &&
                    $(']'))  {
                        return tree.FrameOffset(op, val, memo);
                }
            },

            zoom: function() {
                save();
                var op, val;
                if ($(/^\[\s*zoom/g) &&
                    (op = $(this.entities.comparison)) &&
                    (val = $(this.entities.variable) || $(this.entities.dimension)) && $(']')) {
                        return new tree.Zoom(op, val, memo);
                } else {
                    // backtrack
                    restore();
                }
            },

            // The `block` rule is used by `ruleset`
            // It's a wrapper around the `primary` rule, with added `{}`.
            block: function() {
                var content;

                if ($('{') && (content = $(this.primary)) && $('}')) {
                    return content;
                }
            },

            // div, .class, body > p {...}
            ruleset: function() {
                var selectors = [], s, f, l, rules, filters = [];
                save();

                while (s = $(this.selector)) {
                    selectors.push(s);
                    while ($(this.comment)) {}
                    if (! $(',')) { break; }
                    while ($(this.comment)) {}
                }
                if (s) {
                    while ($(this.comment)) {}
                }

                if (selectors.length > 0 && (rules = $(this.block))) {
                    if (selectors.length === 1 &&
                        selectors[0].elements.length &&
                        selectors[0].elements[0].value === 'Map') {
                        var rs = new tree.Ruleset(selectors, rules);
                        rs.isMap = true;
                        return rs;
                    }
                    return new tree.Ruleset(selectors, rules);
                } else {
                    // Backtrack
                    restore();
                }
            },

            rule: function() {
                var name, value, c = input.charAt(i);
                save();

                if (c === '.' || c === '#') { return; }

                if (name = $(this.variable) || $(this.property)) {
                    value = $(this.value);

                    if (value && $(this.end)) {
                        return new tree.Rule(name, value, memo, env.filename);
                    } else {
                        furthest = i;
                        restore();
                    }
                }
            },

            font: function() {
                var value = [], expression = [], weight, font, e;

                while (e = $(this.entity)) {
                    expression.push(e);
                }

                value.push(new tree.Expression(expression));

                if ($(',')) {
                    while (e = $(this.expression)) {
                        value.push(e);
                        if (! $(',')) { break; }
                    }
                }
                return new tree.Value(value);
            },

            // A Value is a comma-delimited list of Expressions
            // In a Rule, a Value represents everything after the `:`,
            // and before the `;`.
            value: function() {
                var e, expressions = [];

                while (e = $(this.expression)) {
                    expressions.push(e);
                    if (! $(',')) { break; }
                }

                if (expressions.length > 1) {
                    return new tree.Value(expressions.map(function(e) {
                        return e.value[0];
                    }));
                } else if (expressions.length === 1) {
                    return new tree.Value(expressions);
                }
            },
            // A sub-expression, contained by parenthensis
            sub: function() {
                var e, expressions = [];

                if ($('(')) {
                  while (e = $(this.expression)) {
                      expressions.push(e);
                      if (! $(',')) { break; }
                  }
                  $(')');
                }

                if (expressions.length > 1) {
                    return new tree.Value(expressions.map(function(e) {
                        return e.value[0];
                    }));
                } else if (expressions.length === 1) {
                    return new tree.Value(expressions);
                }
            },
            // This is a misnomer because it actually handles multiplication
            // and division.
            multiplication: function() {
                var m, a, op, operation;
                if (m = $(this.operand)) {
                    while ((op = ($('/') || $('*') || $('%'))) && (a = $(this.operand))) {
                        operation = new tree.Operation(op, [operation || m, a], memo);
                    }
                    return operation || m;
                }
            },
            addition: function() {
                var m, a, op, operation;
                if (m = $(this.multiplication)) {
                    while ((op = $(/^[-+]\s+/) || (input.charAt(i - 1) != ' ' && ($('+') || $('-')))) &&
                           (a = $(this.multiplication))) {
                        operation = new tree.Operation(op, [operation || m, a], memo);
                    }
                    return operation || m;
                }
            },

            // An operand is anything that can be part of an operation,
            // such as a Color, or a Variable
            operand: function() {
                return $(this.sub) || $(this.entity);
            },

            // Expressions either represent mathematical operations,
            // or white-space delimited Entities.  @var * 2
            expression: function() {
                var e, delim, entities = [], d;

                while (e = $(this.addition) || $(this.entity)) {
                    entities.push(e);
                }

                if (entities.length > 0) {
                    return new tree.Expression(entities);
                }
            },
            property: function() {
                var name = $(/^(([a-z][-a-z_0-9]*\/)?\*?-?[-a-z_0-9]+)\s*:/);
                if (name) return name[1];
            }
        }
    };
    return parser;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./tree":12,"underscore":417}],9:[function(_dereq_,module,exports){
(function (global){
var _ = global._ || _dereq_('underscore');
var carto = _dereq_('./index');

carto.Renderer = function Renderer(env, options) {
    this.env = env || {};
    this.options = options || {};
    this.options.mapnik_version = this.options.mapnik_version || '3.0.0';
};

/**
 * Prepare a MSS document (given as an string) into a
 * XML Style fragment (mostly useful for debugging)
 *
 * @param {String} data the mss contents as a string.
 */
carto.Renderer.prototype.renderMSS = function render(data) {
    // effects is a container for side-effects, which currently
    // are limited to FontSets.
    var env = _.defaults(this.env, {
        benchmark: false,
        validation_data: false,
        effects: []
    });

    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {
        throw new Error("Could not set mapnik version to " + this.options.mapnik_version);
    }

    var output = [];
    var styles = [];

    if (env.benchmark) console.time('Parsing MSS');
    var parser = (carto.Parser(env)).parse(data);
    if (env.benchmark) console.timeEnd('Parsing MSS');

    if (env.benchmark) console.time('Rule generation');
    var rule_list = parser.toList(env);
    if (env.benchmark) console.timeEnd('Rule generation');

    if (env.benchmark) console.time('Rule inheritance');
    var rules = inheritDefinitions(rule_list, env);
    if (env.benchmark) console.timeEnd('Rule inheritance');

    if (env.benchmark) console.time('Style sort');
    var sorted = sortStyles(rules,env);
    if (env.benchmark) console.timeEnd('Style sort');

    if (env.benchmark) console.time('Total Style generation');
    for (var k = 0, rule, style_name; k < sorted.length; k++) {
        rule = sorted[k];
        style_name = 'style' + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');
        styles.push(style_name);
        var bench_name = '\tStyle "'+style_name+'" (#'+k+') toXML';
        if (env.benchmark) console.time(bench_name);
        // env.effects can be modified by this call
        output.push(carto.tree.StyleXML(style_name, rule.attachment, rule, env));
        if (env.benchmark) console.timeEnd(bench_name);
    }
    if (env.benchmark) console.timeEnd('Total Style generation');
    if (env.errors) throw env.errors;
    return output.join('\n');
};

/**
 * Prepare a MML document (given as an object) into a
 * fully-localized XML file ready for Mapnik2 consumption
 *
 * @param {String} m - the JSON file as a string.
 */
carto.Renderer.prototype.render = function render(m) {
    // effects is a container for side-effects, which currently
    // are limited to FontSets.
    var env = _.defaults(this.env, {
        benchmark: false,
        validation_data: false,
        effects: [],
        ppi: 90.714
    });

    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {
        throw new Error("Could not set mapnik version to " + this.options.mapnik_version);
    }

    var output = [];

    // Transform stylesheets into definitions.
    var definitions = _.chain(m.Stylesheet)
        .map(function(s) {
            if (typeof s == 'string') {
                throw new Error("Stylesheet object is expected not a string: '" + s + "'");
            }
            // Passing the environment from stylesheet to stylesheet,
            // allows frames and effects to be maintained.
            env = _.extend(env, {filename:s.id});

            var time = +new Date(),
                root = (carto.Parser(env)).parse(s.data);
            if (env.benchmark)
                console.warn('Parsing time: ' + (new Date() - time) + 'ms');
            return root.toList(env);
        })
        .flatten()
        .value();

    function appliesTo(name, classIndex) {
        return function(definition) {
            return definition.appliesTo(l.name, classIndex);
        };
    }

    // Iterate through layers and create styles custom-built
    // for each of them, and apply those styles to the layers.
    var styles, l, classIndex, rules, sorted, matching;
    for (var i = 0; i < m.Layer.length; i++) {
        l = m.Layer[i];
        styles = [];
        classIndex = {};

        if (env.benchmark) console.warn('processing layer: ' + l.id);
        // Classes are given as space-separated alphanumeric strings.
        var classes = (l['class'] || '').split(/\s+/g);
        for (var j = 0; j < classes.length; j++) {
            classIndex[classes[j]] = true;
        }
        matching = definitions.filter(appliesTo(l.name, classIndex));
        rules = inheritDefinitions(matching, env);
        sorted = sortStyles(rules, env);

        for (var k = 0, rule, style_name; k < sorted.length; k++) {
            rule = sorted[k];
            style_name = l.name + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');

            // env.effects can be modified by this call
            var styleXML = carto.tree.StyleXML(style_name, rule.attachment, rule, env);

            if (styleXML) {
                output.push(styleXML);
                styles.push(style_name);
            }
        }

        output.push(carto.tree.LayerXML(l, styles));
    }

    output.unshift(env.effects.map(function(e) {
        return e.toXML(env);
    }).join('\n'));

    var map_properties = getMapProperties(m, definitions, env);

    // Exit on errors.
    if (env.errors) throw env.errors;

    // Pass TileJSON and other custom parameters through to Mapnik XML.
    var parameters = _.reduce(m, function(memo, v, k) {
        if (!v && v !== 0) return memo;

        switch (k) {
        // Known skippable properties.
        case 'srs':
        case 'Layer':
        case 'Stylesheet':
            break;
        // Non URL-bound TileJSON properties.
        case 'bounds':
        case 'center':
        case 'minzoom':
        case 'maxzoom':
        case 'version':
            memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            break;
        // Properties that require CDATA.
        case 'name':
        case 'description':
        case 'legend':
        case 'attribution':
        case 'template':
            memo.push('  <Parameter name="' + k + '"><![CDATA[' + v + ']]></Parameter>');
            break;
        // Mapnik image format.
        case 'format':
            memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            break;
        // Mapnik interactivity settings.
        case 'interactivity':
            memo.push('  <Parameter name="interactivity_layer">' + v.layer + '</Parameter>');
            memo.push('  <Parameter name="interactivity_fields">' + v.fields + '</Parameter>');
            break;
        // Support any additional scalar properties.
        default:
            if ('string' === typeof v) {
                memo.push('  <Parameter name="' + k + '"><![CDATA[' + v + ']]></Parameter>');
            } else if ('number' === typeof v) {
                memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            } else if ('boolean' === typeof v) {
                memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            }
            break;
        }
        return memo;
    }, []);
    if (parameters.length) output.unshift(
        '<Parameters>\n' +
        parameters.join('\n') +
        '\n</Parameters>\n'
    );

    var properties = _.map(map_properties, function(v) { return ' ' + v; }).join('');

    output.unshift(
        '<?xml version="1.0" ' +
        'encoding="utf-8"?>\n' +
        '<!DOCTYPE Map[]>\n' +
        '<Map' + properties +'>\n');
    output.push('</Map>');
    return output.join('\n');
};

/**
 * This function currently modifies 'current'
 * @param {Array}  current  current list of rules
 * @param {Object} definition a Definition object to add to the rules
 * @param {Object} byFilter an object/dictionary of existing filters. This is
 * actually keyed `attachment->filter`
 * @param {Object} env the current environment
*/
function addRules(current, definition, byFilter, env) {
    var newFilters = definition.filters,
        newRules = definition.rules,
        updatedFilters, clone, previous;

    // The current definition might have been split up into
    // multiple definitions already.
    for (var k = 0; k < current.length; k++) {
        updatedFilters = current[k].filters.cloneWith(newFilters);
        if (updatedFilters) {
            previous = byFilter[updatedFilters];
            if (previous) {
                // There's already a definition with those exact
                // filters. Add the current definitions' rules
                // and stop processing it as the existing rule
                // has already gone down the inheritance chain.
                previous.addRules(newRules);
            } else {
                clone = current[k].clone(updatedFilters);
                // Make sure that we're only maintaining the clone
                // when we did actually add rules. If not, there's
                // no need to keep the clone around.
                if (clone.addRules(newRules)) {
                    // We inserted an element before this one, so we need
                    // to make sure that in the next loop iteration, we're
                    // not performing the same task for this element again,
                    // hence the k++.
                    byFilter[updatedFilters] = clone;
                    current.splice(k, 0, clone);
                    k++;
                }
            }
        } else if (updatedFilters === null) {
            // if updatedFilters is null, then adding the filters doesn't
            // invalidate or split the selector, so we addRules to the
            // combined selector

            // Filters can be added, but they don't change the
            // filters. This means we don't have to split the
            // definition.
            //
            // this is cloned here because of shared classes, see
            // sharedclass.mss
            current[k] = current[k].clone();
            current[k].addRules(newRules);
        }
        // if updatedFeatures is false, then the filters split the rule,
        // so they aren't the same inheritance chain
    }
    return current;
}

/**
 * Apply inherited styles from their ancestors to them.
 *
 * called either once per render (in the case of mss) or per layer
 * (for mml)
 *
 * @param {Object} definitions - a list of definitions objects
 *   that contain .rules
 * @param {Object} env - the environment
 * @return {Array<Array>} an array of arrays is returned,
 *   in which each array refers to a specific attachment
 */
function inheritDefinitions(definitions, env) {
    var inheritTime = +new Date();
    // definitions are ordered by specificity,
    // high (index 0) to low
    var byAttachment = {},
        byFilter = {};
    var result = [];
    var current, previous, attachment;

    // Evaluate the filters specified by each definition with the given
    // environment to correctly resolve variable references
    definitions.forEach(function(d) {
        d.filters.ev(env);
    });

    for (var i = 0; i < definitions.length; i++) {

        attachment = definitions[i].attachment;
        current = [definitions[i]];

        if (!byAttachment[attachment]) {
            byAttachment[attachment] = [];
            byAttachment[attachment].attachment = attachment;
            byFilter[attachment] = {};
            result.push(byAttachment[attachment]);
        }

        // Iterate over all subsequent rules.
        for (var j = i + 1; j < definitions.length; j++) {
            if (definitions[j].attachment === attachment) {
                // Only inherit rules from the same attachment.
                current = addRules(current, definitions[j], byFilter[attachment], env);
            }
        }

        for (var k = 0; k < current.length; k++) {
            byFilter[attachment][current[k].filters] = current[k];
            byAttachment[attachment].push(current[k]);
        }
    }

    if (env.benchmark) console.warn('Inheritance time: ' + ((new Date() - inheritTime)) + 'ms');

    return result;

}

// Sort styles by the minimum index of their rules.
// This sorts a slice of the styles, so it returns a sorted
// array but does not change the input.
function sortStylesIndex(a, b) { return b.index - a.index; }
function sortStyles(styles, env) {
    for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        style.index = Infinity;
        for (var b = 0; b < style.length; b++) {
            var rules = style[b].rules;
            for (var r = 0; r < rules.length; r++) {
                var rule = rules[r];
                if (rule.index < style.index) {
                    style.index = rule.index;
                }
            }
        }
    }

    var result = styles.slice();
    result.sort(sortStylesIndex);
    return result;
}

/**
 * Find a rule like Map { background-color: #fff; },
 * if any, and return a list of properties to be inserted
 * into the <Map element of the resulting XML. Translates
 * properties of the mml object at `m` directly into XML
 * properties.
 *
 * @param {Object} m the mml object.
 * @param {Array} definitions the output of toList.
 * @param {Object} env
 * @return {String} rendered properties.
 */
function getMapProperties(m, definitions, env) {
    var rules = {};
    var symbolizers = carto.tree.Reference.data.symbolizers.map;

    _(m).each(function(value, key) {
        if (key in symbolizers) rules[key] = key + '="' + value + '"';
    });

    definitions.filter(function(r) {
        return r.elements.join('') === 'Map';
    }).forEach(function(r) {
        for (var i = 0; i < r.rules.length; i++) {
            var key = r.rules[i].name;
            if (!(key in symbolizers)) {
                env.error({
                    message: 'Rule ' + key + ' not allowed for Map.',
                    index: r.rules[i].index
                });
            }
            rules[key] = r.rules[i].ev(env).toXML(env);
        }
    });
    return rules;
}

module.exports = carto;
module.exports.addRules = addRules;
module.exports.inheritDefinitions = inheritDefinitions;
module.exports.sortStyles = sortStyles;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./index":7,"underscore":417}],10:[function(_dereq_,module,exports){
(function (global){
(function(carto) {
var tree = _dereq_('./tree');
var _ = global._ || _dereq_('underscore');


function CartoCSS(style, options) {
  this.options = options || {};
  this.imageURLs = [];
  if(style) {
    this.setStyle(style);
  }
}

CartoCSS.Layer = function(shader, options) {
  this.options = options;
  this.shader = shader;
};


CartoCSS.Layer.prototype = {

  fullName: function() {
    return this.shader.attachment;
  },

  name: function() {
    return this.fullName().split('::')[0];
  },

  // frames this layer need to be rendered
  frames: function() {
    return this.shader.frames;
  },

  attachment: function() {
    return this.fullName().split('::')[1];
  },

  eval: function(prop) {
    var p = this.shader[prop];
    if (!p || !p.style) return;
    return p.style({}, { zoom: 0, 'frame-offset': 0 });
  },

  /*
   * `props`: feature properties
   * `context`: rendering properties, i.e zoom
   */
  getStyle: function(props, context) {
    var style = {};
    for(var i in this.shader) {
      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {
        style[i] = this.shader[i].style(props, context);
      }
    }
    return style;
  },

  /**
   * return the symbolizers that need to be rendered with 
   * this style. The order is the rendering order.
   * @returns a list with 3 possible values 'line', 'marker', 'polygon'
   */
  getSymbolizers: function() {
    return this.shader.symbolizers;
  },

  /**
   * returns if the style varies with some feature property.
   * Useful to optimize rendering
   */
  isVariable: function() {
    for(var i in this.shader) {
      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {
        if (!this.shader[i].constant) {
          return true;
        }
      }
    }
    return false;
  },

  getShader: function() {
    return this.shader;
  },

  /**
   * returns true if a feature needs to be rendered
   */
  filter: function(featureType, props, context) {
    for(var i in this.shader) {
     var s = this.shader[i](props, context);
     if(s) {
       return true;
     }
    }
    return false;
  },

  //
  // given a geoemtry type returns the transformed one acording the CartoCSS
  // For points there are two kind of types: point and sprite, the first one 
  // is a circle, second one is an image sprite
  //
  // the other geometry types are the same than geojson (polygon, linestring...)
  //
  transformGeometry: function(type) {
    return type;
  },

  transformGeometries: function(geojson) {
    return geojson;
  }

};

CartoCSS.prototype = {

  setStyle: function(style) {
    var layers = this.parse(style);
    if(!layers) {
      throw new Error(this.parse_env.errors);
    }
    this.layers = layers.map(function(shader) {
        return new CartoCSS.Layer(shader);
    });
  },

  getLayers: function() {
    return this.layers;
  },

  getDefault: function() {
    return this.findLayer({ attachment: '__default__' });
  },

  findLayer: function(where) {
    return _.find(this.layers, function(value) {
      for (var key in where) {
        var v = value[key];
        if (typeof(v) === 'function') {
          v = v.call(value);
        }
        if (where[key] !== v) return false;
      }
      return true;
    });
  },

  _createFn: function(ops) {
    var body = ops.join('\n');
    if(this.options.debug) console.log(body);
    return Function("data","ctx", "var _value = null; " +  body + "; return _value; ");
  },

  _compile: function(shader) {
    if(typeof shader === 'string') {
        shader = eval("(function() { return " + shader +"; })()");
    }
    this.shader_src = shader;
    for(var attr in shader) {
        var c = mapper[attr];
        if(c) {
            this.compiled[c] = eval("(function() { return shader[attr]; })();");
        }
    }
  },
  getImageURLs: function(){
    return this.imageURLs;
  },

  parse: function(cartocss) {
    var parse_env = {
      frames: [],
      errors: [],
      error: function(obj) {
        this.errors.push(obj);
      }
    };
    this.parse_env = parse_env;

    var ruleset = null;
    try {
      ruleset = (new carto.Parser(parse_env)).parse(cartocss);
    } catch(e) {
      // add the style.mss string to match the response from the server
      parse_env.errors.push(e.message);
      return;
    }
    if(ruleset) {

      function defKey(def) {
        return def.elements[0] + "::" + def.attachment;
      }
      var defs = ruleset.toList(parse_env);
      defs.reverse();
      // group by elements[0].value::attachment
      var layers = {};
      for(var i = 0; i < defs.length; ++i) {
        var def = defs[i];
        var key = defKey(def);
        var layer = layers[key] = (layers[key] || {
          symbolizers: []
        });
        for(var u = 0; u<def.rules.length; u++){
            if(def.rules[u].name === "marker-file" || def.rules[u].name === "point-file"){
                var value = def.rules[u].value.value[0].value[0].value.value;
                this.imageURLs.push(value);
            }
        } 
        layer.frames = [];
        layer.zoom = tree.Zoom.all;
        var props = def.toJS(parse_env);
        if (this.options.debug) console.log("props", props);
        for(var v in props) {
          var lyr = layer[v] = layer[v] || {
            constant: false,
            symbolizer: null,
            js: [],
            index: 0
          };
          // build javascript statements
          lyr.js.push(props[v].map(function(a) { return a.js; }).join('\n'));
          // get symbolizer for prop
          lyr.symbolizer = _.first(props[v].map(function(a) { return a.symbolizer; }));
          // serach the max index to know rendering order
          lyr.index = _.max(props[v].map(function(a) { return a.index; }).concat(lyr.index));
          lyr.constant = !_.any(props[v].map(function(a) { return !a.constant; }));
        }
      }

      var ordered_layers = [];
      if (this.options.debug) console.log(layers);

      var done = {};
      for(var i = 0; i < defs.length; ++i) {
        var def = defs[i];
        var k = defKey(def);
        var layer = layers[k];
        if(!done[k]) {
          if(this.options.debug) console.log("**", k);
          for(var prop in layer) {
            if (prop !== 'zoom' && prop !== 'frames' && prop !== 'symbolizers') {
              if(this.options.debug) console.log("*", prop);
              layer[prop].style = this._createFn(layer[prop].js);
              layer.symbolizers.push(layer[prop].symbolizer);
              layer.symbolizers = _.uniq(layer.symbolizers);
            }
          }
          layer.attachment = k;
          ordered_layers.push(layer);
          done[k] = true;
        }
        layer.zoom |= def.zoom;
        layer.frames.push(def.frame_offset);
      }

      // uniq the frames
      for(i = 0; i < ordered_layers.length; ++i) {
        ordered_layers[i].frames = _.uniq(ordered_layers[i].frames);
      }

      return ordered_layers;

    }
    return null;
  }
};


carto.RendererJS = function (options) {
    this.options = options || {};
    this.options.mapnik_version = this.options.mapnik_version || 'latest';
};

// Prepare a javascript object which contains the layers
carto.RendererJS.prototype.render = function render(cartocss, callback) {
    var reference = _dereq_('./torque-reference');
    tree.Reference.setData(reference.version.latest);
    return new CartoCSS(cartocss, this.options);
}

if(typeof(module) !== 'undefined') {
  module.exports = carto.RendererJS;
}


})(_dereq_('../carto'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../carto":7,"./torque-reference":11,"./tree":12,"underscore":417}],11:[function(_dereq_,module,exports){
var _mapnik_reference_latest = {
    "version": "2.1.1",
    "style": {
        "filter-mode": {
            "type": [
                "all",
                "first"
            ],
            "doc": "Control the processing behavior of Rule filters within a Style. If 'all' is used then all Rules are processed sequentially independent of whether any previous filters matched. If 'first' is used then it means processing ends after the first match (a positive filter evaluation) and no further Rules in the Style are processed ('first' is usually the default for CSS implementations on top of Mapnik to simplify translation from CSS to Mapnik XML)",
            "default-value": "all",
            "default-meaning": "All Rules in a Style are processed whether they have filters or not and whether or not the filter conditions evaluate to true."
        },
        "image-filters": {
            "css": "image-filters",
            "default-value": "none",
            "default-meaning": "no filters",
            "type": "functions",
            "functions": [
                ["agg-stack-blur", 2],
                ["emboss", 0],
                ["blur", 0],
                ["gray", 0],
                ["sobel", 0],
                ["edge-detect", 0],
                ["x-gradient", 0],
                ["y-gradient", 0],
                ["invert", 0],
                ["sharpen", 0],
                ["colorize-alpha", -1],
                ["color-to-alpha", 1],
                ["scale-hsla", 8]
            ],
            "doc": "A list of image filters."
        },
        "comp-op": {
            "css": "comp-op",
            "default-value": "src-over",
            "default-meaning": "add the current layer on top of other layers",
            "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
            "type": ["clear",
                "src",
                "dst",
                "src-over",
                "source-over", // added for torque
                "dst-over",
                "src-in",
                "dst-in",
                "src-out",
                "dst-out",
                "src-atop",
                "dst-atop",
                "xor",
                "plus",
                "minus",
                "multiply",
                "screen",
                "overlay",
                "darken",
                "lighten",
                "lighter", // added for torque
                "color-dodge",
                "color-burn",
                "hard-light",
                "soft-light",
                "difference",
                "exclusion",
                "contrast",
                "invert",
                "invert-rgb",
                "grain-merge",
                "grain-extract",
                "hue",
                "saturation",
                "color",
                "value"
            ]
        },
        "opacity": {
            "css": "opacity",
            "type": "float",
            "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
            "default-value": 1,
            "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
        }
    },
    "layer" : {
        "name": {
            "default-value": "",
            "type":"string",
            "required" : true,
            "default-meaning": "No layer name has been provided",
            "doc": "The name of a layer. Can be anything you wish and is not strictly validated, but ideally unique  in the map"
        },
        "srs": {
            "default-value": "",
            "type":"string",
            "default-meaning": "No srs value is provided and the value will be inherited from the Map's srs",
            "doc": "The spatial reference system definition for the layer, aka the projection. Can either be a proj4 literal string like '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs' or, if the proper proj4 epsg/nad/etc identifier files are installed, a string that uses an id like: '+init=epsg:4326'"
        },
        "status": {
            "default-value": true,
            "type":"boolean",
            "default-meaning": "This layer will be marked as active and available for processing",
            "doc": "A property that can be set to false to disable this layer from being processed"
        },
        "minzoom": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "The layer will be visible at the minimum possible scale",
            "doc": "The minimum scale denominator that this layer will be visible at. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "maxzoom": {
            "default-value": "1.79769e+308",
            "type":"float",
            "default-meaning": "The layer will be visible at the maximum possible scale",
            "doc": "The maximum scale denominator that this layer will be visible at. The default is the numeric limit of the C++ double type, which may vary slightly by system, but is likely a massive number like 1.79769e+308 and ensures that this layer will always be visible unless the value is reduced. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "queryable": {
            "default-value": false,
            "type":"boolean",
            "default-meaning": "The layer will not be available for the direct querying of data values",
            "doc": "This property was added for GetFeatureInfo/WMS compatibility and is rarely used. It is off by default meaning that in a WMS context the layer will not be able to be queried unless the property is explicitly set to true"
        },
        "clear-label-cache": {
            "default-value": false,
            "type":"boolean",
            "default-meaning": "The renderer's collision detector cache (used for avoiding duplicate labels and overlapping markers) will not be cleared immediately before processing this layer",
            "doc": "This property, by default off, can be enabled to allow a user to clear the collision detector cache before a given layer is processed. This may be desirable to ensure that a given layers data shows up on the map even if it normally would not because of collisions with previously rendered labels or markers"
        },
        "group-by": {
            "default-value": "",
            "type":"string",
            "default-meaning": "No special layer grouping will be used during rendering",
            "doc": "https://github.com/mapnik/mapnik/wiki/Grouped-rendering"
        },
        "buffer-size": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "No buffer will be used",
            "doc": "Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering"
        },
        "maximum-extent": {
            "default-value": "none",
            "type":"bbox",
            "default-meaning": "No clipping extent will be used",
            "doc": "An extent to be used to limit the bounds used to query this specific layer data during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Layer."
        }
    },
    "symbolizers" : {
        "*": {
            "image-filters": {
                "css": "image-filters",
                "default-value": "none",
                "default-meaning": "no filters",
                "type": "functions",
                "functions": [
                    ["agg-stack-blur", 2],
                    ["emboss", 0],
                    ["blur", 0],
                    ["gray", 0],
                    ["sobel", 0],
                    ["edge-detect", 0],
                    ["x-gradient", 0],
                    ["y-gradient", 0],
                    ["invert", 0],
                    ["sharpen", 0],
                    ["colorize-alpha", -1],
                    ["color-to-alpha", 1],
                    ["scale-hsla", 8],
                    ["buckets", -1],
                    ["category", -1],
                    ["equal", -1],
                    ["headtails", -1],
                    ["jenks", -1],
                    ["quantiles", -1],
                    ["cartocolor", -1],
                    ["colorbrewer", -1],
                    ["range", -1],
                    ["ramp", -1]
                ],
                "doc": "A list of image filters."
            },
            "comp-op": {
                "css": "comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current layer on top of other layers",
                "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "source-over", // added for torque
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "lighter", // added for torque
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            },
            "opacity": {
                "css": "opacity",
                "type": "float",
                "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
                "default-value": 1,
                "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
            }
        },
        "map": {
            "background-color": {
                "css": "background-color",
                "default-value": "none",
                "default-meaning": "transparent",
                "type": "color",
                "doc": "Map Background color"
            },
            "background-image": {
                "css": "background-image",
                "type": "uri",
                "default-value": "",
                "default-meaning": "transparent",
                "doc": "An image that is repeated below all features on a map as a background.",
                "description": "Map Background image"
            },
            "srs": {
                "css": "srs",
                "type": "string",
                "default-value": "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs",
                "default-meaning": "The proj4 literal of EPSG:4326 is assumed to be the Map's spatial reference and all data from layers within this map will be plotted using this coordinate system. If any layers do not declare an srs value then they will be assumed to be in the same srs as the Map and not transformations will be needed to plot them in the Map's coordinate space",
                "doc": "Map spatial reference (proj4 string)"
            },
            "buffer-size": {
                "css": "buffer-size",
                "default-value": "0",
                "type":"float",
                "default-meaning": "No buffer will be used",
                "doc": "Extra tolerance around the map (in pixels) used to ensure labels crossing tile boundaries are equally rendered in each tile (e.g. cut in each tile). Not intended to be used in combination with \"avoid-edges\"."
            },
            "maximum-extent": {
                "css": "",
                "default-value": "none",
                "type":"bbox",
                "default-meaning": "No clipping extent will be used",
                "doc": "An extent to be used to limit the bounds used to query all layers during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Map."
            },
            "base": {
                "css": "base",
                "default-value": "",
                "default-meaning": "This base path defaults to an empty string meaning that any relative paths to files referenced in styles or layers will be interpreted relative to the application process.",
                "type": "string",
                "doc": "Any relative paths used to reference files will be understood as relative to this directory path if the map is loaded from an in memory object rather than from the filesystem. If the map is loaded from the filesystem and this option is not provided it will be set to the directory of the stylesheet."
            },
            "paths-from-xml": {
                "css": "",
                "default-value": true,
                "default-meaning": "Paths read from XML will be interpreted from the location of the XML",
                "type": "boolean",
                "doc": "value to control whether paths in the XML will be interpreted from the location of the XML or from the working directory of the program that calls load_map()"
            },
            "minimum-version": {
                "css": "",
                "default-value": "none",
                "default-meaning": "Mapnik version will not be detected and no error will be thrown about compatibility",
                "type": "string",
                "doc": "The minumum Mapnik version (e.g. 0.7.2) needed to use certain functionality in the stylesheet"
            },
            "font-directory": {
                "css": "font-directory",
                "type": "uri",
                "default-value": "none",
                "default-meaning": "No map-specific fonts will be registered",
                "doc": "Path to a directory which holds fonts which should be registered when the Map is loaded (in addition to any fonts that may be automatically registered)."
            }
        },
        "polygon": {
            "fill": {
                "css": "polygon-fill",
                "type": "color",
                "default-value": "rgba(128,128,128,1)",
                "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
                "doc": "Fill color to assign to a polygon",
                "expression": true
            },
            "fill-opacity": {
                "css": "polygon-opacity",
                "type": "float",
                "doc": "The opacity of the polygon",
                "default-value": 1,
                "default-meaning": "opaque",
                "expression": true
            },
            "gamma": {
                "css": "polygon-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon edges"
            },
            "gamma-method": {
                "css": "polygon-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "clip": {
                "css": "polygon-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line": {
            "stroke": {
                "css": "line-color",
                "default-value": "rgba(0,0,0,1)",
                "type": "color",
                "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
                "doc": "The color of a drawn line",
                "expression": true
            },
            "stroke-width": {
                "css": "line-width",
                "default-value": 1,
                "type": "float",
                "doc": "The width of a line in pixels",
                "expression": true
            },
            "stroke-opacity": {
                "css": "line-opacity",
                "default-value": 1,
                "type": "float",
                "default-meaning": "opaque",
                "doc": "The opacity of a line"
            },
            "stroke-linejoin": {
                "css": "line-join",
                "default-value": "miter",
                "type": [
                    "miter",
                    "round",
                    "bevel"
                ],
                "doc": "The behavior of lines when joining"
            },
            "stroke-linecap": {
                "css": "line-cap",
                "default-value": "butt",
                "type": [
                    "butt",
                    "round",
                    "square"
                ],
                "doc": "The display of line endings"
            },
            "stroke-gamma": {
                "css": "line-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of stroke line"
            },
            "stroke-gamma-method": {
                "css": "line-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "stroke-dasharray": {
                "css": "line-dasharray",
                "type": "numbers",
                "doc": "A pair of length values [a,b], where (a) is the dash length and (b) is the gap length respectively. More than two values are supported for more complex patterns.",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-dashoffset": {
                "css": "line-dash-offset",
                "type": "numbers",
                "doc": "valid parameter but not currently used in renderers (only exists for experimental svg support in Mapnik which is not yet enabled)",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-miterlimit": {
                "css": "line-miterlimit",
                "type": "float",
                "doc": "The limit on the ratio of the miter length to the stroke-width. Used to automatically convert miter joins to bevel joins for sharp angles to avoid the miter extending beyond the thickness of the stroking path. Normally will not need to be set, but a larger value can sometimes help avoid jaggy artifacts.",
                "default-value": 4.0,
                "default-meaning": "Will auto-convert miters to bevel line joins when theta is less than 29 degrees as per the SVG spec: 'miterLength / stroke-width = 1 / sin ( theta / 2 )'"
            },
            "clip": {
                "css": "line-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "offset": {
                "css": "line-offset",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no offset",
                "doc": "Offsets a line a number of pixels parallel to its actual path. Postive values move the line left, negative values move it right (relative to the directionality of the line)."
            },
            "rasterizer": {
                "css": "line-rasterizer",
                "type": [
                    "full",
                    "fast"
                ],
                "default-value": "full",
                "doc": "Exposes an alternate AGG rendering method that sacrifices some accuracy for speed."
            },
            "geometry-transform": {
                "css": "line-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "markers": {
            "file": {
                "css": "marker-file",
                "doc": "An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.",
                "default-value": "",
                "default-meaning": "An ellipse or circle, if width equals height",
                "type": "uri",
                "expression": true
            },
            "opacity": {
                "css": "marker-opacity",
                "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
                "default-value": 1,
                "default-meaning": "The stroke-opacity and fill-opacity will be used",
                "type": "float"
            },
            "fill-opacity": {
                "css": "marker-fill-opacity",
                "doc": "The fill opacity of the marker",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float"
            },
            "stroke": {
                "css": "marker-line-color",
                "doc": "The color of the stroke around a marker shape.",
                "default-value": "black",
                "type": "color"
            },
            "stroke-width": {
                "css": "marker-line-width",
                "doc": "The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
                "type": "float"
            },
            "stroke-opacity": {
                "css": "marker-line-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "doc": "The opacity of a line",
                "type": "float"
            },
            "placement": {
                "css": "marker-placement",
                "type": [
                    "point",
                    "line",
                    "interior"
                ],
                "default-value": "point",
                "default-meaning": "Place markers at the center point (centroid) of the geometry",
                "doc": "Attempt to place markers on a point, in the center of a polygon, or if markers-placement:line, then multiple times along a line. 'interior' placement can be used to ensure that points placed on polygons are forced to be inside the polygon interior"
            },
            "multi-policy": {
                "css": "marker-multi-policy",
                "type": [
                    "each",
                    "whole",
                    "largest"
                ],
                "default-value": "each",
                "default-meaning": "If a feature contains multiple geometries and the placement type is either point or interior then a marker will be rendered for each",
                "doc": "A special setting to allow the user to control rendering behavior for 'multi-geometries' (when a feature contains multiple geometries). This setting does not apply to markers placed along lines. The 'each' policy is default and means all geometries will get a marker. The 'whole' policy means that the aggregate centroid between all geometries will be used. The 'largest' policy means that only the largest (by bounding box areas) feature will get a rendered marker (this is how text labeling behaves by default)."
            },
            "marker-type": {
                "css": "marker-type",
                "type": [
                    "arrow",
                    "ellipse",
                    "rectangle"
                ],
                "default-value": "ellipse",
                "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an arrow or an ellipse (a circle if height is equal to width)"
            },
            "width": {
                "css": "marker-width",
                "default-value": 10,
                "doc": "The width of the marker, if using one of the default types.",
                "type": "float",
                "expression": true
            },
            "height": {
                "css": "marker-height",
                "default-value": 10,
                "doc": "The height of the marker, if using one of the default types.",
                "type": "float",
                "expression": true
            },
            "fill": {
                "css": "marker-fill",
                "default-value": "blue",
                "doc": "The color of the area of the marker.",
                "type": "color",
                "expression": true
            },
            "allow-overlap": {
                "css": "marker-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping markers are shown or hidden.",
                "default-meaning": "Do not allow makers to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "marker-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "spacing": {
                "css": "marker-spacing",
                "doc": "Space between repeated labels",
                "default-value": 100,
                "type": "float"
            },
            "max-error": {
                "css": "marker-max-error",
                "type": "float",
                "default-value": 0.2,
                "doc": "The maximum difference between actual marker placement and the marker-spacing parameter. Setting a high value can allow the renderer to try to resolve placement conflicts with other symbolizers."
            },
            "transform": {
                "css": "marker-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "clip": {
                "css": "marker-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "marker-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "marker-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "marker-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "shield": {
            "name": {
                "css": "shield-name",
                "type": "string",
                "expression": true,
                "serialization": "content",
                "doc": "Value to use for a shield\"s text label. Data columns are specified using brackets like [column_name]"
            },
            "file": {
                "css": "shield-file",
                "required": true,
                "type": "uri",
                "default-value": "none",
                "doc": "Image file to render behind the shield text"
            },
            "face-name": {
                "css": "shield-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to use for the shield text",
                "default-value": "",
                "required": true
            },
            "unlock-image": {
                "css": "shield-unlock-image",
                "type": "boolean",
                "doc": "This parameter should be set to true if you are trying to position text beside rather than on top of the shield image",
                "default-value": false,
                "default-meaning": "text alignment relative to the shield image uses the center of the image as the anchor for text positioning."
            },
            "size": {
                "css": "shield-size",
                "type": "float",
                "doc": "The size of the shield text in pixels"
            },
            "fill": {
                "css": "shield-fill",
                "type": "color",
                "doc": "The color of the shield text"
            },
            "placement": {
                "css": "shield-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "How this shield should be placed. Point placement attempts to place it on top of points, line places along lines multiple times per feature, vertex places on the vertexes of polygons, and interior attempts to place inside of polygons."
            },
            "avoid-edges": {
                "css": "shield-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "type": "boolean",
                "default-value": false
            },
            "allow-overlap": {
                "css": "shield-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping shields are shown or hidden.",
                "default-meaning": "Do not allow shields to overlap with other map elements already placed."
            },
            "minimum-distance": {
                "css": "shield-min-distance",
                "type": "float",
                "default-value": 0,
                "doc": "Minimum distance to the next shield symbol, not necessarily the same shield."
            },
            "spacing": {
                "css": "shield-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "The spacing between repeated occurrences of the same shield on a line"
            },
            "minimum-padding": {
                "css": "shield-min-padding",
                "default-value": 0,
                "doc": "Determines the minimum amount of padding that a shield gets relative to other shields",
                "type": "float"
            },
            "wrap-width": {
                "css": "shield-wrap-width",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Length of a chunk of text in characters before wrapping text"
            },
            "wrap-before": {
                "css": "shield-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "shield-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long names."
            },
            "halo-fill": {
                "css": "shield-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "shield-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "character-spacing": {
                "css": "shield-character-spacing",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Horizontal spacing between characters (in pixels). Currently works for point placement only, not line placement."
            },
            "line-spacing": {
                "css": "shield-line-spacing",
                "doc": "Vertical spacing between lines of multiline labels (in pixels)",
                "type": "unsigned"
            },
            "dx": {
                "css": "shield-text-dx",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "shield-text-dy",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "shield-dx": {
                "css": "shield-dx",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "shield-dy": {
                "css": "shield-dy",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "opacity": {
                "css": "shield-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the image used for the shield",
                "default-value": 1
            },
            "text-opacity": {
                "css": "shield-text-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the text placed on top of the shield",
                "default-value": 1
            },
            "horizontal-alignment": {
                "css": "shield-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The shield's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "vertical-alignment": {
                "css": "shield-vertical-alignment",
                "type": [
                    "top",
                    "middle",
                    "bottom",
                    "auto"
                ],
                "doc": "The shield's vertical alignment from its centerpoint",
                "default-value": "middle"
            },
            "text-transform": {
                "css": "shield-text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "justify-alignment": {
                "css": "shield-justify-alignment",
                "type": [
                    "left",
                    "center",
                    "right",
                    "auto"
                ],
                "doc": "Define how text in a shield's label is justified",
                "default-value": "auto"
            },
            "clip": {
                "css": "shield-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "shield-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line-pattern": {
            "file": {
                "css": "line-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "An image file to be repeated and warped along a line",
                "expression": true
            },
            "clip": {
                "css": "line-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "line-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "polygon-pattern": {
            "file": {
                "css": "polygon-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "Image to use as a repeated pattern fill within a polygon",
                "expression": true
            },
            "alignment": {
                "css": "polygon-pattern-alignment",
                "type": [
                    "local",
                    "global"
                ],
                "default-value": "local",
                "doc": "Specify whether to align pattern fills to the layer or to the map."
            },
            "gamma": {
                "css": "polygon-pattern-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon pattern edges"
            },
            "opacity": {
                "css": "polygon-pattern-opacity",
                "type": "float",
                "doc": "(Default 1.0) - Apply an opacity level to the image used for the pattern",
                "default-value": 1,
                "default-meaning": "The image is rendered without modifications"
            },
            "clip": {
                "css": "polygon-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "raster": {
            "opacity": {
                "css": "raster-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float",
                "doc": "The opacity of the raster symbolizer on top of other symbolizers."
            },
            "filter-factor": {
                "css": "raster-filter-factor",
                "default-value": -1,
                "default-meaning": "Allow the datasource to choose appropriate downscaling.",
                "type": "float",
                "doc": "This is used by the Raster or Gdal datasources to pre-downscale images using overviews. Higher numbers can sometimes cause much better scaled image output, at the cost of speed."
            },
            "scaling": {
                "css": "raster-scaling",
                "type": [
                    "near",
                    "fast",
                    "bilinear",
                    "bilinear8",
                    "bicubic",
                    "spline16",
                    "spline36",
                    "hanning",
                    "hamming",
                    "hermite",
                    "kaiser",
                    "quadric",
                    "catrom",
                    "gaussian",
                    "bessel",
                    "mitchell",
                    "sinc",
                    "lanczos",
                    "blackman"
                ],
                "default-value": "near",
                "doc": "The scaling algorithm used to making different resolution versions of this raster layer. Bilinear is a good compromise between speed and accuracy, while lanczos gives the highest quality."
            },
            "mesh-size": {
                "css": "raster-mesh-size",
                "default-value": 16,
                "default-meaning": "Reprojection mesh will be 1/16 of the resolution of the source image",
                "type": "unsigned",
                "doc": "A reduced resolution mesh is used for raster reprojection, and the total image size is divided by the mesh-size to determine the quality of that mesh. Values for mesh-size larger than the default will result in faster reprojection but might lead to distortion."
            },
            "comp-op": {
                "css": "raster-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "point": {
            "file": {
                "css": "point-file",
                "type": "uri",
                "required": false,
                "default-value": "none",
                "doc": "Image file to represent a point"
            },
            "allow-overlap": {
                "css": "point-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping points are shown or hidden.",
                "default-meaning": "Do not allow points to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "point-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "opacity": {
                "css": "point-opacity",
                "type": "float",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "doc": "A value from 0 to 1 to control the opacity of the point"
            },
            "placement": {
                "css": "point-placement",
                "type": [
                    "centroid",
                    "interior"
                ],
                "doc": "How this point should be placed. Centroid calculates the geometric center of a polygon, which can be outside of it, while interior always places inside of a polygon.",
                "default-value": "centroid"
            },
            "transform": {
                "css": "point-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "comp-op": {
                "css": "point-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "text": {
            "name": {
                "css": "text-name",
                "type": "string",
                "expression": true,
                "required": true,
                "default-value": "",
                "serialization": "content",
                "doc": "Value to use for a text label. Data columns are specified using brackets like [column_name]"
            },
            "face-name": {
                "css": "text-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to render a label in",
                "required": true
            },
            "size": {
                "css": "text-size",
                "type": "float",
                "default-value": 10,
                "doc": "Text size in pixels"
            },
            "text-ratio": {
                "css": "text-ratio",
                "doc": "Define the amount of text (of the total) present on successive lines when wrapping occurs",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-width": {
                "css": "text-wrap-width",
                "doc": "Length of a chunk of text in characters before wrapping text",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-before": {
                "css": "text-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "text-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long text."
            },
            "spacing": {
                "css": "text-spacing",
                "type": "unsigned",
                "doc": "Distance between repeated text labels on a line (aka. label-spacing)"
            },
            "character-spacing": {
                "css": "text-character-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "Horizontal spacing adjustment between characters in pixels"
            },
            "line-spacing": {
                "css": "text-line-spacing",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Vertical spacing adjustment between lines in pixels"
            },
            "label-position-tolerance": {
                "css": "text-label-position-tolerance",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Allows the label to be displaced from its ideal position by a number of pixels (only works with placement:line)"
            },
            "max-char-angle-delta": {
                "css": "text-max-char-angle-delta",
                "type": "float",
                "default-value": "22.5",
                "doc": "The maximum angle change, in degrees, allowed between adjacent characters in a label. This value internally is converted to radians to the default is 22.5*math.pi/180.0. The higher the value the fewer labels will be placed around around sharp corners."
            },
            "fill": {
                "css": "text-fill",
                "doc": "Specifies the color for the text",
                "default-value": "#000000",
                "type": "color"
            },
            "opacity": {
                "css": "text-opacity",
                "doc": "A number from 0 to 1 specifying the opacity for the text",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "type": "float"
            },
            "halo-fill": {
                "css": "text-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "text-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "dx": {
                "css": "text-dx",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "text-dy",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "vertical-alignment": {
                "css": "text-vertical-alignment",
                "type": [
                  "top",
                  "middle",
                  "bottom",
                  "auto"
                ],
                "doc": "Position of label relative to point position.",
                "default-value": "auto",
                "default-meaning": "Default affected by value of dy; \"bottom\" for dy>0, \"top\" for dy<0."
            },
            "avoid-edges": {
                "css": "text-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "default-value": false,
                "type": "boolean"
            },
            "minimum-distance": {
                "css": "text-min-distance",
                "doc": "Minimum permitted distance to the next text symbolizer.",
                "type": "float"
            },
            "minimum-padding": {
                "css": "text-min-padding",
                "doc": "Determines the minimum amount of padding that a text symbolizer gets relative to other text",
                "type": "float"
            },
            "minimum-path-length": {
                "css": "text-min-path-length",
                "type": "float",
                "default-value": 0,
                "default-meaning": "place labels on all paths",
                "doc": "Place labels only on paths longer than this value."
            },
            "allow-overlap": {
                "css": "text-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping text is shown or hidden.",
                "default-meaning": "Do not allow text to overlap with other text - overlapping markers will not be shown."
            },
            "orientation": {
                "css": "text-orientation",
                "type": "float",
                "expression": true,
                "doc": "Rotate the text."
            },
            "placement": {
                "css": "text-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "Control the style of placement of a point versus the geometry it is attached to."
            },
            "placement-type": {
                "css": "text-placement-type",
                "doc": "Re-position and/or re-size text to avoid overlaps. \"simple\" for basic algorithm (using text-placements string,) \"dummy\" to turn this feature off.",
                "type": [
                    "dummy",
                    "simple"
                ],
                "default-value": "dummy"
            },
            "placements": {
                "css": "text-placements",
                "type": "string",
                "default-value": "",
                "doc": "If \"placement-type\" is set to \"simple\", use this \"POSITIONS,[SIZES]\" string. An example is `text-placements: \"E,NE,SE,W,NW,SW\";` "
            },
            "text-transform": {
                "css": "text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "horizontal-alignment": {
                "css": "text-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The text's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "justify-alignment": {
                "css": "text-align",
                "type": [
                    "left",
                    "right",
                    "center",
                    "auto"
                ],
                "doc": "Define how text is justified",
                "default-value": "auto",
                "default-meaning": "Auto alignment means that text will be centered by default except when using the `placement-type` parameter - in that case either right or left justification will be used automatically depending on where the text could be fit given the `text-placements` directives"
            },
            "clip": {
                "css": "text-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "text-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "building": {
            "fill": {
                "css": "building-fill",
                "default-value": "#FFFFFF",
                "doc": "The color of the buildings walls.",
                "type": "color"
            },
            "fill-opacity": {
                "css": "building-fill-opacity",
                "type": "float",
                "doc": "The opacity of the building as a whole, including all walls.",
                "default-value": 1
            },
            "height": {
                "css": "building-height",
                "doc": "The height of the building in pixels.",
                "type": "float",
                "expression": true,
                "default-value": "0"
            }
        },
        "torque": {
          "-torque-clear-color": {
              "css": "-torque-clear-color",
              "type": "color",
              "default-value": "rgba(255, 255, 255, 0)",
              "default-meaning": "full clear",
              "doc": "color used to clear canvas on each frame"
          },
          "-torque-frame-count": {
              "css": "-torque-frame-count",
              "default-value": "128",
              "type":"float",
              "default-meaning": "the data is broken into 128 time frames",
              "doc": "Number of animation steps/frames used in the animation. If the data contains a fewere number of total frames, the lesser value will be used."
          },
          "-torque-resolution": {
              "css": "-torque-resolution",
              "default-value": "2",
              "type":"float",
              "default-meaning": "",
              "doc": "Spatial resolution in pixels. A resolution of 1 means no spatial aggregation of the data. Any other resolution of N results in spatial aggregation into cells of NxN pixels. The value N must be power of 2"
          },
          "-torque-animation-duration": {
              "css": "-torque-animation-duration",
              "default-value": "30",
              "type":"float",
              "default-meaning": "the animation lasts 30 seconds",
              "doc": "Animation duration in seconds"
          },
          "-torque-aggregation-function": {
              "css": "-torque-aggregation-function",
              "default-value": "count(cartodb_id)",
              "type": "string",
              "default-meaning": "the value for each cell is the count of points in that cell",
              "doc": "A function used to calculate a value from the aggregate data for each cell. See -torque-resolution"
          },
          "-torque-time-attribute": {
              "css": "-torque-time-attribute",
              "default-value": "time",
              "type": "string",
              "default-meaning": "the data column in your table that is of a time based type",
              "doc": "The table column that contains the time information used create the animation"
          },
          "-torque-data-aggregation": {
              "css": "-torque-data-aggregation",
              "default-value": "linear",
              "type": [
                "linear",
                "cumulative"
              ],
              "default-meaning": "previous values are discarded",
              "doc": "A linear animation will discard previous values while a cumulative animation will accumulate them until it restarts"
          }
        }
    },
    "colors": {
        "aliceblue":  [240, 248, 255],
        "antiquewhite":  [250, 235, 215],
        "aqua":  [0, 255, 255],
        "aquamarine":  [127, 255, 212],
        "azure":  [240, 255, 255],
        "beige":  [245, 245, 220],
        "bisque":  [255, 228, 196],
        "black":  [0, 0, 0],
        "blanchedalmond":  [255,235,205],
        "blue":  [0, 0, 255],
        "blueviolet":  [138, 43, 226],
        "brown":  [165, 42, 42],
        "burlywood":  [222, 184, 135],
        "cadetblue":  [95, 158, 160],
        "chartreuse":  [127, 255, 0],
        "chocolate":  [210, 105, 30],
        "coral":  [255, 127, 80],
        "cornflowerblue":  [100, 149, 237],
        "cornsilk":  [255, 248, 220],
        "crimson":  [220, 20, 60],
        "cyan":  [0, 255, 255],
        "darkblue":  [0, 0, 139],
        "darkcyan":  [0, 139, 139],
        "darkgoldenrod":  [184, 134, 11],
        "darkgray":  [169, 169, 169],
        "darkgreen":  [0, 100, 0],
        "darkgrey":  [169, 169, 169],
        "darkkhaki":  [189, 183, 107],
        "darkmagenta":  [139, 0, 139],
        "darkolivegreen":  [85, 107, 47],
        "darkorange":  [255, 140, 0],
        "darkorchid":  [153, 50, 204],
        "darkred":  [139, 0, 0],
        "darksalmon":  [233, 150, 122],
        "darkseagreen":  [143, 188, 143],
        "darkslateblue":  [72, 61, 139],
        "darkslategrey":  [47, 79, 79],
        "darkturquoise":  [0, 206, 209],
        "darkviolet":  [148, 0, 211],
        "deeppink":  [255, 20, 147],
        "deepskyblue":  [0, 191, 255],
        "dimgray":  [105, 105, 105],
        "dimgrey":  [105, 105, 105],
        "dodgerblue":  [30, 144, 255],
        "firebrick":  [178, 34, 34],
        "floralwhite":  [255, 250, 240],
        "forestgreen":  [34, 139, 34],
        "fuchsia":  [255, 0, 255],
        "gainsboro":  [220, 220, 220],
        "ghostwhite":  [248, 248, 255],
        "gold":  [255, 215, 0],
        "goldenrod":  [218, 165, 32],
        "gray":  [128, 128, 128],
        "grey":  [128, 128, 128],
        "green":  [0, 128, 0],
        "greenyellow":  [173, 255, 47],
        "honeydew":  [240, 255, 240],
        "hotpink":  [255, 105, 180],
        "indianred":  [205, 92, 92],
        "indigo":  [75, 0, 130],
        "ivory":  [255, 255, 240],
        "khaki":  [240, 230, 140],
        "lavender":  [230, 230, 250],
        "lavenderblush":  [255, 240, 245],
        "lawngreen":  [124, 252, 0],
        "lemonchiffon":  [255, 250, 205],
        "lightblue":  [173, 216, 230],
        "lightcoral":  [240, 128, 128],
        "lightcyan":  [224, 255, 255],
        "lightgoldenrodyellow":  [250, 250, 210],
        "lightgray":  [211, 211, 211],
        "lightgreen":  [144, 238, 144],
        "lightgrey":  [211, 211, 211],
        "lightpink":  [255, 182, 193],
        "lightsalmon":  [255, 160, 122],
        "lightseagreen":  [32, 178, 170],
        "lightskyblue":  [135, 206, 250],
        "lightslategray":  [119, 136, 153],
        "lightslategrey":  [119, 136, 153],
        "lightsteelblue":  [176, 196, 222],
        "lightyellow":  [255, 255, 224],
        "lime":  [0, 255, 0],
        "limegreen":  [50, 205, 50],
        "linen":  [250, 240, 230],
        "magenta":  [255, 0, 255],
        "maroon":  [128, 0, 0],
        "mediumaquamarine":  [102, 205, 170],
        "mediumblue":  [0, 0, 205],
        "mediumorchid":  [186, 85, 211],
        "mediumpurple":  [147, 112, 219],
        "mediumseagreen":  [60, 179, 113],
        "mediumslateblue":  [123, 104, 238],
        "mediumspringgreen":  [0, 250, 154],
        "mediumturquoise":  [72, 209, 204],
        "mediumvioletred":  [199, 21, 133],
        "midnightblue":  [25, 25, 112],
        "mintcream":  [245, 255, 250],
        "mistyrose":  [255, 228, 225],
        "moccasin":  [255, 228, 181],
        "navajowhite":  [255, 222, 173],
        "navy":  [0, 0, 128],
        "oldlace":  [253, 245, 230],
        "olive":  [128, 128, 0],
        "olivedrab":  [107, 142, 35],
        "orange":  [255, 165, 0],
        "orangered":  [255, 69, 0],
        "orchid":  [218, 112, 214],
        "palegoldenrod":  [238, 232, 170],
        "palegreen":  [152, 251, 152],
        "paleturquoise":  [175, 238, 238],
        "palevioletred":  [219, 112, 147],
        "papayawhip":  [255, 239, 213],
        "peachpuff":  [255, 218, 185],
        "peru":  [205, 133, 63],
        "pink":  [255, 192, 203],
        "plum":  [221, 160, 221],
        "powderblue":  [176, 224, 230],
        "purple":  [128, 0, 128],
        "red":  [255, 0, 0],
        "rosybrown":  [188, 143, 143],
        "royalblue":  [65, 105, 225],
        "saddlebrown":  [139, 69, 19],
        "salmon":  [250, 128, 114],
        "sandybrown":  [244, 164, 96],
        "seagreen":  [46, 139, 87],
        "seashell":  [255, 245, 238],
        "sienna":  [160, 82, 45],
        "silver":  [192, 192, 192],
        "skyblue":  [135, 206, 235],
        "slateblue":  [106, 90, 205],
        "slategray":  [112, 128, 144],
        "slategrey":  [112, 128, 144],
        "snow":  [255, 250, 250],
        "springgreen":  [0, 255, 127],
        "steelblue":  [70, 130, 180],
        "tan":  [210, 180, 140],
        "teal":  [0, 128, 128],
        "thistle":  [216, 191, 216],
        "tomato":  [255, 99, 71],
        "turquoise":  [64, 224, 208],
        "violet":  [238, 130, 238],
        "wheat":  [245, 222, 179],
        "white":  [255, 255, 255],
        "whitesmoke":  [245, 245, 245],
        "yellow":  [255, 255, 0],
        "yellowgreen":  [154, 205, 50],
        "transparent":  [0, 0, 0, 0]
    },
    "filter": {
        "value": [
            "true",
            "false",
            "null",
            "point",
            "linestring",
            "polygon",
            "collection"
        ]
    }
}

module.exports = {
  version: {
    latest: _mapnik_reference_latest,
    '2.1.1': _mapnik_reference_latest
  }
};

},{}],12:[function(_dereq_,module,exports){
/**
 * TODO: document this. What does this do?
 */
if(typeof(module) !== "undefined") {
  module.exports.find = function (obj, fun) {
      for (var i = 0, r; i < obj.length; i++) {
          if (r = fun.call(obj, obj[i])) { return r; }
      }
      return null;
  };
}

},{}],13:[function(_dereq_,module,exports){
(function (global){
(function(tree) {
var _ = global._ || _dereq_('underscore');
tree.Call = function Call(name, args, index) {
    this.name = name;
    this.args = args;
    this.index = index;
};

tree.Call.prototype = {
    is: 'call',
    // When evuating a function call,
    // we either find the function in `tree.functions` [1],
    // in which case we call it, passing the  evaluated arguments,
    // or we simply print it out as it appeared originally [2].
    // The *functions.js* file contains the built-in functions.
    // The reason why we evaluate the arguments, is in the case where
    // we try to pass a variable to a function, like: `saturate(@color)`.
    // The function should receive the value, not the variable.
    'ev': function(env) {
        var args = this.args.map(function(a) { return a.ev(env); });

        for (var i = 0; i < args.length; i++) {
            if (args[i].is === 'undefined') {
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        }

        if (this.name in tree.functions) {
            if (tree.functions[this.name].length <= args.length) {
                var val = tree.functions[this.name].apply(tree.functions, args);
                if (val === null) {
                    env.error({
                        message: 'incorrect arguments given to ' + this.name + '()',
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return { is: 'undefined', value: 'undefined' };
                }
                return val;
            } else {
                env.error({
                    message: 'incorrect number of arguments for ' + this.name +
                        '(). ' + tree.functions[this.name].length + ' expected.',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        } else {
            var fn = tree.Reference.mapnikFunctions[this.name];
            if (fn === undefined) {
                var functions = _.pairs(tree.Reference.mapnikFunctions);
                // cheap closest, needs improvement.
                var name = this.name;
                var mean = functions.map(function(f) {
                    return [f[0], tree.Reference.editDistance(name, f[0]), f[1]];
                }).sort(function(a, b) {
                    return a[1] - b[1];
                });
                env.error({
                    message: 'unknown function ' + this.name + '(), did you mean ' +
                        mean[0][0] + '(' + mean[0][2] + ')',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
            if (fn !== args.length &&
                !(Array.isArray(fn) && _.include(fn, args.length)) &&
                // support variable-arg functions like `colorize-alpha`
                fn !== -1) {
                env.error({
                    message: 'function ' + this.name + '() takes ' +
                        fn + ' arguments and was given ' + args.length,
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            } else {
                // Save the evaluated versions of arguments
                this.args = args;
                return this;
            }
        }
    },

    toString: function(env, format) {
        if (this.args.length) {
            return this.name + '(' + this.args.join(',') + ')';
        } else {
            return this.name;
        }
    }
};

})(_dereq_('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":12,"underscore":417}],14:[function(_dereq_,module,exports){
(function(tree) {
// RGB Colors - #ff0014, #eee
// can be initialized with a 3 or 6 char string or a 3 or 4 element
// numerical array
tree.Color = function Color(rgb, a) {
    // The end goal here, is to parse the arguments
    // into an integer triplet, such as `128, 255, 0`
    //
    // This facilitates operations and conversions.
    if (Array.isArray(rgb)) {
        this.rgb = rgb.slice(0, 3);
    } else if (rgb.length == 6) {
        this.rgb = rgb.match(/.{2}/g).map(function(c) {
            return parseInt(c, 16);
        });
    } else {
        this.rgb = rgb.split('').map(function(c) {
            return parseInt(c + c, 16);
        });
    }

    if (typeof(a) === 'number') {
        this.alpha = a;
    } else if (rgb.length === 4) {
        this.alpha = rgb[3];
    } else {
        this.alpha = 1;
    }
};

tree.Color.prototype = {
    is: 'color',
    'ev': function() { return this; },

    // If we have some transparency, the only way to represent it
    // is via `rgba`. Otherwise, we use the hex representation,
    // which has better compatibility with older browsers.
    // Values are capped between `0` and `255`, rounded and zero-padded.
    toString: function() {
        if (this.alpha < 1.0) {
            return 'rgba(' + this.rgb.map(function(c) {
                return Math.round(c);
            }).concat(this.alpha).join(', ') + ')';
        } else {
            return '#' + this.rgb.map(function(i) {
                i = Math.round(i);
                i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);
                return i.length === 1 ? '0' + i : i;
            }).join('');
        }
    },

    // Operations have to be done per-channel, if not,
    // channels will spill onto each other. Once we have
    // our result, in the form of an integer triplet,
    // we create a new Color node to hold the result.
    operate: function(env, op, other) {
        var result = [];

        if (! (other instanceof tree.Color)) {
            other = other.toColor();
        }

        for (var c = 0; c < 3; c++) {
            result[c] = tree.operate(op, this.rgb[c], other.rgb[c]);
        }
        return new tree.Color(result);
    },

    toHSL: function() {
        var r = this.rgb[0] / 255,
            g = this.rgb[1] / 255,
            b = this.rgb[2] / 255,
            a = this.alpha;

        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2, d = max - min;

        if (max === min) {
            h = s = 0;
        } else {
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h * 360, s: s, l: l, a: a };
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],15:[function(_dereq_,module,exports){
(function(tree) {

tree.Comment = function Comment(value, silent) {
    this.value = value;
    this.silent = !!silent;
};

tree.Comment.prototype = {
    toString: function(env) {
        return '<!--' + this.value + '-->';
    },
    'ev': function() { return this; }
};

})(_dereq_('../tree'));

},{"../tree":12}],16:[function(_dereq_,module,exports){
(function (global){
(function(tree) {
var assert = _dereq_('assert'),
    _ = global._ || _dereq_('underscore');

// A definition is the combination of a selector and rules, like
// #foo {
//     polygon-opacity:1.0;
// }
//
// The selector can have filters
tree.Definition = function Definition(selector, rules) {
    this.elements = selector.elements;
    assert.ok(selector.filters instanceof tree.Filterset);
    this.rules = rules;
    this.ruleIndex = {};
    for (var i = 0; i < this.rules.length; i++) {
        if ('zoom' in this.rules[i]) this.rules[i] = this.rules[i].clone();
        this.rules[i].zoom = selector.zoom;
        this.ruleIndex[this.rules[i].updateID()] = true;
    }
    this.filters = selector.filters;
    this.zoom = selector.zoom;
    this.frame_offset = selector.frame_offset;
    this.attachment = selector.attachment || '__default__';
    this.specificity = selector.specificity();
};

tree.Definition.prototype.toString = function() {
    var str = this.filters.toString();
    for (var i = 0; i < this.rules.length; i++) {
        str += '\n    ' + this.rules[i];
    }
    return str;
};

tree.Definition.prototype.clone = function(filters) {
    if (filters) assert.ok(filters instanceof tree.Filterset);
    var clone = Object.create(tree.Definition.prototype);
    clone.rules = this.rules.slice();
    clone.ruleIndex = _.clone(this.ruleIndex);
    clone.filters = filters ? filters : this.filters.clone();
    clone.attachment = this.attachment;
    return clone;
};

tree.Definition.prototype.addRules = function(rules) {
    var added = 0;

    // Add only unique rules.
    for (var i = 0; i < rules.length; i++) {
        if (!this.ruleIndex[rules[i].id]) {
            this.rules.push(rules[i]);
            this.ruleIndex[rules[i].id] = true;
            added++;
        }
    }

    return added;
};

// Determine whether this selector matches a given id
// and array of classes, by determining whether
// all elements it contains match.
tree.Definition.prototype.appliesTo = function(id, classes) {
    for (var i = 0, l = this.elements.length; i < l; i++) {
        var elem = this.elements[i];
        if (!(elem.wildcard ||
            (elem.type === 'class' && classes[elem.clean]) ||
            (elem.type === 'id' && id === elem.clean))) return false;
    }
    return true;
};

function symbolizerName(symbolizer) {
    function capitalize(str) { return str[1].toUpperCase(); }
    return symbolizer.charAt(0).toUpperCase() +
           symbolizer.slice(1).replace(/\-./, capitalize) + 'Symbolizer';
}

// Get a simple list of the symbolizers, in order
function symbolizerList(sym_order) {
    return sym_order.sort(function(a, b) { return a[1] - b[1]; })
        .map(function(v) { return v[0]; });
}

tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
    var xml = zoom.toXML(env).join('') + this.filters.toXML(env);

    // Sort symbolizers by the index of their first property definition
    var sym_order = [], indexes = [];
    for (var key in symbolizers) {
        indexes = [];
        for (var prop in symbolizers[key]) {
            indexes.push(symbolizers[key][prop].index);
        }
        var min_idx = Math.min.apply(Math, indexes);
        sym_order.push([key, min_idx]);
    }

    sym_order = symbolizerList(sym_order);
    var sym_count = 0;

    for (var i = 0; i < sym_order.length; i++) {
        var attributes = symbolizers[sym_order[i]];
        var symbolizer = sym_order[i].split('/').pop();

        // Skip the magical * symbolizer which is used for universal properties
        // which are bubbled up to Style elements intead of Symbolizer elements.
        if (symbolizer === '*') continue;
        sym_count++;

        var fail = tree.Reference.requiredProperties(symbolizer, attributes);
        if (fail) {
            var rule = attributes[Object.keys(attributes).shift()];
            env.error({
                message: fail,
                index: rule.index,
                filename: rule.filename
            });
        }

        var name = symbolizerName(symbolizer);

        var selfclosing = true, tagcontent;
        xml += '    <' + name + ' ';
        for (var j in attributes) {
            if (symbolizer === 'map') env.error({
                message: 'Map properties are not permitted in other rules',
                index: attributes[j].index,
                filename: attributes[j].filename
            });
            var x = tree.Reference.selector(attributes[j].name);
            if (x && x.serialization && x.serialization === 'content') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else if (x && x.serialization && x.serialization === 'tag') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else {
                xml += attributes[j].ev(env).toXML(env) + ' ';
            }
        }
        if (selfclosing) {
            xml += '/>\n';
        } else if (typeof tagcontent !== "undefined") {
            if (tagcontent.indexOf('<') != -1) {
                xml += '>' + tagcontent + '</' + name + '>\n';
            } else {
                xml += '><![CDATA[' + tagcontent + ']]></' + name + '>\n';
            }
        }
    }
    if (!sym_count || !xml) return '';
    return '  <Rule>\n' + xml + '  </Rule>\n';
};

// Take a zoom range of zooms and 'i', the index of a rule in this.rules,
// and finds all applicable symbolizers
tree.Definition.prototype.collectSymbolizers = function(zooms, i) {
    var symbolizers = {}, child;

    for (var j = i; j < this.rules.length; j++) {
        child = this.rules[j];
        var key = child.instance + '/' + child.symbolizer;
        if (zooms.current & child.zoom &&
           (!(key in symbolizers) ||
           (!(child.name in symbolizers[key])))) {
            zooms.current &= child.zoom;
            if (!(key in symbolizers)) {
                symbolizers[key] = {};
            }
            symbolizers[key][child.name] = child;
        }
    }

    if (Object.keys(symbolizers).length) {
        zooms.rule &= (zooms.available &= ~zooms.current);
        return symbolizers;
    }
};

// The tree.Zoom.toString function ignores the holes in zoom ranges and outputs
// scaledenominators that cover the whole range from the first to last bit set.
// This algorithm can produces zoom ranges that may have holes. However,
// when using the filter-mode="first", more specific zoom filters will always
// end up before broader ranges. The filter-mode will pick those first before
// resorting to the zoom range with the hole and stop processing further rules.
tree.Definition.prototype.toXML = function(env, existing) {
    var filter = this.filters.toString();
    if (!(filter in existing)) existing[filter] = tree.Zoom.all;

    var available = tree.Zoom.all, xml = '', zoom, symbolizers,
        zooms = { available: tree.Zoom.all };
    for (var i = 0; i < this.rules.length && available; i++) {
        zooms.rule = this.rules[i].zoom;
        if (!(existing[filter] & zooms.rule)) continue;

        while (zooms.current = zooms.rule & available) {
            if (symbolizers = this.collectSymbolizers(zooms, i)) {
                if (!(existing[filter] & zooms.current)) continue;
                xml += this.symbolizersToXML(env, symbolizers,
                    (new tree.Zoom()).setZoom(existing[filter] & zooms.current));
                existing[filter] &= ~zooms.current;
            }
        }
    }

    return xml;
};

tree.Definition.prototype.toJS = function(env) {
  var shaderAttrs = {};

  // merge conditions from filters with zoom condition of the
  // definition
  var zoom = "(" + this.zoom + " & (1 << ctx.zoom))";
  var frame_offset = this.frame_offset;
  var _if = this.filters.toJS(env);
  var filters = [zoom];
  if(_if) filters.push(_if);
  if(frame_offset) filters.push('ctx["frame-offset"] === ' + frame_offset);
  _if = filters.join(" && ");
  _.each(this.rules, function(rule) {
      if(rule instanceof tree.Rule) {
        shaderAttrs[rule.name] = shaderAttrs[rule.name] || [];

        var r = {
          index: rule.index,
          symbolizer: rule.symbolizer
        };

        if (_if) {
          r.js = "if(" + _if + "){" + rule.value.toJS(env) + "}"
        } else {
          r.js = rule.value.toJS(env);
        }

        r.constant = rule.value.ev(env).is !== 'field';
        r.filtered = !!_if;

        shaderAttrs[rule.name].push(r);
      } else {
        throw new Error("Ruleset not supported");
        //if (rule instanceof tree.Ruleset) {
          //var sh = rule.toJS(env);
          //for(var v in sh) {
            //shaderAttrs[v] = shaderAttrs[v] || [];
            //for(var attr in sh[v]) {
              //shaderAttrs[v].push(sh[v][attr]);
            //}
          //}
        //}
      }
  });
  return shaderAttrs;
};


})(_dereq_('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":12,"assert":1,"underscore":417}],17:[function(_dereq_,module,exports){
(function (global){
(function(tree) {
var _ = global._ || _dereq_('underscore');
//
// A number with a unit
//
tree.Dimension = function Dimension(value, unit, index) {
    this.value = parseFloat(value);
    this.unit = unit || null;
    this.index = index;
};

tree.Dimension.prototype = {
    is: 'float',
    physical_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc'],
    screen_units: ['px', '%'],
    all_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc', 'px', '%'],
    densities: {
        m: 0.0254,
        mm: 25.4,
        cm: 2.54,
        pt: 72,
        pc: 6
    },
    ev: function (env) {
        if (this.unit && !_.contains(this.all_units, this.unit)) {
            env.error({
                message: "Invalid unit: '" + this.unit + "'",
                index: this.index
            });
            return { is: 'undefined', value: 'undefined' };
        }

        // normalize units which are not px or %
        if (this.unit && _.contains(this.physical_units, this.unit)) {
            if (!env.ppi) {
                env.error({
                    message: "ppi is not set, so metric units can't be used",
                    index: this.index
                });
                return { is: 'undefined', value: 'undefined' };
            }
            // convert all units to inch
            // convert inch to px using ppi
            this.value = (this.value / this.densities[this.unit]) * env.ppi;
            this.unit = 'px';
        }

        return this;
    },
    round: function() {
        this.value = Math.round(this.value);
        return this;
    },
    toColor: function() {
        return new tree.Color([this.value, this.value, this.value]);
    },
    round: function() {
        this.value = Math.round(this.value);
        return this;
    },
    toString: function() {
        return this.value.toString();
    },
    operate: function(env, op, other) {
        if (this.unit === '%' && other.unit !== '%') {
            env.error({
                message: 'If two operands differ, the first must not be %',
                index: this.index
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }

        if (this.unit !== '%' && other.unit === '%') {
            if (op === '*' || op === '/' || op === '%') {
                env.error({
                    message: 'Percent values can only be added or subtracted from other values',
                    index: this.index
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            return new tree.Dimension(tree.operate(op,
                    this.value, this.value * other.value * 0.01),
                this.unit);
        }

        //here the operands are either the same (% or undefined or px), or one is undefined and the other is px
        return new tree.Dimension(tree.operate(op, this.value, other.value),
            this.unit || other.unit);
    }
};

})(_dereq_('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":12,"underscore":417}],18:[function(_dereq_,module,exports){
(function(tree) {

// An element is an id or class selector
tree.Element = function Element(value) {
    this.value = value.trim();
    if (this.value[0] === '#') {
        this.type = 'id';
        this.clean = this.value.replace(/^#/, '');
    }
    if (this.value[0] === '.') {
        this.type = 'class';
        this.clean = this.value.replace(/^\./, '');
    }
    if (this.value.indexOf('*') !== -1) {
        this.type = 'wildcard';
    }
};

// Determine the 'specificity matrix' of this
// specific selector
tree.Element.prototype.specificity = function() {
    return [
        (this.type === 'id') ? 1 : 0, // a
        (this.type === 'class') ? 1 : 0  // b
    ];
};

tree.Element.prototype.toString = function() { return this.value; };

})(_dereq_('../tree'));

},{"../tree":12}],19:[function(_dereq_,module,exports){
(function(tree) {

tree.Expression = function Expression(value) {
    this.value = value;
};

tree.Expression.prototype = {
    is: 'expression',
    ev: function(env) {
        if (this.value.length > 1) {
            return new tree.Expression(this.value.map(function(e) {
                return e.ev(env);
            }));
        } else {
            return this.value[0].ev(env);
        }
    },

    toString: function(env) {
        return this.value.map(function(e) {
            return e.toString(env);
        }).join(' ');
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],20:[function(_dereq_,module,exports){
(function(tree) {

tree.Field = function Field(content) {
    this.value = content || '';
};

tree.Field.prototype = {
    is: 'field',
    toString: function() {
        return '[' + this.value + ']';
    },
    'ev': function() {
        return this;
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],21:[function(_dereq_,module,exports){
(function(tree) {

tree.Filter = function Filter(key, op, val, index, filename) {
    this.key = key;
    this.op = op;
    this.val = val;
    this.index = index;
    this.filename = filename;

    this.id = this.key + this.op + this.val;
};

// xmlsafe, numeric, suffix
var ops = {
    '<': [' &lt; ', 'numeric'],
    '>': [' &gt; ', 'numeric'],
    '=': [' = ', 'both'],
    '!=': [' != ', 'both'],
    '<=': [' &lt;= ', 'numeric'],
    '>=': [' &gt;= ', 'numeric'],
    '=~': ['.match(', 'string', ')']
};

tree.Filter.prototype.ev = function(env) {
    this.key = this.key.ev(env);
    this.val = this.val.ev(env);
    return this;
};

tree.Filter.prototype.toXML = function(env) {
    if (tree.Reference.data.filter) {
        if (this.key.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.key.toString())) {
            env.error({
                message: this.key.toString() + ' is not a valid keyword in a filter expression',
                index: this.index,
                filename: this.filename
            });
        }
        if (this.val.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.val.toString())) {
            env.error({
                message: this.val.toString() + ' is not a valid keyword in a filter expression',
                index: this.index,
                filename: this.filename
            });
        }
    }
    var key = this.key.toString(false);
    var val = this.val.toString(this.val.is == 'string');

    if (
        (ops[this.op][1] == 'numeric' && isNaN(val) && this.val.is !== 'field') ||
        (ops[this.op][1] == 'string' && (val)[0] != "'")
    ) {
        env.error({
            message: 'Cannot use operator "' + this.op + '" with value ' + this.val,
            index: this.index,
            filename: this.filename
        });
    }

    return key + ops[this.op][0] + val + (ops[this.op][2] || '');
};

tree.Filter.prototype.toString = function() {
    return '[' + this.id + ']';
};

})(_dereq_('../tree'));

},{"../tree":12}],22:[function(_dereq_,module,exports){
(function (global){
var tree = _dereq_('../tree');
var _ = global._ || _dereq_('underscore');

tree.Filterset = function Filterset() {
    this.filters = {};
};

tree.Filterset.prototype.toXML = function(env) {
    var filters = [];
    for (var id in this.filters) {
        filters.push('(' + this.filters[id].toXML(env).trim() + ')');
    }
    if (filters.length) {
        return '    <Filter>' + filters.join(' and ') + '</Filter>\n';
    } else {
        return '';
    }
};

tree.Filterset.prototype.toString = function() {
    var arr = [];
    for (var id in this.filters) arr.push(this.filters[id].id);
    return arr.sort().join('\t');
};

tree.Filterset.prototype.ev = function(env) {
    for (var i in this.filters) {
        this.filters[i].ev(env);
    }
    return this;
};

tree.Filterset.prototype.clone = function() {
    var clone = new tree.Filterset();
    for (var id in this.filters) {
        clone.filters[id] = this.filters[id];
    }
    return clone;
};

// Note: other has to be a tree.Filterset.
tree.Filterset.prototype.cloneWith = function(other) {
    var additions = [];
    for (var id in other.filters) {
        var status = this.addable(other.filters[id]);
        // status is true, false or null. if it's null we don't fail this
        // clone nor do we add the filter.
        if (status === false) {
            return false;
        }
        if (status === true) {
            // Adding the filter will override another value.
            additions.push(other.filters[id]);
        }
    }

    // Adding the other filters doesn't make this filterset invalid, but it
    // doesn't add anything to it either.
    if (!additions.length) {
        return null;
    }

    // We can successfully add all filters. Now clone the filterset and add the
    // new rules.
    var clone = new tree.Filterset();

    // We can add the rules that are already present without going through the
    // add function as a Filterset is always in it's simplest canonical form.
    for (id in this.filters) {
        clone.filters[id] = this.filters[id];
    }

    // Only add new filters that actually change the filter.
    while (id = additions.shift()) {
        clone.add(id);
    }

    return clone;
};

tree.Filterset.prototype.toJS = function(env) {
  var opMap = {
    '=': '==='
  };
  return _.map(this.filters, function(filter) {
    var op = filter.op;
    if(op in opMap) {
      op = opMap[op];
    }
    var val = filter.val;
    if(filter._val !== undefined) {
      val = filter._val.toString(true);
    }
    var attrs = "data";
    if (op === '=~') {
      return "(" + attrs + "['" + filter.key.value  + "'] + '').match(" + (val.is === 'string' ? "'" + val.toString().replace(/'/g, "\\'") + "'" : val) + ")";
    }
    return attrs + "['" + filter.key.value  + "'] " + op + " " + (val.is === 'string' ? "'" + val.toString().replace(/'/g, "\\'") + "'" : val);
  }).join(' && ');
};

// Returns true when the new filter can be added, false otherwise.
// It can also return null, and on the other side we test for === true or
// false
tree.Filterset.prototype.addable = function(filter) {
    var key = filter.key.toString(),
        value = filter.val.toString();

    if (value.match(/^[0-9]+(\.[0-9]*)?$/)) value = parseFloat(value);

    switch (filter.op) {
        case '=':
            // if there is already foo= and we're adding foo=
            if (this.filters[key + '='] !== undefined) {
                if (this.filters[key + '='].val.toString() != value) {
                    return false;
                } else {
                    return null;
                }
            }
            if (this.filters[key + '!=' + value] !== undefined) return false;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return false;
            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val < value) return false;
            return true;

        case '=~':
            return true;

        case '!=':
            if (this.filters[key + '='] !== undefined) return (this.filters[key + '='].val == value) ? false : null;
            if (this.filters[key + '!=' + value] !== undefined) return null;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;
            return true;

        case '>':
            if (key + '=' in this.filters) {
                if (this.filters[key + '='].val <= value) {
                    return false;
                } else {
                    return null;
                }
            }
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val <= value) return false;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return null;
            return true;

        case '>=':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val < value) ? false : null;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return false;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return null;
            return true;

        case '<':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val >= value) ? false : null;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return false;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;
            return true;

        case '<=':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val > value) ? false : null;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return false;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) return null;
            return true;
    }
};

// Does the new filter constitute a conflict?
tree.Filterset.prototype.conflict = function(filter) {
    var key = filter.key.toString(),
        value = filter.val.toString();

    if (!isNaN(parseFloat(value))) value = parseFloat(value);

    // if (a=b) && (a=c)
    // if (a=b) && (a!=b)
    // or (a!=b) && (a=b)
    if ((filter.op === '=' && this.filters[key + '='] !== undefined &&
        value != this.filters[key + '='].val.toString()) ||
        (filter.op === '!=' && this.filters[key + '='] !== undefined &&
        value == this.filters[key + '='].val.toString()) ||
        (filter.op === '=' && this.filters[key + '!='] !== undefined &&
        value == this.filters[key + '!='].val.toString())) {
        return filter.toString() + ' added to ' + this.toString() + ' produces an invalid filter';
    }

    return false;
};

// Only call this function for filters that have been cleared by .addable().
tree.Filterset.prototype.add = function(filter, env) {
    var key = filter.key.toString(),
        id,
        op = filter.op,
        conflict = this.conflict(filter),
        numval;

    if (conflict) return conflict;

    if (op === '=') {
        for (var i in this.filters) {
            if (this.filters[i].key == key) delete this.filters[i];
        }
        this.filters[key + '='] = filter;
    } else if (op === '!=') {
        this.filters[key + '!=' + filter.val] = filter;
    } else if (op === '=~') {
        this.filters[key + '=~' + filter.val] = filter;
    } else if (op === '>') {
        // If there are other filters that are also >
        // but are less than this one, they don't matter, so
        // remove them.
        for (var j in this.filters) {
            if (this.filters[j].key == key && this.filters[j].val <= filter.val) {
                delete this.filters[j];
            }
        }
        this.filters[key + '>'] = filter;
    } else if (op === '>=') {
        for (var k in this.filters) {
            numval = (+this.filters[k].val.toString());
            if (this.filters[k].key == key && numval < filter.val) {
                delete this.filters[k];
            }
        }
        if (this.filters[key + '!=' + filter.val] !== undefined) {
            delete this.filters[key + '!=' + filter.val];
            filter.op = '>';
            this.filters[key + '>'] = filter;
        }
        else {
            this.filters[key + '>='] = filter;
        }
    } else if (op === '<') {
        for (var l in this.filters) {
            numval = (+this.filters[l].val.toString());
            if (this.filters[l].key == key && numval >= filter.val) {
                delete this.filters[l];
            }
        }
        this.filters[key + '<'] = filter;
    } else if (op === '<=') {
        for (var m in this.filters) {
            numval = (+this.filters[m].val.toString());
            if (this.filters[m].key == key && numval > filter.val) {
                delete this.filters[m];
            }
        }
        if (this.filters[key + '!=' + filter.val] !== undefined) {
            delete this.filters[key + '!=' + filter.val];
            filter.op = '<';
            this.filters[key + '<'] = filter;
        }
        else {
            this.filters[key + '<='] = filter;
        }
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":12,"underscore":417}],23:[function(_dereq_,module,exports){
(function(tree) {

tree._getFontSet = function(env, fonts) {
    var fontKey = fonts.join('');
    if (env._fontMap && env._fontMap[fontKey]) {
        return env._fontMap[fontKey];
    }

    var new_fontset = new tree.FontSet(env, fonts);
    env.effects.push(new_fontset);
    if (!env._fontMap) env._fontMap = {};
    env._fontMap[fontKey] = new_fontset;
    return new_fontset;
};

tree.FontSet = function FontSet(env, fonts) {
    this.fonts = fonts;
    this.name = 'fontset-' + env.effects.length;
};

tree.FontSet.prototype.toXML = function(env) {
    return '<FontSet name="' +
        this.name +
        '">\n' +
        this.fonts.map(function(f) {
            return '  <Font face-name="' + f +'"/>';
        }).join('\n') +
        '\n</FontSet>';
};

})(_dereq_('../tree'));

},{"../tree":12}],24:[function(_dereq_,module,exports){
var tree = _dereq_('../tree');

// Storage for Frame offset value
// and stores them as bit-sequences so that they can be combined,
// inverted, and compared quickly.
tree.FrameOffset = function(op, value, index) {
    value = parseInt(value, 10);
    if (value > tree.FrameOffset.max || value <= 0) {
        throw {
            message: 'Only frame-offset levels between 1 and ' +
                tree.FrameOffset.max + ' supported.',
            index: index
        };
    }

    if (op !== '=') {
        throw {
            message: 'only = operator is supported for frame-offset',
            index: index
        };
    }
    return value;
};

tree.FrameOffset.max = 32;
tree.FrameOffset.none = 0;


},{"../tree":12}],25:[function(_dereq_,module,exports){
(function(tree) {

tree.ImageFilter = function ImageFilter(filter, args) {
    this.filter = filter;
    this.args = args || null;
};

tree.ImageFilter.prototype = {
    is: 'imagefilter',
    ev: function() { return this; },

    toString: function() {
        if (this.args) {
            return this.filter + '(' + this.args.join(',') + ')';
        } else {
            return this.filter;
        }
    }
};


})(_dereq_('../tree'));

},{"../tree":12}],26:[function(_dereq_,module,exports){
(function (tree) {
tree.Invalid = function Invalid(chunk, index, message) {
    this.chunk = chunk;
    this.index = index;
    this.type = 'syntax';
    this.message = message || "Invalid code: " + this.chunk;
};

tree.Invalid.prototype.is = 'invalid';

tree.Invalid.prototype.ev = function(env) {
    env.error({
        chunk: this.chunk,
        index: this.index,
        type: 'syntax',
        message: this.message || "Invalid code: " + this.chunk
    });
    return {
        is: 'undefined'
    };
};
})(_dereq_('../tree'));

},{"../tree":12}],27:[function(_dereq_,module,exports){
(function(tree) {

tree.Keyword = function Keyword(value) {
    this.value = value;
    var special = {
        'transparent': 'color',
        'true': 'boolean',
        'false': 'boolean'
    };
    this.is = special[value] ? special[value] : 'keyword';
};
tree.Keyword.prototype = {
    ev: function() { return this; },
    toString: function() { return this.value; }
};

})(_dereq_('../tree'));

},{"../tree":12}],28:[function(_dereq_,module,exports){
(function(tree) {

tree.LayerXML = function(obj, styles) {
    var dsoptions = [];
    for (var i in obj.Datasource) {
        dsoptions.push('<Parameter name="' + i + '"><![CDATA[' +
            obj.Datasource[i] + ']]></Parameter>');
    }

    var prop_string = '';
    for (var prop in obj.properties) {
        if (prop === 'minzoom') {
            prop_string += '  maxzoom="' + tree.Zoom.ranges[obj.properties[prop]] + '"\n';
        } else if (prop === 'maxzoom') {
            prop_string += '  minzoom="' + tree.Zoom.ranges[obj.properties[prop]+1] + '"\n';
        } else {
            prop_string += '  ' + prop + '="' + obj.properties[prop] + '"\n';
        }
    }

    return '<Layer' +
        ' name="' + obj.name + '"\n' +
        prop_string +
        ((typeof obj.status === 'undefined') ? '' : '  status="' + obj.status + '"\n') +
        ((typeof obj.srs === 'undefined') ? '' : '  srs="' + obj.srs + '"') + '>\n    ' +
        styles.reverse().map(function(s) {
            return '<StyleName>' + s + '</StyleName>';
        }).join('\n    ') +
        (dsoptions.length ?
        '\n    <Datasource>\n       ' +
        dsoptions.join('\n       ') +
        '\n    </Datasource>\n'
        : '') +
        '  </Layer>\n';
};

})(_dereq_('../tree'));

},{"../tree":12}],29:[function(_dereq_,module,exports){
// A literal is a literal string for Mapnik - the
// result of the combination of a `tree.Field` with any
// other type.
(function(tree) {

tree.Literal = function Field(content) {
    this.value = content || '';
    this.is = 'field';
};

tree.Literal.prototype = {
    toString: function() {
        return this.value;
    },
    'ev': function() {
        return this;
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],30:[function(_dereq_,module,exports){
// An operation is an expression with an op in between two operands,
// like 2 + 1.
(function(tree) {

tree.Operation = function Operation(op, operands, index) {
    this.op = op.trim();
    this.operands = operands;
    this.index = index;
};

tree.Operation.prototype.is = 'operation';

tree.Operation.prototype.ev = function(env) {
    var a = this.operands[0].ev(env),
        b = this.operands[1].ev(env),
        temp;

    if (a.is === 'undefined' || b.is === 'undefined') {
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    if (a instanceof tree.Dimension && b instanceof tree.Color) {
        if (this.op === '*' || this.op === '+') {
            temp = b, b = a, a = temp;
        } else {
            env.error({
                name: "OperationError",
                message: "Can't substract or divide a color from a number",
                index: this.index
            });
        }
    }

    // Only concatenate plain strings, because this is easily
    // pre-processed
    if (a instanceof tree.Quoted && b instanceof tree.Quoted && this.op !== '+') {
        env.error({
           message: "Can't subtract, divide, or multiply strings.",
           index: this.index,
           type: 'runtime',
           filename: this.filename
        });
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    // Fields, literals, dimensions, and quoted strings can be combined.
    if (a instanceof tree.Field || b instanceof tree.Field ||
        a instanceof tree.Literal || b instanceof tree.Literal) {
        if (a.is === 'color' || b.is === 'color') {
            env.error({
               message: "Can't subtract, divide, or multiply colors in expressions.",
               index: this.index,
               type: 'runtime',
               filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        } else {
            return new tree.Literal(a.ev(env).toString(true) + this.op + b.ev(env).toString(true));
        }
    }

    if (a.operate === undefined) {
        env.error({
           message: 'Cannot do math with type ' + a.is + '.',
           index: this.index,
           type: 'runtime',
           filename: this.filename
        });
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    return a.operate(env, this.op, b);
};

tree.operate = function(op, a, b) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '%': return a % b;
        case '/': return a / b;
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],31:[function(_dereq_,module,exports){
(function(tree) {

tree.Quoted = function Quoted(content) {
    this.value = content || '';
};

tree.Quoted.prototype = {
    is: 'string',

    toString: function(quotes) {
        var escapedValue = this.value
            .replace(/&/g, '&amp;')
        var xmlvalue = escapedValue
            .replace(/\'/g, '\\\'')
            .replace(/\"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/\>/g, '&gt;');
        return (quotes === true) ? "'" + xmlvalue + "'" : escapedValue;
    },

    'ev': function() {
        return this;
    },

    operate: function(env, op, other) {
        return new tree.Quoted(tree.operate(op, this.toString(), other.toString(this.contains_field)));
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],32:[function(_dereq_,module,exports){
(function (global){
// Carto pulls in a reference from the `mapnik-reference`
// module. This file builds indexes from that file for its various
// options, and provides validation methods for property: value
// combinations.
(function(tree) {

var _ = global._ || _dereq_('underscore'),
    ref = {};

ref.setData = function(data) {
    ref.data = data;
    ref.selector_cache = generateSelectorCache(data);
    ref.mapnikFunctions = generateMapnikFunctions(data);

    ref.mapnikFunctions.matrix = [6];
    ref.mapnikFunctions.translate = [1, 2];
    ref.mapnikFunctions.scale = [1, 2];
    ref.mapnikFunctions.rotate = [1, 3];
    ref.mapnikFunctions.skewX = [1];
    ref.mapnikFunctions.skewY = [1];

    ref.required_cache = generateRequiredProperties(data);
};

ref.setVersion = function(version) {
    var mapnik_reference = _dereq_('mapnik-reference');
    if (mapnik_reference.version.hasOwnProperty(version)) {
        ref.setData(mapnik_reference.version[version]);
        return true;
    } else {
        return false;
    }
};

ref.selectorData = function(selector, i) {
    if (ref.selector_cache[selector]) return ref.selector_cache[selector][i];
};

ref.validSelector = function(selector) { return !!ref.selector_cache[selector]; };
ref.selectorName = function(selector) { return ref.selectorData(selector, 2); };
ref.selector = function(selector) { return ref.selectorData(selector, 0); };
ref.symbolizer = function(selector) { return ref.selectorData(selector, 1); };

function generateSelectorCache(data) {
    var index = {};
    for (var i in data.symbolizers) {
        for (var j in data.symbolizers[i]) {
            if (data.symbolizers[i][j].hasOwnProperty('css')) {
                index[data.symbolizers[i][j].css] = [data.symbolizers[i][j], i, j];
            }
        }
    }
    return index;
}

function generateMapnikFunctions(data) {
    var functions = {};
    for (var i in data.symbolizers) {
        for (var j in data.symbolizers[i]) {
            if (data.symbolizers[i][j].type === 'functions') {
                for (var k = 0; k < data.symbolizers[i][j].functions.length; k++) {
                    var fn = data.symbolizers[i][j].functions[k];
                    functions[fn[0]] = fn[1];
                }
            }
        }
    }
    return functions;
}

function generateRequiredProperties(data) {
    var cache = {};
    for (var symbolizer_name in data.symbolizers) {
        cache[symbolizer_name] = [];
        for (var j in data.symbolizers[symbolizer_name]) {
            if (data.symbolizers[symbolizer_name][j].required) {
                cache[symbolizer_name].push(data.symbolizers[symbolizer_name][j].css);
            }
        }
    }
    return cache;
}

ref.requiredProperties = function(symbolizer_name, rules) {
    var req = ref.required_cache[symbolizer_name];
    for (var i in req) {
        if (!(req[i] in rules)) {
            return 'Property ' + req[i] + ' required for defining ' +
                symbolizer_name + ' styles.';
        }
    }
};

// TODO: finish implementation - this is dead code
ref._validateValue = {
    'font': function(env, value) {
        if (env.validation_data && env.validation_data.fonts) {
            return env.validation_data.fonts.indexOf(value) != -1;
        } else {
            return true;
        }
    }
};

ref.isFont = function(selector) {
    return ref.selector(selector).validate == 'font';
};

// https://gist.github.com/982927
ref.editDistance = function(a, b){
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    var matrix = [];
    for (var i = 0; i <= b.length; i++) { matrix[i] = [i]; }
    for (var j = 0; j <= a.length; j++) { matrix[0][j] = j; }
    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i-1) == a.charAt(j-1)) {
                matrix[i][j] = matrix[i-1][j-1];
            } else {
                matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution
                    Math.min(matrix[i][j-1] + 1, // insertion
                    matrix[i-1][j] + 1)); // deletion
            }
        }
    }
    return matrix[b.length][a.length];
};

function validateFunctions(value, selector) {
    if (value.value[0].is === 'string') return true;
    for (var i in value.value) {
        for (var j in value.value[i].value) {
            if (value.value[i].value[j].is !== 'call') return false;
            var f = _.find(ref
                .selector(selector).functions, function(x) {
                    return x[0] == value.value[i].value[j].name;
                });
            if (!(f && f[1] == -1)) {
                // This filter is unknown or given an incorrect number of arguments
                if (!f || f[1] !== value.value[i].value[j].args.length) return false;
            }
        }
    }
    return true;
}

function validateKeyword(value, selector) {
    if (typeof ref.selector(selector).type === 'object') {
        return ref.selector(selector).type
            .indexOf(value.value[0].value) !== -1;
    } else {
        // allow unquoted keywords as strings
        return ref.selector(selector).type === 'string';
    }
}

ref.validValue = function(env, selector, value) {
    var i, j;
    // TODO: handle in reusable way
    if (!ref.selector(selector)) {
        return false;
    } else if (value.value[0].is == 'keyword') {
        return validateKeyword(value, selector);
    } else if (value.value[0].is == 'undefined') {
        // caught earlier in the chain - ignore here so that
        // error is not overridden
        return true;
    } else if (ref.selector(selector).type == 'numbers') {
        for (i in value.value) {
            if (value.value[i].is !== 'float') {
                return false;
            }
        }
        return true;
    } else if (ref.selector(selector).type == 'tags') {
        if (!value.value) return false;
        if (!value.value[0].value) {
            return value.value[0].is === 'tag';
        }
        for (i = 0; i < value.value[0].value.length; i++) {
            if (value.value[0].value[i].is !== 'tag') return false;
        }
        return true;
    } else if (ref.selector(selector).type == 'functions') {
        // For backwards compatibility, you can specify a string for `functions`-compatible
        // values, though they will not be validated.
        return validateFunctions(value, selector);
    } else if (ref.selector(selector).type === 'unsigned') {
        if (value.value[0].is === 'float') {
            value.value[0].round();
            return true;
        } else {
            return false;
        }
    } else if ((ref.selector(selector).expression)) {
        return true;
    } else {
        if (ref.selector(selector).validate) {
            var valid = false;
            for (i = 0; i < value.value.length; i++) {
                if (ref.selector(selector).type == value.value[i].is &&
                    ref
                        ._validateValue
                            [ref.selector(selector).validate]
                            (env, value.value[i].value)) {
                    return true;
                }
            }
            return valid;
        } else {
            return ref.selector(selector).type == value.value[0].is;
        }
    }
};

tree.Reference = ref;

})(_dereq_('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":12,"mapnik-reference":102,"underscore":417}],33:[function(_dereq_,module,exports){
(function(tree) {
// a rule is a single property and value combination, or variable
// name and value combination, like
// polygon-opacity: 1.0; or @opacity: 1.0;
tree.Rule = function Rule(name, value, index, filename) {
    var parts = name.split('/');
    this.name = parts.pop();
    this.instance = parts.length ? parts[0] : '__default__';
    this.value = (value instanceof tree.Value) ?
        value : new tree.Value([value]);
    this.index = index;
    this.symbolizer = tree.Reference.symbolizer(this.name);
    this.filename = filename;
    this.variable = (name.charAt(0) === '@');
};

tree.Rule.prototype.is = 'rule';

tree.Rule.prototype.clone = function() {
    var clone = Object.create(tree.Rule.prototype);
    clone.name = this.name;
    clone.value = this.value;
    clone.index = this.index;
    clone.instance = this.instance;
    clone.symbolizer = this.symbolizer;
    clone.filename = this.filename;
    clone.variable = this.variable;
    return clone;
};

tree.Rule.prototype.updateID = function() {
    return this.id = this.zoom + '#' + this.instance + '#' + this.name;
};

tree.Rule.prototype.toString = function() {
    return '[' + tree.Zoom.toString(this.zoom) + '] ' + this.name + ': ' + this.value;
};

function getMean(name) {
    return Object.keys(tree.Reference.selector_cache).map(function(f) {
        return [f, tree.Reference.editDistance(name, f)];
    }).sort(function(a, b) { return a[1] - b[1]; });
}

// second argument, if true, outputs the value of this
// rule without the usual attribute="content" wrapping. Right
// now this is just for the TextSymbolizer, but applies to other
// properties in reference.json which specify serialization=content
tree.Rule.prototype.toXML = function(env, content, sep, format) {
    if (!tree.Reference.validSelector(this.name)) {
        var mean = getMean(this.name);
        var mean_message = '';
        if (mean[0][1] < 3) {
            mean_message = '. Did you mean ' + mean[0][0] + '?';
        }
        return env.error({
            message: "Unrecognized rule: " + this.name + mean_message,
            index: this.index,
            type: 'syntax',
            filename: this.filename
        });
    }

    if ((this.value instanceof tree.Value) &&
        !tree.Reference.validValue(env, this.name, this.value)) {
        if (!tree.Reference.selector(this.name)) {
            return env.error({
                message: 'Unrecognized property: ' +
                    this.name,
                index: this.index,
                type: 'syntax',
                filename: this.filename
            });
        } else {
            var typename;
            if (tree.Reference.selector(this.name).validate) {
                typename = tree.Reference.selector(this.name).validate;
            } else if (typeof tree.Reference.selector(this.name).type === 'object') {
                typename = 'keyword (options: ' + tree.Reference.selector(this.name).type.join(', ') + ')';
            } else {
                typename = tree.Reference.selector(this.name).type;
            }
            return env.error({
                message: 'Invalid value for ' +
                    this.name +
                    ', the type ' + typename +
                    ' is expected. ' + this.value +
                    ' (of type ' + this.value.value[0].is + ') ' +
                    ' was given.',
                index: this.index,
                type: 'syntax',
                filename: this.filename
            });
        }
    }

    if (this.variable) {
        return '';
    } else if (tree.Reference.isFont(this.name) && this.value.value.length > 1) {
        var f = tree._getFontSet(env, this.value.value);
        return 'fontset-name="' + f.name + '"';
    } else if (content) {
        return this.value.toString(env, this.name, sep);
    } else {
        return tree.Reference.selectorName(this.name) +
            '="' +
            this.value.toString(env, this.name) +
            '"';
    }
};

// TODO: Rule ev chain should add fontsets to env.frames
tree.Rule.prototype.ev = function(context) {
    return new tree.Rule(this.name,
        this.value.ev(context),
        this.index,
        this.filename);
};

})(_dereq_('../tree'));

},{"../tree":12}],34:[function(_dereq_,module,exports){
(function(tree) {

tree.Ruleset = function Ruleset(selectors, rules) {
    this.selectors = selectors;
    this.rules = rules;
    // static cache of find() function
    this._lookups = {};
};
tree.Ruleset.prototype = {
    is: 'ruleset',
    'ev': function(env) {
        var i,
            ruleset = new tree.Ruleset(this.selectors, this.rules.slice(0));
        ruleset.root = this.root;

        // push the current ruleset to the frames stack
        env.frames.unshift(ruleset);

        // Evaluate everything else
        for (i = 0, rule; i < ruleset.rules.length; i++) {
            rule = ruleset.rules[i];
            ruleset.rules[i] = rule.ev ? rule.ev(env) : rule;
        }

        // Pop the stack
        env.frames.shift();

        return ruleset;
    },
    match: function(args) {
        return !args || args.length === 0;
    },
    variables: function() {
        if (this._variables) { return this._variables; }
        else {
            return this._variables = this.rules.reduce(function(hash, r) {
                if (r instanceof tree.Rule && r.variable === true) {
                    hash[r.name] = r;
                }
                return hash;
            }, {});
        }
    },
    variable: function(name) {
        return this.variables()[name];
    },
    rulesets: function() {
        if (this._rulesets) { return this._rulesets; }
        else {
            return this._rulesets = this.rules.filter(function(r) {
                return (r instanceof tree.Ruleset);
            });
        }
    },
    find: function(selector, self) {
        self = self || this;
        var rules = [], rule, match,
            key = selector.toString();

        if (key in this._lookups) { return this._lookups[key]; }

        this.rulesets().forEach(function(rule) {
            if (rule !== self) {
                for (var j = 0; j < rule.selectors.length; j++) {
                    match = selector.match(rule.selectors[j]);
                    if (match) {
                        if (selector.elements.length > 1) {
                            Array.prototype.push.apply(rules, rule.find(
                                new tree.Selector(null, null, null, selector.elements.slice(1)), self));
                        } else {
                            rules.push(rule);
                        }
                        break;
                    }
                }
            }
        });
        return this._lookups[key] = rules;
    },
    // Zooms can use variables. This replaces tree.Zoom objects on selectors
    // with simple bit-arrays that we can compare easily.
    evZooms: function(env) {
        for (var i = 0; i < this.selectors.length; i++) {
            var zval = tree.Zoom.all;
            for (var z = 0; z < this.selectors[i].zoom.length; z++) {
                zval = zval & this.selectors[i].zoom[z].ev(env).zoom;
            }
            this.selectors[i].zoom = zval;
        }
    },
    flatten: function(result, parents, env) {
        var selectors = [], i, j;
        if (this.selectors.length === 0) {
            env.frames = env.frames.concat(this.rules);
        }
        // evaluate zoom variables on this object.
        this.evZooms(env);
        for (i = 0; i < this.selectors.length; i++) {
            var child = this.selectors[i];

            if (!child.filters) {
                // TODO: is this internal inconsistency?
                // This is an invalid filterset.
                continue;
            }

            if (parents.length) {
                for (j = 0; j < parents.length; j++) {
                    var parent = parents[j];

                    var mergedFilters = parent.filters.cloneWith(child.filters);
                    if (mergedFilters === null) {
                        // Filters could be added, but they didn't change the
                        // filters. This means that we only have to clone when
                        // the zoom levels or the attachment is different too.
                        if (parent.zoom === (parent.zoom & child.zoom) &&
                            parent.frame_offset === child.frame_offset &&
                            parent.attachment === child.attachment &&
                            parent.elements.join() === child.elements.join()) {
                            selectors.push(parent);
                            continue;
                        } else {
                            mergedFilters = parent.filters;
                        }
                    } else if (!mergedFilters) {
                        // The merged filters are invalid, that means we don't
                        // have to clone.
                        continue;
                    }

                    var clone = Object.create(tree.Selector.prototype);
                    clone.filters = mergedFilters;
                    clone.zoom = parent.zoom & child.zoom;
                    clone.frame_offset = child.frame_offset;
                    clone.elements = parent.elements.concat(child.elements);
                    if (parent.attachment && child.attachment) {
                        clone.attachment = parent.attachment + '/' + child.attachment;
                    }
                    else clone.attachment = child.attachment || parent.attachment;
                    clone.conditions = parent.conditions + child.conditions;
                    clone.index = child.index;
                    selectors.push(clone);
                }
            } else {
                selectors.push(child);
            }
        }

        var rules = [];
        for (i = 0; i < this.rules.length; i++) {
            var rule = this.rules[i];

            // Recursively flatten any nested rulesets
            if (rule instanceof tree.Ruleset) {
                rule.flatten(result, selectors, env);
            } else if (rule instanceof tree.Rule) {
                rules.push(rule);
            } else if (rule instanceof tree.Invalid) {
                env.error(rule);
            }
        }

        var index = rules.length ? rules[0].index : false;
        for (i = 0; i < selectors.length; i++) {
            // For specificity sort, use the position of the first rule to allow
            // defining attachments that are under current element as a descendant
            // selector.
            if (index !== false) {
                selectors[i].index = index;
            }
            result.push(new tree.Definition(selectors[i], rules.slice()));
        }

        return result;
    }
};
})(_dereq_('../tree'));

},{"../tree":12}],35:[function(_dereq_,module,exports){
(function(tree) {

tree.Selector = function Selector(filters, zoom, frame_offset, elements, attachment, conditions, index) {
    this.elements = elements || [];
    this.attachment = attachment;
    this.filters = filters || {};
    this.frame_offset = frame_offset;
    this.zoom = typeof zoom !== 'undefined' ? zoom : tree.Zoom.all;
    this.conditions = conditions;
    this.index = index;
};

// Determine the specificity of this selector
// based on the specificity of its elements - calling
// Element.specificity() in order to do so
//
// [ID, Class, Filters, Position in document]
tree.Selector.prototype.specificity = function() {
    return this.elements.reduce(function(memo, e) {
        var spec = e.specificity();
        memo[0] += spec[0];
        memo[1] += spec[1];
        return memo;
    }, [0, 0, this.conditions, this.index]);
};

})(_dereq_('../tree'));

},{"../tree":12}],36:[function(_dereq_,module,exports){
(function (global){
(function(tree) {
var _ = global._ || _dereq_('underscore');

// Given a style's name, attachment, definitions, and an environment object,
// return a stringified style for Mapnik
tree.StyleXML = function(name, attachment, definitions, env) {
    var existing = {};
    var image_filters = [], image_filters_inflate = [], direct_image_filters = [], comp_op = [], opacity = [];

    for (var i = 0; i < definitions.length; i++) {
        for (var j = 0; j < definitions[i].rules.length; j++) {
            if (definitions[i].rules[j].name === 'image-filters') {
                image_filters.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'image-filters-inflate') {
                image_filters_inflate.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'direct-image-filters') {
                direct_image_filters.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'comp-op') {
                comp_op.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'opacity') {
                opacity.push(definitions[i].rules[j]);
            }
        }
    }

    var rules = definitions.map(function(definition) {
        return definition.toXML(env, existing);
    });

    var attrs_xml = '';

    if (image_filters.length) {
        attrs_xml += ' image-filters="' + _.chain(image_filters)
            // prevent identical filters from being duplicated in the style
            .uniq(function(i) { return i.id; }).map(function(f) {
            return f.ev(env).toXML(env, true, ',', 'image-filter');
        }).value().join(',') + '"';
    }

    if (image_filters_inflate.length) {
        attrs_xml += ' image-filters-inflate="' + image_filters_inflate[0].value.ev(env).toString() + '"';
    }

    if (direct_image_filters.length) {
        attrs_xml += ' direct-image-filters="' + _.chain(direct_image_filters)
            // prevent identical filters from being duplicated in the style
            .uniq(function(i) { return i.id; }).map(function(f) {
            return f.ev(env).toXML(env, true, ',', 'direct-image-filter');
        }).value().join(',') + '"';
    }

    if (comp_op.length && comp_op[0].value.ev(env).value != 'src-over') {
        attrs_xml += ' comp-op="' + comp_op[0].value.ev(env).toString() + '"';
    }

    if (opacity.length && opacity[0].value.ev(env).value != 1) {
        attrs_xml += ' opacity="' + opacity[0].value.ev(env).toString() + '"';
    }
    var rule_string = rules.join('');
    if (!attrs_xml && !rule_string) return '';
    return '<Style name="' + name + '" filter-mode="first"' + attrs_xml + '>\n' + rule_string + '</Style>';
};

})(_dereq_('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":12,"underscore":417}],37:[function(_dereq_,module,exports){
(function(tree) {

tree.URL = function URL(val, paths) {
    this.value = val;
    this.paths = paths;
};

tree.URL.prototype = {
    is: 'uri',
    toString: function() {
        return this.value.toString();
    },
    ev: function(ctx) {
        return new tree.URL(this.value.ev(ctx), this.paths);
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],38:[function(_dereq_,module,exports){
(function(tree) {

tree.Value = function Value(value) {
    this.value = value;
};

tree.Value.prototype = {
    is: 'value',
    ev: function(env) {
        if (this.value.length === 1) {
            return this.value[0].ev(env);
        } else {
            return new tree.Value(this.value.map(function(v) {
                return v.ev(env);
            }));
        }
    },
    toString: function(env, selector, sep, format) {
        return this.value.map(function(e) {
            return e.toString(env, format);
        }).join(sep || ', ');
    },
    clone: function() {
        var obj = Object.create(tree.Value.prototype);
        if (Array.isArray(obj)) obj.value = this.value.slice();
        else obj.value = this.value;
        obj.is = this.is;
        return obj;
    },

    toJS: function(env) {
      //var v = this.value[0].value[0];
      var val = this.ev(env);
      var v = val.toString();
      if(val.is === "color" || val.is === 'uri' || val.is === 'string' || val.is === 'keyword') {
        v = "'" + v + "'";
      } else if (val.is === 'field') {
        // replace [variable] by ctx['variable']
        v = v.replace(/\[([^\]]*)\]/g, function(matched) {
            return matched.replace(/\[(.*)\]/g, "data['$1']");
        });
      }else if (val.is === 'call') {
        v = JSON.stringify({
            name: val.name,
            args: val.args
        })
      }
      return "_value = " + v + ";";
    }

};

})(_dereq_('../tree'));

},{"../tree":12}],39:[function(_dereq_,module,exports){
(function(tree) {

tree.Variable = function Variable(name, index, filename) {
    this.name = name;
    this.index = index;
    this.filename = filename;
};

tree.Variable.prototype = {
    is: 'variable',
    toString: function() {
        return this.name;
    },
    ev: function(env) {
        var variable,
            v,
            name = this.name;

        if (this._css) return this._css;

        var thisframe = env.frames.filter(function(f) {
            return f.name == this.name;
        }.bind(this));
        if (thisframe.length) {
            return thisframe[0].value.ev(env);
        } else {
            env.error({
                message: 'variable ' + this.name + ' is undefined',
                index: this.index,
                type: 'runtime',
                filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }
    }
};

})(_dereq_('../tree'));

},{"../tree":12}],40:[function(_dereq_,module,exports){
var tree = _dereq_('../tree');

// Storage for zoom ranges. Only supports continuous ranges,
// and stores them as bit-sequences so that they can be combined,
// inverted, and compared quickly.
tree.Zoom = function(op, value, index) {
    this.op = op;
    this.value = value;
    this.index = index;
};

tree.Zoom.prototype.setZoom = function(zoom) {
    this.zoom = zoom;
    return this;
};

tree.Zoom.prototype.ev = function(env) {
    var start = 0,
        end = Infinity,
        value = parseInt(this.value.ev(env).toString(), 10),
        zoom = 0;

    if (value > tree.Zoom.maxZoom || value < 0) {
        env.error({
            message: 'Only zoom levels between 0 and ' +
                tree.Zoom.maxZoom + ' supported.',
            index: this.index
        });
    }

    switch (this.op) {
        case '=':
            this.zoom = 1 << value;
            return this;
        case '>':
            start = value + 1;
            break;
        case '>=':
            start = value;
            break;
        case '<':
            end = value - 1;
            break;
        case '<=':
            end = value;
            break;
    }
    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
        if (i >= start && i <= end) {
            zoom |= (1 << i);
        }
    }
    this.zoom = zoom;
    return this;
};

tree.Zoom.prototype.toString = function() {
    return this.zoom;
};

// Covers all zoomlevels from 0 to 22
tree.Zoom.all = 0x7FFFFF;

tree.Zoom.maxZoom = 22;

tree.Zoom.ranges = {
     0: 1000000000,
     1: 500000000,
     2: 200000000,
     3: 100000000,
     4: 50000000,
     5: 25000000,
     6: 12500000,
     7: 6500000,
     8: 3000000,
     9: 1500000,
    10: 750000,
    11: 400000,
    12: 200000,
    13: 100000,
    14: 50000,
    15: 25000,
    16: 12500,
    17: 5000,
    18: 2500,
    19: 1500,
    20: 750,
    21: 500,
    22: 250,
    23: 100
};

// Only works for single range zooms. `[XXX....XXXXX.........]` is invalid.
tree.Zoom.prototype.toXML = function() {
    var conditions = [];
    if (this.zoom != tree.Zoom.all) {
        var start = null, end = null;
        for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
            if (this.zoom & (1 << i)) {
                if (start === null) start = i;
                end = i;
            }
        }
        if (start > 0) conditions.push('    <MaxScaleDenominator>' +
            tree.Zoom.ranges[start] + '</MaxScaleDenominator>\n');
        if (end < 22) conditions.push('    <MinScaleDenominator>' +
            tree.Zoom.ranges[end + 1] + '</MinScaleDenominator>\n');
    }
    return conditions;
};

tree.Zoom.prototype.toString = function() {
    var str = '';
    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
        str += (this.zoom & (1 << i)) ? 'X' : '.';
    }
    return str;
};

},{"../tree":12}],41:[function(_dereq_,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "carto@github:cartodb/carto#master",
        "scope": null,
        "escapedName": "carto",
        "name": "carto",
        "rawSpec": "github:cartodb/carto#master",
        "spec": "github:cartodb/carto#master",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:cartodb/carto.git#master",
          "sshUrl": "git+ssh://git@github.com/cartodb/carto.git#master",
          "httpsUrl": "git+https://github.com/cartodb/carto.git#master",
          "gitUrl": "git://github.com/cartodb/carto.git#master",
          "shortcut": "github:cartodb/carto#master",
          "directUrl": "https://raw.githubusercontent.com/cartodb/carto/master/package.json"
        }
      },
      "/Users/donflopez/Documents/carto/tangram-carto"
    ]
  ],
  "_from": "cartodb/carto#master",
  "_id": "carto@0.15.1-cdb3",
  "_inCache": true,
  "_location": "/carto",
  "_phantomChildren": {},
  "_requested": {
    "raw": "carto@github:cartodb/carto#master",
    "scope": null,
    "escapedName": "carto",
    "name": "carto",
    "rawSpec": "github:cartodb/carto#master",
    "spec": "github:cartodb/carto#master",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:cartodb/carto.git#master",
      "sshUrl": "git+ssh://git@github.com/cartodb/carto.git#master",
      "httpsUrl": "git+https://github.com/cartodb/carto.git#master",
      "gitUrl": "git://github.com/cartodb/carto.git#master",
      "shortcut": "github:cartodb/carto#master",
      "directUrl": "https://raw.githubusercontent.com/cartodb/carto/master/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/cartodb/carto.git#945f5efb74fd1af1f5e1f69f409f9567f94fb5a7",
  "_shasum": "3a31e450564c757b0d6704c722830e0579753436",
  "_shrinkwrap": null,
  "_spec": "carto@github:cartodb/carto#master",
  "_where": "/Users/donflopez/Documents/carto/tangram-carto",
  "author": {
    "name": "CartoDB",
    "url": "http://cartodb.com/"
  },
  "bin": {
    "carto": "./bin/carto"
  },
  "bugs": {
    "url": "https://github.com/cartodb/carto/issues"
  },
  "contributors": [
    {
      "name": "Tom MacWright",
      "email": "macwright@gmail.com"
    },
    {
      "name": "Konstantin Käfer"
    },
    {
      "name": "Alexis Sellier",
      "email": "self@cloudhead.net"
    },
    {
      "name": "Raul Ochoa",
      "email": "rochoa@cartodb.com"
    },
    {
      "name": "Javi Santana",
      "email": "jsantana@cartodb.com"
    }
  ],
  "dependencies": {
    "mapnik-reference": "~6.0.2",
    "optimist": "~0.6.0",
    "underscore": "1.8.3"
  },
  "description": "CartoCSS Stylesheet Compiler",
  "devDependencies": {
    "browserify": "~7.0.0",
    "coveralls": "~2.10.1",
    "istanbul": "~0.2.14",
    "jshint": "0.2.x",
    "mocha": "1.12.x",
    "sax": "0.1.x",
    "uglify-js": "1.3.3"
  },
  "engines": {
    "node": ">=0.4.x"
  },
  "gitHead": "945f5efb74fd1af1f5e1f69f409f9567f94fb5a7",
  "homepage": "https://github.com/cartodb/carto#readme",
  "keywords": [
    "maps",
    "css",
    "stylesheets"
  ],
  "licenses": [
    {
      "type": "Apache"
    }
  ],
  "main": "./lib/carto/index",
  "man": [
    "./man/carto.1"
  ],
  "name": "carto",
  "optionalDependencies": {},
  "readme": "# CartoCSS\n\n[![Build Status](https://travis-ci.org/CartoDB/carto.png?branch=master)](https://travis-ci.org/CartoDB/carto)\n\nIs as stylesheet renderer for javascript, It's an evolution of the Mapnik renderer from Mapbox.\nPlease, see original [Mapbox repo](http://github.com/mapbox/carto) for more information and credits\n\n## Quick Start\n\n```javascript\n// shader is a CartoCSS object\n\nvar cartocss = [\n    '#layer {',\n    ' marker-width: [property]',\n    ' marker-fill: red',\n    '}'\n].join('')\nvar shader = new carto.RendererJS().render(cartocss);\nvar layers = shader.getLayers()\nfor (var i = 0; i < layers.length; ++i) {\n    var layer = layers[i];\n    console.log(\"layer name: \", layer.fullName())\n    console.log(\"- frames: \", layer.frames())\n    console.log(\"- attachment: \", layer.attachment())\n\n    var layerShader = layer.getStyle({ property: 1 }, { zoom: 10 })\n    console.log(layerShader['marker-width']) // 1\n    console.log(layerShader['marker-fill']) // #FF0000\n}\n\n```\n\n# API\n\n## RendererJS\n\n### render(cartocss)\n\n## CartoCSS\n\ncompiled cartocss object\n\n### getLayers\n\nreturn the layers, an array of ``CartoCSS.Layer`` object\n\n### getDefault\n\nreturn the default layer (``CartoCSS.Layer``), usually the Map layer\n\n\n### findLayer(where)\n\nfind a layer using where object.\n\n```\nshader.findLayer({ name: 'test' })\n```\n\n## CartoCSS.Layer\n\n### getStyle(props, context)\n\nreturn the evaluated style:\n    - props: object containing properties needed to render the style. If the cartocss style uses\n      some variables they should be passed in this object\n    - context: rendering context variables like ``zoom`` or animation ``frame``\n\n\n\n\n\n\n\n\n\n\n## Reference Documentation\n\n* [mapbox.com/carto](http://mapbox.com/carto/)\n\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/cartodb/carto.git"
  },
  "scripts": {
    "coverage": "istanbul cover ./node_modules/.bin/_mocha && coveralls < ./coverage/lcov.info",
    "pretest": "npm install",
    "test": "mocha -R spec"
  },
  "url": "https://github.com/cartodb/carto",
  "version": "0.15.1-cdb3"
}

},{}],42:[function(_dereq_,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],43:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.string.iterator');
_dereq_('../../modules/es6.array.from');
module.exports = _dereq_('../../modules/_core').Array.from;
},{"../../modules/_core":50,"../../modules/es6.array.from":97,"../../modules/es6.string.iterator":99}],44:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.assign');
module.exports = _dereq_('../../modules/_core').Object.assign;
},{"../../modules/_core":50,"../../modules/es6.object.assign":98}],45:[function(_dereq_,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],46:[function(_dereq_,module,exports){
var isObject = _dereq_('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":66}],47:[function(_dereq_,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = _dereq_('./_to-iobject')
  , toLength  = _dereq_('./_to-length')
  , toIndex   = _dereq_('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":88,"./_to-iobject":90,"./_to-length":91}],48:[function(_dereq_,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = _dereq_('./_cof')
  , TAG = _dereq_('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":49,"./_wks":95}],49:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],50:[function(_dereq_,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],51:[function(_dereq_,module,exports){
'use strict';
var $defineProperty = _dereq_('./_object-dp')
  , createDesc      = _dereq_('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":75,"./_property-desc":82}],52:[function(_dereq_,module,exports){
// optional / simple context binding
var aFunction = _dereq_('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":45}],53:[function(_dereq_,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],54:[function(_dereq_,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !_dereq_('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":58}],55:[function(_dereq_,module,exports){
var isObject = _dereq_('./_is-object')
  , document = _dereq_('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":59,"./_is-object":66}],56:[function(_dereq_,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],57:[function(_dereq_,module,exports){
var global    = _dereq_('./_global')
  , core      = _dereq_('./_core')
  , ctx       = _dereq_('./_ctx')
  , hide      = _dereq_('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":50,"./_ctx":52,"./_global":59,"./_hide":61}],58:[function(_dereq_,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],59:[function(_dereq_,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],60:[function(_dereq_,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],61:[function(_dereq_,module,exports){
var dP         = _dereq_('./_object-dp')
  , createDesc = _dereq_('./_property-desc');
module.exports = _dereq_('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":54,"./_object-dp":75,"./_property-desc":82}],62:[function(_dereq_,module,exports){
module.exports = _dereq_('./_global').document && document.documentElement;
},{"./_global":59}],63:[function(_dereq_,module,exports){
module.exports = !_dereq_('./_descriptors') && !_dereq_('./_fails')(function(){
  return Object.defineProperty(_dereq_('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":54,"./_dom-create":55,"./_fails":58}],64:[function(_dereq_,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _dereq_('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":49}],65:[function(_dereq_,module,exports){
// check on default Array iterator
var Iterators  = _dereq_('./_iterators')
  , ITERATOR   = _dereq_('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":71,"./_wks":95}],66:[function(_dereq_,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],67:[function(_dereq_,module,exports){
// call something on iterator step with safe closing on error
var anObject = _dereq_('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":46}],68:[function(_dereq_,module,exports){
'use strict';
var create         = _dereq_('./_object-create')
  , descriptor     = _dereq_('./_property-desc')
  , setToStringTag = _dereq_('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_dereq_('./_hide')(IteratorPrototype, _dereq_('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":61,"./_object-create":74,"./_property-desc":82,"./_set-to-string-tag":84,"./_wks":95}],69:[function(_dereq_,module,exports){
'use strict';
var LIBRARY        = _dereq_('./_library')
  , $export        = _dereq_('./_export')
  , redefine       = _dereq_('./_redefine')
  , hide           = _dereq_('./_hide')
  , has            = _dereq_('./_has')
  , Iterators      = _dereq_('./_iterators')
  , $iterCreate    = _dereq_('./_iter-create')
  , setToStringTag = _dereq_('./_set-to-string-tag')
  , getPrototypeOf = _dereq_('./_object-gpo')
  , ITERATOR       = _dereq_('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":57,"./_has":60,"./_hide":61,"./_iter-create":68,"./_iterators":71,"./_library":72,"./_object-gpo":78,"./_redefine":83,"./_set-to-string-tag":84,"./_wks":95}],70:[function(_dereq_,module,exports){
var ITERATOR     = _dereq_('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":95}],71:[function(_dereq_,module,exports){
module.exports = {};
},{}],72:[function(_dereq_,module,exports){
module.exports = true;
},{}],73:[function(_dereq_,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = _dereq_('./_object-keys')
  , gOPS     = _dereq_('./_object-gops')
  , pIE      = _dereq_('./_object-pie')
  , toObject = _dereq_('./_to-object')
  , IObject  = _dereq_('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || _dereq_('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":58,"./_iobject":64,"./_object-gops":77,"./_object-keys":80,"./_object-pie":81,"./_to-object":92}],74:[function(_dereq_,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = _dereq_('./_an-object')
  , dPs         = _dereq_('./_object-dps')
  , enumBugKeys = _dereq_('./_enum-bug-keys')
  , IE_PROTO    = _dereq_('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _dereq_('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  _dereq_('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":46,"./_dom-create":55,"./_enum-bug-keys":56,"./_html":62,"./_object-dps":76,"./_shared-key":85}],75:[function(_dereq_,module,exports){
var anObject       = _dereq_('./_an-object')
  , IE8_DOM_DEFINE = _dereq_('./_ie8-dom-define')
  , toPrimitive    = _dereq_('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = _dereq_('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":46,"./_descriptors":54,"./_ie8-dom-define":63,"./_to-primitive":93}],76:[function(_dereq_,module,exports){
var dP       = _dereq_('./_object-dp')
  , anObject = _dereq_('./_an-object')
  , getKeys  = _dereq_('./_object-keys');

module.exports = _dereq_('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":46,"./_descriptors":54,"./_object-dp":75,"./_object-keys":80}],77:[function(_dereq_,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],78:[function(_dereq_,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = _dereq_('./_has')
  , toObject    = _dereq_('./_to-object')
  , IE_PROTO    = _dereq_('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":60,"./_shared-key":85,"./_to-object":92}],79:[function(_dereq_,module,exports){
var has          = _dereq_('./_has')
  , toIObject    = _dereq_('./_to-iobject')
  , arrayIndexOf = _dereq_('./_array-includes')(false)
  , IE_PROTO     = _dereq_('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":47,"./_has":60,"./_shared-key":85,"./_to-iobject":90}],80:[function(_dereq_,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = _dereq_('./_object-keys-internal')
  , enumBugKeys = _dereq_('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":56,"./_object-keys-internal":79}],81:[function(_dereq_,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],82:[function(_dereq_,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],83:[function(_dereq_,module,exports){
module.exports = _dereq_('./_hide');
},{"./_hide":61}],84:[function(_dereq_,module,exports){
var def = _dereq_('./_object-dp').f
  , has = _dereq_('./_has')
  , TAG = _dereq_('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":60,"./_object-dp":75,"./_wks":95}],85:[function(_dereq_,module,exports){
var shared = _dereq_('./_shared')('keys')
  , uid    = _dereq_('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":86,"./_uid":94}],86:[function(_dereq_,module,exports){
var global = _dereq_('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":59}],87:[function(_dereq_,module,exports){
var toInteger = _dereq_('./_to-integer')
  , defined   = _dereq_('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":53,"./_to-integer":89}],88:[function(_dereq_,module,exports){
var toInteger = _dereq_('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":89}],89:[function(_dereq_,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],90:[function(_dereq_,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _dereq_('./_iobject')
  , defined = _dereq_('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":53,"./_iobject":64}],91:[function(_dereq_,module,exports){
// 7.1.15 ToLength
var toInteger = _dereq_('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":89}],92:[function(_dereq_,module,exports){
// 7.1.13 ToObject(argument)
var defined = _dereq_('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":53}],93:[function(_dereq_,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = _dereq_('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":66}],94:[function(_dereq_,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],95:[function(_dereq_,module,exports){
var store      = _dereq_('./_shared')('wks')
  , uid        = _dereq_('./_uid')
  , Symbol     = _dereq_('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":59,"./_shared":86,"./_uid":94}],96:[function(_dereq_,module,exports){
var classof   = _dereq_('./_classof')
  , ITERATOR  = _dereq_('./_wks')('iterator')
  , Iterators = _dereq_('./_iterators');
module.exports = _dereq_('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":48,"./_core":50,"./_iterators":71,"./_wks":95}],97:[function(_dereq_,module,exports){
'use strict';
var ctx            = _dereq_('./_ctx')
  , $export        = _dereq_('./_export')
  , toObject       = _dereq_('./_to-object')
  , call           = _dereq_('./_iter-call')
  , isArrayIter    = _dereq_('./_is-array-iter')
  , toLength       = _dereq_('./_to-length')
  , createProperty = _dereq_('./_create-property')
  , getIterFn      = _dereq_('./core.get-iterator-method');

$export($export.S + $export.F * !_dereq_('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":51,"./_ctx":52,"./_export":57,"./_is-array-iter":65,"./_iter-call":67,"./_iter-detect":70,"./_to-length":91,"./_to-object":92,"./core.get-iterator-method":96}],98:[function(_dereq_,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = _dereq_('./_export');

$export($export.S + $export.F, 'Object', {assign: _dereq_('./_object-assign')});
},{"./_export":57,"./_object-assign":73}],99:[function(_dereq_,module,exports){
'use strict';
var $at  = _dereq_('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
_dereq_('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":69,"./_string-at":87}],100:[function(_dereq_,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],101:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],102:[function(_dereq_,module,exports){
(function (__dirname){
var fs = _dereq_('fs'),
    path = _dereq_('path'),
    existsSync = _dereq_('fs').existsSync || _dereq_('path').existsSync;

// Load all stated versions into the module exports
module.exports.version = {};

var refs = [
 '2.0.0',
 '2.0.1',
 '2.0.2',
 '2.1.0',
 '2.1.1',
 '2.2.0',
 '2.3.0',
 '3.0.0'
];

refs.map(function(version) {
    module.exports.version[version] = _dereq_(path.join(__dirname, version, 'reference.json'));
    var ds_path = path.join(__dirname, version, 'datasources.json');
    if (existsSync(ds_path)) {
        module.exports.version[version].datasources = _dereq_(ds_path).datasources;
    }
});

}).call(this,"/node_modules/mapnik-reference")

},{"fs":5,"path":104}],103:[function(_dereq_,module,exports){
(function(){
  var crypt = _dereq_('crypt'),
      utf8 = _dereq_('charenc').utf8,
      isBuffer = _dereq_('is-buffer'),
      bin = _dereq_('charenc').bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

},{"charenc":42,"crypt":100,"is-buffer":101}],104:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,_dereq_('_process'))

},{"_process":105}],105:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],106:[function(_dereq_,module,exports){
module.exports = {
  F: _dereq_('./src/F'),
  T: _dereq_('./src/T'),
  __: _dereq_('./src/__'),
  add: _dereq_('./src/add'),
  addIndex: _dereq_('./src/addIndex'),
  adjust: _dereq_('./src/adjust'),
  all: _dereq_('./src/all'),
  allPass: _dereq_('./src/allPass'),
  always: _dereq_('./src/always'),
  and: _dereq_('./src/and'),
  any: _dereq_('./src/any'),
  anyPass: _dereq_('./src/anyPass'),
  ap: _dereq_('./src/ap'),
  aperture: _dereq_('./src/aperture'),
  append: _dereq_('./src/append'),
  apply: _dereq_('./src/apply'),
  applySpec: _dereq_('./src/applySpec'),
  ascend: _dereq_('./src/ascend'),
  assoc: _dereq_('./src/assoc'),
  assocPath: _dereq_('./src/assocPath'),
  binary: _dereq_('./src/binary'),
  bind: _dereq_('./src/bind'),
  both: _dereq_('./src/both'),
  call: _dereq_('./src/call'),
  chain: _dereq_('./src/chain'),
  clamp: _dereq_('./src/clamp'),
  clone: _dereq_('./src/clone'),
  comparator: _dereq_('./src/comparator'),
  complement: _dereq_('./src/complement'),
  compose: _dereq_('./src/compose'),
  composeK: _dereq_('./src/composeK'),
  composeP: _dereq_('./src/composeP'),
  concat: _dereq_('./src/concat'),
  cond: _dereq_('./src/cond'),
  construct: _dereq_('./src/construct'),
  constructN: _dereq_('./src/constructN'),
  contains: _dereq_('./src/contains'),
  converge: _dereq_('./src/converge'),
  countBy: _dereq_('./src/countBy'),
  curry: _dereq_('./src/curry'),
  curryN: _dereq_('./src/curryN'),
  dec: _dereq_('./src/dec'),
  descend: _dereq_('./src/descend'),
  defaultTo: _dereq_('./src/defaultTo'),
  difference: _dereq_('./src/difference'),
  differenceWith: _dereq_('./src/differenceWith'),
  dissoc: _dereq_('./src/dissoc'),
  dissocPath: _dereq_('./src/dissocPath'),
  divide: _dereq_('./src/divide'),
  drop: _dereq_('./src/drop'),
  dropLast: _dereq_('./src/dropLast'),
  dropLastWhile: _dereq_('./src/dropLastWhile'),
  dropRepeats: _dereq_('./src/dropRepeats'),
  dropRepeatsWith: _dereq_('./src/dropRepeatsWith'),
  dropWhile: _dereq_('./src/dropWhile'),
  either: _dereq_('./src/either'),
  empty: _dereq_('./src/empty'),
  eqBy: _dereq_('./src/eqBy'),
  eqProps: _dereq_('./src/eqProps'),
  equals: _dereq_('./src/equals'),
  evolve: _dereq_('./src/evolve'),
  filter: _dereq_('./src/filter'),
  find: _dereq_('./src/find'),
  findIndex: _dereq_('./src/findIndex'),
  findLast: _dereq_('./src/findLast'),
  findLastIndex: _dereq_('./src/findLastIndex'),
  flatten: _dereq_('./src/flatten'),
  flip: _dereq_('./src/flip'),
  forEach: _dereq_('./src/forEach'),
  forEachObjIndexed: _dereq_('./src/forEachObjIndexed'),
  fromPairs: _dereq_('./src/fromPairs'),
  groupBy: _dereq_('./src/groupBy'),
  groupWith: _dereq_('./src/groupWith'),
  gt: _dereq_('./src/gt'),
  gte: _dereq_('./src/gte'),
  has: _dereq_('./src/has'),
  hasIn: _dereq_('./src/hasIn'),
  head: _dereq_('./src/head'),
  identical: _dereq_('./src/identical'),
  identity: _dereq_('./src/identity'),
  ifElse: _dereq_('./src/ifElse'),
  inc: _dereq_('./src/inc'),
  indexBy: _dereq_('./src/indexBy'),
  indexOf: _dereq_('./src/indexOf'),
  init: _dereq_('./src/init'),
  insert: _dereq_('./src/insert'),
  insertAll: _dereq_('./src/insertAll'),
  intersection: _dereq_('./src/intersection'),
  intersectionWith: _dereq_('./src/intersectionWith'),
  intersperse: _dereq_('./src/intersperse'),
  into: _dereq_('./src/into'),
  invert: _dereq_('./src/invert'),
  invertObj: _dereq_('./src/invertObj'),
  invoker: _dereq_('./src/invoker'),
  is: _dereq_('./src/is'),
  isArrayLike: _dereq_('./src/isArrayLike'),
  isEmpty: _dereq_('./src/isEmpty'),
  isNil: _dereq_('./src/isNil'),
  join: _dereq_('./src/join'),
  juxt: _dereq_('./src/juxt'),
  keys: _dereq_('./src/keys'),
  keysIn: _dereq_('./src/keysIn'),
  last: _dereq_('./src/last'),
  lastIndexOf: _dereq_('./src/lastIndexOf'),
  length: _dereq_('./src/length'),
  lens: _dereq_('./src/lens'),
  lensIndex: _dereq_('./src/lensIndex'),
  lensPath: _dereq_('./src/lensPath'),
  lensProp: _dereq_('./src/lensProp'),
  lift: _dereq_('./src/lift'),
  liftN: _dereq_('./src/liftN'),
  lt: _dereq_('./src/lt'),
  lte: _dereq_('./src/lte'),
  map: _dereq_('./src/map'),
  mapAccum: _dereq_('./src/mapAccum'),
  mapAccumRight: _dereq_('./src/mapAccumRight'),
  mapObjIndexed: _dereq_('./src/mapObjIndexed'),
  match: _dereq_('./src/match'),
  mathMod: _dereq_('./src/mathMod'),
  max: _dereq_('./src/max'),
  maxBy: _dereq_('./src/maxBy'),
  mean: _dereq_('./src/mean'),
  median: _dereq_('./src/median'),
  memoize: _dereq_('./src/memoize'),
  merge: _dereq_('./src/merge'),
  mergeAll: _dereq_('./src/mergeAll'),
  mergeWith: _dereq_('./src/mergeWith'),
  mergeWithKey: _dereq_('./src/mergeWithKey'),
  min: _dereq_('./src/min'),
  minBy: _dereq_('./src/minBy'),
  modulo: _dereq_('./src/modulo'),
  multiply: _dereq_('./src/multiply'),
  nAry: _dereq_('./src/nAry'),
  negate: _dereq_('./src/negate'),
  none: _dereq_('./src/none'),
  not: _dereq_('./src/not'),
  nth: _dereq_('./src/nth'),
  nthArg: _dereq_('./src/nthArg'),
  objOf: _dereq_('./src/objOf'),
  of: _dereq_('./src/of'),
  omit: _dereq_('./src/omit'),
  once: _dereq_('./src/once'),
  or: _dereq_('./src/or'),
  over: _dereq_('./src/over'),
  pair: _dereq_('./src/pair'),
  partial: _dereq_('./src/partial'),
  partialRight: _dereq_('./src/partialRight'),
  partition: _dereq_('./src/partition'),
  path: _dereq_('./src/path'),
  pathEq: _dereq_('./src/pathEq'),
  pathOr: _dereq_('./src/pathOr'),
  pathSatisfies: _dereq_('./src/pathSatisfies'),
  pick: _dereq_('./src/pick'),
  pickAll: _dereq_('./src/pickAll'),
  pickBy: _dereq_('./src/pickBy'),
  pipe: _dereq_('./src/pipe'),
  pipeK: _dereq_('./src/pipeK'),
  pipeP: _dereq_('./src/pipeP'),
  pluck: _dereq_('./src/pluck'),
  prepend: _dereq_('./src/prepend'),
  product: _dereq_('./src/product'),
  project: _dereq_('./src/project'),
  prop: _dereq_('./src/prop'),
  propEq: _dereq_('./src/propEq'),
  propIs: _dereq_('./src/propIs'),
  propOr: _dereq_('./src/propOr'),
  propSatisfies: _dereq_('./src/propSatisfies'),
  props: _dereq_('./src/props'),
  range: _dereq_('./src/range'),
  reduce: _dereq_('./src/reduce'),
  reduceBy: _dereq_('./src/reduceBy'),
  reduceRight: _dereq_('./src/reduceRight'),
  reduceWhile: _dereq_('./src/reduceWhile'),
  reduced: _dereq_('./src/reduced'),
  reject: _dereq_('./src/reject'),
  remove: _dereq_('./src/remove'),
  repeat: _dereq_('./src/repeat'),
  replace: _dereq_('./src/replace'),
  reverse: _dereq_('./src/reverse'),
  scan: _dereq_('./src/scan'),
  sequence: _dereq_('./src/sequence'),
  set: _dereq_('./src/set'),
  slice: _dereq_('./src/slice'),
  sort: _dereq_('./src/sort'),
  sortBy: _dereq_('./src/sortBy'),
  sortWith: _dereq_('./src/sortWith'),
  split: _dereq_('./src/split'),
  splitAt: _dereq_('./src/splitAt'),
  splitEvery: _dereq_('./src/splitEvery'),
  splitWhen: _dereq_('./src/splitWhen'),
  subtract: _dereq_('./src/subtract'),
  sum: _dereq_('./src/sum'),
  symmetricDifference: _dereq_('./src/symmetricDifference'),
  symmetricDifferenceWith: _dereq_('./src/symmetricDifferenceWith'),
  tail: _dereq_('./src/tail'),
  take: _dereq_('./src/take'),
  takeLast: _dereq_('./src/takeLast'),
  takeLastWhile: _dereq_('./src/takeLastWhile'),
  takeWhile: _dereq_('./src/takeWhile'),
  tap: _dereq_('./src/tap'),
  test: _dereq_('./src/test'),
  times: _dereq_('./src/times'),
  toLower: _dereq_('./src/toLower'),
  toPairs: _dereq_('./src/toPairs'),
  toPairsIn: _dereq_('./src/toPairsIn'),
  toString: _dereq_('./src/toString'),
  toUpper: _dereq_('./src/toUpper'),
  transduce: _dereq_('./src/transduce'),
  transpose: _dereq_('./src/transpose'),
  traverse: _dereq_('./src/traverse'),
  trim: _dereq_('./src/trim'),
  tryCatch: _dereq_('./src/tryCatch'),
  type: _dereq_('./src/type'),
  unapply: _dereq_('./src/unapply'),
  unary: _dereq_('./src/unary'),
  uncurryN: _dereq_('./src/uncurryN'),
  unfold: _dereq_('./src/unfold'),
  union: _dereq_('./src/union'),
  unionWith: _dereq_('./src/unionWith'),
  uniq: _dereq_('./src/uniq'),
  uniqBy: _dereq_('./src/uniqBy'),
  uniqWith: _dereq_('./src/uniqWith'),
  unless: _dereq_('./src/unless'),
  unnest: _dereq_('./src/unnest'),
  until: _dereq_('./src/until'),
  update: _dereq_('./src/update'),
  useWith: _dereq_('./src/useWith'),
  values: _dereq_('./src/values'),
  valuesIn: _dereq_('./src/valuesIn'),
  view: _dereq_('./src/view'),
  when: _dereq_('./src/when'),
  where: _dereq_('./src/where'),
  whereEq: _dereq_('./src/whereEq'),
  without: _dereq_('./src/without'),
  xprod: _dereq_('./src/xprod'),
  zip: _dereq_('./src/zip'),
  zipObj: _dereq_('./src/zipObj'),
  zipWith: _dereq_('./src/zipWith')
};

},{"./src/F":107,"./src/T":108,"./src/__":109,"./src/add":110,"./src/addIndex":111,"./src/adjust":112,"./src/all":113,"./src/allPass":114,"./src/always":115,"./src/and":116,"./src/any":117,"./src/anyPass":118,"./src/ap":119,"./src/aperture":120,"./src/append":121,"./src/apply":122,"./src/applySpec":123,"./src/ascend":124,"./src/assoc":125,"./src/assocPath":126,"./src/binary":127,"./src/bind":128,"./src/both":129,"./src/call":130,"./src/chain":131,"./src/clamp":132,"./src/clone":133,"./src/comparator":134,"./src/complement":135,"./src/compose":136,"./src/composeK":137,"./src/composeP":138,"./src/concat":139,"./src/cond":140,"./src/construct":141,"./src/constructN":142,"./src/contains":143,"./src/converge":144,"./src/countBy":145,"./src/curry":146,"./src/curryN":147,"./src/dec":148,"./src/defaultTo":149,"./src/descend":150,"./src/difference":151,"./src/differenceWith":152,"./src/dissoc":153,"./src/dissocPath":154,"./src/divide":155,"./src/drop":156,"./src/dropLast":157,"./src/dropLastWhile":158,"./src/dropRepeats":159,"./src/dropRepeatsWith":160,"./src/dropWhile":161,"./src/either":162,"./src/empty":163,"./src/eqBy":164,"./src/eqProps":165,"./src/equals":166,"./src/evolve":167,"./src/filter":168,"./src/find":169,"./src/findIndex":170,"./src/findLast":171,"./src/findLastIndex":172,"./src/flatten":173,"./src/flip":174,"./src/forEach":175,"./src/forEachObjIndexed":176,"./src/fromPairs":177,"./src/groupBy":178,"./src/groupWith":179,"./src/gt":180,"./src/gte":181,"./src/has":182,"./src/hasIn":183,"./src/head":184,"./src/identical":185,"./src/identity":186,"./src/ifElse":187,"./src/inc":188,"./src/indexBy":189,"./src/indexOf":190,"./src/init":191,"./src/insert":192,"./src/insertAll":193,"./src/intersection":264,"./src/intersectionWith":265,"./src/intersperse":266,"./src/into":267,"./src/invert":268,"./src/invertObj":269,"./src/invoker":270,"./src/is":271,"./src/isArrayLike":272,"./src/isEmpty":273,"./src/isNil":274,"./src/join":275,"./src/juxt":276,"./src/keys":277,"./src/keysIn":278,"./src/last":279,"./src/lastIndexOf":280,"./src/length":281,"./src/lens":282,"./src/lensIndex":283,"./src/lensPath":284,"./src/lensProp":285,"./src/lift":286,"./src/liftN":287,"./src/lt":288,"./src/lte":289,"./src/map":290,"./src/mapAccum":291,"./src/mapAccumRight":292,"./src/mapObjIndexed":293,"./src/match":294,"./src/mathMod":295,"./src/max":296,"./src/maxBy":297,"./src/mean":298,"./src/median":299,"./src/memoize":300,"./src/merge":301,"./src/mergeAll":302,"./src/mergeWith":303,"./src/mergeWithKey":304,"./src/min":305,"./src/minBy":306,"./src/modulo":307,"./src/multiply":308,"./src/nAry":309,"./src/negate":310,"./src/none":311,"./src/not":312,"./src/nth":313,"./src/nthArg":314,"./src/objOf":315,"./src/of":316,"./src/omit":317,"./src/once":318,"./src/or":319,"./src/over":320,"./src/pair":321,"./src/partial":322,"./src/partialRight":323,"./src/partition":324,"./src/path":325,"./src/pathEq":326,"./src/pathOr":327,"./src/pathSatisfies":328,"./src/pick":329,"./src/pickAll":330,"./src/pickBy":331,"./src/pipe":332,"./src/pipeK":333,"./src/pipeP":334,"./src/pluck":335,"./src/prepend":336,"./src/product":337,"./src/project":338,"./src/prop":339,"./src/propEq":340,"./src/propIs":341,"./src/propOr":342,"./src/propSatisfies":343,"./src/props":344,"./src/range":345,"./src/reduce":346,"./src/reduceBy":347,"./src/reduceRight":348,"./src/reduceWhile":349,"./src/reduced":350,"./src/reject":351,"./src/remove":352,"./src/repeat":353,"./src/replace":354,"./src/reverse":355,"./src/scan":356,"./src/sequence":357,"./src/set":358,"./src/slice":359,"./src/sort":360,"./src/sortBy":361,"./src/sortWith":362,"./src/split":363,"./src/splitAt":364,"./src/splitEvery":365,"./src/splitWhen":366,"./src/subtract":367,"./src/sum":368,"./src/symmetricDifference":369,"./src/symmetricDifferenceWith":370,"./src/tail":371,"./src/take":372,"./src/takeLast":373,"./src/takeLastWhile":374,"./src/takeWhile":375,"./src/tap":376,"./src/test":377,"./src/times":378,"./src/toLower":379,"./src/toPairs":380,"./src/toPairsIn":381,"./src/toString":382,"./src/toUpper":383,"./src/transduce":384,"./src/transpose":385,"./src/traverse":386,"./src/trim":387,"./src/tryCatch":388,"./src/type":389,"./src/unapply":390,"./src/unary":391,"./src/uncurryN":392,"./src/unfold":393,"./src/union":394,"./src/unionWith":395,"./src/uniq":396,"./src/uniqBy":397,"./src/uniqWith":398,"./src/unless":399,"./src/unnest":400,"./src/until":401,"./src/update":402,"./src/useWith":403,"./src/values":404,"./src/valuesIn":405,"./src/view":406,"./src/when":407,"./src/where":408,"./src/whereEq":409,"./src/without":410,"./src/xprod":411,"./src/zip":412,"./src/zipObj":413,"./src/zipWith":414}],107:[function(_dereq_,module,exports){
var always = _dereq_('./always');


/**
 * A function that always returns `false`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.T
 * @example
 *
 *      R.F(); //=> false
 */
module.exports = always(false);

},{"./always":115}],108:[function(_dereq_,module,exports){
var always = _dereq_('./always');


/**
 * A function that always returns `true`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.F
 * @example
 *
 *      R.T(); //=> true
 */
module.exports = always(true);

},{"./always":115}],109:[function(_dereq_,module,exports){
/**
 * A special placeholder value used to specify "gaps" within curried functions,
 * allowing partial application of any combination of arguments, regardless of
 * their positions.
 *
 * If `g` is a curried ternary function and `_` is `R.__`, the following are
 * equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2, _)(1, 3)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @constant
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @example
 *
 *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
 *      greet('Alice'); //=> 'Hello, Alice!'
 */
module.exports = {'@@functional/placeholder': true};

},{}],110:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */
module.exports = _curry2(function add(a, b) {
  return Number(a) + Number(b);
});

},{"./internal/_curry2":208}],111:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _curry1 = _dereq_('./internal/_curry1');
var curryN = _dereq_('./curryN');


/**
 * Creates a new list iteration function from an existing one by adding two new
 * parameters to its callback function: the current index, and the entire list.
 *
 * This would turn, for instance, Ramda's simple `map` function into one that
 * more closely resembles `Array.prototype.map`. Note that this will only work
 * for functions in which the iteration callback function is the first
 * parameter, and where the list is the last parameter. (This latter might be
 * unimportant if the list parameter is not used.)
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Function
 * @category List
 * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
 * @param {Function} fn A list iteration function that does not pass index or list to its callback
 * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
 * @example
 *
 *      var mapIndexed = R.addIndex(R.map);
 *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
 *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
 */
module.exports = _curry1(function addIndex(fn) {
  return curryN(fn.length, function() {
    var idx = 0;
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function() {
      var result = origFn.apply(this, _concat(arguments, [idx, list]));
      idx += 1;
      return result;
    };
    return fn.apply(this, args);
  });
});

},{"./curryN":147,"./internal/_concat":203,"./internal/_curry1":207}],112:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Applies a function to the value at the given index of an array, returning a
 * new copy of the array with the element at the given index replaced with the
 * result of the function application.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig (a -> a) -> Number -> [a] -> [a]
 * @param {Function} fn The function to apply.
 * @param {Number} idx The index.
 * @param {Array|Arguments} list An array-like object whose value
 *        at the supplied index will be replaced.
 * @return {Array} A copy of the supplied array-like object with
 *         the element at index `idx` replaced with the value
 *         returned by applying `fn` to the existing element.
 * @see R.update
 * @example
 *
 *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
 *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
 * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
 * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
 */
module.exports = _curry3(function adjust(fn, idx, list) {
  if (idx >= list.length || idx < -list.length) {
    return list;
  }
  var start = idx < 0 ? list.length : 0;
  var _idx = start + idx;
  var _list = _concat(list);
  _list[_idx] = fn(list[_idx]);
  return _list;
});

},{"./internal/_concat":203,"./internal/_curry3":209}],113:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xall = _dereq_('./internal/_xall');


/**
 * Returns `true` if all elements of the list match the predicate, `false` if
 * there are any that don't.
 *
 * Dispatches to the `all` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none, R.transduce
 * @example
 *
 *      var equals3 = R.equals(3);
 *      R.all(equals3)([3, 3, 3, 3]); //=> true
 *      R.all(equals3)([3, 3, 1, 3]); //=> false
 */
module.exports = _curry2(_dispatchable(['all'], _xall, function all(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xall":244}],114:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var curryN = _dereq_('./curryN');
var max = _dereq_('./max');
var pluck = _dereq_('./pluck');
var reduce = _dereq_('./reduce');


/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if every one of the provided predicates is satisfied
 * by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.anyPass
 * @example
 *
 *      var isQueen = R.propEq('rank', 'Q');
 *      var isSpade = R.propEq('suit', '♠︎');
 *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
 *
 *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
 *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
 */
module.exports = _curry1(function allPass(preds) {
  return curryN(reduce(max, 0, pluck('length', preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }
      idx += 1;
    }
    return true;
  });
});

},{"./curryN":147,"./internal/_curry1":207,"./max":296,"./pluck":335,"./reduce":346}],115:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Returns a function that always returns the given value. Note that for
 * non-primitives the value returned is a reference to the original value.
 *
 * This function is known as `const`, `constant`, or `K` (for K combinator) in
 * other languages and libraries.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> (* -> a)
 * @param {*} val The value to wrap in a function
 * @return {Function} A Function :: * -> val.
 * @example
 *
 *      var t = R.always('Tee');
 *      t(); //=> 'Tee'
 */
module.exports = _curry1(function always(val) {
  return function() {
    return val;
  };
});

},{"./internal/_curry1":207}],116:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns `true` if both arguments are `true`; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if it is falsy, otherwise the second argument.
 * @see R.both
 * @example
 *
 *      R.and(true, true); //=> true
 *      R.and(true, false); //=> false
 *      R.and(false, true); //=> false
 *      R.and(false, false); //=> false
 */
module.exports = _curry2(function and(a, b) {
  return a && b;
});

},{"./internal/_curry2":208}],117:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xany = _dereq_('./internal/_xany');


/**
 * Returns `true` if at least one of elements of the list match the predicate,
 * `false` otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
 *         otherwise.
 * @see R.all, R.none, R.transduce
 * @example
 *
 *      var lessThan0 = R.flip(R.lt)(0);
 *      var lessThan2 = R.flip(R.lt)(2);
 *      R.any(lessThan0)([1, 2]); //=> false
 *      R.any(lessThan2)([1, 2]); //=> true
 */
module.exports = _curry2(_dispatchable(['any'], _xany, function any(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (fn(list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xany":245}],118:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var curryN = _dereq_('./curryN');
var max = _dereq_('./max');
var pluck = _dereq_('./pluck');
var reduce = _dereq_('./reduce');


/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if at least one of the provided predicates is
 * satisfied by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.allPass
 * @example
 *
 *      var isClub = R.propEq('suit', '♣');
 *      var isSpade = R.propEq('suit', '♠');
 *      var isBlackCard = R.anyPass([isClub, isSpade]);
 *
 *      isBlackCard({rank: '10', suit: '♣'}); //=> true
 *      isBlackCard({rank: 'Q', suit: '♠'}); //=> true
 *      isBlackCard({rank: 'Q', suit: '♦'}); //=> false
 */
module.exports = _curry1(function anyPass(preds) {
  return curryN(reduce(max, 0, pluck('length', preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }
      idx += 1;
    }
    return false;
  });
});

},{"./curryN":147,"./internal/_curry1":207,"./max":296,"./pluck":335,"./reduce":346}],119:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _curry2 = _dereq_('./internal/_curry2');
var _reduce = _dereq_('./internal/_reduce');
var map = _dereq_('./map');


/**
 * ap applies a list of functions to a list of values.
 *
 * Dispatches to the `ap` method of the second argument, if present. Also
 * treats curried functions as applicatives.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig [a -> b] -> [a] -> [b]
 * @sig Apply f => f (a -> b) -> f a -> f b
 * @param {Array} fns An array of functions
 * @param {Array} vs An array of values
 * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
 * @example
 *
 *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
 *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
 * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
 */
module.exports = _curry2(function ap(applicative, fn) {
  return (
    typeof applicative.ap === 'function' ?
      applicative.ap(fn) :
    typeof applicative === 'function' ?
      function(x) { return applicative(x)(fn(x)); } :
    // else
      _reduce(function(acc, f) { return _concat(acc, map(f, fn)); }, [], applicative)
  );
});

},{"./internal/_concat":203,"./internal/_curry2":208,"./internal/_reduce":239,"./map":290}],120:[function(_dereq_,module,exports){
var _aperture = _dereq_('./internal/_aperture');
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xaperture = _dereq_('./internal/_xaperture');


/**
 * Returns a new list, composed of n-tuples of consecutive elements If `n` is
 * greater than the length of the list, an empty list is returned.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @param {Number} n The size of the tuples to create
 * @param {Array} list The list to split into `n`-length tuples
 * @return {Array} The resulting list of `n`-length tuples
 * @see R.transduce
 * @example
 *
 *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
 *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
 *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
 */
module.exports = _curry2(_dispatchable([], _xaperture, _aperture));

},{"./internal/_aperture":195,"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xaperture":246}],121:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a new list containing the contents of the given list, followed by
 * the given element.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The element to add to the end of the new list.
 * @param {Array} list The list of elements to add a new item to.
 *        list.
 * @return {Array} A new list containing the elements of the old list followed by `el`.
 * @see R.prepend
 * @example
 *
 *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
 *      R.append('tests', []); //=> ['tests']
 *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
 */
module.exports = _curry2(function append(el, list) {
  return _concat(list, [el]);
});

},{"./internal/_concat":203,"./internal/_curry2":208}],122:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Applies function `fn` to the argument list `args`. This is useful for
 * creating a fixed-arity function from a variadic function. `fn` should be a
 * bound function if context is significant.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> a) -> [*] -> a
 * @param {Function} fn The function which will be called with `args`
 * @param {Array} args The arguments to call `fn` with
 * @return {*} result The result, equivalent to `fn(...args)`
 * @see R.call, R.unapply
 * @example
 *
 *      var nums = [1, 2, 3, -99, 42, 6, 7];
 *      R.apply(Math.max, nums); //=> 42
 * @symb R.apply(f, [a, b, c]) = f(a, b, c)
 */
module.exports = _curry2(function apply(fn, args) {
  return fn.apply(this, args);
});

},{"./internal/_curry2":208}],123:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var apply = _dereq_('./apply');
var curryN = _dereq_('./curryN');
var map = _dereq_('./map');
var max = _dereq_('./max');
var pluck = _dereq_('./pluck');
var reduce = _dereq_('./reduce');
var values = _dereq_('./values');


/**
 * Given a spec object recursively mapping properties to functions, creates a
 * function producing an object of the same structure, by mapping each property
 * to the result of calling its associated function with the supplied arguments.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
 * @param {Object} spec an object recursively mapping properties to functions for
 *        producing the values for these properties.
 * @return {Function} A function that returns an object of the same structure
 * as `spec', with each property set to the value returned by calling its
 * associated function with the supplied arguments.
 * @see R.converge, R.juxt
 * @example
 *
 *      var getMetrics = R.applySpec({
 *                                      sum: R.add,
 *                                      nested: { mul: R.multiply }
 *                                   });
 *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
 * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
 */
module.exports = _curry1(function applySpec(spec) {
  spec = map(function(v) { return typeof v == 'function' ? v : applySpec(v); },
             spec);
  return curryN(reduce(max, 0, pluck('length', values(spec))),
                function() {
                  var args = arguments;
                  return map(function(f) { return apply(f, args); }, spec);
                });
});

},{"./apply":122,"./curryN":147,"./internal/_curry1":207,"./map":290,"./max":296,"./pluck":335,"./reduce":346,"./values":404}],124:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Makes an ascending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
 * @example
 *
 *      var byAge = R.ascend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByYoungestFirst = R.sort(byAge, people);
 */
module.exports = _curry3(function ascend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa < bb ? -1 : aa > bb ? 1 : 0;
});

},{"./internal/_curry3":209}],125:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Makes a shallow clone of an object, setting or overriding the specified
 * property with the given value. Note that this copies and flattens prototype
 * properties onto the new object as well. All non-primitive properties are
 * copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig String -> a -> {k: v} -> {k: v}
 * @param {String} prop The property name to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except for the changed property.
 * @see R.dissoc
 * @example
 *
 *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
 */
module.exports = _curry3(function assoc(prop, val, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  result[prop] = val;
  return result;
});

},{"./internal/_curry3":209}],126:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var _has = _dereq_('./internal/_has');
var _isArray = _dereq_('./internal/_isArray');
var _isInteger = _dereq_('./internal/_isInteger');
var assoc = _dereq_('./assoc');


/**
 * Makes a shallow clone of an object, setting or overriding the nodes required
 * to create the given path, and placing the specific value at the tail end of
 * that path. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> {a}
 * @param {Array} path the path to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except along the specified path.
 * @see R.dissocPath
 * @example
 *
 *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
 *
 *      // Any missing or non-object keys in path will be overridden
 *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
 */
module.exports = _curry3(function assocPath(path, val, obj) {
  if (path.length === 0) {
    return val;
  }
  var idx = path[0];
  if (path.length > 1) {
    var nextObj = _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
    val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
  }
  if (_isInteger(idx) && _isArray(obj)) {
    var arr = [].concat(obj);
    arr[idx] = val;
    return arr;
  } else {
    return assoc(idx, val, obj);
  }
});

},{"./assoc":125,"./internal/_curry3":209,"./internal/_has":219,"./internal/_isArray":223,"./internal/_isInteger":225}],127:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var nAry = _dereq_('./nAry');


/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 2 parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> c) -> (a, b -> c)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 2.
 * @example
 *
 *      var takesThreeArgs = function(a, b, c) {
 *        return [a, b, c];
 *      };
 *      takesThreeArgs.length; //=> 3
 *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
 *
 *      var takesTwoArgs = R.binary(takesThreeArgs);
 *      takesTwoArgs.length; //=> 2
 *      // Only 2 arguments are passed to the wrapped function
 *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
 * @symb R.binary(f)(a, b, c) = f(a, b)
 */
module.exports = _curry1(function binary(fn) {
  return nAry(2, fn);
});

},{"./internal/_curry1":207,"./nAry":309}],128:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      var log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */
module.exports = _curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});

},{"./internal/_arity":196,"./internal/_curry2":208}],129:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isFunction = _dereq_('./internal/_isFunction');
var and = _dereq_('./and');
var lift = _dereq_('./lift');


/**
 * A function which calls the two provided functions and returns the `&&`
 * of the results.
 * It returns the result of the first function if it is false-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * false-y value.
 *
 * In addition to functions, `R.both` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f A predicate
 * @param {Function} g Another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
 * @see R.and
 * @example
 *
 *      var gt10 = R.gt(R.__, 10)
 *      var lt20 = R.lt(R.__, 20)
 *      var f = R.both(gt10, lt20);
 *      f(15); //=> true
 *      f(30); //=> false
 */
module.exports = _curry2(function both(f, g) {
  return _isFunction(f) ?
    function _both() {
      return f.apply(this, arguments) && g.apply(this, arguments);
    } :
    lift(and)(f, g);
});

},{"./and":116,"./internal/_curry2":208,"./internal/_isFunction":224,"./lift":286}],130:[function(_dereq_,module,exports){
var curry = _dereq_('./curry');


/**
 * Returns the result of calling its first argument with the remaining
 * arguments. This is occasionally useful as a converging function for
 * `R.converge`: the left branch can produce a function while the right branch
 * produces a value to be passed to that function as an argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig (*... -> a),*... -> a
 * @param {Function} fn The function to apply to the remaining arguments.
 * @param {...*} args Any number of positional arguments.
 * @return {*}
 * @see R.apply
 * @example
 *
 *      R.call(R.add, 1, 2); //=> 3
 *
 *      var indentN = R.pipe(R.times(R.always(' ')),
 *                           R.join(''),
 *                           R.replace(/^(?!$)/gm));
 *
 *      var format = R.converge(R.call, [
 *                                  R.pipe(R.prop('indent'), indentN),
 *                                  R.prop('value')
 *                              ]);
 *
 *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
 * @symb R.call(f, a, b) = f(a, b)
 */
module.exports = curry(function call(fn) {
  return fn.apply(this, Array.prototype.slice.call(arguments, 1));
});

},{"./curry":146}],131:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _makeFlat = _dereq_('./internal/_makeFlat');
var _xchain = _dereq_('./internal/_xchain');
var map = _dereq_('./map');


/**
 * `chain` maps a function over a list and concatenates the results. `chain`
 * is also known as `flatMap` in some libraries
 *
 * Dispatches to the `chain` method of the second argument, if present,
 * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain m => (a -> m b) -> m a -> m b
 * @param {Function} fn The function to map with
 * @param {Array} list The list to map over
 * @return {Array} The result of flat-mapping `list` with `fn`
 * @example
 *
 *      var duplicate = n => [n, n];
 *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
 *
 *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
 */
module.exports = _curry2(_dispatchable(['chain'], _xchain, function chain(fn, monad) {
  if (typeof monad === 'function') {
    return function(x) { return fn(monad(x))(x); };
  }
  return _makeFlat(false)(map(fn, monad));
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_makeFlat":232,"./internal/_xchain":247,"./map":290}],132:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');

/**
 * Restricts a number to be within a range.
 *
 * Also works for other ordered types such as Strings and Dates.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Relation
 * @sig Ord a => a -> a -> a -> a
 * @param {Number} minimum The lower limit of the clamp (inclusive)
 * @param {Number} maximum The upper limit of the clamp (inclusive)
 * @param {Number} value Value to be clamped
 * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
 * @example
 *
 *      R.clamp(1, 10, -5) // => 1
 *      R.clamp(1, 10, 15) // => 10
 *      R.clamp(1, 10, 4)  // => 4
 */
module.exports = _curry3(function clamp(min, max, value) {
  if (min > max) {
    throw new Error('min must not be greater than max in clamp(min, max, value)');
  }
  return value < min ? min :
         value > max ? max :
         value;
});

},{"./internal/_curry3":209}],133:[function(_dereq_,module,exports){
var _clone = _dereq_('./internal/_clone');
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Creates a deep copy of the value which may contain (nested) `Array`s and
 * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
 * assigned by reference rather than copied
 *
 * Dispatches to a `clone` method if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {*} -> {*}
 * @param {*} value The object or array to clone
 * @return {*} A deeply cloned copy of `val`
 * @example
 *
 *      var objects = [{}, {}, {}];
 *      var objectsClone = R.clone(objects);
 *      objects === objectsClone; //=> false
 *      objects[0] === objectsClone[0]; //=> false
 */
module.exports = _curry1(function clone(value) {
  return value != null && typeof value.clone === 'function' ?
    value.clone() :
    _clone(value, [], [], true);
});

},{"./internal/_clone":200,"./internal/_curry1":207}],134:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Makes a comparator function out of a function that reports whether the first
 * element is less than the second.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a, b -> Boolean) -> (a, b -> Number)
 * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
 * is less than the second, `false` otherwise
 * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
 * @example
 *
 *      var byAge = R.comparator((a, b) => a.age < b.age);
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByIncreasingAge = R.sort(byAge, people);
 */
module.exports = _curry1(function comparator(pred) {
  return function(a, b) {
    return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
  };
});

},{"./internal/_curry1":207}],135:[function(_dereq_,module,exports){
var lift = _dereq_('./lift');
var not = _dereq_('./not');


/**
 * Takes a function `f` and returns a function `g` such that if called with the same arguments
 * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
 *
 * `R.complement` may be applied to any functor
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> *) -> (*... -> Boolean)
 * @param {Function} f
 * @return {Function}
 * @see R.not
 * @example
 *
 *      var isNotNil = R.complement(R.isNil);
 *      isNil(null); //=> true
 *      isNotNil(null); //=> false
 *      isNil(7); //=> false
 *      isNotNil(7); //=> true
 */
module.exports = lift(not);

},{"./lift":286,"./not":312}],136:[function(_dereq_,module,exports){
var pipe = _dereq_('./pipe');
var reverse = _dereq_('./reverse');


/**
 * Performs right-to-left function composition. The rightmost function may have
 * any arity; the remaining functions must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 */
module.exports = function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }
  return pipe.apply(this, reverse(arguments));
};

},{"./pipe":332,"./reverse":355}],137:[function(_dereq_,module,exports){
var chain = _dereq_('./chain');
var compose = _dereq_('./compose');
var map = _dereq_('./map');


/**
 * Returns the right-to-left Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipeK
 * @example
 *
 *       //  get :: String -> Object -> Maybe *
 *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
 *
 *       //  getStateCode :: Maybe String -> Maybe String
 *       var getStateCode = R.composeK(
 *         R.compose(Maybe.of, R.toUpper),
 *         get('state'),
 *         get('address'),
 *         get('user'),
 *       );
 *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
 *       getStateCode({}); //=> Maybe.Nothing()
 * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
 */
module.exports = function composeK() {
  if (arguments.length === 0) {
    throw new Error('composeK requires at least one argument');
  }
  var init = Array.prototype.slice.call(arguments);
  var last = init.pop();
  return compose(compose.apply(this, map(chain, init)), last);
};

},{"./chain":131,"./compose":136,"./map":290}],138:[function(_dereq_,module,exports){
var pipeP = _dereq_('./pipeP');
var reverse = _dereq_('./reverse');


/**
 * Performs right-to-left composition of one or more Promise-returning
 * functions. The rightmost function may have any arity; the remaining
 * functions must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
 * @param {...Function} functions The functions to compose
 * @return {Function}
 * @see R.pipeP
 * @example
 *
 *      var db = {
 *        users: {
 *          JOE: {
 *            name: 'Joe',
 *            followers: ['STEVE', 'SUZY']
 *          }
 *        }
 *      }
 *
 *      // We'll pretend to do a db lookup which returns a promise
 *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
 *      var lookupFollowers = (user) => Promise.resolve(user.followers)
 *      lookupUser('JOE').then(lookupFollowers)
 *
 *      //  followersForUser :: String -> Promise [UserId]
 *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
 *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
 *      // Followers: ["STEVE","SUZY"]
 */
module.exports = function composeP() {
  if (arguments.length === 0) {
    throw new Error('composeP requires at least one argument');
  }
  return pipeP.apply(this, reverse(arguments));
};

},{"./pipeP":334,"./reverse":355}],139:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isArray = _dereq_('./internal/_isArray');
var _isFunction = _dereq_('./internal/_isFunction');
var toString = _dereq_('./toString');


/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: `R.concat` expects both arguments to be of the same type,
 * unlike the native `Array.prototype.concat` method. It will throw
 * an error if you `concat` an Array with a non-Array value.
 *
 * Dispatches to the `concat` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @sig String -> String -> String
 * @param {Array|String} firstList The first list
 * @param {Array|String} secondList The second list
 * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
 * `secondList`.
 *
 * @example
 *
 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 *      R.concat([], []); //=> []
 */
module.exports = _curry2(function concat(a, b) {
  if (a == null || !_isFunction(a.concat)) {
    throw new TypeError(toString(a) + ' does not have a method named "concat"');
  }
  if (_isArray(a) && !_isArray(b)) {
    throw new TypeError(toString(b) + ' is not an array');
  }
  return a.concat(b);
});

},{"./internal/_curry2":208,"./internal/_isArray":223,"./internal/_isFunction":224,"./toString":382}],140:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _curry1 = _dereq_('./internal/_curry1');
var map = _dereq_('./map');
var max = _dereq_('./max');
var reduce = _dereq_('./reduce');


/**
 * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
 * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
 * to `fn` are applied to each of the predicates in turn until one returns a
 * "truthy" value, at which point `fn` returns the result of applying its
 * arguments to the corresponding transformer. If none of the predicates
 * matches, `fn` returns undefined.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Logic
 * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
 * @param {Array} pairs A list of [predicate, transformer]
 * @return {Function}
 * @example
 *
 *      var fn = R.cond([
 *        [R.equals(0),   R.always('water freezes at 0°C')],
 *        [R.equals(100), R.always('water boils at 100°C')],
 *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
 *      ]);
 *      fn(0); //=> 'water freezes at 0°C'
 *      fn(50); //=> 'nothing special happens at 50°C'
 *      fn(100); //=> 'water boils at 100°C'
 */
module.exports = _curry1(function cond(pairs) {
  var arity = reduce(max,
                     0,
                     map(function(pair) { return pair[0].length; }, pairs));
  return _arity(arity, function() {
    var idx = 0;
    while (idx < pairs.length) {
      if (pairs[idx][0].apply(this, arguments)) {
        return pairs[idx][1].apply(this, arguments);
      }
      idx += 1;
    }
  });
});

},{"./internal/_arity":196,"./internal/_curry1":207,"./map":290,"./max":296,"./reduce":346}],141:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var constructN = _dereq_('./constructN');


/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> {*}) -> (* -> {*})
 * @param {Function} fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @example
 *
 *      // Constructor function
 *      function Animal(kind) {
 *        this.kind = kind;
 *      };
 *      Animal.prototype.sighting = function() {
 *        return "It's a " + this.kind + "!";
 *      }
 *
 *      var AnimalConstructor = R.construct(Animal)
 *
 *      // Notice we no longer need the 'new' keyword:
 *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
 *
 *      var animalTypes = ["Lion", "Tiger", "Bear"];
 *      var animalSighting = R.invoker(0, 'sighting');
 *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
 *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
 */
module.exports = _curry1(function construct(Fn) {
  return constructN(Fn.length, Fn);
});

},{"./constructN":142,"./internal/_curry1":207}],142:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var curry = _dereq_('./curry');
var nAry = _dereq_('./nAry');


/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type. The arity of the function
 * returned is specified to allow using variadic constructor functions.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Function
 * @sig Number -> (* -> {*}) -> (* -> {*})
 * @param {Number} n The arity of the constructor function.
 * @param {Function} Fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @example
 *
 *      // Variadic Constructor function
 *      function Salad() {
 *        this.ingredients = arguments;
 *      };
 *      Salad.prototype.recipe = function() {
 *        var instructions = R.map((ingredient) => (
 *          'Add a whollop of ' + ingredient, this.ingredients)
 *        )
 *        return R.join('\n', instructions)
 *      }
 *
 *      var ThreeLayerSalad = R.constructN(3, Salad)
 *
 *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
 *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup')
 *      console.log(salad.recipe());
 *      // Add a whollop of Mayonnaise
 *      // Add a whollop of Potato Chips
 *      // Add a whollop of Potato Ketchup
 */
module.exports = _curry2(function constructN(n, Fn) {
  if (n > 10) {
    throw new Error('Constructor with greater than ten arguments');
  }
  if (n === 0) {
    return function() { return new Fn(); };
  }
  return curry(nAry(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
    switch (arguments.length) {
      case  1: return new Fn($0);
      case  2: return new Fn($0, $1);
      case  3: return new Fn($0, $1, $2);
      case  4: return new Fn($0, $1, $2, $3);
      case  5: return new Fn($0, $1, $2, $3, $4);
      case  6: return new Fn($0, $1, $2, $3, $4, $5);
      case  7: return new Fn($0, $1, $2, $3, $4, $5, $6);
      case  8: return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
      case  9: return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
      case 10: return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
    }
  }));
});

},{"./curry":146,"./internal/_curry2":208,"./nAry":309}],143:[function(_dereq_,module,exports){
var _contains = _dereq_('./internal/_contains');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns `true` if the specified value is equal, in `R.equals` terms, to at
 * least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.contains([42], [[42]]); //=> true
 */
module.exports = _curry2(_contains);

},{"./internal/_contains":204,"./internal/_curry2":208}],144:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _map = _dereq_('./internal/_map');
var curryN = _dereq_('./curryN');
var max = _dereq_('./max');
var pluck = _dereq_('./pluck');
var reduce = _dereq_('./reduce');


/**
 * Accepts a converging function and a list of branching functions and returns
 * a new function. When invoked, this new function is applied to some
 * arguments, each branching function is applied to those same arguments. The
 * results of each branching function are passed as arguments to the converging
 * function to produce the return value.
 *
 * @func
 * @memberOf R
 * @since v0.4.2
 * @category Function
 * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} after A function. `after` will be invoked with the return values of
 *        `fn1` and `fn2` as its arguments.
 * @param {Array} functions A list of functions.
 * @return {Function} A new function.
 * @see R.useWith
 * @example
 *
 *      var average = R.converge(R.divide, [R.sum, R.length])
 *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
 *
 *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
 *      strangeConcat("Yodel") //=> "YODELyodel"
 *
 * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
 */
module.exports = _curry2(function converge(after, fns) {
  return curryN(reduce(max, 0, pluck('length', fns)), function() {
    var args = arguments;
    var context = this;
    return after.apply(context, _map(function(fn) {
      return fn.apply(context, args);
    }, fns));
  });
});

},{"./curryN":147,"./internal/_curry2":208,"./internal/_map":233,"./max":296,"./pluck":335,"./reduce":346}],145:[function(_dereq_,module,exports){
var reduceBy = _dereq_('./reduceBy');


/**
 * Counts the elements of a list according to how many match each value of a
 * key generated by the supplied function. Returns an object mapping the keys
 * produced by `fn` to the number of occurrences in the list. Note that all
 * keys are coerced to strings because of how JavaScript objects work.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig (a -> String) -> [a] -> {*}
 * @param {Function} fn The function used to map values to keys.
 * @param {Array} list The list to count elements from.
 * @return {Object} An object mapping keys to number of occurrences in the list.
 * @example
 *
 *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
 *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
 *
 *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
 *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
 */
module.exports = reduceBy(function(acc, elem) { return acc + 1; }, 0);

},{"./reduceBy":347}],146:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var curryN = _dereq_('./curryN');


/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN
 * @example
 *
 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
module.exports = _curry1(function curry(fn) {
  return curryN(fn.length, fn);
});

},{"./curryN":147,"./internal/_curry1":207}],147:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _curry1 = _dereq_('./internal/_curry1');
var _curry2 = _dereq_('./internal/_curry2');
var _curryN = _dereq_('./internal/_curryN');


/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      var sumArgs = (...args) => R.sum(args);
 *
 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
module.exports = _curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});

},{"./internal/_arity":196,"./internal/_curry1":207,"./internal/_curry2":208,"./internal/_curryN":210}],148:[function(_dereq_,module,exports){
var add = _dereq_('./add');


/**
 * Decrements its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n - 1
 * @see R.inc
 * @example
 *
 *      R.dec(42); //=> 41
 */
module.exports = add(-1);

},{"./add":110}],149:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`
 * otherwise the first argument is returned.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {a} default The default value.
 * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
 * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
 * @example
 *
 *      var defaultTo42 = R.defaultTo(42);
 *
 *      defaultTo42(null);  //=> 42
 *      defaultTo42(undefined);  //=> 42
 *      defaultTo42('Ramda');  //=> 'Ramda'
 *      // parseInt('string') results in NaN
 *      defaultTo42(parseInt('string')); //=> 42
 */
module.exports = _curry2(function defaultTo(d, v) {
  return v == null || v !== v ? d : v;
});

},{"./internal/_curry2":208}],150:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Makes a descending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
 * @example
 *
 *      var byAge = R.descend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByOldestFirst = R.sort(byAge, people);
 */
module.exports = _curry3(function descend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa > bb ? -1 : aa < bb ? 1 : 0;
});

},{"./internal/_curry3":209}],151:[function(_dereq_,module,exports){
var _contains = _dereq_('./internal/_contains');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Objects and Arrays are compared are compared
 * in terms of value equality, not reference equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith
 * @example
 *
 *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
 *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
 *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
 */
module.exports = _curry2(function difference(first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
      out[out.length] = first[idx];
    }
    idx += 1;
  }
  return out;
});

},{"./internal/_contains":204,"./internal/_curry2":208}],152:[function(_dereq_,module,exports){
var _containsWith = _dereq_('./internal/_containsWith');
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Duplication is determined according to the
 * value returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
 * @example
 *
 *      var cmp = (x, y) => x.a === y.a;
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
 *      var l2 = [{a: 3}, {a: 4}];
 *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
 */
module.exports = _curry3(function differenceWith(pred, first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!_containsWith(pred, first[idx], second) &&
        !_containsWith(pred, first[idx], out)) {
      out.push(first[idx]);
    }
    idx += 1;
  }
  return out;
});

},{"./internal/_containsWith":205,"./internal/_curry3":209}],153:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a new object that does not contain a `prop` property.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Object
 * @sig String -> {k: v} -> {k: v}
 * @param {String} prop The name of the property to dissociate
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original but without the specified property
 * @see R.assoc
 * @example
 *
 *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
 */
module.exports = _curry2(function dissoc(prop, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  delete result[prop];
  return result;
});

},{"./internal/_curry2":208}],154:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var assoc = _dereq_('./assoc');
var dissoc = _dereq_('./dissoc');


/**
 * Makes a shallow clone of an object, omitting the property at the given path.
 * Note that this copies and flattens prototype properties onto the new object
 * as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.11.0
 * @category Object
 * @sig [String] -> {k: v} -> {k: v}
 * @param {Array} path The path to the value to omit
 * @param {Object} obj The object to clone
 * @return {Object} A new object without the property at path
 * @see R.assocPath
 * @example
 *
 *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
 */
module.exports = _curry2(function dissocPath(path, obj) {
  switch (path.length) {
    case 0:
      return obj;
    case 1:
      return dissoc(path[0], obj);
    default:
      var head = path[0];
      var tail = Array.prototype.slice.call(path, 1);
      return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
  }
});

},{"./assoc":125,"./dissoc":153,"./internal/_curry2":208}],155:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Divides two numbers. Equivalent to `a / b`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a / b`.
 * @see R.multiply
 * @example
 *
 *      R.divide(71, 100); //=> 0.71
 *
 *      var half = R.divide(R.__, 2);
 *      half(42); //=> 21
 *
 *      var reciprocal = R.divide(1);
 *      reciprocal(4);   //=> 0.25
 */
module.exports = _curry2(function divide(a, b) { return a / b; });

},{"./internal/_curry2":208}],156:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xdrop = _dereq_('./internal/_xdrop');
var slice = _dereq_('./slice');


/**
 * Returns all but the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `drop` method).
 *
 * Dispatches to the `drop` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {[a]} list
 * @return {[a]} A copy of list without the first `n` elements
 * @see R.take, R.transduce, R.dropLast, R.dropWhile
 * @example
 *
 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(3, 'ramda');               //=> 'da'
 */
module.exports = _curry2(_dispatchable(['drop'], _xdrop, function drop(n, xs) {
  return slice(Math.max(0, n), Infinity, xs);
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xdrop":248,"./slice":359}],157:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _dropLast = _dereq_('./internal/_dropLast');
var _xdropLast = _dereq_('./internal/_xdropLast');


/**
 * Returns a list containing all but the last `n` elements of the given `list`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements of `list` to skip.
 * @param {Array} list The list of elements to consider.
 * @return {Array} A copy of the list with only the first `list.length - n` elements
 * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
 * @example
 *
 *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(3, 'ramda');               //=> 'ra'
 */
module.exports = _curry2(_dispatchable([], _xdropLast, _dropLast));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_dropLast":212,"./internal/_xdropLast":249}],158:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _dropLastWhile = _dereq_('./internal/_dropLastWhile');
var _xdropLastWhile = _dereq_('./internal/_xdropLastWhile');


/**
 * Returns a new list excluding all the tailing elements of a given list which
 * satisfy the supplied predicate function. It passes each value from the right
 * to the supplied predicate function, skipping elements until the predicate
 * function returns a `falsy` value. The predicate function is applied to one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} predicate The function to be called on each element
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
 * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
 * @example
 *
 *      var lteThree = x => x <= 3;
 *
 *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
 */
module.exports = _curry2(_dispatchable([], _xdropLastWhile, _dropLastWhile));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_dropLastWhile":213,"./internal/_xdropLastWhile":250}],159:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xdropRepeatsWith = _dereq_('./internal/_xdropRepeatsWith');
var dropRepeatsWith = _dereq_('./dropRepeatsWith');
var equals = _dereq_('./equals');


/**
 * Returns a new list without any consecutively repeating elements. `R.equals`
 * is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
 */
module.exports = _curry1(_dispatchable([], _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

},{"./dropRepeatsWith":160,"./equals":166,"./internal/_curry1":207,"./internal/_dispatchable":211,"./internal/_xdropRepeatsWith":251}],160:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xdropRepeatsWith = _dereq_('./internal/_xdropRepeatsWith');
var last = _dereq_('./last');


/**
 * Returns a new list without any consecutively repeating elements. Equality is
 * determined by applying the supplied predicate to each pair of consecutive elements. The
 * first element in a series of equal elements will be preserved.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig (a, a -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
 *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
 */
module.exports = _curry2(_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
  var result = [];
  var idx = 1;
  var len = list.length;
  if (len !== 0) {
    result[0] = list[0];
    while (idx < len) {
      if (!pred(last(result), list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
  }
  return result;
}));


},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xdropRepeatsWith":251,"./last":279}],161:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xdropWhile = _dereq_('./internal/_xdropWhile');


/**
 * Returns a new list excluding the leading elements of a given list which
 * satisfy the supplied predicate function. It passes each value to the supplied
 * predicate function, skipping elements while the predicate function returns
 * `true`. The predicate function is applied to one argument: *(value)*.
 *
 * Dispatches to the `dropWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} fn The function called per iteration.
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array.
 * @see R.takeWhile, R.transduce, R.addIndex
 * @example
 *
 *      var lteTwo = x => x <= 2;
 *
 *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
 */
module.exports = _curry2(_dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len && pred(list[idx])) {
    idx += 1;
  }
  return Array.prototype.slice.call(list, idx);
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xdropWhile":252}],162:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isFunction = _dereq_('./internal/_isFunction');
var lift = _dereq_('./lift');
var or = _dereq_('./or');


/**
 * A function wrapping calls to the two functions in an `||` operation,
 * returning the result of the first function if it is truth-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * truth-y value.
 *
 * In addition to functions, `R.either` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f a predicate
 * @param {Function} g another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
 * @see R.or
 * @example
 *
 *      var gt10 = x => x > 10;
 *      var even = x => x % 2 === 0;
 *      var f = R.either(gt10, even);
 *      f(101); //=> true
 *      f(8); //=> true
 */
module.exports = _curry2(function either(f, g) {
  return _isFunction(f) ?
    function _either() {
      return f.apply(this, arguments) || g.apply(this, arguments);
    } :
    lift(or)(f, g);
});

},{"./internal/_curry2":208,"./internal/_isFunction":224,"./lift":286,"./or":319}],163:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _isArguments = _dereq_('./internal/_isArguments');
var _isArray = _dereq_('./internal/_isArray');
var _isObject = _dereq_('./internal/_isObject');
var _isString = _dereq_('./internal/_isString');


/**
 * Returns the empty value of its argument's type. Ramda defines the empty
 * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
 * types are supported if they define `<Type>.empty` and/or
 * `<Type>.prototype.empty`.
 *
 * Dispatches to the `empty` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> a
 * @param {*} x
 * @return {*}
 * @example
 *
 *      R.empty(Just(42));      //=> Nothing()
 *      R.empty([1, 2, 3]);     //=> []
 *      R.empty('unicorns');    //=> ''
 *      R.empty({x: 1, y: 2});  //=> {}
 */
module.exports = _curry1(function empty(x) {
  return (
    (x != null && typeof x.empty === 'function') ?
      x.empty() :
    (x != null && x.constructor != null && typeof x.constructor.empty === 'function') ?
      x.constructor.empty() :
    _isArray(x) ?
      [] :
    _isString(x) ?
      '' :
    _isObject(x) ?
      {} :
    _isArguments(x) ?
      (function() { return arguments; }()) :
    // else
      void 0
  );
});

},{"./internal/_curry1":207,"./internal/_isArguments":222,"./internal/_isArray":223,"./internal/_isObject":227,"./internal/_isString":230}],164:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var equals = _dereq_('./equals');


/**
 * Takes a function and two values in its domain and returns `true` if the
 * values map to the same value in the codomain; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Relation
 * @sig (a -> b) -> a -> a -> Boolean
 * @param {Function} f
 * @param {*} x
 * @param {*} y
 * @return {Boolean}
 * @example
 *
 *      R.eqBy(Math.abs, 5, -5); //=> true
 */
module.exports = _curry3(function eqBy(f, x, y) {
  return equals(f(x), f(y));
});

},{"./equals":166,"./internal/_curry3":209}],165:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var equals = _dereq_('./equals');


/**
 * Reports whether two objects have the same value, in `R.equals` terms, for
 * the specified property. Useful as a curried predicate.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig k -> {k: v} -> {k: v} -> Boolean
 * @param {String} prop The name of the property to compare
 * @param {Object} obj1
 * @param {Object} obj2
 * @return {Boolean}
 *
 * @example
 *
 *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
 *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
 *      R.eqProps('a', o1, o2); //=> false
 *      R.eqProps('c', o1, o2); //=> true
 */
module.exports = _curry3(function eqProps(prop, obj1, obj2) {
  return equals(obj1[prop], obj2[prop]);
});

},{"./equals":166,"./internal/_curry3":209}],166:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _equals = _dereq_('./internal/_equals');


/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
module.exports = _curry2(function equals(a, b) {
  return _equals(a, b, [], []);
});

},{"./internal/_curry2":208,"./internal/_equals":214}],167:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Creates a new object by recursively evolving a shallow copy of `object`,
 * according to the `transformation` functions. All non-primitive properties
 * are copied by reference.
 *
 * A `transformation` function will not be invoked if its corresponding key
 * does not exist in the evolved object.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {k: (v -> v)} -> {k: v} -> {k: v}
 * @param {Object} transformations The object specifying transformation functions to apply
 *        to the object.
 * @param {Object} object The object to be transformed.
 * @return {Object} The transformed object.
 * @example
 *
 *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
 *      var transformations = {
 *        firstName: R.trim,
 *        lastName: R.trim, // Will not get invoked.
 *        data: {elapsed: R.add(1), remaining: R.add(-1)}
 *      };
 *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
 */
module.exports = _curry2(function evolve(transformations, object) {
  var result = {};
  var transformation, key, type;
  for (key in object) {
    transformation = transformations[key];
    type = typeof transformation;
    result[key] = type === 'function'                 ? transformation(object[key])
                : transformation && type === 'object' ? evolve(transformation, object[key])
                                                      : object[key];
  }
  return result;
});

},{"./internal/_curry2":208}],168:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _filter = _dereq_('./internal/_filter');
var _isObject = _dereq_('./internal/_isObject');
var _reduce = _dereq_('./internal/_reduce');
var _xfilter = _dereq_('./internal/_xfilter');
var keys = _dereq_('./keys');


/**
 * Takes a predicate and a "filterable", and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
module.exports = _curry2(_dispatchable(['filter'], _xfilter, function(pred, filterable) {
  return (
    _isObject(filterable) ?
      _reduce(function(acc, key) {
        if (pred(filterable[key])) {
          acc[key] = filterable[key];
        }
        return acc;
      }, {}, keys(filterable)) :
    // else
      _filter(pred, filterable)
  );
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_filter":215,"./internal/_isObject":227,"./internal/_reduce":239,"./internal/_xfilter":254,"./keys":277}],169:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xfind = _dereq_('./internal/_xfind');


/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */
module.exports = _curry2(_dispatchable(['find'], _xfind, function find(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx += 1;
  }
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xfind":255}],170:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xfindIndex = _dereq_('./internal/_xfindIndex');


/**
 * Returns the index of the first element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
 */
module.exports = _curry2(_dispatchable([], _xfindIndex, function findIndex(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xfindIndex":256}],171:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xfindLast = _dereq_('./internal/_xfindLast');


/**
 * Returns the last element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
 *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
 */
module.exports = _curry2(_dispatchable([], _xfindLast, function findLast(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx -= 1;
  }
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xfindLast":257}],172:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xfindLastIndex = _dereq_('./internal/_xfindLastIndex');


/**
 * Returns the index of the last element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
 *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
 */
module.exports = _curry2(_dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return idx;
    }
    idx -= 1;
  }
  return -1;
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xfindLastIndex":258}],173:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _makeFlat = _dereq_('./internal/_makeFlat');


/**
 * Returns a new list by pulling every item out of it (and all its sub-arrays)
 * and putting them in a new array, depth-first.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b]
 * @param {Array} list The array to consider.
 * @return {Array} The flattened list.
 * @see R.unnest
 * @example
 *
 *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
 *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
 */
module.exports = _curry1(_makeFlat(true));

},{"./internal/_curry1":207,"./internal/_makeFlat":232}],174:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var curry = _dereq_('./curry');


/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
 * @param {Function} fn The function to invoke with its first two parameters reversed.
 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
 * @example
 *
 *      var mergeThree = (a, b, c) => [].concat(a, b, c);
 *
 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
 *
 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
 * @symb R.flip(f)(a, b, c) = f(b, a, c)
 */
module.exports = _curry1(function flip(fn) {
  return curry(function(a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});

},{"./curry":146,"./internal/_curry1":207}],175:[function(_dereq_,module,exports){
var _checkForMethod = _dereq_('./internal/_checkForMethod');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Iterate over an input `list`, calling a provided function `fn` for each
 * element in the list.
 *
 * `fn` receives one argument: *(value)*.
 *
 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.forEach` method. For more
 * details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
 *
 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
 * the original array. In some libraries this function is named `each`.
 *
 * Dispatches to the `forEach` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> *) -> [a] -> [a]
 * @param {Function} fn The function to invoke. Receives one argument, `value`.
 * @param {Array} list The list to iterate over.
 * @return {Array} The original list.
 * @see R.addIndex
 * @example
 *
 *      var printXPlusFive = x => console.log(x + 5);
 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
 *      // logs 6
 *      // logs 7
 *      // logs 8
 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
 */
module.exports = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
  var len = list.length;
  var idx = 0;
  while (idx < len) {
    fn(list[idx]);
    idx += 1;
  }
  return list;
}));

},{"./internal/_checkForMethod":199,"./internal/_curry2":208}],176:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var keys = _dereq_('./keys');


/**
 * Iterate over an input `object`, calling a provided function `fn` for each
 * key and value in the object.
 *
 * `fn` receives three argument: *(value, key, obj)*.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Object
 * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
 * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
 * @param {Object} obj The object to iterate over.
 * @return {Object} The original object.
 * @example
 *
 *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
 *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
 *      // logs x:1
 *      // logs y:2
 * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
 */
module.exports = _curry2(function forEachObjIndexed(fn, obj) {
  var keyList = keys(obj);
  var idx = 0;
  while (idx < keyList.length) {
    var key = keyList[idx];
    fn(obj[key], key, obj);
    idx += 1;
  }
  return obj;
});

},{"./internal/_curry2":208,"./keys":277}],177:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Creates a new object from a list key-value pairs. If a key appears in
 * multiple pairs, the rightmost pair is included in the object.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [[k,v]] -> {k: v}
 * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
 * @return {Object} The object made by pairing up `keys` and `values`.
 * @see R.toPairs, R.pair
 * @example
 *
 *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
 */
module.exports = _curry1(function fromPairs(pairs) {
  var result = {};
  var idx = 0;
  while (idx < pairs.length) {
    result[pairs[idx][0]] = pairs[idx][1];
    idx += 1;
  }
  return result;
});

},{"./internal/_curry1":207}],178:[function(_dereq_,module,exports){
var _checkForMethod = _dereq_('./internal/_checkForMethod');
var _curry2 = _dereq_('./internal/_curry2');
var reduceBy = _dereq_('./reduceBy');

/**
 * Splits a list into sub-lists stored in an object, based on the result of
 * calling a String-returning function on each element, and grouping the
 * results according to values returned.
 *
 * Dispatches to the `groupBy` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> String) -> [a] -> {String: [a]}
 * @param {Function} fn Function :: a -> String
 * @param {Array} list The array to group
 * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
 *         that produced that key when passed to `fn`.
 * @see R.transduce
 * @example
 *
 *      var byGrade = R.groupBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Abby', score: 84},
 *                      {name: 'Eddy', score: 58},
 *                      // ...
 *                      {name: 'Jack', score: 69}];
 *      byGrade(students);
 *      // {
 *      //   'A': [{name: 'Dianne', score: 99}],
 *      //   'B': [{name: 'Abby', score: 84}]
 *      //   // ...,
 *      //   'F': [{name: 'Eddy', score: 58}]
 *      // }
 */
module.exports = _curry2(_checkForMethod('groupBy', reduceBy(function(acc, item) {
  if (acc == null) {
    acc = [];
  }
  acc.push(item);
  return acc;
}, null)));

},{"./internal/_checkForMethod":199,"./internal/_curry2":208,"./reduceBy":347}],179:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');

/**
 * Takes a list and returns a list of lists where each sublist's elements are
 * all "equal" according to the provided equality function.
 *
 * @func
 * @memberOf R
 * @since v0.21.0
 * @category List
 * @sig ((a, a) → Boolean) → [a] → [[a]]
 * @param {Function} fn Function for determining whether two given (adjacent)
 *        elements should be in the same group
 * @param {Array} list The array to group. Also accepts a string, which will be
 *        treated as a list of characters.
 * @return {List} A list that contains sublists of equal elements,
 *         whose concatenations are equal to the original list.
 * @example
 *
 * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
 *
 * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
 *
 * R.groupWith(R.eqBy(isVowel), 'aestiou')
 * //=> ['ae', 'st', 'iou']
 */
module.exports = _curry2(function(fn, list) {
  var res = [];
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    var nextidx = idx + 1;
    while (nextidx < len && fn(list[idx], list[nextidx])) {
      nextidx += 1;
    }
    res.push(list.slice(idx, nextidx));
    idx = nextidx;
  }
  return res;
});

},{"./internal/_curry2":208}],180:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns `true` if the first argument is greater than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.lt
 * @example
 *
 *      R.gt(2, 1); //=> true
 *      R.gt(2, 2); //=> false
 *      R.gt(2, 3); //=> false
 *      R.gt('a', 'z'); //=> false
 *      R.gt('z', 'a'); //=> true
 */
module.exports = _curry2(function gt(a, b) { return a > b; });

},{"./internal/_curry2":208}],181:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns `true` if the first argument is greater than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.lte
 * @example
 *
 *      R.gte(2, 1); //=> true
 *      R.gte(2, 2); //=> true
 *      R.gte(2, 3); //=> false
 *      R.gte('a', 'z'); //=> false
 *      R.gte('z', 'a'); //=> true
 */
module.exports = _curry2(function gte(a, b) { return a >= b; });

},{"./internal/_curry2":208}],182:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _has = _dereq_('./internal/_has');


/**
 * Returns whether or not an object has an own property with the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      var hasName = R.has('name');
 *      hasName({name: 'alice'});   //=> true
 *      hasName({name: 'bob'});     //=> true
 *      hasName({});                //=> false
 *
 *      var point = {x: 0, y: 0};
 *      var pointHas = R.has(R.__, point);
 *      pointHas('x');  //=> true
 *      pointHas('y');  //=> true
 *      pointHas('z');  //=> false
 */
module.exports = _curry2(_has);

},{"./internal/_curry2":208,"./internal/_has":219}],183:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns whether or not an object or its prototype chain has a property with
 * the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      function Rectangle(width, height) {
 *        this.width = width;
 *        this.height = height;
 *      }
 *      Rectangle.prototype.area = function() {
 *        return this.width * this.height;
 *      };
 *
 *      var square = new Rectangle(2, 2);
 *      R.hasIn('width', square);  //=> true
 *      R.hasIn('area', square);  //=> true
 */
module.exports = _curry2(function hasIn(prop, obj) {
  return prop in obj;
});

},{"./internal/_curry2":208}],184:[function(_dereq_,module,exports){
var nth = _dereq_('./nth');


/**
 * Returns the first element of the given list or string. In some libraries
 * this function is named `first`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {Array|String} list
 * @return {*}
 * @see R.tail, R.init, R.last
 * @example
 *
 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
 *      R.head([]); //=> undefined
 *
 *      R.head('abc'); //=> 'a'
 *      R.head(''); //=> ''
 */
module.exports = nth(0);

},{"./nth":313}],185:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
module.exports = _curry2(function identical(a, b) {
  // SameValue algorithm
  if (a === b) { // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});

},{"./internal/_curry2":208}],186:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _identity = _dereq_('./internal/_identity');


/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      var obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */
module.exports = _curry1(_identity);

},{"./internal/_curry1":207,"./internal/_identity":220}],187:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var curryN = _dereq_('./curryN');


/**
 * Creates a function that will process either the `onTrue` or the `onFalse`
 * function depending upon the result of the `condition` predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
 * @param {Function} condition A predicate function
 * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
 * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
 * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
 *                    function depending upon the result of the `condition` predicate.
 * @see R.unless, R.when
 * @example
 *
 *      var incCount = R.ifElse(
 *        R.has('count'),
 *        R.over(R.lensProp('count'), R.inc),
 *        R.assoc('count', 1)
 *      );
 *      incCount({});           //=> { count: 1 }
 *      incCount({ count: 1 }); //=> { count: 2 }
 */
module.exports = _curry3(function ifElse(condition, onTrue, onFalse) {
  return curryN(Math.max(condition.length, onTrue.length, onFalse.length),
    function _ifElse() {
      return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
    }
  );
});

},{"./curryN":147,"./internal/_curry3":209}],188:[function(_dereq_,module,exports){
var add = _dereq_('./add');


/**
 * Increments its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n + 1
 * @see R.dec
 * @example
 *
 *      R.inc(42); //=> 43
 */
module.exports = add(1);

},{"./add":110}],189:[function(_dereq_,module,exports){
var reduceBy = _dereq_('./reduceBy');


/**
 * Given a function that generates a key, turns a list of objects into an
 * object indexing the objects by the given key. Note that if multiple
 * objects generate the same value for the indexing key only the last value
 * will be included in the generated object.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
 * @param {Function} fn Function :: a -> String
 * @param {Array} array The array of objects to index
 * @return {Object} An object indexing each array element by the given property.
 * @example
 *
 *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
 *      R.indexBy(R.prop('id'), list);
 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
 */
module.exports = reduceBy(function(acc, elem) { return elem; }, null);

},{"./reduceBy":347}],190:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _indexOf = _dereq_('./internal/_indexOf');
var _isArray = _dereq_('./internal/_isArray');


/**
 * Returns the position of the first occurrence of an item in an array, or -1
 * if the item is not included in the array. `R.equals` is used to determine
 * equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.lastIndexOf
 * @example
 *
 *      R.indexOf(3, [1,2,3,4]); //=> 2
 *      R.indexOf(10, [1,2,3,4]); //=> -1
 */
module.exports = _curry2(function indexOf(target, xs) {
  return typeof xs.indexOf === 'function' && !_isArray(xs) ?
    xs.indexOf(target) :
    _indexOf(xs, target, 0);
});

},{"./internal/_curry2":208,"./internal/_indexOf":221,"./internal/_isArray":223}],191:[function(_dereq_,module,exports){
var slice = _dereq_('./slice');


/**
 * Returns all but the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.last, R.head, R.tail
 * @example
 *
 *      R.init([1, 2, 3]);  //=> [1, 2]
 *      R.init([1, 2]);     //=> [1]
 *      R.init([1]);        //=> []
 *      R.init([]);         //=> []
 *
 *      R.init('abc');  //=> 'ab'
 *      R.init('ab');   //=> 'a'
 *      R.init('a');    //=> ''
 *      R.init('');     //=> ''
 */
module.exports = slice(0, -1);

},{"./slice":359}],192:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Inserts the supplied element into the list, at index `index`. _Note that
 * this is not destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} index The position to insert the element
 * @param {*} elt The element to insert into the Array
 * @param {Array} list The list to insert into
 * @return {Array} A new Array with `elt` inserted at `index`.
 * @example
 *
 *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
 */
module.exports = _curry3(function insert(idx, elt, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  var result = Array.prototype.slice.call(list, 0);
  result.splice(idx, 0, elt);
  return result;
});

},{"./internal/_curry3":209}],193:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Inserts the sub-list into the list, at index `index`. _Note that this is not
 * destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig Number -> [a] -> [a] -> [a]
 * @param {Number} index The position to insert the sub-list
 * @param {Array} elts The sub-list to insert into the Array
 * @param {Array} list The list to insert the sub-list into
 * @return {Array} A new Array with `elts` inserted starting at `index`.
 * @example
 *
 *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
 */
module.exports = _curry3(function insertAll(idx, elts, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  return [].concat(Array.prototype.slice.call(list, 0, idx),
                   elts,
                   Array.prototype.slice.call(list, idx));
});

},{"./internal/_curry3":209}],194:[function(_dereq_,module,exports){
var _contains = _dereq_('./_contains');


// A simple Set type that honours R.equals semantics
module.exports = (function() {
  function _Set() {
    /* globals Set */
    this._nativeSet = typeof Set === 'function' ? new Set() : null;
    this._items = {};
  }

  // until we figure out why jsdoc chokes on this
  // @param item The item to add to the Set
  // @returns {boolean} true if the item did not exist prior, otherwise false
  //
  _Set.prototype.add = function(item) {
    return !hasOrAdd(item, true, this);
  };

  //
  // @param item The item to check for existence in the Set
  // @returns {boolean} true if the item exists in the Set, otherwise false
  //
  _Set.prototype.has = function(item) {
    return hasOrAdd(item, false, this);
  };

  //
  // Combines the logic for checking whether an item is a member of the set and
  // for adding a new item to the set.
  //
  // @param item       The item to check or add to the Set instance.
  // @param shouldAdd  If true, the item will be added to the set if it doesn't
  //                   already exist.
  // @param set        The set instance to check or add to.
  // @return {boolean} true if the item already existed, otherwise false.
  //
  function hasOrAdd(item, shouldAdd, set) {
    var type = typeof item;
    var prevSize, newSize;
    switch (type) {
      case 'string':
      case 'number':
        // distinguish between +0 and -0
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items['-0']) {
            return true;
          } else {
            if (shouldAdd) {
              set._items['-0'] = true;
            }
            return false;
          }
        }
        // these types can all utilise the native Set
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = {};
              set._items[type][item] = true;
            }
            return false;
          } else if (item in set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][item] = true;
            }
            return false;
          }
        }

      case 'boolean':
        // set._items['boolean'] holds a two element array
        // representing [ falseExists, trueExists ]
        if (type in set._items) {
          var bIdx = item ? 1 : 0;
          if (set._items[type][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type] = item ? [false, true] : [true, false];
          }
          return false;
        }

      case 'function':
        // compare functions for reference equality
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }
            return false;
          }
          if (!_contains(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }
            return false;
          }
          return true;
        }

      case 'undefined':
        if (set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type] = true;
          }
          return false;
        }

      case 'object':
        if (item === null) {
          if (!set._items['null']) {
            if (shouldAdd) {
              set._items['null'] = true;
            }
            return false;
          }
          return true;
        }
      /* falls through */
      default:
        // reduce the search size of heterogeneous sets by creating buckets
        // for each type.
        type = Object.prototype.toString.call(item);
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }
          return false;
        }
        // scan through all previously applied items
        if (!_contains(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }
          return false;
        }
        return true;
    }
  }
  return _Set;
}());

},{"./_contains":204}],195:[function(_dereq_,module,exports){
module.exports = function _aperture(n, list) {
  var idx = 0;
  var limit = list.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
    idx += 1;
  }
  return acc;
};

},{}],196:[function(_dereq_,module,exports){
module.exports = function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0: return function() { return fn.apply(this, arguments); };
    case 1: return function(a0) { return fn.apply(this, arguments); };
    case 2: return function(a0, a1) { return fn.apply(this, arguments); };
    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };
    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };
    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };
    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };
    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };
    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };
    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };
    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };
    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
};

},{}],197:[function(_dereq_,module,exports){
module.exports = function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
};

},{}],198:[function(_dereq_,module,exports){
var _objectAssign = _dereq_('./_objectAssign');

module.exports =
  typeof Object.assign === 'function' ? Object.assign : _objectAssign;

},{"./_objectAssign":234}],199:[function(_dereq_,module,exports){
var _isArray = _dereq_('./_isArray');


/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */
module.exports = function _checkForMethod(methodname, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return (_isArray(obj) || typeof obj[methodname] !== 'function') ?
      fn.apply(this, arguments) :
      obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
};

},{"./_isArray":223}],200:[function(_dereq_,module,exports){
var _cloneRegExp = _dereq_('./_cloneRegExp');
var type = _dereq_('../type');


/**
 * Copies an object.
 *
 * @private
 * @param {*} value The value to be copied
 * @param {Array} refFrom Array containing the source references
 * @param {Array} refTo Array containing the copied source references
 * @param {Boolean} deep Whether or not to perform deep cloning.
 * @return {*} The copied value.
 */
module.exports = function _clone(value, refFrom, refTo, deep) {
  var copy = function copy(copiedValue) {
    var len = refFrom.length;
    var idx = 0;
    while (idx < len) {
      if (value === refFrom[idx]) {
        return refTo[idx];
      }
      idx += 1;
    }
    refFrom[idx + 1] = value;
    refTo[idx + 1] = copiedValue;
    for (var key in value) {
      copiedValue[key] = deep ?
        _clone(value[key], refFrom, refTo, true) : value[key];
    }
    return copiedValue;
  };
  switch (type(value)) {
    case 'Object':  return copy({});
    case 'Array':   return copy([]);
    case 'Date':    return new Date(value.valueOf());
    case 'RegExp':  return _cloneRegExp(value);
    default:        return value;
  }
};

},{"../type":389,"./_cloneRegExp":201}],201:[function(_dereq_,module,exports){
module.exports = function _cloneRegExp(pattern) {
  return new RegExp(pattern.source, (pattern.global     ? 'g' : '') +
                                    (pattern.ignoreCase ? 'i' : '') +
                                    (pattern.multiline  ? 'm' : '') +
                                    (pattern.sticky     ? 'y' : '') +
                                    (pattern.unicode    ? 'u' : ''));
};

},{}],202:[function(_dereq_,module,exports){
module.exports = function _complement(f) {
  return function() {
    return !f.apply(this, arguments);
  };
};

},{}],203:[function(_dereq_,module,exports){
/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
module.exports = function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];

  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }
  return result;
};

},{}],204:[function(_dereq_,module,exports){
var _indexOf = _dereq_('./_indexOf');


module.exports = function _contains(a, list) {
  return _indexOf(list, a, 0) >= 0;
};

},{"./_indexOf":221}],205:[function(_dereq_,module,exports){
module.exports = function _containsWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
};

},{}],206:[function(_dereq_,module,exports){
var _arity = _dereq_('./_arity');
var _curry2 = _dereq_('./_curry2');


module.exports = function _createPartialApplicator(concat) {
  return _curry2(function(fn, args) {
    return _arity(Math.max(0, fn.length - args.length), function() {
      return fn.apply(this, concat(args, arguments));
    });
  });
};

},{"./_arity":196,"./_curry2":208}],207:[function(_dereq_,module,exports){
var _isPlaceholder = _dereq_('./_isPlaceholder');


/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

},{"./_isPlaceholder":228}],208:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./_curry1');
var _isPlaceholder = _dereq_('./_isPlaceholder');


/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2
             : _curry1(function(_b) { return fn(a, _b); });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2
             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })
             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })
             : fn(a, b);
    }
  };
};

},{"./_curry1":207,"./_isPlaceholder":228}],209:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./_curry1');
var _curry2 = _dereq_('./_curry2');
var _isPlaceholder = _dereq_('./_isPlaceholder');


/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3
             : _curry2(function(_b, _c) { return fn(a, _b, _c); });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3
             : _isPlaceholder(a) ? _curry2(function(_a, _c) { return fn(_a, b, _c); })
             : _isPlaceholder(b) ? _curry2(function(_b, _c) { return fn(a, _b, _c); })
             : _curry1(function(_c) { return fn(a, b, _c); });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3
             : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) { return fn(_a, _b, c); })
             : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) { return fn(_a, b, _c); })
             : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) { return fn(a, _b, _c); })
             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b, c); })
             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b, c); })
             : _isPlaceholder(c) ? _curry1(function(_c) { return fn(a, b, _c); })
             : fn(a, b, c);
    }
  };
};

},{"./_curry1":207,"./_curry2":208,"./_isPlaceholder":228}],210:[function(_dereq_,module,exports){
var _arity = _dereq_('./_arity');
var _isPlaceholder = _dereq_('./_isPlaceholder');


/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curryN(length, received, fn) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length &&
          (!_isPlaceholder(received[combinedIdx]) ||
           argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined)
                     : _arity(left, _curryN(length, combined, fn));
  };
};

},{"./_arity":196,"./_isPlaceholder":228}],211:[function(_dereq_,module,exports){
var _isArray = _dereq_('./_isArray');
var _isTransformer = _dereq_('./_isTransformer');


/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
module.exports = function _dispatchable(methodNames, xf, fn) {
  return function() {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!_isArray(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
};

},{"./_isArray":223,"./_isTransformer":231}],212:[function(_dereq_,module,exports){
var take = _dereq_('../take');

module.exports = function dropLast(n, xs) {
  return take(n < xs.length ? xs.length - n : 0, xs);
};

},{"../take":372}],213:[function(_dereq_,module,exports){
module.exports = function dropLastWhile(pred, list) {
  var idx = list.length - 1;
  while (idx >= 0 && pred(list[idx])) {
    idx -= 1;
  }
  return Array.prototype.slice.call(list, 0, idx + 1);
};

},{}],214:[function(_dereq_,module,exports){
var _arrayFromIterator = _dereq_('./_arrayFromIterator');
var _functionName = _dereq_('./_functionName');
var _has = _dereq_('./_has');
var identical = _dereq_('../identical');
var keys = _dereq_('../keys');
var type = _dereq_('../type');


module.exports = function _equals(a, b, stackA, stackB) {
  if (identical(a, b)) {
    return true;
  }

  if (type(a) !== type(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) &&
           typeof b.equals === 'function' && b.equals(a);
  }

  switch (type(a)) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' &&
          _functionName(a.constructor) === 'Promise') {
        return a === b;
      }
      break;
    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case 'Date':
      if (!identical(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case 'Error':
      return a.name === b.name && a.message === b.message;
    case 'RegExp':
      if (!(a.source === b.source &&
            a.global === b.global &&
            a.ignoreCase === b.ignoreCase &&
            a.multiline === b.multiline &&
            a.sticky === b.sticky &&
            a.unicode === b.unicode)) {
        return false;
      }
      break;
    case 'Map':
    case 'Set':
      if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
        return false;
      }
      break;
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
      break;
    case 'ArrayBuffer':
      break;
    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = keys(a);
  if (keysA.length !== keys(b).length) {
    return false;
  }

  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }

  stackA.push(a);
  stackB.push(b);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
      return false;
    }
    idx -= 1;
  }
  stackA.pop();
  stackB.pop();
  return true;
};

},{"../identical":185,"../keys":277,"../type":389,"./_arrayFromIterator":197,"./_functionName":218,"./_has":219}],215:[function(_dereq_,module,exports){
module.exports = function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
};

},{}],216:[function(_dereq_,module,exports){
var _forceReduced = _dereq_('./_forceReduced');
var _reduce = _dereq_('./_reduce');
var _xfBase = _dereq_('./_xfBase');
var isArrayLike = _dereq_('../isArrayLike');

module.exports = (function() {
  var preservingReduced = function(xf) {
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function(result) {
        return xf['@@transducer/result'](result);
      },
      '@@transducer/step': function(result, input) {
        var ret = xf['@@transducer/step'](result, input);
        return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
      }
    };
  };

  return function _xcat(xf) {
    var rxf = preservingReduced(xf);
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function(result) {
        return rxf['@@transducer/result'](result);
      },
      '@@transducer/step': function(result, input) {
        return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
      }
    };
  };
}());

},{"../isArrayLike":272,"./_forceReduced":217,"./_reduce":239,"./_xfBase":253}],217:[function(_dereq_,module,exports){
module.exports = function _forceReduced(x) {
  return {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
};

},{}],218:[function(_dereq_,module,exports){
module.exports = function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
};

},{}],219:[function(_dereq_,module,exports){
module.exports = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

},{}],220:[function(_dereq_,module,exports){
module.exports = function _identity(x) { return x; };

},{}],221:[function(_dereq_,module,exports){
var equals = _dereq_('../equals');


module.exports = function _indexOf(list, a, idx) {
  var inf, item;
  // Array.prototype.indexOf doesn't exist below IE9
  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === 'number' && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        // non-zero numbers can utilise Set
        return list.indexOf(a, idx);

      // all these types can utilise Set
      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }
    }
  }
  // anything else not covered above, defer to R.equals
  while (idx < list.length) {
    if (equals(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
};

},{"../equals":166}],222:[function(_dereq_,module,exports){
var _has = _dereq_('./_has');


module.exports = (function() {
  var toString = Object.prototype.toString;
  return toString.call(arguments) === '[object Arguments]' ?
    function _isArguments(x) { return toString.call(x) === '[object Arguments]'; } :
    function _isArguments(x) { return _has('callee', x); };
}());

},{"./_has":219}],223:[function(_dereq_,module,exports){
/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]');
};

},{}],224:[function(_dereq_,module,exports){
module.exports = function _isFunction(x) {
  return Object.prototype.toString.call(x) === '[object Function]';
};

},{}],225:[function(_dereq_,module,exports){
/**
 * Determine if the passed argument is an integer.
 *
 * @private
 * @param {*} n
 * @category Type
 * @return {Boolean}
 */
module.exports = Number.isInteger || function _isInteger(n) {
  return (n << 0) === n;
};

},{}],226:[function(_dereq_,module,exports){
module.exports = function _isNumber(x) {
  return Object.prototype.toString.call(x) === '[object Number]';
};

},{}],227:[function(_dereq_,module,exports){
module.exports = function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
};

},{}],228:[function(_dereq_,module,exports){
module.exports = function _isPlaceholder(a) {
  return a != null &&
         typeof a === 'object' &&
         a['@@functional/placeholder'] === true;
};

},{}],229:[function(_dereq_,module,exports){
module.exports = function _isRegExp(x) {
  return Object.prototype.toString.call(x) === '[object RegExp]';
};

},{}],230:[function(_dereq_,module,exports){
module.exports = function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
};

},{}],231:[function(_dereq_,module,exports){
module.exports = function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

},{}],232:[function(_dereq_,module,exports){
var isArrayLike = _dereq_('../isArrayLike');


/**
 * `_makeFlat` is a helper function that returns a one-level or fully recursive
 * function based on the flag passed in.
 *
 * @private
 */
module.exports = function _makeFlat(recursive) {
  return function flatt(list) {
    var value, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list.length;

    while (idx < ilen) {
      if (isArrayLike(list[idx])) {
        value = recursive ? flatt(list[idx]) : list[idx];
        j = 0;
        jlen = value.length;
        while (j < jlen) {
          result[result.length] = value[j];
          j += 1;
        }
      } else {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
};

},{"../isArrayLike":272}],233:[function(_dereq_,module,exports){
module.exports = function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
};

},{}],234:[function(_dereq_,module,exports){
var _has = _dereq_('./_has');

// Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
module.exports = function _objectAssign(target) {
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  var idx = 1;
  var length = arguments.length;
  while (idx < length) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
};

},{"./_has":219}],235:[function(_dereq_,module,exports){
module.exports = function _of(x) { return [x]; };

},{}],236:[function(_dereq_,module,exports){
module.exports = function _pipe(f, g) {
  return function() {
    return g.call(this, f.apply(this, arguments));
  };
};

},{}],237:[function(_dereq_,module,exports){
module.exports = function _pipeP(f, g) {
  return function() {
    var ctx = this;
    return f.apply(ctx, arguments).then(function(x) {
      return g.call(ctx, x);
    });
  };
};

},{}],238:[function(_dereq_,module,exports){
module.exports = function _quote(s) {
  var escaped = s
    .replace(/\\/g, '\\\\')
    .replace(/[\b]/g, '\\b')  // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t')
    .replace(/\v/g, '\\v')
    .replace(/\0/g, '\\0');

  return '"' + escaped.replace(/"/g, '\\"') + '"';
};

},{}],239:[function(_dereq_,module,exports){
var _xwrap = _dereq_('./_xwrap');
var bind = _dereq_('../bind');
var isArrayLike = _dereq_('../isArrayLike');


module.exports = (function() {
  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      idx += 1;
    }
    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      step = iter.next();
    }
    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj) {
    return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';
  return function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }
    if (isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }
    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list);
    }
    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }
    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }
    throw new TypeError('reduce: list must be array or iterable');
  };
}());

},{"../bind":128,"../isArrayLike":272,"./_xwrap":263}],240:[function(_dereq_,module,exports){
module.exports = function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x :
    {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
};

},{}],241:[function(_dereq_,module,exports){
var _assign = _dereq_('./_assign');
var _identity = _dereq_('./_identity');
var _isTransformer = _dereq_('./_isTransformer');
var isArrayLike = _dereq_('../isArrayLike');
var objOf = _dereq_('../objOf');


module.exports = (function() {
  var _stepCatArray = {
    '@@transducer/init': Array,
    '@@transducer/step': function(xs, x) {
      xs.push(x);
      return xs;
    },
    '@@transducer/result': _identity
  };
  var _stepCatString = {
    '@@transducer/init': String,
    '@@transducer/step': function(a, b) { return a + b; },
    '@@transducer/result': _identity
  };
  var _stepCatObject = {
    '@@transducer/init': Object,
    '@@transducer/step': function(result, input) {
      return _assign(
        result,
        isArrayLike(input) ? objOf(input[0], input[1]) : input
      );
    },
    '@@transducer/result': _identity
  };

  return function _stepCat(obj) {
    if (_isTransformer(obj)) {
      return obj;
    }
    if (isArrayLike(obj)) {
      return _stepCatArray;
    }
    if (typeof obj === 'string') {
      return _stepCatString;
    }
    if (typeof obj === 'object') {
      return _stepCatObject;
    }
    throw new Error('Cannot create transformer for ' + obj);
  };
}());

},{"../isArrayLike":272,"../objOf":315,"./_assign":198,"./_identity":220,"./_isTransformer":231}],242:[function(_dereq_,module,exports){
/**
 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
 */
module.exports = (function() {
  var pad = function pad(n) { return (n < 10 ? '0' : '') + n; };

  return typeof Date.prototype.toISOString === 'function' ?
    function _toISOString(d) {
      return d.toISOString();
    } :
    function _toISOString(d) {
      return (
        d.getUTCFullYear() + '-' +
        pad(d.getUTCMonth() + 1) + '-' +
        pad(d.getUTCDate()) + 'T' +
        pad(d.getUTCHours()) + ':' +
        pad(d.getUTCMinutes()) + ':' +
        pad(d.getUTCSeconds()) + '.' +
        (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z'
      );
    };
}());

},{}],243:[function(_dereq_,module,exports){
var _contains = _dereq_('./_contains');
var _map = _dereq_('./_map');
var _quote = _dereq_('./_quote');
var _toISOString = _dereq_('./_toISOString');
var keys = _dereq_('../keys');
var reject = _dereq_('../reject');


module.exports = function _toString(x, seen) {
  var recur = function recur(y) {
    var xs = seen.concat([x]);
    return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
  };

  //  mapPairs :: (Object, [String]) -> [String]
  var mapPairs = function(obj, keys) {
    return _map(function(k) { return _quote(k) + ': ' + recur(obj[k]); }, keys.slice().sort());
  };

  switch (Object.prototype.toString.call(x)) {
    case '[object Arguments]':
      return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
    case '[object Array]':
      return '[' + _map(recur, x).concat(mapPairs(x, reject(function(k) { return /^\d+$/.test(k); }, keys(x)))).join(', ') + ']';
    case '[object Boolean]':
      return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
    case '[object Date]':
      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
    case '[object Null]':
      return 'null';
    case '[object Number]':
      return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
    case '[object String]':
      return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
    case '[object Undefined]':
      return 'undefined';
    default:
      if (typeof x.toString === 'function') {
        var repr = x.toString();
        if (repr !== '[object Object]') {
          return repr;
        }
      }
      return '{' + mapPairs(x, keys(x)).join(', ') + '}';
  }
};

},{"../keys":277,"../reject":351,"./_contains":204,"./_map":233,"./_quote":238,"./_toISOString":242}],244:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _reduced = _dereq_('./_reduced');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }
  XAll.prototype['@@transducer/init'] = _xfBase.init;
  XAll.prototype['@@transducer/result'] = function(result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAll.prototype['@@transducer/step'] = function(result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf['@@transducer/step'](result, false));
    }
    return result;
  };

  return _curry2(function _xall(f, xf) { return new XAll(f, xf); });
}());

},{"./_curry2":208,"./_reduced":240,"./_xfBase":253}],245:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _reduced = _dereq_('./_reduced');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XAny(f, xf) {
    this.xf = xf;
    this.f = f;
    this.any = false;
  }
  XAny.prototype['@@transducer/init'] = _xfBase.init;
  XAny.prototype['@@transducer/result'] = function(result) {
    if (!this.any) {
      result = this.xf['@@transducer/step'](result, false);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAny.prototype['@@transducer/step'] = function(result, input) {
    if (this.f(input)) {
      this.any = true;
      result = _reduced(this.xf['@@transducer/step'](result, true));
    }
    return result;
  };

  return _curry2(function _xany(f, xf) { return new XAny(f, xf); });
}());

},{"./_curry2":208,"./_reduced":240,"./_xfBase":253}],246:[function(_dereq_,module,exports){
var _concat = _dereq_('./_concat');
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XAperture(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XAperture.prototype['@@transducer/init'] = _xfBase.init;
  XAperture.prototype['@@transducer/result'] = function(result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XAperture.prototype['@@transducer/step'] = function(result, input) {
    this.store(input);
    return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
  };
  XAperture.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  XAperture.prototype.getCopy = function() {
    return _concat(Array.prototype.slice.call(this.acc, this.pos),
                   Array.prototype.slice.call(this.acc, 0, this.pos));
  };

  return _curry2(function _xaperture(n, xf) { return new XAperture(n, xf); });
}());

},{"./_concat":203,"./_curry2":208,"./_xfBase":253}],247:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _flatCat = _dereq_('./_flatCat');
var map = _dereq_('../map');


module.exports = _curry2(function _xchain(f, xf) {
  return map(f, _flatCat(xf));
});

},{"../map":290,"./_curry2":208,"./_flatCat":216}],248:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XDrop(n, xf) {
    this.xf = xf;
    this.n = n;
  }
  XDrop.prototype['@@transducer/init'] = _xfBase.init;
  XDrop.prototype['@@transducer/result'] = _xfBase.result;
  XDrop.prototype['@@transducer/step'] = function(result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return _curry2(function _xdrop(n, xf) { return new XDrop(n, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],249:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XDropLast(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XDropLast.prototype['@@transducer/init'] = _xfBase.init;
  XDropLast.prototype['@@transducer/result'] =  function(result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLast.prototype['@@transducer/step'] = function(result, input) {
    if (this.full) {
      result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
    }
    this.store(input);
    return result;
  };
  XDropLast.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };

  return _curry2(function _xdropLast(n, xf) { return new XDropLast(n, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],250:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _reduce = _dereq_('./_reduce');
var _xfBase = _dereq_('./_xfBase');

module.exports = (function() {
  function XDropLastWhile(fn, xf) {
    this.f = fn;
    this.retained = [];
    this.xf = xf;
  }
  XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
  XDropLastWhile.prototype['@@transducer/result'] = function(result) {
    this.retained = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLastWhile.prototype['@@transducer/step'] = function(result, input) {
    return this.f(input) ? this.retain(result, input)
                         : this.flush(result, input);
  };
  XDropLastWhile.prototype.flush = function(result, input) {
    result = _reduce(
      this.xf['@@transducer/step'],
      result,
      this.retained
    );
    this.retained = [];
    return this.xf['@@transducer/step'](result, input);
  };
  XDropLastWhile.prototype.retain = function(result, input) {
    this.retained.push(input);
    return result;
  };

  return _curry2(function _xdropLastWhile(fn, xf) { return new XDropLastWhile(fn, xf); });
}());

},{"./_curry2":208,"./_reduce":239,"./_xfBase":253}],251:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XDropRepeatsWith(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.lastValue = undefined;
    this.seenFirstValue = false;
  }

  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;
  XDropRepeatsWith.prototype['@@transducer/step'] = function(result, input) {
    var sameAsLast = false;
    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }
    this.lastValue = input;
    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
  };

  return _curry2(function _xdropRepeatsWith(pred, xf) { return new XDropRepeatsWith(pred, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],252:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XDropWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
  XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
  XDropWhile.prototype['@@transducer/step'] = function(result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }
      this.f = null;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return _curry2(function _xdropWhile(f, xf) { return new XDropWhile(f, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],253:[function(_dereq_,module,exports){
module.exports = {
  init: function() {
    return this.xf['@@transducer/init']();
  },
  result: function(result) {
    return this.xf['@@transducer/result'](result);
  }
};

},{}],254:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;
  XFilter.prototype['@@transducer/step'] = function(result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return _curry2(function _xfilter(f, xf) { return new XFilter(f, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],255:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _reduced = _dereq_('./_reduced');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }
  XFind.prototype['@@transducer/init'] = _xfBase.init;
  XFind.prototype['@@transducer/result'] = function(result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFind.prototype['@@transducer/step'] = function(result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, input));
    }
    return result;
  };

  return _curry2(function _xfind(f, xf) { return new XFind(f, xf); });
}());

},{"./_curry2":208,"./_reduced":240,"./_xfBase":253}],256:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _reduced = _dereq_('./_reduced');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XFindIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.found = false;
  }
  XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
  XFindIndex.prototype['@@transducer/result'] = function(result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, -1);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFindIndex.prototype['@@transducer/step'] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, this.idx));
    }
    return result;
  };

  return _curry2(function _xfindIndex(f, xf) { return new XFindIndex(f, xf); });
}());

},{"./_curry2":208,"./_reduced":240,"./_xfBase":253}],257:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XFindLast(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFindLast.prototype['@@transducer/init'] = _xfBase.init;
  XFindLast.prototype['@@transducer/result'] = function(result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
  };
  XFindLast.prototype['@@transducer/step'] = function(result, input) {
    if (this.f(input)) {
      this.last = input;
    }
    return result;
  };

  return _curry2(function _xfindLast(f, xf) { return new XFindLast(f, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],258:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XFindLastIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.lastIdx = -1;
  }
  XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
  XFindLastIndex.prototype['@@transducer/result'] = function(result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
  };
  XFindLastIndex.prototype['@@transducer/step'] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.lastIdx = this.idx;
    }
    return result;
  };

  return _curry2(function _xfindLastIndex(f, xf) { return new XFindLastIndex(f, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],259:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;
  XMap.prototype['@@transducer/step'] = function(result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return _curry2(function _xmap(f, xf) { return new XMap(f, xf); });
}());

},{"./_curry2":208,"./_xfBase":253}],260:[function(_dereq_,module,exports){
var _curryN = _dereq_('./_curryN');
var _has = _dereq_('./_has');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XReduceBy(valueFn, valueAcc, keyFn, xf) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf;
    this.inputs = {};
  }
  XReduceBy.prototype['@@transducer/init'] = _xfBase.init;
  XReduceBy.prototype['@@transducer/result'] = function(result) {
    var key;
    for (key in this.inputs) {
      if (_has(key, this.inputs)) {
        result = this.xf['@@transducer/step'](result, this.inputs[key]);
        if (result['@@transducer/reduced']) {
          result = result['@@transducer/value'];
          break;
        }
      }
    }
    this.inputs = null;
    return this.xf['@@transducer/result'](result);
  };
  XReduceBy.prototype['@@transducer/step'] = function(result, input) {
    var key = this.keyFn(input);
    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
    return result;
  };

  return _curryN(4, [],
                 function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
                   return new XReduceBy(valueFn, valueAcc, keyFn, xf);
                 });
}());

},{"./_curryN":210,"./_has":219,"./_xfBase":253}],261:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _reduced = _dereq_('./_reduced');
var _xfBase = _dereq_('./_xfBase');

module.exports = (function() {
  function XTake(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }
  XTake.prototype['@@transducer/init'] = _xfBase.init;
  XTake.prototype['@@transducer/result'] = _xfBase.result;
  XTake.prototype['@@transducer/step'] = function(result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
    return this.i >= this.n ? _reduced(ret) : ret;
  };

  return _curry2(function _xtake(n, xf) { return new XTake(n, xf); });
}());

},{"./_curry2":208,"./_reduced":240,"./_xfBase":253}],262:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./_curry2');
var _reduced = _dereq_('./_reduced');
var _xfBase = _dereq_('./_xfBase');


module.exports = (function() {
  function XTakeWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
  XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
  XTakeWhile.prototype['@@transducer/step'] = function(result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
  };

  return _curry2(function _xtakeWhile(f, xf) { return new XTakeWhile(f, xf); });
}());

},{"./_curry2":208,"./_reduced":240,"./_xfBase":253}],263:[function(_dereq_,module,exports){
module.exports = (function() {
  function XWrap(fn) {
    this.f = fn;
  }
  XWrap.prototype['@@transducer/init'] = function() {
    throw new Error('init not implemented on XWrap');
  };
  XWrap.prototype['@@transducer/result'] = function(acc) { return acc; };
  XWrap.prototype['@@transducer/step'] = function(acc, x) {
    return this.f(acc, x);
  };

  return function _xwrap(fn) { return new XWrap(fn); };
}());

},{}],264:[function(_dereq_,module,exports){
var _contains = _dereq_('./internal/_contains');
var _curry2 = _dereq_('./internal/_curry2');
var _filter = _dereq_('./internal/_filter');
var flip = _dereq_('./flip');
var uniq = _dereq_('./uniq');


/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The list of elements found in both `list1` and `list2`.
 * @see R.intersectionWith
 * @example
 *
 *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
 */
module.exports = _curry2(function intersection(list1, list2) {
  var lookupList, filteredList;
  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }
  return uniq(_filter(flip(_contains)(lookupList), filteredList));
});

},{"./flip":174,"./internal/_contains":204,"./internal/_curry2":208,"./internal/_filter":215,"./uniq":396}],265:[function(_dereq_,module,exports){
var _containsWith = _dereq_('./internal/_containsWith');
var _curry3 = _dereq_('./internal/_curry3');
var uniqWith = _dereq_('./uniqWith');


/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists. Duplication is determined according to the
 * value returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate function that determines whether
 *        the two supplied elements are equal.
 * @param {Array} list1 One list of items to compare
 * @param {Array} list2 A second list of items to compare
 * @return {Array} A new list containing those elements common to both lists.
 * @see R.intersection
 * @example
 *
 *      var buffaloSpringfield = [
 *        {id: 824, name: 'Richie Furay'},
 *        {id: 956, name: 'Dewey Martin'},
 *        {id: 313, name: 'Bruce Palmer'},
 *        {id: 456, name: 'Stephen Stills'},
 *        {id: 177, name: 'Neil Young'}
 *      ];
 *      var csny = [
 *        {id: 204, name: 'David Crosby'},
 *        {id: 456, name: 'Stephen Stills'},
 *        {id: 539, name: 'Graham Nash'},
 *        {id: 177, name: 'Neil Young'}
 *      ];
 *
 *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
 *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
 */
module.exports = _curry3(function intersectionWith(pred, list1, list2) {
  var lookupList, filteredList;
  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }
  var results = [];
  var idx = 0;
  while (idx < filteredList.length) {
    if (_containsWith(pred, filteredList[idx], lookupList)) {
      results[results.length] = filteredList[idx];
    }
    idx += 1;
  }
  return uniqWith(pred, results);
});

},{"./internal/_containsWith":205,"./internal/_curry3":209,"./uniqWith":398}],266:[function(_dereq_,module,exports){
var _checkForMethod = _dereq_('./internal/_checkForMethod');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Creates a new list with the separator interposed between elements.
 *
 * Dispatches to the `intersperse` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} separator The element to add to the list.
 * @param {Array} list The list to be interposed.
 * @return {Array} The new list.
 * @example
 *
 *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
 */
module.exports = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
  var out = [];
  var idx = 0;
  var length = list.length;
  while (idx < length) {
    if (idx === length - 1) {
      out.push(list[idx]);
    } else {
      out.push(list[idx], separator);
    }
    idx += 1;
  }
  return out;
}));

},{"./internal/_checkForMethod":199,"./internal/_curry2":208}],267:[function(_dereq_,module,exports){
var _clone = _dereq_('./internal/_clone');
var _curry3 = _dereq_('./internal/_curry3');
var _isTransformer = _dereq_('./internal/_isTransformer');
var _reduce = _dereq_('./internal/_reduce');
var _stepCat = _dereq_('./internal/_stepCat');


/**
 * Transforms the items of the list with the transducer and appends the
 * transformed items to the accumulator using an appropriate iterator function
 * based on the accumulator type.
 *
 * The accumulator can be an array, string, object or a transformer. Iterated
 * items will be appended to arrays and concatenated to strings. Objects will
 * be merged directly or 2-item arrays will be merged as key, value pairs.
 *
 * The accumulator can also be a transformer object that provides a 2-arity
 * reducing iterator function, step, 0-arity initial value function, init, and
 * 1-arity result extraction function result. The step function is used as the
 * iterator function in reduce. The result function is used to convert the
 * final accumulator into the return type and in most cases is R.identity. The
 * init function is used to provide the initial accumulator.
 *
 * The iteration is performed with R.reduce after initializing the transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig a -> (b -> b) -> [c] -> a
 * @param {*} acc The initial accumulator value.
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *
 *      R.into([], transducer, numbers); //=> [2, 3]
 *
 *      var intoArray = R.into([]);
 *      intoArray(transducer, numbers); //=> [2, 3]
 */
module.exports = _curry3(function into(acc, xf, list) {
  return _isTransformer(acc) ?
    _reduce(xf(acc), acc['@@transducer/init'](), list) :
    _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
});

},{"./internal/_clone":200,"./internal/_curry3":209,"./internal/_isTransformer":231,"./internal/_reduce":239,"./internal/_stepCat":241}],268:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _has = _dereq_('./internal/_has');
var keys = _dereq_('./keys');


/**
 * Same as R.invertObj, however this accounts for objects with duplicate values
 * by putting the values into an array.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: [ s, ... ]}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object with keys
 * in an array.
 * @example
 *
 *      var raceResultsByFirstName = {
 *        first: 'alice',
 *        second: 'jake',
 *        third: 'alice',
 *      };
 *      R.invert(raceResultsByFirstName);
 *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
 */
module.exports = _curry1(function invert(obj) {
  var props = keys(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    var val = obj[key];
    var list = _has(val, out) ? out[val] : (out[val] = []);
    list[list.length] = key;
    idx += 1;
  }
  return out;
});

},{"./internal/_curry1":207,"./internal/_has":219,"./keys":277}],269:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var keys = _dereq_('./keys');


/**
 * Returns a new object with the keys of the given object as values, and the
 * values of the given object, which are coerced to strings, as keys. Note
 * that the last key found is preferred when handling the same value.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: s}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object
 * @example
 *
 *      var raceResults = {
 *        first: 'alice',
 *        second: 'jake'
 *      };
 *      R.invertObj(raceResults);
 *      //=> { 'alice': 'first', 'jake':'second' }
 *
 *      // Alternatively:
 *      var raceResults = ['alice', 'jake'];
 *      R.invertObj(raceResults);
 *      //=> { 'alice': '0', 'jake':'1' }
 */
module.exports = _curry1(function invertObj(obj) {
  var props = keys(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    out[obj[key]] = key;
    idx += 1;
  }
  return out;
});

},{"./internal/_curry1":207,"./keys":277}],270:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isFunction = _dereq_('./internal/_isFunction');
var curryN = _dereq_('./curryN');
var toString = _dereq_('./toString');


/**
 * Turns a named method with a specified arity into a function that can be
 * called directly supplied with arguments and a target object.
 *
 * The returned function is curried and accepts `arity + 1` parameters where
 * the final parameter is the target object.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
 * @param {Number} arity Number of arguments the returned function should take
 *        before the target object.
 * @param {String} method Name of the method to call.
 * @return {Function} A new curried function.
 * @example
 *
 *      var sliceFrom = R.invoker(1, 'slice');
 *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
 *      var sliceFrom6 = R.invoker(2, 'slice')(6);
 *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
 * @symb R.invoker(0, 'method')(o) = o['method']()
 * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
 * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
 */
module.exports = _curry2(function invoker(arity, method) {
  return curryN(arity + 1, function() {
    var target = arguments[arity];
    if (target != null && _isFunction(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
  });
});

},{"./curryN":147,"./internal/_curry2":208,"./internal/_isFunction":224,"./toString":382}],271:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * See if an object (`val`) is an instance of the supplied constructor. This
 * function will check up the inheritance chain, if any.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Type
 * @sig (* -> {*}) -> a -> Boolean
 * @param {Object} ctor A constructor
 * @param {*} val The value to test
 * @return {Boolean}
 * @example
 *
 *      R.is(Object, {}); //=> true
 *      R.is(Number, 1); //=> true
 *      R.is(Object, 1); //=> false
 *      R.is(String, 's'); //=> true
 *      R.is(String, new String('')); //=> true
 *      R.is(Object, new String('')); //=> true
 *      R.is(Object, 's'); //=> false
 *      R.is(Number, {}); //=> false
 */
module.exports = _curry2(function is(Ctor, val) {
  return val != null && val.constructor === Ctor || val instanceof Ctor;
});

},{"./internal/_curry2":208}],272:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _isArray = _dereq_('./internal/_isArray');
var _isString = _dereq_('./internal/_isString');


/**
 * Tests whether or not an object is similar to an array.
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @deprecated since v0.23.0
 * @example
 *
 *      R.isArrayLike([]); //=> true
 *      R.isArrayLike(true); //=> false
 *      R.isArrayLike({}); //=> false
 *      R.isArrayLike({length: 10}); //=> false
 *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */
module.exports = _curry1(function isArrayLike(x) {
  if (_isArray(x)) { return true; }
  if (!x) { return false; }
  if (typeof x !== 'object') { return false; }
  if (_isString(x)) { return false; }
  if (x.nodeType === 1) { return !!x.length; }
  if (x.length === 0) { return true; }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});

},{"./internal/_curry1":207,"./internal/_isArray":223,"./internal/_isString":230}],273:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var empty = _dereq_('./empty');
var equals = _dereq_('./equals');


/**
 * Returns `true` if the given value is its type's empty value; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> Boolean
 * @param {*} x
 * @return {Boolean}
 * @see R.empty
 * @example
 *
 *      R.isEmpty([1, 2, 3]);   //=> false
 *      R.isEmpty([]);          //=> true
 *      R.isEmpty('');          //=> true
 *      R.isEmpty(null);        //=> false
 *      R.isEmpty({});          //=> true
 *      R.isEmpty({length: 0}); //=> false
 */
module.exports = _curry1(function isEmpty(x) {
  return x != null && equals(x, empty(x));
});

},{"./empty":163,"./equals":166,"./internal/_curry1":207}],274:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */
module.exports = _curry1(function isNil(x) { return x == null; });

},{"./internal/_curry1":207}],275:[function(_dereq_,module,exports){
var invoker = _dereq_('./invoker');


/**
 * Returns a string made by inserting the `separator` between each element and
 * concatenating all the elements into a single string.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig String -> [a] -> String
 * @param {Number|String} separator The string used to separate the elements.
 * @param {Array} xs The elements to join into a string.
 * @return {String} str The string made by concatenating `xs` with `separator`.
 * @see R.split
 * @example
 *
 *      var spacer = R.join(' ');
 *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
 *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
 */
module.exports = invoker(1, 'join');

},{"./invoker":270}],276:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var converge = _dereq_('./converge');


/**
 * juxt applies a list of functions to a list of values.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Function
 * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
 * @param {Array} fns An array of functions
 * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
 * @see R.applySpec
 * @example
 *
 *      var getRange = R.juxt([Math.min, Math.max]);
 *      getRange(3, 4, 9, -3); //=> [-3, 9]
 * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
 */
module.exports = _curry1(function juxt(fns) {
  return converge(function() { return Array.prototype.slice.call(arguments, 0); }, fns);
});

},{"./converge":144,"./internal/_curry1":207}],277:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _has = _dereq_('./internal/_has');
var _isArguments = _dereq_('./internal/_isArguments');


/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
module.exports = (function() {
  // cover IE < 9 keys issues
  var hasEnumBug = !({toString: null}).propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString',
                            'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  // Safari bug
  var hasArgsEnumBug = (function() {
    'use strict';
    return arguments.propertyIsEnumerable('length');
  }());

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  return typeof Object.keys === 'function' && !hasArgsEnumBug ?
    _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, nIdx;
      var ks = [];
      var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
}());

},{"./internal/_curry1":207,"./internal/_has":219,"./internal/_isArguments":222}],278:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Returns a list containing the names of all the properties of the supplied
 * object, including prototype properties.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.keysIn(f); //=> ['x', 'y']
 */
module.exports = _curry1(function keysIn(obj) {
  var prop;
  var ks = [];
  for (prop in obj) {
    ks[ks.length] = prop;
  }
  return ks;
});

},{"./internal/_curry1":207}],279:[function(_dereq_,module,exports){
var nth = _dereq_('./nth');


/**
 * Returns the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.init, R.head, R.tail
 * @example
 *
 *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
 *      R.last([]); //=> undefined
 *
 *      R.last('abc'); //=> 'c'
 *      R.last(''); //=> ''
 */
module.exports = nth(-1);

},{"./nth":313}],280:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isArray = _dereq_('./internal/_isArray');
var equals = _dereq_('./equals');


/**
 * Returns the position of the last occurrence of an item in an array, or -1 if
 * the item is not included in the array. `R.equals` is used to determine
 * equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.indexOf
 * @example
 *
 *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
 *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
 */
module.exports = _curry2(function lastIndexOf(target, xs) {
  if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
    return xs.lastIndexOf(target);
  } else {
    var idx = xs.length - 1;
    while (idx >= 0) {
      if (equals(xs[idx], target)) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }
});

},{"./equals":166,"./internal/_curry2":208,"./internal/_isArray":223}],281:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _isNumber = _dereq_('./internal/_isNumber');


/**
 * Returns the number of elements in the array by returning `list.length`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [a] -> Number
 * @param {Array} list The array to inspect.
 * @return {Number} The length of the array.
 * @example
 *
 *      R.length([]); //=> 0
 *      R.length([1, 2, 3]); //=> 3
 */
module.exports = _curry1(function length(list) {
  return list != null && _isNumber(list.length) ? list.length : NaN;
});

},{"./internal/_curry1":207,"./internal/_isNumber":226}],282:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var map = _dereq_('./map');


/**
 * Returns a lens for the given getter and setter functions. The getter "gets"
 * the value of the focus; the setter "sets" the value of the focus. The setter
 * should not mutate the data structure.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
 * @param {Function} getter
 * @param {Function} setter
 * @return {Lens}
 * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
module.exports = _curry2(function lens(getter, setter) {
  return function(toFunctorFn) {
    return function(target) {
      return map(
        function(focus) {
          return setter(focus, target);
        },
        toFunctorFn(getter(target))
      );
    };
  };
});

},{"./internal/_curry2":208,"./map":290}],283:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var lens = _dereq_('./lens');
var nth = _dereq_('./nth');
var update = _dereq_('./update');


/**
 * Returns a lens whose focus is the specified index.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Number -> Lens s a
 * @param {Number} n
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
 *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
 *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
 */
module.exports = _curry1(function lensIndex(n) {
  return lens(nth(n), update(n));
});

},{"./internal/_curry1":207,"./lens":282,"./nth":313,"./update":402}],284:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var assocPath = _dereq_('./assocPath');
var lens = _dereq_('./lens');
var path = _dereq_('./path');


/**
 * Returns a lens whose focus is the specified path.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @typedefn Idx = String | Int
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig [Idx] -> Lens s a
 * @param {Array} path The path to use.
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
 *
 *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> 2
 *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
 *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
 */
module.exports = _curry1(function lensPath(p) {
  return lens(path(p), assocPath(p));
});

},{"./assocPath":126,"./internal/_curry1":207,"./lens":282,"./path":325}],285:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var assoc = _dereq_('./assoc');
var lens = _dereq_('./lens');
var prop = _dereq_('./prop');


/**
 * Returns a lens whose focus is the specified property.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig String -> Lens s a
 * @param {String} k
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
module.exports = _curry1(function lensProp(k) {
  return lens(prop(k), assoc(k));
});

},{"./assoc":125,"./internal/_curry1":207,"./lens":282,"./prop":339}],286:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var liftN = _dereq_('./liftN');


/**
 * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
 * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.liftN
 * @example
 *
 *      var madd3 = R.lift((a, b, c) => a + b + c);
 *
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 *
 *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
 *
 *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
 */
module.exports = _curry1(function lift(fn) {
  return liftN(fn.length, fn);
});

},{"./internal/_curry1":207,"./liftN":287}],287:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _reduce = _dereq_('./internal/_reduce');
var ap = _dereq_('./ap');
var curryN = _dereq_('./curryN');
var map = _dereq_('./map');


/**
 * "lifts" a function to be the specified arity, so that it may "map over" that
 * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig Number -> (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.lift, R.ap
 * @example
 *
 *      var madd3 = R.liftN(3, (...args) => R.sum(args));
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 */
module.exports = _curry2(function liftN(arity, fn) {
  var lifted = curryN(arity, fn);
  return curryN(arity, function() {
    return _reduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});

},{"./ap":119,"./curryN":147,"./internal/_curry2":208,"./internal/_reduce":239,"./map":290}],288:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns `true` if the first argument is less than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.gt
 * @example
 *
 *      R.lt(2, 1); //=> false
 *      R.lt(2, 2); //=> false
 *      R.lt(2, 3); //=> true
 *      R.lt('a', 'z'); //=> true
 *      R.lt('z', 'a'); //=> false
 */
module.exports = _curry2(function lt(a, b) { return a < b; });

},{"./internal/_curry2":208}],289:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns `true` if the first argument is less than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.gte
 * @example
 *
 *      R.lte(2, 1); //=> false
 *      R.lte(2, 2); //=> true
 *      R.lte(2, 3); //=> true
 *      R.lte('a', 'z'); //=> true
 *      R.lte('z', 'a'); //=> false
 */
module.exports = _curry2(function lte(a, b) { return a <= b; });

},{"./internal/_curry2":208}],290:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _map = _dereq_('./internal/_map');
var _reduce = _dereq_('./internal/_reduce');
var _xmap = _dereq_('./internal/_xmap');
var curryN = _dereq_('./curryN');
var keys = _dereq_('./keys');


/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex
 * @example
 *
 *      var double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 * @symb R.map(f, [a, b]) = [f(a), f(b)]
 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
 * @symb R.map(f, functor_o) = functor_o.map(f)
 */
module.exports = _curry2(_dispatchable(['map'], _xmap, function map(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return curryN(functor.length, function() {
        return fn.call(this, functor.apply(this, arguments));
      });
    case '[object Object]':
      return _reduce(function(acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, keys(functor));
    default:
      return _map(fn, functor);
  }
}));

},{"./curryN":147,"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_map":233,"./internal/_reduce":239,"./internal/_xmap":259,"./keys":277}],291:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * The mapAccum function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from left to right, and returning a final value of this
 * accumulator together with the new list.
 *
 * The iterator function receives two arguments, *acc* and *value*, and should
 * return a tuple *[acc, value]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccumRight
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var appender = (a, b) => [a + b, a + b];
 *
 *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
 * @symb R.mapAccum(f, a, [b, c, d]) = [
 *   f(f(f(a, b)[0], c)[0], d)[0],
 *   [
 *     f(a, b)[1],
 *     f(f(a, b)[0], c)[1],
 *     f(f(f(a, b)[0], c)[0], d)[1]
 *   ]
 * ]
 */
module.exports = _curry3(function mapAccum(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var tuple = [acc];
  while (idx < len) {
    tuple = fn(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx += 1;
  }
  return [tuple[0], result];
});

},{"./internal/_curry3":209}],292:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * The mapAccumRight function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from right to left, and returning a final value of this
 * accumulator together with the new list.
 *
 * Similar to `mapAccum`, except moves through the input list from the right to
 * the left.
 *
 * The iterator function receives two arguments, *value* and *acc*, and should
 * return a tuple *[value, acc]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (x-> acc -> (y, acc)) -> acc -> [x] -> ([y], acc)
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccum
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var append = (a, b) => [a + b, a + b];
 *
 *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
 * @symb R.mapAccumRight(f, a, [b, c, d]) = [
 *   [
 *     f(b, f(c, f(d, a)[0])[0])[1],
 *     f(c, f(d, a)[0])[1],
 *     f(d, a)[1],
 *   ]
 *   f(b, f(c, f(d, a)[0])[0])[0],
 * ]
 */
module.exports = _curry3(function mapAccumRight(fn, acc, list) {
  var idx = list.length - 1;
  var result = [];
  var tuple = [acc];
  while (idx >= 0) {
    tuple = fn(list[idx], tuple[0]);
    result[idx] = tuple[1];
    idx -= 1;
  }
  return [result, tuple[0]];
});

},{"./internal/_curry3":209}],293:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _reduce = _dereq_('./internal/_reduce');
var keys = _dereq_('./keys');


/**
 * An Object-specific version of `map`. The function is applied to three
 * arguments: *(value, key, obj)*. If only the value is significant, use
 * `map` instead.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig ((*, String, Object) -> *) -> Object -> Object
 * @param {Function} fn
 * @param {Object} obj
 * @return {Object}
 * @see R.map
 * @example
 *
 *      var values = { x: 1, y: 2, z: 3 };
 *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
 *
 *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
 */
module.exports = _curry2(function mapObjIndexed(fn, obj) {
  return _reduce(function(acc, key) {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {}, keys(obj));
});

},{"./internal/_curry2":208,"./internal/_reduce":239,"./keys":277}],294:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Tests a regular expression against a String. Note that this function will
 * return an empty array when there are no matches. This differs from
 * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
 * which returns `null` when there are no matches.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig RegExp -> String -> [String | Undefined]
 * @param {RegExp} rx A regular expression.
 * @param {String} str The string to match against
 * @return {Array} The list of matches or empty array.
 * @see R.test
 * @example
 *
 *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
 *      R.match(/a/, 'b'); //=> []
 *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
 */
module.exports = _curry2(function match(rx, str) {
  return str.match(rx) || [];
});

},{"./internal/_curry2":208}],295:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isInteger = _dereq_('./internal/_isInteger');


/**
 * mathMod behaves like the modulo operator should mathematically, unlike the
 * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
 * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
 * when the modulus is zero or negative.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} m The dividend.
 * @param {Number} p the modulus.
 * @return {Number} The result of `b mod a`.
 * @example
 *
 *      R.mathMod(-17, 5);  //=> 3
 *      R.mathMod(17, 5);   //=> 2
 *      R.mathMod(17, -5);  //=> NaN
 *      R.mathMod(17, 0);   //=> NaN
 *      R.mathMod(17.2, 5); //=> NaN
 *      R.mathMod(17, 5.3); //=> NaN
 *
 *      var clock = R.mathMod(R.__, 12);
 *      clock(15); //=> 3
 *      clock(24); //=> 0
 *
 *      var seventeenMod = R.mathMod(17);
 *      seventeenMod(3);  //=> 2
 *      seventeenMod(4);  //=> 1
 *      seventeenMod(10); //=> 7
 */
module.exports = _curry2(function mathMod(m, p) {
  if (!_isInteger(m)) { return NaN; }
  if (!_isInteger(p) || p < 1) { return NaN; }
  return ((m % p) + p) % p;
});

},{"./internal/_curry2":208,"./internal/_isInteger":225}],296:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns the larger of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.maxBy, R.min
 * @example
 *
 *      R.max(789, 123); //=> 789
 *      R.max('a', 'b'); //=> 'b'
 */
module.exports = _curry2(function max(a, b) { return b > a ? b : a; });

},{"./internal/_curry2":208}],297:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Takes a function and two values, and returns whichever value produces the
 * larger result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.max, R.minBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.maxBy(square, -3, 2); //=> -3
 *
 *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
 *      R.reduce(R.maxBy(square), 0, []); //=> 0
 */
module.exports = _curry3(function maxBy(f, a, b) {
  return f(b) > f(a) ? b : a;
});

},{"./internal/_curry3":209}],298:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var sum = _dereq_('./sum');


/**
 * Returns the mean of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @example
 *
 *      R.mean([2, 7, 9]); //=> 6
 *      R.mean([]); //=> NaN
 */
module.exports = _curry1(function mean(list) {
  return sum(list) / list.length;
});

},{"./internal/_curry1":207,"./sum":368}],299:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var mean = _dereq_('./mean');


/**
 * Returns the median of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @example
 *
 *      R.median([2, 9, 7]); //=> 7
 *      R.median([7, 2, 10, 9]); //=> 8
 *      R.median([]); //=> NaN
 */
module.exports = _curry1(function median(list) {
  var len = list.length;
  if (len === 0) {
    return NaN;
  }
  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return mean(Array.prototype.slice.call(list, 0).sort(function(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }).slice(idx, idx + width));
});

},{"./internal/_curry1":207,"./mean":298}],300:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _curry1 = _dereq_('./internal/_curry1');
var _has = _dereq_('./internal/_has');
var toString = _dereq_('./toString');


/**
 * Creates a new function that, when invoked, caches the result of calling `fn`
 * for a given argument set and returns the result. Subsequent calls to the
 * memoized `fn` with the same argument set will not result in an additional
 * call to `fn`; instead, the cached result for that set of arguments will be
 * returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (*... -> a) -> (*... -> a)
 * @param {Function} fn The function to memoize.
 * @return {Function} Memoized version of `fn`.
 * @example
 *
 *      var count = 0;
 *      var factorial = R.memoize(n => {
 *        count += 1;
 *        return R.product(R.range(1, n + 1));
 *      });
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      count; //=> 1
 */
module.exports = _curry1(function memoize(fn) {
  var cache = {};
  return _arity(fn.length, function() {
    var key = toString(arguments);
    if (!_has(key, cache)) {
      cache[key] = fn.apply(this, arguments);
    }
    return cache[key];
  });
});

},{"./internal/_arity":196,"./internal/_curry1":207,"./internal/_has":219,"./toString":382}],301:[function(_dereq_,module,exports){
var _assign = _dereq_('./internal/_assign');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Create a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects,
 * the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeWith, R.mergeWithKey
 * @example
 *
 *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
 *      //=> { 'name': 'fred', 'age': 40 }
 *
 *      var resetToDefault = R.merge(R.__, {x: 0});
 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
 * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
 */
module.exports = _curry2(function merge(l, r) {
  return _assign({}, l, r);
});

},{"./internal/_assign":198,"./internal/_curry2":208}],302:[function(_dereq_,module,exports){
var _assign = _dereq_('./internal/_assign');
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Merges a list of objects together into one object.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig [{k: v}] -> {k: v}
 * @param {Array} list An array of objects
 * @return {Object} A merged object.
 * @see R.reduce
 * @example
 *
 *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
 *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
 * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
 */
module.exports = _curry1(function mergeAll(list) {
  return _assign.apply(null, [{}].concat(list));
});

},{"./internal/_assign":198,"./internal/_curry1":207}],303:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var mergeWithKey = _dereq_('./mergeWithKey');


/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the values
 * associated with the key in each object, with the result being used as the
 * value associated with the key in the returned object. The key will be
 * excluded from the returned object if the resulting value is `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig (a -> a -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.merge, R.mergeWithKey
 * @example
 *
 *      R.mergeWith(R.concat,
 *                  { a: true, values: [10, 20] },
 *                  { b: true, values: [15, 35] });
 *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
 */
module.exports = _curry3(function mergeWith(fn, l, r) {
  return mergeWithKey(function(_, _l, _r) {
    return fn(_l, _r);
  }, l, r);
});

},{"./internal/_curry3":209,"./mergeWithKey":304}],304:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var _has = _dereq_('./internal/_has');


/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the key
 * and the values associated with the key in each object, with the result being
 * used as the value associated with the key in the returned object. The key
 * will be excluded from the returned object if the resulting value is
 * `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.merge, R.mergeWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeWithKey(concatValues,
 *                     { a: true, thing: 'foo', values: [10, 20] },
 *                     { b: true, thing: 'bar', values: [15, 35] });
 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
 */
module.exports = _curry3(function mergeWithKey(fn, l, r) {
  var result = {};
  var k;

  for (k in l) {
    if (_has(k, l)) {
      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }

  for (k in r) {
    if (_has(k, r) && !(_has(k, result))) {
      result[k] = r[k];
    }
  }

  return result;
});

},{"./internal/_curry3":209,"./internal/_has":219}],305:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns the smaller of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.minBy, R.max
 * @example
 *
 *      R.min(789, 123); //=> 123
 *      R.min('a', 'b'); //=> 'a'
 */
module.exports = _curry2(function min(a, b) { return b < a ? b : a; });

},{"./internal/_curry2":208}],306:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Takes a function and two values, and returns whichever value produces the
 * smaller result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.min, R.maxBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.minBy(square, -3, 2); //=> 2
 *
 *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
 *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
 */
module.exports = _curry3(function minBy(f, a, b) {
  return f(b) < f(a) ? b : a;
});

},{"./internal/_curry3":209}],307:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Divides the first parameter by the second and returns the remainder. Note
 * that this function preserves the JavaScript-style behavior for modulo. For
 * mathematical modulo see `mathMod`.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The value to the divide.
 * @param {Number} b The pseudo-modulus
 * @return {Number} The result of `b % a`.
 * @see R.mathMod
 * @example
 *
 *      R.modulo(17, 3); //=> 2
 *      // JS behavior:
 *      R.modulo(-17, 3); //=> -2
 *      R.modulo(17, -3); //=> 2
 *
 *      var isOdd = R.modulo(R.__, 2);
 *      isOdd(42); //=> 0
 *      isOdd(21); //=> 1
 */
module.exports = _curry2(function modulo(a, b) { return a % b; });

},{"./internal/_curry2":208}],308:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Multiplies two numbers. Equivalent to `a * b` but curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a * b`.
 * @see R.divide
 * @example
 *
 *      var double = R.multiply(2);
 *      var triple = R.multiply(3);
 *      double(3);       //=>  6
 *      triple(4);       //=> 12
 *      R.multiply(2, 5);  //=> 10
 */
module.exports = _curry2(function multiply(a, b) { return a * b; });

},{"./internal/_curry2":208}],309:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly `n` parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} n The desired arity of the new function.
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity `n`.
 * @example
 *
 *      var takesTwoArgs = (a, b) => [a, b];
 *
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.nAry(1, takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only `n` arguments are passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.nAry(0, f)(a, b) = f()
 * @symb R.nAry(1, f)(a, b) = f(a)
 * @symb R.nAry(2, f)(a, b) = f(a, b)
 */
module.exports = _curry2(function nAry(n, fn) {
  switch (n) {
    case 0: return function() {return fn.call(this);};
    case 1: return function(a0) {return fn.call(this, a0);};
    case 2: return function(a0, a1) {return fn.call(this, a0, a1);};
    case 3: return function(a0, a1, a2) {return fn.call(this, a0, a1, a2);};
    case 4: return function(a0, a1, a2, a3) {return fn.call(this, a0, a1, a2, a3);};
    case 5: return function(a0, a1, a2, a3, a4) {return fn.call(this, a0, a1, a2, a3, a4);};
    case 6: return function(a0, a1, a2, a3, a4, a5) {return fn.call(this, a0, a1, a2, a3, a4, a5);};
    case 7: return function(a0, a1, a2, a3, a4, a5, a6) {return fn.call(this, a0, a1, a2, a3, a4, a5, a6);};
    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) {return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);};
    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);};
    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);};
    default: throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
  }
});

},{"./internal/_curry2":208}],310:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Negates its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number}
 * @example
 *
 *      R.negate(42); //=> -42
 */
module.exports = _curry1(function negate(n) { return -n; });

},{"./internal/_curry1":207}],311:[function(_dereq_,module,exports){
var _complement = _dereq_('./internal/_complement');
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xany = _dereq_('./internal/_xany');
var any = _dereq_('./any');


/**
 * Returns `true` if no elements of the list match the predicate, `false`
 * otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
 * @see R.all, R.any
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
 *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
 */
module.exports = _curry2(_complement(_dispatchable(['any'], _xany, any)));

},{"./any":117,"./internal/_complement":202,"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xany":245}],312:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * A function that returns the `!` of its argument. It will return `true` when
 * passed false-y value, and `false` when passed a truth-y one.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig * -> Boolean
 * @param {*} a any value
 * @return {Boolean} the logical inverse of passed argument.
 * @see R.complement
 * @example
 *
 *      R.not(true); //=> false
 *      R.not(false); //=> true
 *      R.not(0); //=> true
 *      R.not(1); //=> false
 */
module.exports = _curry1(function not(a) {
  return !a;
});

},{"./internal/_curry1":207}],313:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isString = _dereq_('./internal/_isString');


/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      var list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */
module.exports = _curry2(function nth(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString(list) ? list.charAt(idx) : list[idx];
});

},{"./internal/_curry2":208,"./internal/_isString":230}],314:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var curryN = _dereq_('./curryN');
var nth = _dereq_('./nth');


/**
 * Returns a function which returns its nth argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig Number -> *... -> *
 * @param {Number} n
 * @return {Function}
 * @example
 *
 *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
 *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
 * @symb R.nthArg(-1)(a, b, c) = c
 * @symb R.nthArg(0)(a, b, c) = a
 * @symb R.nthArg(1)(a, b, c) = b
 */
module.exports = _curry1(function nthArg(n) {
  var arity = n < 0 ? 1 : n + 1;
  return curryN(arity, function() {
    return nth(n, arguments);
  });
});

},{"./curryN":147,"./internal/_curry1":207,"./nth":313}],315:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Creates an object containing a single key:value pair.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @sig String -> a -> {String:a}
 * @param {String} key
 * @param {*} val
 * @return {Object}
 * @see R.pair
 * @example
 *
 *      var matchPhrases = R.compose(
 *        R.objOf('must'),
 *        R.map(R.objOf('match_phrase'))
 *      );
 *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
 */
module.exports = _curry2(function objOf(key, val) {
  var obj = {};
  obj[key] = val;
  return obj;
});

},{"./internal/_curry2":208}],316:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _of = _dereq_('./internal/_of');


/**
 * Returns a singleton array containing the value provided.
 *
 * Note this `of` is different from the ES6 `of`; See
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> [a]
 * @param {*} x any value
 * @return {Array} An array wrapping `x`.
 * @example
 *
 *      R.of(null); //=> [null]
 *      R.of([42]); //=> [[42]]
 */
module.exports = _curry1(_of);

},{"./internal/_curry1":207,"./internal/_of":235}],317:[function(_dereq_,module,exports){
var _contains = _dereq_('./internal/_contains');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a partial copy of an object omitting the keys specified.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [String] -> {String: *} -> {String: *}
 * @param {Array} names an array of String property names to omit from the new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with properties from `names` not on it.
 * @see R.pick
 * @example
 *
 *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
 */
module.exports = _curry2(function omit(names, obj) {
  var result = {};
  for (var prop in obj) {
    if (!_contains(prop, names)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});

},{"./internal/_contains":204,"./internal/_curry2":208}],318:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Accepts a function `fn` and returns a function that guards invocation of
 * `fn` such that `fn` can only ever be called once, no matter how many times
 * the returned function is invoked. The first value calculated is returned in
 * subsequent invocations.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a... -> b) -> (a... -> b)
 * @param {Function} fn The function to wrap in a call-only-once wrapper.
 * @return {Function} The wrapped function.
 * @example
 *
 *      var addOneOnce = R.once(x => x + 1);
 *      addOneOnce(10); //=> 11
 *      addOneOnce(addOneOnce(50)); //=> 11
 */
module.exports = _curry1(function once(fn) {
  var called = false;
  var result;
  return _arity(fn.length, function() {
    if (called) {
      return result;
    }
    called = true;
    result = fn.apply(this, arguments);
    return result;
  });
});

},{"./internal/_arity":196,"./internal/_curry1":207}],319:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns `true` if one or both of its arguments are `true`. Returns `false`
 * if both arguments are `false`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if truthy, otherwise the second argument.
 * @see R.either
 * @example
 *
 *      R.or(true, true); //=> true
 *      R.or(true, false); //=> true
 *      R.or(false, true); //=> true
 *      R.or(false, false); //=> false
 */
module.exports = _curry2(function or(a, b) {
  return a || b;
});

},{"./internal/_curry2":208}],320:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the result of applying the given function to
 * the focused value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> (a -> a) -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
 */
module.exports = (function() {
  // `Identity` is a functor that holds a single value, where `map` simply
  // transforms the held value with the provided function.
  var Identity = function(x) {
    return {value: x, map: function(f) { return Identity(f(x)); }};
  };

  return _curry3(function over(lens, f, x) {
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    return lens(function(y) { return Identity(f(y)); })(x).value;
  });
}());

},{"./internal/_curry3":209}],321:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category List
 * @sig a -> b -> (a,b)
 * @param {*} fst
 * @param {*} snd
 * @return {Array}
 * @see R.objOf, R.of
 * @example
 *
 *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
 */
module.exports = _curry2(function pair(fst, snd) { return [fst, snd]; });

},{"./internal/_curry2":208}],322:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _createPartialApplicator = _dereq_('./internal/_createPartialApplicator');


/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided initially followed by the arguments provided to `g`.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partialRight
 * @example
 *
 *      var multiply2 = (a, b) => a * b;
 *      var double = R.partial(multiply2, [2]);
 *      double(2); //=> 4
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var sayHello = R.partial(greet, ['Hello']);
 *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
 *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
 */
module.exports = _createPartialApplicator(_concat);

},{"./internal/_concat":203,"./internal/_createPartialApplicator":206}],323:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _createPartialApplicator = _dereq_('./internal/_createPartialApplicator');
var flip = _dereq_('./flip');


/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided to `g` followed by the arguments provided initially.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partial
 * @example
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
 *
 *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
 */
module.exports = _createPartialApplicator(flip(_concat));

},{"./flip":174,"./internal/_concat":203,"./internal/_createPartialApplicator":206}],324:[function(_dereq_,module,exports){
var filter = _dereq_('./filter');
var juxt = _dereq_('./juxt');
var reject = _dereq_('./reject');


/**
 * Takes a predicate and a list or other "filterable" object and returns the
 * pair of filterable objects of the same type of elements which do and do not
 * satisfy, the predicate, respectively.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
 * @param {Function} pred A predicate to determine which side the element belongs to.
 * @param {Array} filterable the list (or other filterable) to partition.
 * @return {Array} An array, containing first the subset of elements that satisfy the
 *         predicate, and second the subset of elements that do not satisfy.
 * @see R.filter, R.reject
 * @example
 *
 *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
 *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
 *
 *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
 *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
 */
module.exports = juxt([filter, reject]);

},{"./filter":168,"./juxt":276,"./reject":351}],325:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {a} -> a | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 */
module.exports = _curry2(function path(paths, obj) {
  var val = obj;
  var idx = 0;
  while (idx < paths.length) {
    if (val == null) {
      return;
    }
    val = val[paths[idx]];
    idx += 1;
  }
  return val;
});

},{"./internal/_curry2":208}],326:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var equals = _dereq_('./equals');
var path = _dereq_('./path');


/**
 * Determines whether a nested path on an object has a specific value, in
 * `R.equals` terms. Most likely used to filter a list.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Relation
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> Boolean
 * @param {Array} path The path of the nested property to use
 * @param {*} val The value to compare the nested property with
 * @param {Object} obj The object to check the nested property in
 * @return {Boolean} `true` if the value equals the nested object property,
 *         `false` otherwise.
 * @example
 *
 *      var user1 = { address: { zipCode: 90210 } };
 *      var user2 = { address: { zipCode: 55555 } };
 *      var user3 = { name: 'Bob' };
 *      var users = [ user1, user2, user3 ];
 *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
 *      R.filter(isFamous, users); //=> [ user1 ]
 */
module.exports = _curry3(function pathEq(_path, val, obj) {
  return equals(path(_path, obj), val);
});

},{"./equals":166,"./internal/_curry3":209,"./path":325}],327:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var defaultTo = _dereq_('./defaultTo');
var path = _dereq_('./path');


/**
 * If the given, non-null object has a value at the given path, returns the
 * value at that path. Otherwise returns the provided default value.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig a -> [Idx] -> {a} -> a
 * @param {*} d The default value.
 * @param {Array} p The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path` of the supplied object or the default value.
 * @example
 *
 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
 */
module.exports = _curry3(function pathOr(d, p, obj) {
  return defaultTo(d, path(p, obj));
});

},{"./defaultTo":149,"./internal/_curry3":209,"./path":325}],328:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var path = _dereq_('./path');


/**
 * Returns `true` if the specified object property at given path satisfies the
 * given predicate; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Logic
 * @typedefn Idx = String | Int
 * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
 * @param {Function} pred
 * @param {Array} propPath
 * @param {*} obj
 * @return {Boolean}
 * @see R.propSatisfies, R.path
 * @example
 *
 *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
 */
module.exports = _curry3(function pathSatisfies(pred, propPath, obj) {
  return propPath.length > 0 && pred(path(propPath, obj));
});

},{"./internal/_curry3":209,"./path":325}],329:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a partial copy of an object containing only the keys specified. If
 * the key does not exist, the property is ignored.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.omit, R.props
 * @example
 *
 *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
 */
module.exports = _curry2(function pick(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});

},{"./internal/_curry2":208}],330:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Similar to `pick` except that this one includes a `key: undefined` pair for
 * properties that don't exist.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.pick
 * @example
 *
 *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
 */
module.exports = _curry2(function pickAll(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    var name = names[idx];
    result[name] = obj[name];
    idx += 1;
  }
  return result;
});

},{"./internal/_curry2":208}],331:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a partial copy of an object containing only the keys that satisfy
 * the supplied predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
 * @param {Function} pred A predicate to determine whether or not a key
 *        should be included on the output object.
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties that satisfy `pred`
 *         on it.
 * @see R.pick, R.filter
 * @example
 *
 *      var isUpperCase = (val, key) => key.toUpperCase() === key;
 *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
 */
module.exports = _curry2(function pickBy(test, obj) {
  var result = {};
  for (var prop in obj) {
    if (test(obj[prop], prop, obj)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});

},{"./internal/_curry2":208}],332:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _pipe = _dereq_('./internal/_pipe');
var reduce = _dereq_('./reduce');
var tail = _dereq_('./tail');


/**
 * Performs left-to-right function composition. The leftmost function may have
 * any arity; the remaining functions must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      var f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */
module.exports = function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }
  return _arity(arguments[0].length,
                reduce(_pipe, arguments[0], tail(arguments)));
};

},{"./internal/_arity":196,"./internal/_pipe":236,"./reduce":346,"./tail":371}],333:[function(_dereq_,module,exports){
var composeK = _dereq_('./composeK');
var reverse = _dereq_('./reverse');

/**
 * Returns the left-to-right Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
 * @param {...Function}
 * @return {Function}
 * @see R.composeK
 * @example
 *
 *      //  parseJson :: String -> Maybe *
 *      //  get :: String -> Object -> Maybe *
 *
 *      //  getStateCode :: Maybe String -> Maybe String
 *      var getStateCode = R.pipeK(
 *        parseJson,
 *        get('user'),
 *        get('address'),
 *        get('state'),
 *        R.compose(Maybe.of, R.toUpper)
 *      );
 *
 *      getStateCode('{"user":{"address":{"state":"ny"}}}');
 *      //=> Just('NY')
 *      getStateCode('[Invalid JSON]');
 *      //=> Nothing()
 * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
 */
module.exports = function pipeK() {
  if (arguments.length === 0) {
    throw new Error('pipeK requires at least one argument');
  }
  return composeK.apply(this, reverse(arguments));
};

},{"./composeK":137,"./reverse":355}],334:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _pipeP = _dereq_('./internal/_pipeP');
var reduce = _dereq_('./reduce');
var tail = _dereq_('./tail');


/**
 * Performs left-to-right composition of one or more Promise-returning
 * functions. The leftmost function may have any arity; the remaining functions
 * must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.composeP
 * @example
 *
 *      //  followersForUser :: String -> Promise [User]
 *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
 */
module.exports = function pipeP() {
  if (arguments.length === 0) {
    throw new Error('pipeP requires at least one argument');
  }
  return _arity(arguments[0].length,
                reduce(_pipeP, arguments[0], tail(arguments)));
};

},{"./internal/_arity":196,"./internal/_pipeP":237,"./reduce":346,"./tail":371}],335:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var map = _dereq_('./map');
var prop = _dereq_('./prop');


/**
 * Returns a new list by plucking the same named property off all objects in
 * the list supplied.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig k -> [{k: v}] -> [v]
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} list The array to consider.
 * @return {Array} The list of values for the given key.
 * @see R.props
 * @example
 *
 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
 * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
 * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
 */
module.exports = _curry2(function pluck(p, list) {
  return map(prop(p), list);
});

},{"./internal/_curry2":208,"./map":290,"./prop":339}],336:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a new list with the given element at the front, followed by the
 * contents of the list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The item to add to the head of the output list.
 * @param {Array} list The array to add to the tail of the output list.
 * @return {Array} A new array.
 * @see R.append
 * @example
 *
 *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
 */
module.exports = _curry2(function prepend(el, list) {
  return _concat([el], list);
});

},{"./internal/_concat":203,"./internal/_curry2":208}],337:[function(_dereq_,module,exports){
var multiply = _dereq_('./multiply');
var reduce = _dereq_('./reduce');


/**
 * Multiplies together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The product of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.product([2,4,6,8,100,1]); //=> 38400
 */
module.exports = reduce(multiply, 1);

},{"./multiply":308,"./reduce":346}],338:[function(_dereq_,module,exports){
var _map = _dereq_('./internal/_map');
var identity = _dereq_('./identity');
var pickAll = _dereq_('./pickAll');
var useWith = _dereq_('./useWith');


/**
 * Reasonable analog to SQL `select` statement.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @category Relation
 * @sig [k] -> [{k: v}] -> [{k: v}]
 * @param {Array} props The property names to project
 * @param {Array} objs The objects to query
 * @return {Array} An array of objects with just the `props` properties.
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
 *      var kids = [abby, fred];
 *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
 */
module.exports = useWith(_map, [pickAll, identity]); // passing `identity` gives correct arity

},{"./identity":186,"./internal/_map":233,"./pickAll":330,"./useWith":403}],339:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */
module.exports = _curry2(function prop(p, obj) { return obj[p]; });

},{"./internal/_curry2":208}],340:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var equals = _dereq_('./equals');


/**
 * Returns `true` if the specified object property is equal, in `R.equals`
 * terms, to the given value; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.equals, R.propSatisfies
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      var kids = [abby, fred, rusty, alois];
 *      var hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */
module.exports = _curry3(function propEq(name, val, obj) {
  return equals(val, obj[name]);
});

},{"./equals":166,"./internal/_curry3":209}],341:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var is = _dereq_('./is');


/**
 * Returns `true` if the specified object property is of the given type;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Type
 * @sig Type -> String -> Object -> Boolean
 * @param {Function} type
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.is, R.propSatisfies
 * @example
 *
 *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
 *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
 *      R.propIs(Number, 'x', {});            //=> false
 */
module.exports = _curry3(function propIs(type, name, obj) {
  return is(type, obj[name]);
});

},{"./internal/_curry3":209,"./is":271}],342:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var _has = _dereq_('./internal/_has');


/**
 * If the given, non-null object has an own property with the specified name,
 * returns the value of that property. Otherwise returns the provided default
 * value.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Object
 * @sig a -> String -> Object -> a
 * @param {*} val The default value.
 * @param {String} p The name of the property to return.
 * @param {Object} obj The object to query.
 * @return {*} The value of given property of the supplied object or the default value.
 * @example
 *
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var favorite = R.prop('favoriteLibrary');
 *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
 *
 *      favorite(alice);  //=> undefined
 *      favoriteWithDefault(alice);  //=> 'Ramda'
 */
module.exports = _curry3(function propOr(val, p, obj) {
  return (obj != null && _has(p, obj)) ? obj[p] : val;
});

},{"./internal/_curry3":209,"./internal/_has":219}],343:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Returns `true` if the specified object property satisfies the given
 * predicate; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Logic
 * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
 * @param {Function} pred
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.propEq, R.propIs
 * @example
 *
 *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
 */
module.exports = _curry3(function propSatisfies(pred, name, obj) {
  return pred(obj[name]);
});

},{"./internal/_curry3":209}],344:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Acts as multiple `prop`: array of keys in, array of values out. Preserves
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> [v]
 * @param {Array} ps The property names to fetch
 * @param {Object} obj The object to query
 * @return {Array} The corresponding values or partially applied function.
 * @example
 *
 *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
 *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
 *
 *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
 *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
 */
module.exports = _curry2(function props(ps, obj) {
  var len = ps.length;
  var out = [];
  var idx = 0;

  while (idx < len) {
    out[idx] = obj[ps[idx]];
    idx += 1;
  }

  return out;
});

},{"./internal/_curry2":208}],345:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _isNumber = _dereq_('./internal/_isNumber');


/**
 * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> Number -> [Number]
 * @param {Number} from The first number in the list.
 * @param {Number} to One more than the last number in the list.
 * @return {Array} The list of numbers in tthe set `[a, b)`.
 * @example
 *
 *      R.range(1, 5);    //=> [1, 2, 3, 4]
 *      R.range(50, 53);  //=> [50, 51, 52]
 */
module.exports = _curry2(function range(from, to) {
  if (!(_isNumber(from) && _isNumber(to))) {
    throw new TypeError('Both arguments to range must be numbers');
  }
  var result = [];
  var n = from;
  while (n < to) {
    result.push(n);
    n += 1;
  }
  return result;
});

},{"./internal/_curry2":208,"./internal/_isNumber":226}],346:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var _reduce = _dereq_('./internal/_reduce');


/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * `R.reduced` to shortcut the iteration.
 *
 * The arguments' order of `reduceRight`'s iterator function is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *                -               -10
 *               / \              / \
 *              -   4           -6   4
 *             / \              / \
 *            -   3   ==>     -3   3
 *           / \              / \
 *          -   2           -1   2
 *         / \              / \
 *        0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */
module.exports = _curry3(_reduce);

},{"./internal/_curry3":209,"./internal/_reduce":239}],347:[function(_dereq_,module,exports){
var _curryN = _dereq_('./internal/_curryN');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _has = _dereq_('./internal/_has');
var _reduce = _dereq_('./internal/_reduce');
var _xreduceBy = _dereq_('./internal/_xreduceBy');


/**
 * Groups the elements of the list according to the result of calling
 * the String-returning function `keyFn` on each element and reduces the elements
 * of each group to a single value via the reducer function `valueFn`.
 *
 * This function is basically a more general `groupBy` function.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category List
 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
 * @param {Function} valueFn The function that reduces the elements of each group to a single
 *        value. Receives two values, accumulator for a particular group and the current element.
 * @param {*} acc The (initial) accumulator value for each group.
 * @param {Function} keyFn The function that maps the list's element into a key.
 * @param {Array} list The array to group.
 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
 *         `valueFn` for elements which produced that key when passed to `keyFn`.
 * @see R.groupBy, R.reduce
 * @example
 *
 *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
 *      var namesByGrade = reduceToNamesBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Lucy', score: 92},
 *                      {name: 'Drew', score: 85},
 *                      // ...
 *                      {name: 'Bart', score: 62}];
 *      namesByGrade(students);
 *      // {
 *      //   'A': ['Lucy'],
 *      //   'B': ['Drew']
 *      //   // ...,
 *      //   'F': ['Bart']
 *      // }
 */
module.exports = _curryN(4, [], _dispatchable([], _xreduceBy,
  function reduceBy(valueFn, valueAcc, keyFn, list) {
    return _reduce(function(acc, elt) {
      var key = keyFn(elt);
      acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
      return acc;
    }, {}, list);
  }));

},{"./internal/_curryN":210,"./internal/_dispatchable":211,"./internal/_has":219,"./internal/_reduce":239,"./internal/_xreduceBy":260}],348:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * Similar to `reduce`, except moves through the input list from the right to
 * the left.
 *
 * The iterator function receives two values: *(value, acc)*, while the arguments'
 * order of `reduce`'s iterator function is *(acc, value)*.
 *
 * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a, b -> b) -> b -> [a] -> b
 * @param {Function} fn The iterator function. Receives two values, the current element from the array
 *        and the accumulator.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.addIndex
 * @example
 *
 *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
 *          -               -2
 *         / \              / \
 *        1   -            1   3
 *           / \              / \
 *          2   -     ==>    2  -1
 *             / \              / \
 *            3   -            3   4
 *               / \              / \
 *              4   0            4   0
 *
 * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
 */
module.exports = _curry3(function reduceRight(fn, acc, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    acc = fn(list[idx], acc);
    idx -= 1;
  }
  return acc;
});

},{"./internal/_curry3":209}],349:[function(_dereq_,module,exports){
var _curryN = _dereq_('./internal/_curryN');
var _reduce = _dereq_('./internal/_reduce');
var _reduced = _dereq_('./internal/_reduced');


/**
 * Like `reduce`, `reduceWhile` returns a single item by iterating through
 * the list, successively calling the iterator function. `reduceWhile` also
 * takes a predicate that is evaluated before each step. If the predicate returns
 * `false`, it "short-circuits" the iteration and returns the current value
 * of the accumulator.
 *
 * @func
 * @memberOf R
 * @since v0.22.0
 * @category List
 * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} pred The predicate. It is passed the accumulator and the
 *        current element.
 * @param {Function} fn The iterator function. Receives two values, the
 *        accumulator and the current element.
 * @param {*} a The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced
 * @example
 *
 *      var isOdd = (acc, x) => x % 2 === 1;
 *      var xs = [1, 3, 5, 60, 777, 800];
 *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
 *
 *      var ys = [2, 4, 6]
 *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
 */
module.exports = _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
  return _reduce(function(acc, x) {
    return pred(acc, x) ? fn(acc, x) : _reduced(acc);
  }, a, list);
});

},{"./internal/_curryN":210,"./internal/_reduce":239,"./internal/_reduced":240}],350:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _reduced = _dereq_('./internal/_reduced');

/**
 * Returns a value wrapped to indicate that it is the final value of the reduce
 * and transduce functions. The returned value should be considered a black
 * box: the internal structure is not guaranteed to be stable.
 *
 * Note: this optimization is unavailable to functions not explicitly listed
 * above. For instance, it is not currently supported by reduceRight.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category List
 * @sig a -> *
 * @param {*} x The final value of the reduce.
 * @return {*} The wrapped value.
 * @see R.reduce, R.transduce
 * @example
 *
 *      R.reduce(
 *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
 *        0,
 *        [1, 2, 3, 4, 5]) // 10
 */

module.exports = _curry1(_reduced);

},{"./internal/_curry1":207,"./internal/_reduced":240}],351:[function(_dereq_,module,exports){
var _complement = _dereq_('./internal/_complement');
var _curry2 = _dereq_('./internal/_curry2');
var filter = _dereq_('./filter');


/**
 * The complement of `filter`.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      var isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
module.exports = _curry2(function reject(pred, filterable) {
  return filter(_complement(pred), filterable);
});

},{"./filter":168,"./internal/_complement":202,"./internal/_curry2":208}],352:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Removes the sub-list of `list` starting at index `start` and containing
 * `count` elements. _Note that this is not destructive_: it returns a copy of
 * the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @param {Number} start The position to start removing elements
 * @param {Number} count The number of elements to remove
 * @param {Array} list The list to remove from
 * @return {Array} A new Array with `count` elements from `start` removed.
 * @example
 *
 *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
 */
module.exports = _curry3(function remove(start, count, list) {
  var result = Array.prototype.slice.call(list, 0);
  result.splice(start, count);
  return result;
});

},{"./internal/_curry3":209}],353:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var always = _dereq_('./always');
var times = _dereq_('./times');


/**
 * Returns a fixed list of size `n` containing a specified identical value.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig a -> n -> [a]
 * @param {*} value The value to repeat.
 * @param {Number} n The desired size of the output list.
 * @return {Array} A new array containing `n` `value`s.
 * @example
 *
 *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
 *
 *      var obj = {};
 *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
 *      repeatedObjs[0] === repeatedObjs[1]; //=> true
 * @symb R.repeat(a, 0) = []
 * @symb R.repeat(a, 1) = [a]
 * @symb R.repeat(a, 2) = [a, a]
 */
module.exports = _curry2(function repeat(value, n) {
  return times(always(value), n);
});

},{"./always":115,"./internal/_curry2":208,"./times":378}],354:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Replace a substring or regex match in a string with a replacement.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category String
 * @sig RegExp|String -> String -> String -> String
 * @param {RegExp|String} pattern A regular expression or a substring to match.
 * @param {String} replacement The string to replace the matches with.
 * @param {String} str The String to do the search and replacement in.
 * @return {String} The result.
 * @example
 *
 *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *
 *      // Use the "g" (global) flag to replace all occurrences:
 *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
 */
module.exports = _curry3(function replace(regex, replacement, str) {
  return str.replace(regex, replacement);
});

},{"./internal/_curry3":209}],355:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _isString = _dereq_('./internal/_isString');


/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */
module.exports = _curry1(function reverse(list) {
  return _isString(list) ? list.split('').reverse().join('') :
                           Array.prototype.slice.call(list, 0).reverse();
});

},{"./internal/_curry1":207,"./internal/_isString":230}],356:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Scan is similar to reduce, but returns a list of successively reduced values
 * from the left
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (a,b -> a) -> a -> [b] -> [a]
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {Array} A list of all intermediately reduced values.
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
 * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
 */
module.exports = _curry3(function scan(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [acc];
  while (idx < len) {
    acc = fn(acc, list[idx]);
    result[idx + 1] = acc;
    idx += 1;
  }
  return result;
});

},{"./internal/_curry3":209}],357:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var ap = _dereq_('./ap');
var map = _dereq_('./map');
var prepend = _dereq_('./prepend');
var reduceRight = _dereq_('./reduceRight');


/**
 * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
 * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
 * Applicative of Traversable.
 *
 * Dispatches to the `sequence` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
 * @param {Function} of
 * @param {*} traversable
 * @return {*}
 * @see R.traverse
 * @example
 *
 *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
 *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
 *
 *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
 *      R.sequence(R.of, Nothing());       //=> [Nothing()]
 */
module.exports = _curry2(function sequence(of, traversable) {
  return typeof traversable.sequence === 'function' ?
    traversable.sequence(of) :
    reduceRight(function(x, acc) { return ap(map(prepend, x), acc); },
                of([]),
                traversable);
});

},{"./ap":119,"./internal/_curry2":208,"./map":290,"./prepend":336,"./reduceRight":348}],358:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var always = _dereq_('./always');
var over = _dereq_('./over');


/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the given value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> a -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
 *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
 */
module.exports = _curry3(function set(lens, v, x) {
  return over(lens, always(v), x);
});

},{"./always":115,"./internal/_curry3":209,"./over":320}],359:[function(_dereq_,module,exports){
var _checkForMethod = _dereq_('./internal/_checkForMethod');
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */
module.exports = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

},{"./internal/_checkForMethod":199,"./internal/_curry3":209}],360:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a copy of the list, sorted according to the comparator function,
 * which should accept two values at a time and return a negative number if the
 * first value is smaller, a positive number if it's larger, and zero if they
 * are equal. Please note that this is a **copy** of the list. It does not
 * modify the original.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a,a -> Number) -> [a] -> [a]
 * @param {Function} comparator A sorting function :: a -> b -> Int
 * @param {Array} list The list to sort
 * @return {Array} a new array with its elements sorted by the comparator function.
 * @example
 *
 *      var diff = function(a, b) { return a - b; };
 *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
 */
module.exports = _curry2(function sort(comparator, list) {
  return Array.prototype.slice.call(list, 0).sort(comparator);
});

},{"./internal/_curry2":208}],361:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Sorts the list according to the supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord b => (a -> b) -> [a] -> [a]
 * @param {Function} fn
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted by the keys generated by `fn`.
 * @example
 *
 *      var sortByFirstItem = R.sortBy(R.prop(0));
 *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
 *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
 *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var bob = {
 *        name: 'Bob',
 *        age: -10
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 314.159
 *      };
 *      var people = [clara, bob, alice];
 *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
 */
module.exports = _curry2(function sortBy(fn, list) {
  return Array.prototype.slice.call(list, 0).sort(function(a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
});

},{"./internal/_curry2":208}],362:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Sorts a list according to a list of comparators.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Relation
 * @sig [a -> a -> Number] -> [a] -> [a]
 * @param {Array} functions A list of comparator functions.
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted according to the comarator functions.
 * @example
 *
 *      var alice = {
 *        name: 'alice',
 *        age: 40
 *      };
 *      var bob = {
 *        name: 'bob',
 *        age: 30
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 40
 *      };
 *      var people = [clara, bob, alice];
 *      var ageNameSort = R.sortWith([
 *        R.descend(R.prop('age')),
 *        R.ascend(R.prop('name'))
 *      ]);
 *      ageNameSort(people); //=> [alice, clara, bob]
 */
module.exports = _curry2(function sortWith(fns, list) {
  return Array.prototype.slice.call(list, 0).sort(function(a, b) {
    var result = 0;
    var i = 0;
    while (result === 0 && i < fns.length) {
      result = fns[i](a, b);
      i += 1;
    }
    return result;
  });
});

},{"./internal/_curry2":208}],363:[function(_dereq_,module,exports){
var invoker = _dereq_('./invoker');


/**
 * Splits a string into an array of strings based on the given
 * separator.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig (String | RegExp) -> String -> [String]
 * @param {String|RegExp} sep The pattern.
 * @param {String} str The string to separate into an array.
 * @return {Array} The array of strings from `str` separated by `str`.
 * @see R.join
 * @example
 *
 *      var pathComponents = R.split('/');
 *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
 *
 *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
 */
module.exports = invoker(1, 'split');

},{"./invoker":270}],364:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var length = _dereq_('./length');
var slice = _dereq_('./slice');


/**
 * Splits a given list or string at a given index.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig Number -> [a] -> [[a], [a]]
 * @sig Number -> String -> [String, String]
 * @param {Number} index The index where the array/string is split.
 * @param {Array|String} array The array/string to be split.
 * @return {Array}
 * @example
 *
 *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
 *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
 *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
 */
module.exports = _curry2(function splitAt(index, array) {
  return [slice(0, index, array), slice(index, length(array), array)];
});

},{"./internal/_curry2":208,"./length":281,"./slice":359}],365:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var slice = _dereq_('./slice');


/**
 * Splits a collection into slices of the specified length.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @sig Number -> String -> [String]
 * @param {Number} n
 * @param {Array} list
 * @return {Array}
 * @example
 *
 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
 */
module.exports = _curry2(function splitEvery(n, list) {
  if (n <= 0) {
    throw new Error('First argument to splitEvery must be a positive integer');
  }
  var result = [];
  var idx = 0;
  while (idx < list.length) {
    result.push(slice(idx, idx += n, list));
  }
  return result;
});

},{"./internal/_curry2":208,"./slice":359}],366:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Takes a list and a predicate and returns a pair of lists with the following properties:
 *
 *  - the result of concatenating the two output lists is equivalent to the input list;
 *  - none of the elements of the first output list satisfies the predicate; and
 *  - if the second output list is non-empty, its first element satisfies the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [[a], [a]]
 * @param {Function} pred The predicate that determines where the array is split.
 * @param {Array} list The array to be split.
 * @return {Array}
 * @example
 *
 *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
 */
module.exports = _curry2(function splitWhen(pred, list) {
  var idx = 0;
  var len = list.length;
  var prefix = [];

  while (idx < len && !pred(list[idx])) {
    prefix.push(list[idx]);
    idx += 1;
  }

  return [prefix, Array.prototype.slice.call(list, idx)];
});

},{"./internal/_curry2":208}],367:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Subtracts its second argument from its first argument.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a - b`.
 * @see R.add
 * @example
 *
 *      R.subtract(10, 8); //=> 2
 *
 *      var minus5 = R.subtract(R.__, 5);
 *      minus5(17); //=> 12
 *
 *      var complementaryAngle = R.subtract(90);
 *      complementaryAngle(30); //=> 60
 *      complementaryAngle(72); //=> 18
 */
module.exports = _curry2(function subtract(a, b) {
  return Number(a) - Number(b);
});

},{"./internal/_curry2":208}],368:[function(_dereq_,module,exports){
var add = _dereq_('./add');
var reduce = _dereq_('./reduce');


/**
 * Adds together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The sum of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.sum([2,4,6,8,100,1]); //=> 121
 */
module.exports = reduce(add, 0);

},{"./add":110,"./reduce":346}],369:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var concat = _dereq_('./concat');
var difference = _dereq_('./difference');


/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
 * @example
 *
 *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
 *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
 */
module.exports = _curry2(function symmetricDifference(list1, list2) {
  return concat(difference(list1, list2), difference(list2, list1));
});

},{"./concat":139,"./difference":151,"./internal/_curry2":208}],370:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var concat = _dereq_('./concat');
var differenceWith = _dereq_('./differenceWith');


/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both. Duplication is determined according to the value
 * returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifference, R.difference, R.differenceWith
 * @example
 *
 *      var eqA = R.eqBy(R.prop('a'));
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
 *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
 *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
 */
module.exports = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
  return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
});

},{"./concat":139,"./differenceWith":152,"./internal/_curry3":209}],371:[function(_dereq_,module,exports){
var _checkForMethod = _dereq_('./internal/_checkForMethod');
var _curry1 = _dereq_('./internal/_curry1');
var slice = _dereq_('./slice');


/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */
module.exports = _curry1(_checkForMethod('tail', slice(1, Infinity)));

},{"./internal/_checkForMethod":199,"./internal/_curry1":207,"./slice":359}],372:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xtake = _dereq_('./internal/_xtake');
var slice = _dereq_('./slice');


/**
 * Returns the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `take` method).
 *
 * Dispatches to the `take` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*}
 * @see R.drop
 * @example
 *
 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(3, 'ramda');               //=> 'ram'
 *
 *      var personnel = [
 *        'Dave Brubeck',
 *        'Paul Desmond',
 *        'Eugene Wright',
 *        'Joe Morello',
 *        'Gerry Mulligan',
 *        'Bob Bates',
 *        'Joe Dodge',
 *        'Ron Crotty'
 *      ];
 *
 *      var takeFive = R.take(5);
 *      takeFive(personnel);
 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
 * @symb R.take(-1, [a, b]) = [a, b]
 * @symb R.take(0, [a, b]) = []
 * @symb R.take(1, [a, b]) = [a]
 * @symb R.take(2, [a, b]) = [a, b]
 */
module.exports = _curry2(_dispatchable(['take'], _xtake, function take(n, xs) {
  return slice(0, n < 0 ? Infinity : n, xs);
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xtake":261,"./slice":359}],373:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var drop = _dereq_('./drop');


/**
 * Returns a new list containing the last `n` elements of the given list.
 * If `n > list.length`, returns a list of `list.length` elements.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements to return.
 * @param {Array} xs The collection to consider.
 * @return {Array}
 * @see R.dropLast
 * @example
 *
 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(3, 'ramda');               //=> 'mda'
 */
module.exports = _curry2(function takeLast(n, xs) {
  return drop(n >= 0 ? xs.length - n : 0, xs);
});

},{"./drop":156,"./internal/_curry2":208}],374:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a new list containing the last `n` elements of a given list, passing
 * each value to the supplied predicate function, and terminating when the
 * predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} fn The function called per iteration.
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropLastWhile, R.addIndex
 * @example
 *
 *      var isNotOne = x => x !== 1;
 *
 *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
 */
module.exports = _curry2(function takeLastWhile(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0 && fn(list[idx])) {
    idx -= 1;
  }
  return Array.prototype.slice.call(list, idx + 1);
});

},{"./internal/_curry2":208}],375:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _dispatchable = _dereq_('./internal/_dispatchable');
var _xtakeWhile = _dereq_('./internal/_xtakeWhile');


/**
 * Returns a new list containing the first `n` elements of a given list,
 * passing each value to the supplied predicate function, and terminating when
 * the predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * Dispatches to the `takeWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} fn The function called per iteration.
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropWhile, R.transduce, R.addIndex
 * @example
 *
 *      var isNotFour = x => x !== 4;
 *
 *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
 */
module.exports = _curry2(_dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len && fn(list[idx])) {
    idx += 1;
  }
  return Array.prototype.slice.call(list, 0, idx);
}));

},{"./internal/_curry2":208,"./internal/_dispatchable":211,"./internal/_xtakeWhile":262}],376:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Runs the given function with the supplied object, then returns the object.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a -> *) -> a -> a
 * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
 * @param {*} x
 * @return {*} `x`.
 * @example
 *
 *      var sayX = x => console.log('x is ' + x);
 *      R.tap(sayX, 100); //=> 100
 *      // logs 'x is 100'
 * @symb R.tap(f, a) = a
 */
module.exports = _curry2(function tap(fn, x) {
  fn(x);
  return x;
});

},{"./internal/_curry2":208}],377:[function(_dereq_,module,exports){
var _cloneRegExp = _dereq_('./internal/_cloneRegExp');
var _curry2 = _dereq_('./internal/_curry2');
var _isRegExp = _dereq_('./internal/_isRegExp');
var toString = _dereq_('./toString');


/**
 * Determines whether a given string matches a given regular expression.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category String
 * @sig RegExp -> String -> Boolean
 * @param {RegExp} pattern
 * @param {String} str
 * @return {Boolean}
 * @see R.match
 * @example
 *
 *      R.test(/^x/, 'xyz'); //=> true
 *      R.test(/^y/, 'xyz'); //=> false
 */
module.exports = _curry2(function test(pattern, str) {
  if (!_isRegExp(pattern)) {
    throw new TypeError('‘test’ requires a value of type RegExp as its first argument; received ' + toString(pattern));
  }
  return _cloneRegExp(pattern).test(str);
});

},{"./internal/_cloneRegExp":201,"./internal/_curry2":208,"./internal/_isRegExp":229,"./toString":382}],378:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Calls an input function `n` times, returning an array containing the results
 * of those function calls.
 *
 * `fn` is passed one argument: The current value of `n`, which begins at `0`
 * and is gradually incremented to `n - 1`.
 *
 * @func
 * @memberOf R
 * @since v0.2.3
 * @category List
 * @sig (Number -> a) -> Number -> [a]
 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
 * @return {Array} An array containing the return values of all calls to `fn`.
 * @example
 *
 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
 * @symb R.times(f, 0) = []
 * @symb R.times(f, 1) = [f(0)]
 * @symb R.times(f, 2) = [f(0), f(1)]
 */
module.exports = _curry2(function times(fn, n) {
  var len = Number(n);
  var idx = 0;
  var list;

  if (len < 0 || isNaN(len)) {
    throw new RangeError('n must be a non-negative number');
  }
  list = new Array(len);
  while (idx < len) {
    list[idx] = fn(idx);
    idx += 1;
  }
  return list;
});

},{"./internal/_curry2":208}],379:[function(_dereq_,module,exports){
var invoker = _dereq_('./invoker');


/**
 * The lower case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to lower case.
 * @return {String} The lower case version of `str`.
 * @see R.toUpper
 * @example
 *
 *      R.toLower('XYZ'); //=> 'xyz'
 */
module.exports = invoker(0, 'toLowerCase');

},{"./invoker":270}],380:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _has = _dereq_('./internal/_has');


/**
 * Converts an object into an array of key, value arrays. Only the object's
 * own properties are used.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own properties.
 * @see R.fromPairs
 * @example
 *
 *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
 */
module.exports = _curry1(function toPairs(obj) {
  var pairs = [];
  for (var prop in obj) {
    if (_has(prop, obj)) {
      pairs[pairs.length] = [prop, obj[prop]];
    }
  }
  return pairs;
});

},{"./internal/_curry1":207,"./internal/_has":219}],381:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Converts an object into an array of key, value arrays. The object's own
 * properties and prototype properties are used. Note that the order of the
 * output array is not guaranteed to be consistent across different JS
 * platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own
 *         and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
 */
module.exports = _curry1(function toPairsIn(obj) {
  var pairs = [];
  for (var prop in obj) {
    pairs[pairs.length] = [prop, obj[prop]];
  }
  return pairs;
});

},{"./internal/_curry1":207}],382:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var _toString = _dereq_('./internal/_toString');


/**
 * Returns the string representation of the given value. `eval`'ing the output
 * should result in a value equivalent to the input value. Many of the built-in
 * `toString` methods do not satisfy this requirement.
 *
 * If the given value is an `[object Object]` with a `toString` method other
 * than `Object.prototype.toString`, this method is invoked with no arguments
 * to produce the return value. This means user-defined constructor functions
 * can provide a suitable `toString` method. For example:
 *
 *     function Point(x, y) {
 *       this.x = x;
 *       this.y = y;
 *     }
 *
 *     Point.prototype.toString = function() {
 *       return 'new Point(' + this.x + ', ' + this.y + ')';
 *     };
 *
 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category String
 * @sig * -> String
 * @param {*} val
 * @return {String}
 * @example
 *
 *      R.toString(42); //=> '42'
 *      R.toString('abc'); //=> '"abc"'
 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
 */
module.exports = _curry1(function toString(val) { return _toString(val, []); });

},{"./internal/_curry1":207,"./internal/_toString":243}],383:[function(_dereq_,module,exports){
var invoker = _dereq_('./invoker');


/**
 * The upper case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to upper case.
 * @return {String} The upper case version of `str`.
 * @see R.toLower
 * @example
 *
 *      R.toUpper('abc'); //=> 'ABC'
 */
module.exports = invoker(0, 'toUpperCase');

},{"./invoker":270}],384:[function(_dereq_,module,exports){
var _reduce = _dereq_('./internal/_reduce');
var _xwrap = _dereq_('./internal/_xwrap');
var curryN = _dereq_('./curryN');


/**
 * Initializes a transducer using supplied iterator function. Returns a single
 * item by iterating through the list, successively calling the transformed
 * iterator function and passing it an accumulator value and the current value
 * from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It will be
 * wrapped as a transformer to initialize the transducer. A transformer can be
 * passed directly in place of an iterator function. In both cases, iteration
 * may be stopped early with the `R.reduced` function.
 *
 * A transducer is a function that accepts a transformer and returns a
 * transformer and can be composed directly.
 *
 * A transformer is an an object that provides a 2-arity reducing iterator
 * function, step, 0-arity initial value function, init, and 1-arity result
 * extraction function, result. The step function is used as the iterator
 * function in reduce. The result function is used to convert the final
 * accumulator into the return type and in most cases is R.identity. The init
 * function can be used to provide an initial accumulator, but is ignored by
 * transduce.
 *
 * The iteration is performed with R.reduce after initializing the transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array. Wrapped as transformer, if necessary, and used to
 *        initialize the transducer
 * @param {*} acc The initial accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced, R.into
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *
 *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
 */
module.exports = curryN(4, function transduce(xf, fn, acc, list) {
  return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
});

},{"./curryN":147,"./internal/_reduce":239,"./internal/_xwrap":263}],385:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Transposes the rows and columns of a 2D list.
 * When passed a list of `n` lists of length `x`,
 * returns a list of `x` lists of length `n`.
 *
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [[a]] -> [[a]]
 * @param {Array} list A 2D list
 * @return {Array} A 2D list
 * @example
 *
 *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
 *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 *
 * If some of the rows are shorter than the following rows, their elements are skipped:
 *
 *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
 * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
 * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
 * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
 */
module.exports = _curry1(function transpose(outerlist) {
  var i = 0;
  var result = [];
  while (i < outerlist.length) {
    var innerlist = outerlist[i];
    var j = 0;
    while (j < innerlist.length) {
      if (typeof result[j] === 'undefined') {
        result[j] = [];
      }
      result[j].push(innerlist[j]);
      j += 1;
    }
    i += 1;
  }
  return result;
});

},{"./internal/_curry1":207}],386:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var map = _dereq_('./map');
var sequence = _dereq_('./sequence');


/**
 * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
 * into an Applicative of Traversable.
 *
 * Dispatches to the `sequence` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
 * @param {Function} of
 * @param {Function} f
 * @param {*} traversable
 * @return {*}
 * @see R.sequence
 * @example
 *
 *      // Returns `Nothing` if the given divisor is `0`
 *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
 *
 *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
 *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
 */
module.exports = _curry3(function traverse(of, f, traversable) {
  return sequence(of, map(f, traversable));
});

},{"./internal/_curry3":209,"./map":290,"./sequence":357}],387:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Removes (strips) whitespace from both ends of the string.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to trim.
 * @return {String} Trimmed version of `str`.
 * @example
 *
 *      R.trim('   xyz  '); //=> 'xyz'
 *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
 */
module.exports = (function() {
  var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
           '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
           '\u2029\uFEFF';
  var zeroWidth = '\u200b';
  var hasProtoTrim = (typeof String.prototype.trim === 'function');
  if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
    return _curry1(function trim(str) {
      var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
      var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
      return str.replace(beginRx, '').replace(endRx, '');
    });
  } else {
    return _curry1(function trim(str) {
      return str.trim();
    });
  }
}());

},{"./internal/_curry1":207}],388:[function(_dereq_,module,exports){
var _arity = _dereq_('./internal/_arity');
var _concat = _dereq_('./internal/_concat');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
 * function evaluates the `tryer`; if it does not throw, it simply returns the
 * result. If the `tryer` *does* throw, the returned function evaluates the
 * `catcher` function and returns its result. Note that for effective
 * composition with this function, both the `tryer` and `catcher` functions
 * must return the same type of results.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
 * @param {Function} tryer The function that may throw.
 * @param {Function} catcher The function that will be evaluated if `tryer` throws.
 * @return {Function} A new function that will catch exceptions and send then to the catcher.
 * @example
 *
 *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
 *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
 */
module.exports = _curry2(function _tryCatch(tryer, catcher) {
  return _arity(tryer.length, function() {
    try {
      return tryer.apply(this, arguments);
    } catch (e) {
      return catcher.apply(this, _concat([e], arguments));
    }
  });
});

},{"./internal/_arity":196,"./internal/_concat":203,"./internal/_curry2":208}],389:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 */
module.exports = _curry1(function type(val) {
  return val === null      ? 'Null'      :
         val === undefined ? 'Undefined' :
         Object.prototype.toString.call(val).slice(8, -1);
});

},{"./internal/_curry1":207}],390:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Takes a function `fn`, which takes a single array argument, and returns a
 * function which:
 *
 *   - takes any number of positional arguments;
 *   - passes these arguments to `fn` as an array; and
 *   - returns the result.
 *
 * In other words, R.unapply derives a variadic function from a function which
 * takes an array. R.unapply is the inverse of R.apply.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Function
 * @sig ([*...] -> a) -> (*... -> a)
 * @param {Function} fn
 * @return {Function}
 * @see R.apply
 * @example
 *
 *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
 * @symb R.unapply(f)(a, b) = f([a, b])
 */
module.exports = _curry1(function unapply(fn) {
  return function() {
    return fn(Array.prototype.slice.call(arguments, 0));
  };
});

},{"./internal/_curry1":207}],391:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var nAry = _dereq_('./nAry');


/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 1 parameter. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> b) -> (a -> b)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 1.
 * @example
 *
 *      var takesTwoArgs = function(a, b) {
 *        return [a, b];
 *      };
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.unary(takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only 1 argument is passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.unary(f)(a, b, c) = f(a)
 */
module.exports = _curry1(function unary(fn) {
  return nAry(1, fn);
});

},{"./internal/_curry1":207,"./nAry":309}],392:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var curryN = _dereq_('./curryN');


/**
 * Returns a function of arity `n` from a (manually) curried function.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Function
 * @sig Number -> (a -> b) -> (a -> c)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to uncurry.
 * @return {Function} A new function.
 * @see R.curry
 * @example
 *
 *      var addFour = a => b => c => d => a + b + c + d;
 *
 *      var uncurriedAddFour = R.uncurryN(4, addFour);
 *      uncurriedAddFour(1, 2, 3, 4); //=> 10
 */
module.exports = _curry2(function uncurryN(depth, fn) {
  return curryN(depth, function() {
    var currentDepth = 1;
    var value = fn;
    var idx = 0;
    var endIdx;
    while (currentDepth <= depth && typeof value === 'function') {
      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
      currentDepth += 1;
      idx = endIdx;
    }
    return value;
  });
});

},{"./curryN":147,"./internal/_curry2":208}],393:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Builds a list from a seed value. Accepts an iterator function, which returns
 * either false to stop iteration or an array of length 2 containing the value
 * to add to the resulting list and the seed to be used in the next call to the
 * iterator function.
 *
 * The iterator function receives one argument: *(seed)*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (a -> [b]) -> * -> [b]
 * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
 *        either false to quit iteration or an array of length two to proceed. The element
 *        at index 0 of this array will be added to the resulting array, and the element
 *        at index 1 will be passed to the next call to `fn`.
 * @param {*} seed The seed value.
 * @return {Array} The final list.
 * @example
 *
 *      var f = n => n > 50 ? false : [-n, n + 10];
 *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
 * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
 */
module.exports = _curry2(function unfold(fn, seed) {
  var pair = fn(seed);
  var result = [];
  while (pair && pair.length) {
    result[result.length] = pair[0];
    pair = fn(pair[1]);
  }
  return result;
});

},{"./internal/_curry2":208}],394:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _curry2 = _dereq_('./internal/_curry2');
var compose = _dereq_('./compose');
var uniq = _dereq_('./uniq');


/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @example
 *
 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
 */
module.exports = _curry2(compose(uniq, _concat));

},{"./compose":136,"./internal/_concat":203,"./internal/_curry2":208,"./uniq":396}],395:[function(_dereq_,module,exports){
var _concat = _dereq_('./internal/_concat');
var _curry3 = _dereq_('./internal/_curry3');
var uniqWith = _dereq_('./uniqWith');


/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list. Duplication is determined according to the value returned by
 * applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @see R.union
 * @example
 *
 *      var l1 = [{a: 1}, {a: 2}];
 *      var l2 = [{a: 1}, {a: 4}];
 *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
 */
module.exports = _curry3(function unionWith(pred, list1, list2) {
  return uniqWith(pred, _concat(list1, list2));
});

},{"./internal/_concat":203,"./internal/_curry3":209,"./uniqWith":398}],396:[function(_dereq_,module,exports){
var identity = _dereq_('./identity');
var uniqBy = _dereq_('./uniqBy');


/**
 * Returns a new list containing only one copy of each element in the original
 * list. `R.equals` is used to determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
 *      R.uniq([1, '1']);     //=> [1, '1']
 *      R.uniq([[42], [42]]); //=> [[42]]
 */
module.exports = uniqBy(identity);

},{"./identity":186,"./uniqBy":397}],397:[function(_dereq_,module,exports){
var _Set = _dereq_('./internal/_Set');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied function to
 * each list element. Prefers the first item if the supplied function produces
 * the same value on two items. `R.equals` is used for comparison.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> b) -> [a] -> [a]
 * @param {Function} fn A function used to produce a value to use during comparisons.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
 */
module.exports = _curry2(function uniqBy(fn, list) {
  var set = new _Set();
  var result = [];
  var idx = 0;
  var appliedItem, item;

  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);
    if (set.add(appliedItem)) {
      result.push(item);
    }
    idx += 1;
  }
  return result;
});

},{"./internal/_Set":194,"./internal/_curry2":208}],398:[function(_dereq_,module,exports){
var _containsWith = _dereq_('./internal/_containsWith');
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied predicate to
 * two list elements. Prefers the first item if two items compare equal based
 * on the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category List
 * @sig (a, a -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      var strEq = R.eqBy(String);
 *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
 *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
 *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
 *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
 */
module.exports = _curry2(function uniqWith(pred, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var item;
  while (idx < len) {
    item = list[idx];
    if (!_containsWith(pred, item, result)) {
      result[result.length] = item;
    }
    idx += 1;
  }
  return result;
});

},{"./internal/_containsWith":205,"./internal/_curry2":208}],399:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is not satisfied, the function will return the result of
 * calling the `whenFalseFn` function with the same argument. If the predicate
 * is satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred        A predicate function
 * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
 *                               to a falsy value.
 * @param {*}        x           An object to test with the `pred` function and
 *                               pass to `whenFalseFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
 * @see R.ifElse, R.when
 * @example
 *
 *      // coerceArray :: (a|[a]) -> [a]
 *      var coerceArray = R.unless(R.isArrayLike, R.of);
 *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
 *      coerceArray(1);         //=> [1]
 */
module.exports = _curry3(function unless(pred, whenFalseFn, x) {
  return pred(x) ? x : whenFalseFn(x);
});

},{"./internal/_curry3":209}],400:[function(_dereq_,module,exports){
var _identity = _dereq_('./internal/_identity');
var chain = _dereq_('./chain');


/**
 * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
 * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain c => c (c a) -> c a
 * @param {*} list
 * @return {*}
 * @see R.flatten, R.chain
 * @example
 *
 *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
 *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
 */
module.exports = chain(_identity);

},{"./chain":131,"./internal/_identity":220}],401:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Takes a predicate, a transformation function, and an initial value,
 * and returns a value of the same type as the initial value.
 * It does so by applying the transformation until the predicate is satisfied,
 * at which point it returns the satisfactory value.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred A predicate function
 * @param {Function} fn The iterator function
 * @param {*} init Initial value
 * @return {*} Final value that satisfies predicate
 * @example
 *
 *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
 */
module.exports = _curry3(function until(pred, fn, init) {
  var val = init;
  while (!pred(val)) {
    val = fn(val);
  }
  return val;
});

},{"./internal/_curry3":209}],402:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');
var adjust = _dereq_('./adjust');
var always = _dereq_('./always');


/**
 * Returns a new copy of the array with the element at the provided index
 * replaced with the given value.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} idx The index to update.
 * @param {*} x The value to exist at the given index of the returned array.
 * @param {Array|Arguments} list The source array-like object to be updated.
 * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
 * @see R.adjust
 * @example
 *
 *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
 *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
 * @symb R.update(-1, a, [b, c]) = [b, a]
 * @symb R.update(0, a, [b, c]) = [a, c]
 * @symb R.update(1, a, [b, c]) = [b, a]
 */
module.exports = _curry3(function update(idx, x, list) {
  return adjust(always(x), idx, list);
});

},{"./adjust":112,"./always":115,"./internal/_curry3":209}],403:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var curryN = _dereq_('./curryN');


/**
 * Accepts a function `fn` and a list of transformer functions and returns a
 * new curried function. When the new function is invoked, it calls the
 * function `fn` with parameters consisting of the result of calling each
 * supplied handler on successive arguments to the new function.
 *
 * If more arguments are passed to the returned function than transformer
 * functions, those arguments are passed directly to `fn` as additional
 * parameters. If you expect additional arguments that don't need to be
 * transformed, although you can ignore them, it's best to pass an identity
 * function so that the new function reports the correct arity.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} fn The function to wrap.
 * @param {Array} transformers A list of transformer functions
 * @return {Function} The wrapped function.
 * @see R.converge
 * @example
 *
 *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
 *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
 *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
 *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
 * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
 */
module.exports = _curry2(function useWith(fn, transformers) {
  return curryN(transformers.length, function() {
    var args = [];
    var idx = 0;
    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }
    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});

},{"./curryN":147,"./internal/_curry2":208}],404:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');
var keys = _dereq_('./keys');


/**
 * Returns a list of all the enumerable own properties of the supplied object.
 * Note that the order of the output array is not guaranteed across different
 * JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own properties.
 * @example
 *
 *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
 */
module.exports = _curry1(function values(obj) {
  var props = keys(obj);
  var len = props.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props[idx]];
    idx += 1;
  }
  return vals;
});

},{"./internal/_curry1":207,"./keys":277}],405:[function(_dereq_,module,exports){
var _curry1 = _dereq_('./internal/_curry1');


/**
 * Returns a list of all the properties, including prototype properties, of the
 * supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.valuesIn(f); //=> ['X', 'Y']
 */
module.exports = _curry1(function valuesIn(obj) {
  var prop;
  var vs = [];
  for (prop in obj) {
    vs[vs.length] = obj[prop];
  }
  return vs;
});

},{"./internal/_curry1":207}],406:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Returns a "view" of the given data structure, determined by the given lens.
 * The lens's focus determines which portion of the data structure is visible.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> s -> a
 * @param {Lens} lens
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});  //=> 1
 *      R.view(xLens, {x: 4, y: 2});  //=> 4
 */
module.exports = (function() {
  // `Const` is a functor that effectively ignores the function given to `map`.
  var Const = function(x) {
    return {value: x, map: function() { return this; }};
  };

  return _curry2(function view(lens, x) {
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    return lens(Const)(x).value;
  });
}());

},{"./internal/_curry2":208}],407:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is satisfied, the function will return the result of calling
 * the `whenTrueFn` function with the same argument. If the predicate is not
 * satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred       A predicate function
 * @param {Function} whenTrueFn A function to invoke when the `condition`
 *                              evaluates to a truthy value.
 * @param {*}        x          An object to test with the `pred` function and
 *                              pass to `whenTrueFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
 * @see R.ifElse, R.unless
 * @example
 *
 *      // truncate :: String -> String
 *      var truncate = R.when(
 *        R.propSatisfies(R.gt(R.__, 10), 'length'),
 *        R.pipe(R.take(10), R.append('…'), R.join(''))
 *      );
 *      truncate('12345');         //=> '12345'
 *      truncate('0123456789ABC'); //=> '0123456789…'
 */
module.exports = _curry3(function when(pred, whenTrueFn, x) {
  return pred(x) ? whenTrueFn(x) : x;
});

},{"./internal/_curry3":209}],408:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var _has = _dereq_('./internal/_has');


/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec. Each of the spec's own properties must be a predicate function.
 * Each predicate is applied to the value of the corresponding property of the
 * test object. `where` returns true if all the predicates return true, false
 * otherwise.
 *
 * `where` is well suited to declaratively expressing constraints for other
 * functions such as `filter` and `find`.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Object
 * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.where({
 *        a: R.equals('foo'),
 *        b: R.complement(R.equals('bar')),
 *        x: R.gt(__, 10),
 *        y: R.lt(__, 20)
 *      });
 *
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
 *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
 */
module.exports = _curry2(function where(spec, testObj) {
  for (var prop in spec) {
    if (_has(prop, spec) && !spec[prop](testObj[prop])) {
      return false;
    }
  }
  return true;
});

},{"./internal/_curry2":208,"./internal/_has":219}],409:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');
var equals = _dereq_('./equals');
var map = _dereq_('./map');
var where = _dereq_('./where');


/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec, false otherwise. An object satisfies the spec if, for each of the
 * spec's own properties, accessing that property of the object gives the same
 * value (in `R.equals` terms) as accessing that property of the spec.
 *
 * `whereEq` is a specialization of [`where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @sig {String: *} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @see R.where
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.whereEq({a: 1, b: 2});
 *
 *      pred({a: 1});              //=> false
 *      pred({a: 1, b: 2});        //=> true
 *      pred({a: 1, b: 2, c: 3});  //=> true
 *      pred({a: 1, b: 1});        //=> false
 */
module.exports = _curry2(function whereEq(spec, testObj) {
  return where(map(equals, spec), testObj);
});

},{"./equals":166,"./internal/_curry2":208,"./map":290,"./where":408}],410:[function(_dereq_,module,exports){
var _contains = _dereq_('./internal/_contains');
var _curry2 = _dereq_('./internal/_curry2');
var flip = _dereq_('./flip');
var reject = _dereq_('./reject');


/**
 * Returns a new list without values in the first argument.
 * `R.equals` is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @param {Array} list1 The values to be removed from `list2`.
 * @param {Array} list2 The array to remove values from.
 * @return {Array} The new array without values in `list1`.
 * @see R.transduce
 * @example
 *
 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
 */
module.exports = _curry2(function(xs, list) {
  return reject(flip(_contains)(xs), list);
});

},{"./flip":174,"./internal/_contains":204,"./internal/_curry2":208,"./reject":351}],411:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Creates a new list out of the two supplied by creating each possible pair
 * from the lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The list made by combining each possible pair from
 *         `as` and `bs` into pairs (`[a, b]`).
 * @example
 *
 *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
 * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
 */
module.exports = _curry2(function xprod(a, b) { // = xprodWith(prepend); (takes about 3 times as long...)
  var idx = 0;
  var ilen = a.length;
  var j;
  var jlen = b.length;
  var result = [];
  while (idx < ilen) {
    j = 0;
    while (j < jlen) {
      result[result.length] = [a[idx], b[j]];
      j += 1;
    }
    idx += 1;
  }
  return result;
});

},{"./internal/_curry2":208}],412:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Creates a new list out of the two supplied by pairing up equally-positioned
 * items from both lists. The returned list is truncated to the length of the
 * shorter of the two input lists.
 * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
 * @example
 *
 *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
 */
module.exports = _curry2(function zip(a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = [a[idx], b[idx]];
    idx += 1;
  }
  return rv;
});

},{"./internal/_curry2":208}],413:[function(_dereq_,module,exports){
var _curry2 = _dereq_('./internal/_curry2');


/**
 * Creates a new object out of a list of keys and a list of values.
 * Key/value pairing is truncated to the length of the shorter of the two lists.
 * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [String] -> [*] -> {String: *}
 * @param {Array} keys The array that will be properties on the output object.
 * @param {Array} values The list of values on the output object.
 * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
 * @example
 *
 *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
 */
module.exports = _curry2(function zipObj(keys, values) {
  var idx = 0;
  var len = Math.min(keys.length, values.length);
  var out = {};
  while (idx < len) {
    out[keys[idx]] = values[idx];
    idx += 1;
  }
  return out;
});

},{"./internal/_curry2":208}],414:[function(_dereq_,module,exports){
var _curry3 = _dereq_('./internal/_curry3');


/**
 * Creates a new list out of the two supplied by applying the function to each
 * equally-positioned pair in the lists. The returned list is truncated to the
 * length of the shorter of the two input lists.
 *
 * @function
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a,b -> c) -> [a] -> [b] -> [c]
 * @param {Function} fn The function used to combine the two elements into one value.
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
 *         using `fn`.
 * @example
 *
 *      var f = (x, y) => {
 *        // ...
 *      };
 *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
 *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
 * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
 */
module.exports = _curry3(function zipWith(fn, a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = fn(a[idx], b[idx]);
    idx += 1;
  }
  return rv;
});

},{"./internal/_curry3":209}],415:[function(_dereq_,module,exports){
module.exports={
  "version": "1.0.0",
  "symbolizers": {
    "polygon": {
      "fill": {
        "css": "polygon-fill",
        "type": "color",
        "default-value": "rgba(128,128,128,1)",
        "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
        "doc": "Fill color to assign to a polygon"
      },
      "fill-opacity": {
        "css": "polygon-opacity",
        "type": "float",
        "doc": "The opacity of the polygon",
        "default-value": 1,
        "default-meaning": "opaque"
      },
      "comp-op": {
        "css": "polygon-comp-op",
        "default-value": "src-over",
        "default-meaning": "Add the current symbolizer on top of other symbolizer.",
        "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
        "type": [
          "multiply",
          "add",
          "overlay"
        ],
        "expression": true
      }
    },
    "polygon-pattern": {
      "file": {
        "css": "polygon-pattern-file",
        "type": "uri",
        "expression": true,
        "default-value": "none",
        "required": true,
        "doc": "Image to use as a repeated pattern fill within a polygon. Accepted formats: svg, jpg, png, tiff, and webp.",
        "default-meaning": ""
      }
    },
    "line": {
      "stroke": {
        "css": "line-color",
        "default-value": "rgba(0,0,0,1)",
        "type": "color",
        "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
        "doc": "The color of a drawn line"
      },
      "stroke-width": {
        "css": "line-width",
        "default-value": 1,
        "type": "float",
        "doc": "The width of a line in pixels"
      },
      "stroke-opacity": {
        "css": "line-opacity",
        "default-value": 1,
        "type": "float",
        "default-meaning": "opaque",
        "doc": "The opacity of a line"
      },
      "stroke-linejoin": {
        "css": "line-join",
        "default-value": "miter",
        "type": [
          "miter",
          "miter-revert",
          "round",
          "bevel"
        ],
        "expression": true,
        "doc": "The behavior of lines when joining.",
        "default-meaning": "The line joins will be rendered using a miter look."
      },
      "stroke-linecap": {
        "css": "line-cap",
        "default-value": "butt",
        "type": [
          "butt",
          "round",
          "square"
        ],
        "expression": true,
        "doc": "The display of line endings.",
        "default-meaning": "The line endings will be rendered using a butt look."
      },
      "comp-op": {
        "css": "line-comp-op",
        "default-value": "overlay",
        "default-meaning": "Add the current symbolizer on top of other symbolizer.",
        "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
        "type": [
          "multiply",
          "add",
          "overlay"
        ],
        "expression": true
      },
      "stroke-dasharray": {
        "css": "line-dasharray",
        "type": "numbers",
        "expression": true,
        "doc": "A pair of length values [a,b], where (a) is the dash length and (b) is the gap length respectively. More than two values are supported for more complex patterns.",
        "default-value": "none",
        "default-meaning": "The line will be drawn without dashes."
      }
    },
    "markers": {
      "file": {
        "css": "marker-file",
        "doc": "A file that this marker shows at each placement. If no file is given, the marker will show an ellipse. Accepted formats: svg, jpg, png, tiff, and webp.",
        "default-value": "none",
        "default-meaning": "An ellipse or circle, if width equals height.",
        "type": "uri",
        "expression": true
      },
      "opacity": {
        "css": "marker-opacity",
        "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
        "default-value": 1,
        "default-meaning": "The stroke-opacity and fill-opacity will be used",
        "type": "float"
      },
      "fill": {
        "css": "marker-fill",
        "default-value": "blue",
        "doc": "The color of the area of the marker.",
        "type": "color",
        "expression": true
      },
      "allow-overlap": {
        "css": "marker-allow-overlap",
        "type": "boolean",
        "expression": true,
        "default-value": false,
        "doc": "Control whether overlapping markers are shown or hidden.",
        "default-meaning": "Do not allow markers to overlap with each other - overlapping markers will not be shown."
      },
      "width": {
        "css": "marker-width",
        "default-value": 10.0,
        "doc": "The width of the marker, if using one of the default types.",
        "type": "float",
        "expression": true,
        "default-meaning": "The marker width is 10 pixels."
      },
      "fill-opacity": {
        "css": "marker-fill-opacity",
        "doc": "The fill opacity of the marker.",
        "default-value": 1.0,
        "expression": true,
        "default-meaning": "Color is fully opaque.",
        "type": "float"
      },
      "comp-op": {
        "css": "marker-comp-op",
        "default-value": "src-over",
        "default-meaning": "Add the current symbolizer on top of other symbolizer.",
        "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
        "type": [
          "multiply",
          "add",
          "overlay"
        ],
        "expression": true
      },
      "stroke": {
        "css": "marker-line-color",
        "doc": "The color of the stroke around the marker.",
        "default-value": "black",
        "type": "color",
        "expression": true,
        "default-meaning": "The marker will be drawn with a black outline."
      },
      "stroke-width": {
        "css": "marker-line-width",
        "default-value": 0.5,
        "doc": "The width of the stroke around the marker, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
        "type": "float",
        "expression": true,
        "default-meaning": "The marker will be drawn with an outline of .5 pixels wide."
      },
      "stroke-opacity": {
        "css": "marker-line-opacity",
        "default-value": 1.0,
        "default-meaning": "Color is fully opaque.",
        "doc": "The opacity of a line.",
        "type": "float",
        "expression": true
      },
      "placement": {
        "css": "marker-placement",
        "type": [
          "point"
        ],
        "expression": true,
        "default-value": "point",
        "default-meaning": "Place markers at the center point (centroid) of the geometry.",
        "doc": "Attempt to place markers on a point, in the center of a polygon, or if markers-placement:line, then multiple times along a line. 'interior' placement can be used to ensure that points placed on polygons are forced to be inside the polygon interior. The 'vertex-first' and 'vertex-last' options can be used to place markers at the first or last vertex of lines or polygons."
      },
      "marker-type": {
        "css": "marker-type",
        "type": [
          "ellipse"
        ],
        "expression": true,
        "default-value": "ellipse",
        "default-meaning": "The marker shape is an ellipse.",
        "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an arrow or an ellipse (a circle if height is equal to width).",
        "status": "deprecated"
      }
    },
    "text": {
      "name": {
        "css": "text-name",
        "type": "string",
        "expression": true,
        "required": true,
        "default-value": "none",
        "serialization": "content",
        "doc": "Value to use for a text label. Data columns are specified using brackets like [column_name].",
        "default-meaning": ""
      },
      "size": {
        "css": "text-size",
        "type": "float",
        "expression": true,
        "default-value": 10.0,
        "doc": "Text size in pixels.",
        "default-meaning": "Font size of 10 will be used to render text."
      },
      "fill": {
        "css": "text-fill",
        "type": "color",
        "expression": true,
        "doc": "Specifies the color for the text.",
        "default-value": "black",
        "default-meaning": "The text will be rendered black."
      },
      "opacity": {
        "css": "text-opacity",
        "doc": "A number from 0 to 1 specifying the opacity for the text.",
        "default-value": 1.0,
        "default-meaning": "Fully opaque",
        "expression": true,
        "type": "float"
      }
    }
  },
  "colors": {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "grey": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50],
    "transparent": [0, 0, 0, 0]
  }
}

},{}],416:[function(_dereq_,module,exports){
var fs = _dereq_('fs'),
    path = _dereq_('path'),
    existsSync = _dereq_('fs').existsSync || _dereq_('path').existsSync;

var versions = [
    '1.0.0'
];

module.exports.versions = versions;

module.exports.load = function(version) {
    if (versions.indexOf(version) <= -1) {
	throw new Error("Unknown mapnik-reference version: '" + version + "'");
    }
    var ref = _dereq_('./1.0.0/reference.json');
 //    var ds_path = path.join(__dirname, version, 'datasources.json');
 //    if (existsSync(ds_path)) {
	// ref.datasources = require(ds_path).datasources;
 //    }
    return ref;
}

},{"./1.0.0/reference.json":415,"fs":5,"path":104}],417:[function(_dereq_,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],418:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],419:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],420:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":419,"_process":105,"inherits":418}],421:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ramda = _dereq_('ramda');

var _referenceHelpers = _dereq_('../utils/reference-helpers');

var _reference = _dereq_('../utils/reference');

var _reference2 = _interopRequireDefault(_reference);

var _geom = _dereq_('../utils/geom');

var _geom2 = _interopRequireDefault(_geom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
	 ___       ___  ________   _______   ________
	|\  \     |\  \|\   ___  \|\  ___ \ |\   ____\
	\ \  \    \ \  \ \  \\ \  \ \   __/|\ \  \___|_
	 \ \  \    \ \  \ \  \\ \  \ \  \_|/_\ \_____  \
	  \ \  \____\ \  \ \  \\ \  \ \  \_|\ \|____|\  \
	   \ \_______\ \__\ \__\\ \__\ \_______\____\_\  \
	    \|_______|\|__|\|__| \|__|\|_______|\_________\
	                                       \|_________|

 */

/*
	EXTERNAL DEPENDENCIES
 */

var notEq = (0, _ramda.curry)((0, _ramda.compose)(_ramda.not, _ramda.equals));

/*
	INTERNAL DEPENDENCIES
 */

var LR = _reference2.default.getLine(null); // Line reference
/*
	INTERNAL LINE FUNCTIONS
 */

var checkLineSym = _reference2.default.checkSymbolizer('line');

/**
 * Function for getting the color in rgba
 *
 * @param   {object} c3ss compiled carto css
 * @returns {object} with a function that contain the conditions to return a color with alpha channel
 */

var getColor = (0, _referenceHelpers.getColorFn)((0, _referenceHelpers.getPropertyOrDefFn)('stroke', LR), (0, _referenceHelpers.getPropertyOrDefFn)('stroke-opacity', LR));

/**
 * Function for getting the width in meters dynamically by zoom
 *
 * @param   {object} c3ss compiled carto css
 * @returns {object} witha a function with the conditions to return width value
 */

var getWidth = (0, _ramda.compose)(_geom2.default.px2Meters, (0, _referenceHelpers.getPropertyOrDefFn)('stroke-width', LR));

/**
 * Function for getting the cap statically
 *
 * @param   {object} c3ss compiled carto css
 * @returns {string} with cap value Ex: round
 */
var getCap = (0, _referenceHelpers.getExecutedFn)('stroke-linecap', LR);

/**
 * Function for getting the join statically
 *
 * @param   {object} c3ss compiled carto css
 * @returns {string} with join value Ex: round
 */
var getJoin = (0, _referenceHelpers.getExecutedFn)('stroke-linejoin', LR);

/**
 * Function for getting the blend statically
 *
 * @param   {object} c3ss compiled carto css
 * @returns {string} with blending value Ex: "multiply"
 */
var getBlending = (0, _referenceHelpers.getBlendFn)(LR);

/**
 * Function for getting dash value statically
 *
 * @param   {object} c3ss compiled carto css
 * @returns {string} with dash value Ex: [2, 1]
 */

var getDashed = (0, _ramda.compose)((0, _ramda.cond)([[notEq('none'), _ramda.identity]]), (0, _referenceHelpers.getExecutedFn)('stroke-dasharray', LR));

/**
 * Basic Line
 */

var Line = {};

exports.default = Line;

/**
 * Function to get the draw object of a line.
 *
 * @param   {object} c3ss compiled carto css
 * @returns {function} function with the conditions to return alpha value
 */

Line.getDraw = function (c3ss, id) {
  var draw = {};
  if (checkLineSym(c3ss)) {
    draw['lines_' + id] = {
      color: getColor(c3ss),
      width: getWidth(c3ss),
      cap: getCap(c3ss),
      join: getJoin(c3ss)
    };
  }

  return draw;
};

/**
 * Function to get the style configuration of a line.
 *
 * @returns default style configuration for lines
 */
Line.getStyle = function (c3ss, id, ord) {
  var style = {};

  style['lines_' + id] = {
    base: 'lines',
    blend: getBlending(c3ss),
    dash: getDashed(c3ss),
    blend_order: typeof ord === 'number' ? ord + 1 : 1
  };

  return style;
};

},{"../utils/geom":428,"../utils/reference":430,"../utils/reference-helpers":429,"ramda":106}],422:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _md = _dereq_('md5');

var _md2 = _interopRequireDefault(_md);

var _ramda = _dereq_('ramda');

var _referenceHelpers = _dereq_('../utils/reference-helpers');

var _reference = _dereq_('../utils/reference');

var _reference2 = _interopRequireDefault(_reference);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
	INTERNAL DEPENDENCIES
 */

/*
	 ________  ________  ___  ________   _________
	|\   __  \|\   __  \|\  \|\   ___  \|\___   ___\
	\ \  \|\  \ \  \|\  \ \  \ \  \\ \  \|___ \  \_|
	 \ \   ____\ \  \\\  \ \  \ \  \\ \  \   \ \  \
	  \ \  \___|\ \  \\\  \ \  \ \  \\ \  \   \ \  \
	   \ \__\    \ \_______\ \__\ \__\\ \__\   \ \__\
	    \|__|     \|_______|\|__|\|__| \|__|    \|__|

 */

/*
	EXTERNAL DEPENDENCIES
 */
var PR = _reference2.default.getPoint(null); // Point reference

/*
	INTERNAL MARKER FUNCTIONS
 */

var checkMarkerSym = _reference2.default.checkSymbolizer('markers');

/**
 * get colors from cartocss with the alpha channel applied
 * @param  {object} c3ss compiled carto css
 * @return {object}      draw object with color and border_color
 */

var getColor = (0, _referenceHelpers.getColorFn)((0, _referenceHelpers.getPropertyOrDefFn)('fill', PR), (0, _referenceHelpers.getEitherProp)('fill-opacity', 'opacity', PR));

var getOutlineColor = (0, _referenceHelpers.getColorFn)((0, _referenceHelpers.getPropertyFnSafe)('stroke', PR), (0, _referenceHelpers.getEitherProp)('stroke-opacity', 'opacity', PR));

var getColors = (0, _ramda.compose)((0, _ramda.pickBy)((0, _ramda.compose)(_ramda.not, _ramda.isNil)), (0, _ramda.applySpec)({
  color: getColor,
  outline: {
    color: getOutlineColor
  }
}));

/**
 * getWidth for the marker and his border
 * @param  {object} c3ss compiled carto css
 * @return {object}      size and border_width
 */

var getMarkerWidth = (0, _referenceHelpers.getPropertyFnSafe)('width', PR);

var getOutlineWidth = (0, _referenceHelpers.getPropertyFnSafe)('stroke-width', PR);

var getWidths = (0, _ramda.compose)((0, _ramda.pickBy)((0, _ramda.compose)(_ramda.not, _ramda.isNil)), (0, _ramda.applySpec)({
  size: getMarkerWidth,
  outline: {
    width: getOutlineWidth
  }
}));

/**
 * Get collide from allow-overlap in cartocss [NON-DYNAMIC]
 * @param  {object} c3ss compiled carto css
 * @return {object}      return draw object with a non-dynamic collide option
 */

var getCollide = (0, _referenceHelpers.getExecutedFn)('allow-overlap', PR);

var getTextureFile = (0, _referenceHelpers.getExecutedFn)('file', PR);

/**
 * Get texture from marker-file in cartocss [NON-DYNAMIC]
 * @param  {object} c3ss compiled carto css
 * @return {object}      return draw object with a non-dynamic texture.
 */
var getTexture = (0, _ramda.compose)(_md2.default, getTextureFile);

var getBlending = (0, _referenceHelpers.getBlendFn)(PR);

/**
 * Basic point
 */

var Point = {};

exports.default = Point;

/**
 * Get the draw (for tangram) object of a point from compiled carto css
 * @param  {object} c3ss compiled carto @class
 * @return {object}      object with the draw types and their properties
 */

Point.getDraw = function (c3ss, id) {
  var point = {},
      draw = {};

  if (checkMarkerSym(c3ss)) {

    point = (0, _ramda.mergeWith)(_ramda.merge, getWidths(c3ss), getColors(c3ss));

    point.collide = !getCollide(c3ss);
  }

  draw['points_' + id] = point;

  return draw;
};

// TODO
/**
 * [getStyle description]
 * @param  {[type]} c3ss  [description]
 * @return {[type]}       [description]
 */
Point.getStyle = function (c3ss, id, ord) {
  var style = {};
  style['points_' + id] = {
    base: 'points',
    blend: 'overlay',
    blend_order: ord || 1
  };

  if (checkMarkerSym(c3ss)) {
    var p = style['points_' + id];
    p.texture = getTextureFile(c3ss) !== 'none' ? getTexture(c3ss) : void 0;
    p.blend = getBlending(c3ss);
  }

  return style;
};

Point.getTextures = function (c3ss) {
  var tex = {};
  if (checkMarkerSym(c3ss)) {
    var texture = getTextureFile(c3ss);

    if (texture !== 'none') {
      tex[(0, _md2.default)(texture)] = { url: texture };
    }

    return tex;
  }
};

},{"../utils/reference":430,"../utils/reference-helpers":429,"md5":103,"ramda":106}],423:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _md = _dereq_('md5');

var _md2 = _interopRequireDefault(_md);

var _ramda = _dereq_('ramda');

var _referenceHelpers = _dereq_('../utils/reference-helpers');

var _reference = _dereq_('../utils/reference');

var _reference2 = _interopRequireDefault(_reference);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
	INTERNAL DEPENDENCIES
 */

/*
 ________  ________  ___           ___    ___ ________  ________  ________   ________
|\   __  \|\   __  \|\  \         |\  \  /  /|\   ____\|\   __  \|\   ___  \|\   ____\
\ \  \|\  \ \  \|\  \ \  \        \ \  \/  / | \  \___|\ \  \|\  \ \  \\ \  \ \  \___|_
 \ \   ____\ \  \\\  \ \  \        \ \    / / \ \  \  __\ \  \\\  \ \  \\ \  \ \_____  \
  \ \  \___|\ \  \\\  \ \  \____    \/  /  /   \ \  \|\  \ \  \\\  \ \  \\ \  \|____|\  \
   \ \__\    \ \_______\ \_______\__/  / /      \ \_______\ \_______\ \__\\ \__\____\_\  \
    \|__|     \|_______|\|_______|\___/ /        \|_______|\|_______|\|__| \|__|\_________\
                                 \|___|/                                       \|_________|

 */

/*
	EXTERNAL DEPENDENCIES
 */
var PR = _reference2.default.getPolygon(null); // Polygon reference
var PPR = _reference2.default.getPolygonPattern(null);

/*
	INTERNAL POLYGONS FUNCTIONS
 */

var checkPolygonSym = _reference2.default.checkSymbolizer('polygon');
var checkPolPatternSym = _reference2.default.checkSymbolizer('polygon-pattern');

/**
 * Function for getting the color in rgba
 *
 * @param   {object} c3ss compiled carto css
 * @returns {object} with a function that contain the conditions to return a color with alpha channel
 */
var getColor = (0, _referenceHelpers.getColorFn)((0, _referenceHelpers.getPropertyOrDefFn)('fill', PR), (0, _referenceHelpers.getPropertyOrDefFn)('fill-opacity', PR));

var getTextureFile = (0, _referenceHelpers.getExecutedFn)('file', PPR);

var getTexture = (0, _ramda.compose)(_md2.default, getTextureFile);

var getBlending = (0, _referenceHelpers.getBlendFn)(PR);

/**
 * Basic Polygon
 */

var Polygon = {};

exports.default = Polygon;

/**
 * Function to get the draw object of a polygon.
 *
 * @param   {object} c3ss compiled carto css
 * @returns {function} function with the conditions to return alpha value
 */

Polygon.getDraw = function (c3ss, id) {
  var draw = {};

  if (checkPolygonSym(c3ss)) {
    draw['polygons_' + id] = {
      color: getColor(c3ss)
    };
  }

  return draw;
};

/**
 * Function to get the style configuration of a polygon.
 *
 * @returns default style configuration for polygon
 */
Polygon.getStyle = function (c3ss, id, ord) {
  var style = {};

  style['polygons_' + id] = {
    base: 'polygons',
    blend: getBlending(c3ss),
    blend_order: ord || 1
  };

  if (checkPolPatternSym(c3ss)) {
    style['polygons_' + id].material = {
      diffuse: {
        texture: getTexture(c3ss),
        mapping: 'uv'
      }
    };
  }

  return style;
};

Polygon.getTextures = function (c3ss) {
  var tex = {};
  if (checkPolPatternSym(c3ss)) {
    var texture = getTextureFile(c3ss);

    if (texture) {
      tex[(0, _md2.default)(texture)] = { url: texture };
    }
  }
  return tex;
};

},{"../utils/reference":430,"../utils/reference-helpers":429,"md5":103,"ramda":106}],424:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _referenceHelpers = _dereq_('../utils/reference-helpers');

var _reference = _dereq_('../utils/reference');

var _reference2 = _interopRequireDefault(_reference);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
   _________  _______      ___    ___ _________
  |\___   ___\\  ___ \    |\  \  /  /|\___   ___\
  \|___ \  \_\ \   __/|   \ \  \/  / ||___ \  \_|
      \ \  \ \ \  \_|/__  \ \    / /     \ \  \
        \ \  \ \ \  \_|\ \  /     \/       \ \  \
        \ \__\ \ \_______\/  /\   \         \ \__\
          \|__|  \|_______/__/ /\ __\        \|__|
                          |__|/ \|__|

 */

/*
  EXTERNAL DEPENDENCIES
*/

/*
  INTERNAL DEPENDENCIES
*/

var TR = _reference2.default.getText(null);

/*
  INTERNAL POLYGONS FUNCTIONS
*/

var checkTextSym = _reference2.default.checkSymbolizer('text');

var getTextName = (0, _referenceHelpers.getPropertyFnSafe)('name', TR);

var getSize = (0, _referenceHelpers.getPropertyFnSafe)('size', TR);

var getColor = (0, _referenceHelpers.getColorFn)((0, _referenceHelpers.getPropertyFnSafe)('fill', TR), (0, _referenceHelpers.getPropertyOrDefFn)('opacity', TR));

var TextPoint = {};

exports.default = TextPoint;


TextPoint.getDraw = function (c3ss, id) {
  var draw = {};

  if (checkTextSym(c3ss)) {
    draw['text_' + id] = {
      collide: false,
      color: 'transparent',
      text: {
        text_source: getTextName(c3ss),
        font: {
          size: getSize(c3ss),
          fill: getColor(c3ss)
        },
        optional: false
      }
    };
  }

  return draw;
};

TextPoint.getStyle = function (c3ss, id, ord) {
  var style = {};

  style['text_' + id] = {
    base: 'points',
    blend: 'overlay',
    blend_order: ord || 1
  };

  return style;
};

},{"../utils/reference":430,"../utils/reference-helpers":429}],425:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = _dereq_('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _carto = _dereq_('carto');

var _carto2 = _interopRequireDefault(_carto);

var _points = _dereq_('./basic/points');

var _points2 = _interopRequireDefault(_points);

var _polygons = _dereq_('./basic/polygons');

var _polygons2 = _interopRequireDefault(_polygons);

var _lines = _dereq_('./basic/lines');

var _lines2 = _interopRequireDefault(_lines);

var _text = _dereq_('./basic/text');

var _text2 = _interopRequireDefault(_text);

var _md = _dereq_('md5');

var _md2 = _interopRequireDefault(_md);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CartoCSSRenderer = new _carto2.default.RendererJS();

var extractFeatures = function extractFeatures(ccss, index) {
  var layers = CartoCSSRenderer.render(ccss).getLayers(),
      id = (0, _md2.default)(ccss),
      draw = {},
      styles = {},
      textures = {};

  // NOTE: this is wrong, we have to separate the layers.
  for (var i = 0; i < layers.length; i++) {
    var ly = layers[i].shader;

    (0, _assign2.default)(draw, _points2.default.getDraw(ly, id), _polygons2.default.getDraw(ly, id), _lines2.default.getDraw(ly, id), _text2.default.getDraw(ly, id));

    (0, _assign2.default)(textures, _points2.default.getTextures(ly), _polygons2.default.getTextures(ly));

    (0, _assign2.default)(styles, _points2.default.getStyle(ly, id, index), _polygons2.default.getStyle(ly, id, index), _lines2.default.getStyle(ly, id, index), _text2.default.getStyle(ly, id, index));
  }

  return { textures: textures, draw: draw, styles: styles };
};

var C2T;

exports.default = C2T = {
  extractFeatures: extractFeatures
};

},{"./basic/lines":421,"./basic/points":422,"./basic/polygons":423,"./basic/text":424,"babel-runtime/core-js/object/assign":3,"carto":7,"md5":103}],426:[function(_dereq_,module,exports){
'use strict';

var _carto = _dereq_('./carto');

var _carto2 = _interopRequireDefault(_carto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
  carto2Draw: _carto2.default.extractFeatures
};

},{"./carto":425}],427:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _utils = _dereq_('../utils/utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Colors = {};

exports.default = Colors;


var C = Colors;

Colors._isHex = _utils2.default.functionString('function isHex (c) {\n\t\treturn c.indexOf(\'#\') >= 0;\n\t}');

Colors._isRGB = _utils2.default.functionString('function (c) {\n\t\treturn c.indexOf(\'rgb\') >= 0;\n\t}');

Colors._isRGBA = _utils2.default.functionString('function (c) {\n\t\treturn c.indexOf(\'rgba\') >= 0;\n\t}');

Colors.toSixHex = _utils2.default.functionString('function (c) {\n\t\t\tif (c.length === 7) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar r = c[1],\n\t\t\t\t\tg = c[2],\n\t\t\t\t\tb = c[3];\n\n\t\t\t\treturn \'#\' + r + r + g + g + b + b;\n\t\t\t}\n\t\t}');

Colors.hexToInt = _utils2.default.functionString('function (hex) {\n\t\treturn parseInt(\'0x\' + hex);\n\t}');

Colors.toRGB = _utils2.default.functionString('function (c) {\n\t\tvar r = ' + C.hexToInt + '(c.substr(1, 2)) + \', \',\n\t\t\tg = ' + C.hexToInt + '(c.substr(3, 2)) + \', \',\n\t\t\tb = ' + C.hexToInt + '(c.substr(5, 2));\n\n\t\treturn \'rgb(\' + r + g + b + \')\';\n\t}');

Colors.toRGBA = _utils2.default.functionString('function (rgb, alpha) {\n\t\treturn rgb.replace(\'rgb\', \'rgba\').replace(\')\', \', \' + alpha + \')\');\n\t}');

Colors.getAlphaColorFn = _utils2.default.functionString('function (color, opacity) {\n\t\t// TODO: review this fallback to \'black\' color.\n\t\tcolor = color || \'#000\';\n    var toRGBA = ' + C.toRGBA + ';\n\t\tif ( ' + C._isRGBA + '(color) ) {\n\t\t\treturn color;\n\t\t}\n\t\telse {\n\t\t\tif ( ' + C._isHex + '(color) ) {\n\t\t\t\treturn toRGBA( ' + C.toRGB + '( ' + C.toSixHex + '(color) ), opacity );\n\t\t\t}\n\t\t\telse if ( ' + C._isRGB + '(color) ) {\n\t\t\t\treturn toRGBA(color);\n\t\t\t}\n\t\t}\n\t}');

Colors.getAlphaColor = function (color, opacity) {
	if (color && typeof opacity !== 'number') {
		return _utils2.default.functionString('function () {\n          var op = ' + opacity + '();\n          return ' + C.getAlphaColorFn + '(' + color + '(), typeof op === "number" ? op : 1);\n      }');
	}

	return color;
};

},{"../utils/utils":431}],428:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var Geom = {};

exports.default = Geom;


Geom.px2Meters = function (fn) {
  return ('function () {\n  \t\tvar val = (' + fn + '());\n  \t\treturn val * $meters_per_pixel;\n  \t}').replace(/(\t)/g, '');
};

},{}],429:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getColorFn = exports.getBlendFn = exports.getExecutedFn = exports.getEitherProp = exports.getPropertyOrDefFn = exports.getPropertyFnSafe = exports.getPropertyFn = exports.getPropOrDef = exports.getProp = exports.getDefProp = exports.generateDefaultFromRef = undefined;

var _ramda = _dereq_('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _utils = _dereq_('../utils/utils');

var _utils2 = _interopRequireDefault(_utils);

var _reference = _dereq_('../utils/reference');

var _reference2 = _interopRequireDefault(_reference);

var _colors = _dereq_('../style/colors');

var _colors2 = _interopRequireDefault(_colors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  INTERNAL REFERENCE FUNCTIONS
 */

var curryComp = _utils2.default.curryCompose3;

/*
  REFERENCE HELPER
 */

var generateDefaultFromRef = function generateDefaultFromRef(Ref, prop) {
  return { js: _utils2.default.generateDefault('"' + Ref[prop]['default-value'] + '"') };
};

var getDefProp = _ramda2.default.curry(function (prop, ref) {
  return generateDefaultFromRef(ref, prop);
});

// ref = 'stroke-opacity' -> get {stroke-opacity: {css: 'line-opacity'}} -> line-opacity;
// ref['line-opacity'];
var getProp = _ramda2.default.curry(function (prop, ref, c3ss) {
  return _utils2.default.pick(_utils2.default.pick(prop + '.css', ref), c3ss);
});

var getPropOrDef = _ramda2.default.either(getProp, getDefProp);

var getPropertyFn = curryComp(_ramda2.default.compose(_utils2.default.buildCCSSFn, _ramda2.default.prop('js'), // get property js from object
getProp));

var getPropertyFnSafe = _ramda2.default.ifElse(getProp, getPropertyFn, function () {
  return void 0;
});

var getPropertyOrDefFn = curryComp(_ramda2.default.compose(_utils2.default.buildCCSSFn, _ramda2.default.prop('js'), getPropOrDef));

var getEitherProp = function getEitherProp(propA, propB, ref) {
  return _ramda2.default.either(getPropertyFnSafe(propA, ref), getPropertyOrDefFn(propB, ref));
};

var getExecutedFn = curryComp(_ramda2.default.compose(_utils2.default.buildAndExecuteFn, _ramda2.default.prop('js'), getPropOrDef));

var getBlendFn = _ramda2.default.curry(function (ref, c3ss) {
  return _ramda2.default.compose(_ramda2.default.defaultTo('overlay'), _reference2.default.checkType(ref['comp-op']), getExecutedFn('comp-op'))(ref, c3ss);
});

var getColorFn = function getColorFn(fill, alpha) {
  return _ramda2.default.compose(_ramda2.default.apply(_colors2.default.getAlphaColor), _ramda2.default.values, _ramda2.default.applySpec({
    fill: fill,
    alpha: alpha
  }));
};

exports.generateDefaultFromRef = generateDefaultFromRef;
exports.getDefProp = getDefProp;
exports.getProp = getProp;
exports.getPropOrDef = getPropOrDef;
exports.getPropertyFn = getPropertyFn;
exports.getPropertyFnSafe = getPropertyFnSafe;
exports.getPropertyOrDefFn = getPropertyOrDefFn;
exports.getEitherProp = getEitherProp;
exports.getExecutedFn = getExecutedFn;
exports.getBlendFn = getBlendFn;
exports.getColorFn = getColorFn;

},{"../style/colors":427,"../utils/reference":430,"../utils/utils":431,"ramda":106}],430:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ramda = _dereq_('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _tangramReference = _dereq_('tangram-reference');

var _tangramReference2 = _interopRequireDefault(_tangramReference);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Ref = _tangramReference2.default.load('1.0.0');

var TangramReference = {};

exports.default = TangramReference;


var getProperty = _ramda2.default.curry(function (type, prop) {
	var obj = Ref.symbolizers[type];
	return prop ? obj[prop] : obj;
});

TangramReference.getPoint = getProperty('markers');

TangramReference.getLine = getProperty('line');

TangramReference.getPolygon = getProperty('polygon');

TangramReference.getText = getProperty('text');

TangramReference.getPolygonPattern = getProperty('polygon-pattern');

TangramReference.checkSymbolizer = _ramda2.default.curry(function (sym, c3ss) {
	return c3ss.symbolizers.indexOf(sym) !== -1 ? c3ss : null;
});

TangramReference.checkType = _ramda2.default.curry(function (ref, val) {
	return ref.type.indexOf(val) !== -1 ? val : null;
});

},{"ramda":106,"tangram-reference":416}],431:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
		value: true
});

var _toConsumableArray2 = _dereq_('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _ramda = _dereq_('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Utils = {};

exports.default = Utils;


var replace = _ramda2.default.curry(_ramda2.default.replace);

var geometries = {
		'1': '"point"',
		'2': '"line"',
		'3': '"polygon"'
};

Utils.curryCompose3 = function (compose) {
		return _ramda2.default.curry(function (a, b, c) {
				return compose(a, b, c);
		});
};

Utils.wrapCodeInFunction = function (innerCode) {
		var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [' '];

		attr = attr.join(',');

		return ('function (' + attr + ') {\n\t\t\t\tvar _value = null;\n\t\t\t\t' + innerCode + '\n\t\t\t\treturn _value;\n\t\t\t}').replace(/(\t)/g, '');
};

Utils.functionString = function (fn) {
		var args = fn.substring(fn.indexOf('(') + 1, fn.indexOf(')')).replace(/\s/g, '');

		args = args ? args.split(',') : [];

		var body = fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'));
		var func = new (Function.prototype.bind.apply(Function, [null].concat((0, _toConsumableArray3.default)(args), [body])))();

		func.toString = function () {
				return fn;
		};

		return func;
};

Utils.transpile2Tangram = _ramda2.default.compose(replace(/ctx.zoom/g, '$zoom'), replace(/data\[/g, 'feature['), replace(/data\['mapnik::geometry_type'\] === (\d)/g, function ($0, $1) {
		return '$geometry === ' + geometries[$1];
}));

Utils.buildCCSSFn = function (js, attr) {
		var fn = '';

		for (var i = 0; i < js.length; i++) {
				fn += Utils.transpile2Tangram(js[i]);
		}

		return Utils.functionString(Utils.wrapCodeInFunction(fn, attr));
};

Utils.buildAndExecuteFn = function (js) {
		return Utils.buildCCSSFn(js, ['$zoom'])(10);
};

Utils.generateDefault = function (val) {
		return 'return ' + val + ';';
};

Utils.pick = _ramda2.default.curry(function (path, obj) {
		return _ramda2.default.reduce(function (accumulator, key) {
				return accumulator[key];
		}, obj, _ramda2.default.split('.', path));
});

},{"babel-runtime/helpers/toConsumableArray":4,"ramda":106}]},{},[426])(426)
});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(_dereq_,module,exports){
module.exports = { "default": _dereq_("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":4}],3:[function(_dereq_,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],4:[function(_dereq_,module,exports){
_dereq_('../../modules/es6.object.assign');
module.exports = _dereq_('../../modules/_core').Object.assign;
},{"../../modules/_core":9,"../../modules/es6.object.assign":39}],5:[function(_dereq_,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],6:[function(_dereq_,module,exports){
var isObject = _dereq_('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":22}],7:[function(_dereq_,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = _dereq_('./_to-iobject')
  , toLength  = _dereq_('./_to-length')
  , toIndex   = _dereq_('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":32,"./_to-iobject":34,"./_to-length":35}],8:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],9:[function(_dereq_,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],10:[function(_dereq_,module,exports){
// optional / simple context binding
var aFunction = _dereq_('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":5}],11:[function(_dereq_,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],12:[function(_dereq_,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !_dereq_('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":16}],13:[function(_dereq_,module,exports){
var isObject = _dereq_('./_is-object')
  , document = _dereq_('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":17,"./_is-object":22}],14:[function(_dereq_,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],15:[function(_dereq_,module,exports){
var global    = _dereq_('./_global')
  , core      = _dereq_('./_core')
  , ctx       = _dereq_('./_ctx')
  , hide      = _dereq_('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":9,"./_ctx":10,"./_global":17,"./_hide":19}],16:[function(_dereq_,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],17:[function(_dereq_,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],18:[function(_dereq_,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],19:[function(_dereq_,module,exports){
var dP         = _dereq_('./_object-dp')
  , createDesc = _dereq_('./_property-desc');
module.exports = _dereq_('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":12,"./_object-dp":24,"./_property-desc":29}],20:[function(_dereq_,module,exports){
module.exports = !_dereq_('./_descriptors') && !_dereq_('./_fails')(function(){
  return Object.defineProperty(_dereq_('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":12,"./_dom-create":13,"./_fails":16}],21:[function(_dereq_,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _dereq_('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":8}],22:[function(_dereq_,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],23:[function(_dereq_,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = _dereq_('./_object-keys')
  , gOPS     = _dereq_('./_object-gops')
  , pIE      = _dereq_('./_object-pie')
  , toObject = _dereq_('./_to-object')
  , IObject  = _dereq_('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || _dereq_('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":16,"./_iobject":21,"./_object-gops":25,"./_object-keys":27,"./_object-pie":28,"./_to-object":36}],24:[function(_dereq_,module,exports){
var anObject       = _dereq_('./_an-object')
  , IE8_DOM_DEFINE = _dereq_('./_ie8-dom-define')
  , toPrimitive    = _dereq_('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = _dereq_('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":6,"./_descriptors":12,"./_ie8-dom-define":20,"./_to-primitive":37}],25:[function(_dereq_,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],26:[function(_dereq_,module,exports){
var has          = _dereq_('./_has')
  , toIObject    = _dereq_('./_to-iobject')
  , arrayIndexOf = _dereq_('./_array-includes')(false)
  , IE_PROTO     = _dereq_('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":7,"./_has":18,"./_shared-key":30,"./_to-iobject":34}],27:[function(_dereq_,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = _dereq_('./_object-keys-internal')
  , enumBugKeys = _dereq_('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":14,"./_object-keys-internal":26}],28:[function(_dereq_,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],29:[function(_dereq_,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],30:[function(_dereq_,module,exports){
var shared = _dereq_('./_shared')('keys')
  , uid    = _dereq_('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":31,"./_uid":38}],31:[function(_dereq_,module,exports){
var global = _dereq_('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":17}],32:[function(_dereq_,module,exports){
var toInteger = _dereq_('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":33}],33:[function(_dereq_,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],34:[function(_dereq_,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _dereq_('./_iobject')
  , defined = _dereq_('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":11,"./_iobject":21}],35:[function(_dereq_,module,exports){
// 7.1.15 ToLength
var toInteger = _dereq_('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":33}],36:[function(_dereq_,module,exports){
// 7.1.13 ToObject(argument)
var defined = _dereq_('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":11}],37:[function(_dereq_,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = _dereq_('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":22}],38:[function(_dereq_,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],39:[function(_dereq_,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = _dereq_('./_export');

$export($export.S + $export.F, 'Object', {assign: _dereq_('./_object-assign')});
},{"./_export":15,"./_object-assign":23}],40:[function(_dereq_,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],41:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],42:[function(_dereq_,module,exports){
(function(){
  var crypt = _dereq_('crypt'),
      utf8 = _dereq_('charenc').utf8,
      isBuffer = _dereq_('is-buffer'),
      bin = _dereq_('charenc').bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

},{"charenc":3,"crypt":40,"is-buffer":41}],43:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var Dumper, Inline, Utils;

Utils = _dereq_('./Utils');

Inline = _dereq_('./Inline');

Dumper = (function() {
  function Dumper() {}

  Dumper.indentation = 4;

  Dumper.prototype.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var i, key, len, output, prefix, value, willBeInlined;
    if (inline == null) {
      inline = 0;
    }
    if (indent == null) {
      indent = 0;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    output = '';
    prefix = (indent ? Utils.strRepeat(' ', indent) : '');
    if (inline <= 0 || typeof input !== 'object' || input instanceof Date || Utils.isEmpty(input)) {
      output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
    } else {
      if (input instanceof Array) {
        for (i = 0, len = input.length; i < len; i++) {
          value = input[i];
          willBeInlined = inline - 1 <= 0 || typeof value !== 'object' || Utils.isEmpty(value);
          output += prefix + '-' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, (willBeInlined ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      } else {
        for (key in input) {
          value = input[key];
          willBeInlined = inline - 1 <= 0 || typeof value !== 'object' || Utils.isEmpty(value);
          output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ':' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, (willBeInlined ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      }
    }
    return output;
  };

  return Dumper;

})();

module.exports = Dumper;

},{"./Inline":47,"./Utils":51}],44:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var Escaper, Pattern;

Pattern = _dereq_('./Pattern');

Escaper = (function() {
  var ch;

  function Escaper() {}

  Escaper.LIST_ESCAPEES = ['\\', '\\\\', '\\"', '"', "\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", "\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", (ch = String.fromCharCode)(0x0085), ch(0x00A0), ch(0x2028), ch(0x2029)];

  Escaper.LIST_ESCAPED = ['\\\\', '\\"', '\\"', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];

  Escaper.MAPPING_ESCAPEES_TO_ESCAPED = (function() {
    var i, j, mapping, ref;
    mapping = {};
    for (i = j = 0, ref = Escaper.LIST_ESCAPEES.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      mapping[Escaper.LIST_ESCAPEES[i]] = Escaper.LIST_ESCAPED[i];
    }
    return mapping;
  })();

  Escaper.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern('[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9');

  Escaper.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper.LIST_ESCAPEES.join('|').split('\\').join('\\\\'));

  Escaper.PATTERN_SINGLE_QUOTING = new Pattern('[\\s\'":{}[\\],&*#?]|^[-?|<>=!%@`]');

  Escaper.requiresDoubleQuoting = function(value) {
    return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
  };

  Escaper.escapeWithDoubleQuotes = function(value) {
    var result;
    result = this.PATTERN_MAPPING_ESCAPEES.replace(value, (function(_this) {
      return function(str) {
        return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
      };
    })(this));
    return '"' + result + '"';
  };

  Escaper.requiresSingleQuoting = function(value) {
    return this.PATTERN_SINGLE_QUOTING.test(value);
  };

  Escaper.escapeWithSingleQuotes = function(value) {
    return "'" + value.replace(/'/g, "''") + "'";
  };

  return Escaper;

})();

module.exports = Escaper;

},{"./Pattern":49}],45:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var DumpException,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DumpException = (function(superClass) {
  extend(DumpException, superClass);

  function DumpException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  DumpException.prototype.toString = function() {
    if ((this.parsedLine != null) && (this.snippet != null)) {
      return '<DumpException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<DumpException> ' + this.message;
    }
  };

  return DumpException;

})(Error);

module.exports = DumpException;

},{}],46:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var ParseException,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ParseException = (function(superClass) {
  extend(ParseException, superClass);

  function ParseException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  ParseException.prototype.toString = function() {
    if ((this.parsedLine != null) && (this.snippet != null)) {
      return '<ParseException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<ParseException> ' + this.message;
    }
  };

  return ParseException;

})(Error);

module.exports = ParseException;

},{}],47:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var DumpException, Escaper, Inline, ParseException, Pattern, Unescaper, Utils,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Pattern = _dereq_('./Pattern');

Unescaper = _dereq_('./Unescaper');

Escaper = _dereq_('./Escaper');

Utils = _dereq_('./Utils');

ParseException = _dereq_('./Exception/ParseException');

DumpException = _dereq_('./Exception/DumpException');

Inline = (function() {
  function Inline() {}

  Inline.REGEX_QUOTED_STRING = '(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'(?:[^\']*(?:\'\'[^\']*)*)\')';

  Inline.PATTERN_TRAILING_COMMENTS = new Pattern('^\\s*#.*$');

  Inline.PATTERN_QUOTED_SCALAR = new Pattern('^' + Inline.REGEX_QUOTED_STRING);

  Inline.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern('^(-|\\+)?[0-9,]+(\\.[0-9]+)?$');

  Inline.PATTERN_SCALAR_BY_DELIMITERS = {};

  Inline.settings = {};

  Inline.configure = function(exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = null;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;
  };

  Inline.parse = function(value, exceptionOnInvalidType, objectDecoder) {
    var context, result;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;
    if (value == null) {
      return '';
    }
    value = Utils.trim(value);
    if (0 === value.length) {
      return '';
    }
    context = {
      exceptionOnInvalidType: exceptionOnInvalidType,
      objectDecoder: objectDecoder,
      i: 0
    };
    switch (value.charAt(0)) {
      case '[':
        result = this.parseSequence(value, context);
        ++context.i;
        break;
      case '{':
        result = this.parseMapping(value, context);
        ++context.i;
        break;
      default:
        result = this.parseScalar(value, null, ['"', "'"], context);
    }
    if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), '') !== '') {
      throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
    }
    return result;
  };

  Inline.dump = function(value, exceptionOnInvalidType, objectEncoder) {
    var ref, result, type;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    if (value == null) {
      return 'null';
    }
    type = typeof value;
    if (type === 'object') {
      if (value instanceof Date) {
        return value.toISOString();
      } else if (objectEncoder != null) {
        result = objectEncoder(value);
        if (typeof result === 'string' || (result != null)) {
          return result;
        }
      }
      return this.dumpObject(value);
    }
    if (type === 'boolean') {
      return (value ? 'true' : 'false');
    }
    if (Utils.isDigits(value)) {
      return (type === 'string' ? "'" + value + "'" : String(parseInt(value)));
    }
    if (Utils.isNumeric(value)) {
      return (type === 'string' ? "'" + value + "'" : String(parseFloat(value)));
    }
    if (type === 'number') {
      return (value === Infinity ? '.Inf' : (value === -Infinity ? '-.Inf' : (isNaN(value) ? '.NaN' : value)));
    }
    if (Escaper.requiresDoubleQuoting(value)) {
      return Escaper.escapeWithDoubleQuotes(value);
    }
    if (Escaper.requiresSingleQuoting(value)) {
      return Escaper.escapeWithSingleQuotes(value);
    }
    if ('' === value) {
      return '""';
    }
    if (Utils.PATTERN_DATE.test(value)) {
      return "'" + value + "'";
    }
    if ((ref = value.toLowerCase()) === 'null' || ref === '~' || ref === 'true' || ref === 'false') {
      return "'" + value + "'";
    }
    return value;
  };

  Inline.dumpObject = function(value, exceptionOnInvalidType, objectSupport) {
    var j, key, len1, output, val;
    if (objectSupport == null) {
      objectSupport = null;
    }
    if (value instanceof Array) {
      output = [];
      for (j = 0, len1 = value.length; j < len1; j++) {
        val = value[j];
        output.push(this.dump(val));
      }
      return '[' + output.join(', ') + ']';
    } else {
      output = [];
      for (key in value) {
        val = value[key];
        output.push(this.dump(key) + ': ' + this.dump(val));
      }
      return '{' + output.join(', ') + '}';
    }
  };

  Inline.parseScalar = function(scalar, delimiters, stringDelimiters, context, evaluate) {
    var i, joinedDelimiters, match, output, pattern, ref, ref1, strpos, tmp;
    if (delimiters == null) {
      delimiters = null;
    }
    if (stringDelimiters == null) {
      stringDelimiters = ['"', "'"];
    }
    if (context == null) {
      context = null;
    }
    if (evaluate == null) {
      evaluate = true;
    }
    if (context == null) {
      context = {
        exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
        objectDecoder: this.settings.objectDecoder,
        i: 0
      };
    }
    i = context.i;
    if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) >= 0) {
      output = this.parseQuotedScalar(scalar, context);
      i = context.i;
      if (delimiters != null) {
        tmp = Utils.ltrim(scalar.slice(i), ' ');
        if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) >= 0)) {
          throw new ParseException('Unexpected characters (' + scalar.slice(i) + ').');
        }
      }
    } else {
      if (!delimiters) {
        output = scalar.slice(i);
        i += output.length;
        strpos = output.indexOf(' #');
        if (strpos !== -1) {
          output = Utils.rtrim(output.slice(0, strpos));
        }
      } else {
        joinedDelimiters = delimiters.join('|');
        pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
        if (pattern == null) {
          pattern = new Pattern('^(.+?)(' + joinedDelimiters + ')');
          this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
        }
        if (match = pattern.exec(scalar.slice(i))) {
          output = match[1];
          i += output.length;
        } else {
          throw new ParseException('Malformed inline YAML string (' + scalar + ').');
        }
      }
      if (evaluate) {
        output = this.evaluateScalar(output, context);
      }
    }
    context.i = i;
    return output;
  };

  Inline.parseQuotedScalar = function(scalar, context) {
    var i, match, output;
    i = context.i;
    if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
      throw new ParseException('Malformed inline YAML string (' + scalar.slice(i) + ').');
    }
    output = match[0].substr(1, match[0].length - 2);
    if ('"' === scalar.charAt(i)) {
      output = Unescaper.unescapeDoubleQuotedString(output);
    } else {
      output = Unescaper.unescapeSingleQuotedString(output);
    }
    i += match[0].length;
    context.i = i;
    return output;
  };

  Inline.parseSequence = function(sequence, context) {
    var e, error, i, isQuoted, len, output, ref, value;
    output = [];
    len = sequence.length;
    i = context.i;
    i += 1;
    while (i < len) {
      context.i = i;
      switch (sequence.charAt(i)) {
        case '[':
          output.push(this.parseSequence(sequence, context));
          i = context.i;
          break;
        case '{':
          output.push(this.parseMapping(sequence, context));
          i = context.i;
          break;
        case ']':
          return output;
        case ',':
        case ' ':
        case "\n":
          break;
        default:
          isQuoted = ((ref = sequence.charAt(i)) === '"' || ref === "'");
          value = this.parseScalar(sequence, [',', ']'], ['"', "'"], context);
          i = context.i;
          if (!isQuoted && typeof value === 'string' && (value.indexOf(': ') !== -1 || value.indexOf(":\n") !== -1)) {
            try {
              value = this.parseMapping('{' + value + '}');
            } catch (error) {
              e = error;
            }
          }
          output.push(value);
          --i;
      }
      ++i;
    }
    throw new ParseException('Malformed inline YAML string ' + sequence);
  };

  Inline.parseMapping = function(mapping, context) {
    var done, i, key, len, output, shouldContinueWhileLoop, value;
    output = {};
    len = mapping.length;
    i = context.i;
    i += 1;
    shouldContinueWhileLoop = false;
    while (i < len) {
      context.i = i;
      switch (mapping.charAt(i)) {
        case ' ':
        case ',':
        case "\n":
          ++i;
          context.i = i;
          shouldContinueWhileLoop = true;
          break;
        case '}':
          return output;
      }
      if (shouldContinueWhileLoop) {
        shouldContinueWhileLoop = false;
        continue;
      }
      key = this.parseScalar(mapping, [':', ' ', "\n"], ['"', "'"], context, false);
      i = context.i;
      done = false;
      while (i < len) {
        context.i = i;
        switch (mapping.charAt(i)) {
          case '[':
            value = this.parseSequence(mapping, context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            break;
          case '{':
            value = this.parseMapping(mapping, context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            break;
          case ':':
          case ' ':
          case "\n":
            break;
          default:
            value = this.parseScalar(mapping, [',', '}'], ['"', "'"], context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            --i;
        }
        ++i;
        if (done) {
          break;
        }
      }
    }
    throw new ParseException('Malformed inline YAML string ' + mapping);
  };

  Inline.evaluateScalar = function(scalar, context) {
    var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
    scalar = Utils.trim(scalar);
    scalarLower = scalar.toLowerCase();
    switch (scalarLower) {
      case 'null':
      case '':
      case '~':
        return null;
      case 'true':
        return true;
      case 'false':
        return false;
      case '.inf':
        return Infinity;
      case '.nan':
        return NaN;
      case '-.inf':
        return Infinity;
      default:
        firstChar = scalarLower.charAt(0);
        switch (firstChar) {
          case '!':
            firstSpace = scalar.indexOf(' ');
            if (firstSpace === -1) {
              firstWord = scalarLower;
            } else {
              firstWord = scalarLower.slice(0, firstSpace);
            }
            switch (firstWord) {
              case '!':
                if (firstSpace !== -1) {
                  return parseInt(this.parseScalar(scalar.slice(2)));
                }
                return null;
              case '!str':
                return Utils.ltrim(scalar.slice(4));
              case '!!str':
                return Utils.ltrim(scalar.slice(5));
              case '!!int':
                return parseInt(this.parseScalar(scalar.slice(5)));
              case '!!bool':
                return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
              case '!!float':
                return parseFloat(this.parseScalar(scalar.slice(7)));
              case '!!timestamp':
                return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
              default:
                if (context == null) {
                  context = {
                    exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                    objectDecoder: this.settings.objectDecoder,
                    i: 0
                  };
                }
                objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
                if (objectDecoder) {
                  trimmedScalar = Utils.rtrim(scalar);
                  firstSpace = trimmedScalar.indexOf(' ');
                  if (firstSpace === -1) {
                    return objectDecoder(trimmedScalar, null);
                  } else {
                    subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));
                    if (!(subValue.length > 0)) {
                      subValue = null;
                    }
                    return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                  }
                }
                if (exceptionOnInvalidType) {
                  throw new ParseException('Custom object support when parsing a YAML file has been disabled.');
                }
                return null;
            }
            break;
          case '0':
            if ('0x' === scalar.slice(0, 2)) {
              return Utils.hexDec(scalar);
            } else if (Utils.isDigits(scalar)) {
              return Utils.octDec(scalar);
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else {
              return scalar;
            }
            break;
          case '+':
            if (Utils.isDigits(scalar)) {
              raw = scalar;
              cast = parseInt(raw);
              if (raw === String(cast)) {
                return cast;
              } else {
                return raw;
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
          case '-':
            if (Utils.isDigits(scalar.slice(1))) {
              if ('0' === scalar.charAt(1)) {
                return -Utils.octDec(scalar.slice(1));
              } else {
                raw = scalar.slice(1);
                cast = parseInt(raw);
                if (raw === String(cast)) {
                  return -cast;
                } else {
                  return -raw;
                }
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
          default:
            if (date = Utils.stringToDate(scalar)) {
              return date;
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
        }
    }
  };

  return Inline;

})();

module.exports = Inline;

},{"./Escaper":44,"./Exception/DumpException":45,"./Exception/ParseException":46,"./Pattern":49,"./Unescaper":50,"./Utils":51}],48:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var Inline, ParseException, Parser, Pattern, Utils;

Inline = _dereq_('./Inline');

Pattern = _dereq_('./Pattern');

Utils = _dereq_('./Utils');

ParseException = _dereq_('./Exception/ParseException');

Parser = (function() {
  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');

  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');

  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');

  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\d+');

  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');

  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\n*)$');

  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\%YAML[: ][\\d\\.]+.*\n');

  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\#.*?\n)+');

  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\-\\-\\-.*?\n');

  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\.\\.\\.\\s*$');

  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};

  Parser.prototype.CONTEXT_NONE = 0;

  Parser.prototype.CONTEXT_SEQUENCE = 1;

  Parser.prototype.CONTEXT_MAPPING = 2;

  function Parser(offset) {
    this.offset = offset != null ? offset : 0;
    this.lines = [];
    this.currentLineNb = -1;
    this.currentLine = '';
    this.refs = {};
  }

  Parser.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {
    var alias, allowOverwrite, block, c, context, data, e, error, error1, error2, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.currentLineNb = -1;
    this.currentLine = '';
    this.lines = this.cleanup(value).split("\n");
    data = null;
    context = this.CONTEXT_NONE;
    allowOverwrite = false;
    while (this.moveToNextLine()) {
      if (this.isCurrentLineEmpty()) {
        continue;
      }
      if ("\t" === this.currentLine[0]) {
        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
      isRef = mergeNode = false;
      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
        if (this.CONTEXT_MAPPING === context) {
          throw new ParseException('You cannot define a sequence item when in a mapping');
        }
        context = this.CONTEXT_SEQUENCE;
        if (data == null) {
          data = [];
        }
        if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }
        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(null);
          }
        } else {
          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
            c = this.getRealCurrentLineNb();
            parser = new Parser(c);
            parser.refs = this.refs;
            block = values.value;
            indent = this.getCurrentLineIndentation();
            if (this.isNextLineIndented(false)) {
              block += "\n" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
            }
            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
          }
        }
      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {
        if (this.CONTEXT_SEQUENCE === context) {
          throw new ParseException('You cannot define a mapping item when in a sequence');
        }
        context = this.CONTEXT_MAPPING;
        if (data == null) {
          data = {};
        }
        Inline.configure(exceptionOnInvalidType, objectDecoder);
        try {
          key = Inline.parseScalar(values.key);
        } catch (error) {
          e = error;
          e.parsedLine = this.getRealCurrentLineNb() + 1;
          e.snippet = this.currentLine;
          throw e;
        }
        if ('<<' === key) {
          mergeNode = true;
          allowOverwrite = true;
          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {
            refName = values.value.slice(1);
            if (this.refs[refName] == null) {
              throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            refValue = this.refs[refName];
            if (typeof refValue !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            if (refValue instanceof Array) {
              for (i = j = 0, len = refValue.length; j < len; i = ++j) {
                value = refValue[i];
                if (data[name = String(i)] == null) {
                  data[name] = value;
                }
              }
            } else {
              for (key in refValue) {
                value = refValue[key];
                if (data[key] == null) {
                  data[key] = value;
                }
              }
            }
          } else {
            if ((values.value != null) && values.value !== '') {
              value = values.value;
            } else {
              value = this.getNextEmbedBlock();
            }
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            parsed = parser.parse(value, exceptionOnInvalidType);
            if (typeof parsed !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            if (parsed instanceof Array) {
              for (l = 0, len1 = parsed.length; l < len1; l++) {
                parsedItem = parsed[l];
                if (typeof parsedItem !== 'object') {
                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);
                }
                if (parsedItem instanceof Array) {
                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {
                    value = parsedItem[i];
                    k = String(i);
                    if (!data.hasOwnProperty(k)) {
                      data[k] = value;
                    }
                  }
                } else {
                  for (key in parsedItem) {
                    value = parsedItem[key];
                    if (!data.hasOwnProperty(key)) {
                      data[key] = value;
                    }
                  }
                }
              }
            } else {
              for (key in parsed) {
                value = parsed[key];
                if (!data.hasOwnProperty(key)) {
                  data[key] = value;
                }
              }
            }
          }
        } else if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }
        if (mergeNode) {

        } else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (!(this.isNextLineIndented()) && !(this.isNextLineUnIndentedCollection())) {
            if (allowOverwrite || data[key] === void 0) {
              data[key] = null;
            }
          } else {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);
            if (allowOverwrite || data[key] === void 0) {
              data[key] = val;
            }
          }
        } else {
          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);
          if (allowOverwrite || data[key] === void 0) {
            data[key] = val;
          }
        }
      } else {
        lineCount = this.lines.length;
        if (1 === lineCount || (2 === lineCount && Utils.isEmpty(this.lines[1]))) {
          try {
            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
          } catch (error1) {
            e = error1;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
          if (typeof value === 'object') {
            if (value instanceof Array) {
              first = value[0];
            } else {
              for (key in value) {
                first = value[key];
                break;
              }
            }
            if (typeof first === 'string' && first.indexOf('*') === 0) {
              data = [];
              for (n = 0, len3 = value.length; n < len3; n++) {
                alias = value[n];
                data.push(this.refs[alias.slice(1)]);
              }
              value = data;
            }
          }
          return value;
        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {
          try {
            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
          } catch (error2) {
            e = error2;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
        }
        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
      if (isRef) {
        if (data instanceof Array) {
          this.refs[isRef] = data[data.length - 1];
        } else {
          lastKey = null;
          for (key in data) {
            lastKey = key;
          }
          this.refs[isRef] = data[lastKey];
        }
      }
    }
    if (Utils.isEmpty(data)) {
      return null;
    } else {
      return data;
    }
  };

  Parser.prototype.getRealCurrentLineNb = function() {
    return this.currentLineNb + this.offset;
  };

  Parser.prototype.getCurrentLineIndentation = function() {
    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;
  };

  Parser.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {
    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
    if (indentation == null) {
      indentation = null;
    }
    if (includeUnindentedCollection == null) {
      includeUnindentedCollection = false;
    }
    this.moveToNextLine();
    if (indentation == null) {
      newIndent = this.getCurrentLineIndentation();
      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
      if (!(this.isCurrentLineEmpty()) && 0 === newIndent && !unindentedEmbedBlock) {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    } else {
      newIndent = indentation;
    }
    data = [this.currentLine.slice(newIndent)];
    if (!includeUnindentedCollection) {
      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
    }
    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
    removeComments = !removeCommentsPattern.test(this.currentLine);
    while (this.moveToNextLine()) {
      indent = this.getCurrentLineIndentation();
      if (indent === newIndent) {
        removeComments = !removeCommentsPattern.test(this.currentLine);
      }
      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {
        this.moveToPreviousLine();
        break;
      }
      if (this.isCurrentLineBlank()) {
        data.push(this.currentLine.slice(newIndent));
        continue;
      }
      if (removeComments && this.isCurrentLineComment()) {
        if (indent === newIndent) {
          continue;
        }
      }
      if (indent >= newIndent) {
        data.push(this.currentLine.slice(newIndent));
      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {

      } else if (0 === indent) {
        this.moveToPreviousLine();
        break;
      } else {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    }
    return data.join("\n");
  };

  Parser.prototype.moveToNextLine = function() {
    if (this.currentLineNb >= this.lines.length - 1) {
      return false;
    }
    this.currentLine = this.lines[++this.currentLineNb];
    return true;
  };

  Parser.prototype.moveToPreviousLine = function() {
    this.currentLine = this.lines[--this.currentLineNb];
  };

  Parser.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {
    var e, error, error1, foldedIndent, matches, modifiers, pos, ref, ref1, val;
    if (0 === value.indexOf('*')) {
      pos = value.indexOf('#');
      if (pos !== -1) {
        value = value.substr(1, pos - 2);
      } else {
        value = value.slice(1);
      }
      if (this.refs[value] === void 0) {
        throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
      }
      return this.refs[value];
    }
    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
      modifiers = (ref = matches.modifiers) != null ? ref : '';
      foldedIndent = Math.abs(parseInt(modifiers));
      if (isNaN(foldedIndent)) {
        foldedIndent = 0;
      }
      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);
      if (matches.type != null) {
        Inline.configure(exceptionOnInvalidType, objectDecoder);
        return Inline.parseScalar(matches.type + ' ' + val);
      } else {
        return val;
      }
    }
    try {
      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
    } catch (error) {
      e = error;
      if (((ref1 = value.charAt(0)) === '[' || ref1 === '{') && e instanceof ParseException && this.isNextLineIndented()) {
        value += "\n" + this.getNextEmbedBlock();
        try {
          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
        } catch (error1) {
          e = error1;
          e.parsedLine = this.getRealCurrentLineNb() + 1;
          e.snippet = this.currentLine;
          throw e;
        }
      } else {
        e.parsedLine = this.getRealCurrentLineNb() + 1;
        e.snippet = this.currentLine;
        throw e;
      }
    }
  };

  Parser.prototype.parseFoldedScalar = function(separator, indicator, indentation) {
    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;
    if (indicator == null) {
      indicator = '';
    }
    if (indentation == null) {
      indentation = 0;
    }
    notEOF = this.moveToNextLine();
    if (!notEOF) {
      return '';
    }
    isCurrentLineBlank = this.isCurrentLineBlank();
    text = '';
    while (notEOF && isCurrentLineBlank) {
      if (notEOF = this.moveToNextLine()) {
        text += "\n";
        isCurrentLineBlank = this.isCurrentLineBlank();
      }
    }
    if (0 === indentation) {
      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
        indentation = matches[0].length;
      }
    }
    if (indentation > 0) {
      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
      if (pattern == null) {
        pattern = new Pattern('^ {' + indentation + '}(.*)$');
        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
      }
      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
        if (isCurrentLineBlank) {
          text += this.currentLine.slice(indentation);
        } else {
          text += matches[1];
        }
        if (notEOF = this.moveToNextLine()) {
          text += "\n";
          isCurrentLineBlank = this.isCurrentLineBlank();
        }
      }
    } else if (notEOF) {
      text += "\n";
    }
    if (notEOF) {
      this.moveToPreviousLine();
    }
    if ('>' === separator) {
      newText = '';
      ref = text.split("\n");
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        if (line.length === 0 || line.charAt(0) === ' ') {
          newText = Utils.rtrim(newText, ' ') + line + "\n";
        } else {
          newText += line + ' ';
        }
      }
      text = newText;
    }
    if ('+' !== indicator) {
      text = Utils.rtrim(text);
    }
    if ('' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
    } else if ('-' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, '');
    }
    return text;
  };

  Parser.prototype.isNextLineIndented = function(ignoreComments) {
    var EOF, currentIndentation, ret;
    if (ignoreComments == null) {
      ignoreComments = true;
    }
    currentIndentation = this.getCurrentLineIndentation();
    EOF = !this.moveToNextLine();
    if (ignoreComments) {
      while (!EOF && this.isCurrentLineEmpty()) {
        EOF = !this.moveToNextLine();
      }
    } else {
      while (!EOF && this.isCurrentLineBlank()) {
        EOF = !this.moveToNextLine();
      }
    }
    if (EOF) {
      return false;
    }
    ret = false;
    if (this.getCurrentLineIndentation() > currentIndentation) {
      ret = true;
    }
    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isCurrentLineEmpty = function() {
    var trimmedLine;
    trimmedLine = Utils.trim(this.currentLine, ' ');
    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';
  };

  Parser.prototype.isCurrentLineBlank = function() {
    return '' === Utils.trim(this.currentLine, ' ');
  };

  Parser.prototype.isCurrentLineComment = function() {
    var ltrimmedLine;
    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');
    return ltrimmedLine.charAt(0) === '#';
  };

  Parser.prototype.cleanup = function(value) {
    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
    if (value.indexOf("\r") !== -1) {
      value = value.split("\r\n").join("\n").split("\r").join("\n");
    }
    count = 0;
    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];
    this.offset += count;
    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];
    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
    }
    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];
    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');
    }
    lines = value.split("\n");
    smallestIndent = -1;
    for (j = 0, len = lines.length; j < len; j++) {
      line = lines[j];
      if (Utils.trim(line, ' ').length === 0) {
        continue;
      }
      indent = line.length - Utils.ltrim(line).length;
      if (smallestIndent === -1 || indent < smallestIndent) {
        smallestIndent = indent;
      }
    }
    if (smallestIndent > 0) {
      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {
        line = lines[i];
        lines[i] = line.slice(smallestIndent);
      }
      value = lines.join("\n");
    }
    return value;
  };

  Parser.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {
    var notEOF, ret;
    if (currentIndentation == null) {
      currentIndentation = null;
    }
    if (currentIndentation == null) {
      currentIndentation = this.getCurrentLineIndentation();
    }
    notEOF = this.moveToNextLine();
    while (notEOF && this.isCurrentLineEmpty()) {
      notEOF = this.moveToNextLine();
    }
    if (false === notEOF) {
      return false;
    }
    ret = false;
    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
      ret = true;
    }
    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isStringUnIndentedCollectionItem = function() {
    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';
  };

  return Parser;

})();

module.exports = Parser;

},{"./Exception/ParseException":46,"./Inline":47,"./Pattern":49,"./Utils":51}],49:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var Pattern;

Pattern = (function() {
  Pattern.prototype.regex = null;

  Pattern.prototype.rawRegex = null;

  Pattern.prototype.cleanedRegex = null;

  Pattern.prototype.mapping = null;

  function Pattern(rawRegex, modifiers) {
    var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
    if (modifiers == null) {
      modifiers = '';
    }
    cleanedRegex = '';
    len = rawRegex.length;
    mapping = null;
    capturingBracketNumber = 0;
    i = 0;
    while (i < len) {
      _char = rawRegex.charAt(i);
      if (_char === '\\') {
        cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
        i++;
      } else if (_char === '(') {
        if (i < len - 2) {
          part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
          if (part === '(?:') {
            i += 2;
            cleanedRegex += part;
          } else if (part === '(?<') {
            capturingBracketNumber++;
            i += 2;
            name = '';
            while (i + 1 < len) {
              subChar = rawRegex.charAt(i + 1);
              if (subChar === '>') {
                cleanedRegex += '(';
                i++;
                if (name.length > 0) {
                  if (mapping == null) {
                    mapping = {};
                  }
                  mapping[name] = capturingBracketNumber;
                }
                break;
              } else {
                name += subChar;
              }
              i++;
            }
          } else {
            cleanedRegex += _char;
            capturingBracketNumber++;
          }
        } else {
          cleanedRegex += _char;
        }
      } else {
        cleanedRegex += _char;
      }
      i++;
    }
    this.rawRegex = rawRegex;
    this.cleanedRegex = cleanedRegex;
    this.regex = new RegExp(this.cleanedRegex, 'g' + modifiers.replace('g', ''));
    this.mapping = mapping;
  }

  Pattern.prototype.exec = function(str) {
    var index, matches, name, ref;
    this.regex.lastIndex = 0;
    matches = this.regex.exec(str);
    if (matches == null) {
      return null;
    }
    if (this.mapping != null) {
      ref = this.mapping;
      for (name in ref) {
        index = ref[name];
        matches[name] = matches[index];
      }
    }
    return matches;
  };

  Pattern.prototype.test = function(str) {
    this.regex.lastIndex = 0;
    return this.regex.test(str);
  };

  Pattern.prototype.replace = function(str, replacement) {
    this.regex.lastIndex = 0;
    return str.replace(this.regex, replacement);
  };

  Pattern.prototype.replaceAll = function(str, replacement, limit) {
    var count;
    if (limit == null) {
      limit = 0;
    }
    this.regex.lastIndex = 0;
    count = 0;
    while (this.regex.test(str) && (limit === 0 || count < limit)) {
      this.regex.lastIndex = 0;
      str = str.replace(this.regex, '');
      count++;
    }
    return [str, count];
  };

  return Pattern;

})();

module.exports = Pattern;

},{}],50:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var Pattern, Unescaper, Utils;

Utils = _dereq_('./Utils');

Pattern = _dereq_('./Pattern');

Unescaper = (function() {
  function Unescaper() {}

  Unescaper.PATTERN_ESCAPED_CHARACTER = new Pattern('\\\\([0abt\tnvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');

  Unescaper.unescapeSingleQuotedString = function(value) {
    return value.replace(/\'\'/g, '\'');
  };

  Unescaper.unescapeDoubleQuotedString = function(value) {
    if (this._unescapeCallback == null) {
      this._unescapeCallback = (function(_this) {
        return function(str) {
          return _this.unescapeCharacter(str);
        };
      })(this);
    }
    return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
  };

  Unescaper.unescapeCharacter = function(value) {
    var ch;
    ch = String.fromCharCode;
    switch (value.charAt(1)) {
      case '0':
        return ch(0);
      case 'a':
        return ch(7);
      case 'b':
        return ch(8);
      case 't':
        return "\t";
      case "\t":
        return "\t";
      case 'n':
        return "\n";
      case 'v':
        return ch(11);
      case 'f':
        return ch(12);
      case 'r':
        return ch(13);
      case 'e':
        return ch(27);
      case ' ':
        return ' ';
      case '"':
        return '"';
      case '/':
        return '/';
      case '\\':
        return '\\';
      case 'N':
        return ch(0x0085);
      case '_':
        return ch(0x00A0);
      case 'L':
        return ch(0x2028);
      case 'P':
        return ch(0x2029);
      case 'x':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));
      case 'u':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
      case 'U':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
      default:
        return '';
    }
  };

  return Unescaper;

})();

module.exports = Unescaper;

},{"./Pattern":49,"./Utils":51}],51:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var Pattern, Utils;

Pattern = _dereq_('./Pattern');

Utils = (function() {
  function Utils() {}

  Utils.REGEX_LEFT_TRIM_BY_CHAR = {};

  Utils.REGEX_RIGHT_TRIM_BY_CHAR = {};

  Utils.REGEX_SPACES = /\s+/g;

  Utils.REGEX_DIGITS = /^\d+$/;

  Utils.REGEX_OCTAL = /[^0-7]/gi;

  Utils.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;

  Utils.PATTERN_DATE = new Pattern('^' + '(?<year>[0-9][0-9][0-9][0-9])' + '-(?<month>[0-9][0-9]?)' + '-(?<day>[0-9][0-9]?)' + '(?:(?:[Tt]|[ \t]+)' + '(?<hour>[0-9][0-9]?)' + ':(?<minute>[0-9][0-9])' + ':(?<second>[0-9][0-9])' + '(?:\.(?<fraction>[0-9]*))?' + '(?:[ \t]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)' + '(?::(?<tz_minute>[0-9][0-9]))?))?)?' + '$', 'i');

  Utils.LOCAL_TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;

  Utils.trim = function(str, _char) {
    var regexLeft, regexRight;
    if (_char == null) {
      _char = '\\s';
    }
    return str.trim();
    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp('^' + _char + '' + _char + '*');
    }
    regexLeft.lastIndex = 0;
    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + '' + _char + '*$');
    }
    regexRight.lastIndex = 0;
    return str.replace(regexLeft, '').replace(regexRight, '');
  };

  Utils.ltrim = function(str, _char) {
    var regexLeft;
    if (_char == null) {
      _char = '\\s';
    }
    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp('^' + _char + '' + _char + '*');
    }
    regexLeft.lastIndex = 0;
    return str.replace(regexLeft, '');
  };

  Utils.rtrim = function(str, _char) {
    var regexRight;
    if (_char == null) {
      _char = '\\s';
    }
    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + '' + _char + '*$');
    }
    regexRight.lastIndex = 0;
    return str.replace(regexRight, '');
  };

  Utils.isEmpty = function(value) {
    return !value || value === '' || value === '0' || (value instanceof Array && value.length === 0);
  };

  Utils.subStrCount = function(string, subString, start, length) {
    var c, i, j, len, ref, sublen;
    c = 0;
    string = '' + string;
    subString = '' + subString;
    if (start != null) {
      string = string.slice(start);
    }
    if (length != null) {
      string = string.slice(0, length);
    }
    len = string.length;
    sublen = subString.length;
    for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (subString === string.slice(i, sublen)) {
        c++;
        i += sublen - 1;
      }
    }
    return c;
  };

  Utils.isDigits = function(input) {
    this.REGEX_DIGITS.lastIndex = 0;
    return this.REGEX_DIGITS.test(input);
  };

  Utils.octDec = function(input) {
    this.REGEX_OCTAL.lastIndex = 0;
    return parseInt((input + '').replace(this.REGEX_OCTAL, ''), 8);
  };

  Utils.hexDec = function(input) {
    this.REGEX_HEXADECIMAL.lastIndex = 0;
    input = this.trim(input);
    if ((input + '').slice(0, 2) === '0x') {
      input = (input + '').slice(2);
    }
    return parseInt((input + '').replace(this.REGEX_HEXADECIMAL, ''), 16);
  };

  Utils.utf8chr = function(c) {
    var ch;
    ch = String.fromCharCode;
    if (0x80 > (c %= 0x200000)) {
      return ch(c);
    }
    if (0x800 > c) {
      return ch(0xC0 | c >> 6) + ch(0x80 | c & 0x3F);
    }
    if (0x10000 > c) {
      return ch(0xE0 | c >> 12) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
    }
    return ch(0xF0 | c >> 18) + ch(0x80 | c >> 12 & 0x3F) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
  };

  Utils.parseBoolean = function(input, strict) {
    var lowerInput;
    if (strict == null) {
      strict = true;
    }
    if (typeof input === 'string') {
      lowerInput = input.toLowerCase();
      if (!strict) {
        if (lowerInput === 'no') {
          return false;
        }
      }
      if (lowerInput === '0') {
        return false;
      }
      if (lowerInput === 'false') {
        return false;
      }
      if (lowerInput === '') {
        return false;
      }
      return true;
    }
    return !!input;
  };

  Utils.isNumeric = function(input) {
    this.REGEX_SPACES.lastIndex = 0;
    return typeof input === 'number' || typeof input === 'string' && !isNaN(input) && input.replace(this.REGEX_SPACES, '') !== '';
  };

  Utils.stringToDate = function(str) {
    var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
    if (!(str != null ? str.length : void 0)) {
      return null;
    }
    info = this.PATTERN_DATE.exec(str);
    if (!info) {
      return null;
    }
    year = parseInt(info.year, 10);
    month = parseInt(info.month, 10) - 1;
    day = parseInt(info.day, 10);
    if (info.hour == null) {
      date = new Date(Date.UTC(year, month, day));
      return date;
    }
    hour = parseInt(info.hour, 10);
    minute = parseInt(info.minute, 10);
    second = parseInt(info.second, 10);
    if (info.fraction != null) {
      fraction = info.fraction.slice(0, 3);
      while (fraction.length < 3) {
        fraction += '0';
      }
      fraction = parseInt(fraction, 10);
    } else {
      fraction = 0;
    }
    if (info.tz != null) {
      tz_hour = parseInt(info.tz_hour, 10);
      if (info.tz_minute != null) {
        tz_minute = parseInt(info.tz_minute, 10);
      } else {
        tz_minute = 0;
      }
      tz_offset = (tz_hour * 60 + tz_minute) * 60000;
      if ('-' === info.tz_sign) {
        tz_offset *= -1;
      }
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (tz_offset) {
      date.setTime(date.getTime() + tz_offset);
    }
    return date;
  };

  Utils.strRepeat = function(str, number) {
    var i, res;
    res = '';
    i = 0;
    while (i < number) {
      res += str;
      i++;
    }
    return res;
  };

  Utils.getStringFromFile = function(path, callback) {
    var data, fs, j, len1, name, ref, req, xhr;
    if (callback == null) {
      callback = null;
    }
    xhr = null;
    if (typeof window !== "undefined" && window !== null) {
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else if (window.ActiveXObject) {
        ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          name = ref[j];
          try {
            xhr = new ActiveXObject(name);
          } catch (undefined) {}
        }
      }
    }
    if (xhr != null) {
      if (callback != null) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200 || xhr.status === 0) {
              return callback(xhr.responseText);
            } else {
              return callback(null);
            }
          }
        };
        xhr.open('GET', path, true);
        return xhr.send(null);
      } else {
        xhr.open('GET', path, false);
        xhr.send(null);
        if (xhr.status === 200 || xhr.status === 0) {
          return xhr.responseText;
        }
        return null;
      }
    } else {
      req = _dereq_;
      fs = req('fs');
      if (callback != null) {
        return fs.readFile(path, function(err, data) {
          if (err) {
            return callback(null);
          } else {
            return callback(String(data));
          }
        });
      } else {
        data = fs.readFileSync(path);
        if (data != null) {
          return String(data);
        }
        return null;
      }
    }
  };

  return Utils;

})();

module.exports = Utils;

},{"./Pattern":49}],52:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.10.0
var Dumper, Parser, Utils, Yaml;

Parser = _dereq_('./Parser');

Dumper = _dereq_('./Dumper');

Utils = _dereq_('./Utils');

Yaml = (function() {
  function Yaml() {}

  Yaml.parse = function(input, exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
  };

  Yaml.parseFile = function(path, callback, exceptionOnInvalidType, objectDecoder) {
    var input;
    if (callback == null) {
      callback = null;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    if (callback != null) {
      return Utils.getStringFromFile(path, (function(_this) {
        return function(input) {
          var result;
          result = null;
          if (input != null) {
            result = _this.parse(input, exceptionOnInvalidType, objectDecoder);
          }
          callback(result);
        };
      })(this));
    } else {
      input = Utils.getStringFromFile(path);
      if (input != null) {
        return this.parse(input, exceptionOnInvalidType, objectDecoder);
      }
      return null;
    }
  };

  Yaml.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var yaml;
    if (inline == null) {
      inline = 2;
    }
    if (indent == null) {
      indent = 4;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    yaml = new Dumper();
    yaml.indentation = indent;
    return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.register = function() {
    var require_handler;
    require_handler = function(module, filename) {
      return module.exports = YAML.parseFile(filename);
    };
    if ((typeof _dereq_ !== "undefined" && _dereq_ !== null ? _dereq_.extensions : void 0) != null) {
      _dereq_.extensions['.yml'] = require_handler;
      return _dereq_.extensions['.yaml'] = require_handler;
    }
  };

  Yaml.stringify = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.load = function(path, callback, exceptionOnInvalidType, objectDecoder) {
    return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
  };

  return Yaml;

})();

if (typeof window !== "undefined" && window !== null) {
  window.YAML = Yaml;
}

if (typeof window === "undefined" || window === null) {
  this.YAML = Yaml;
}

module.exports = Yaml;

},{"./Dumper":43,"./Parser":48,"./Utils":51}],53:[function(_dereq_,module,exports){
'use strict';

var _tangram = _dereq_('./tangram');

var _tangram2 = _interopRequireDefault(_tangram);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = _tangram2.default;

},{"./tangram":54}],54:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = _dereq_('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _tangramCartocss = _dereq_('tangram-cartocss');

var _tangramCartocss2 = _interopRequireDefault(_tangramCartocss);

var _yaml = _dereq_('./yaml');

var _yaml2 = _interopRequireDefault(_yaml);

var _md = _dereq_('md5');

var _md2 = _interopRequireDefault(_md);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SOURCES = {
  mapnik: {
    type: 'MVT'
  }
};

var generateSources = function generateSources(url) {
  // TODO: make this dynamic if it is neccessary
  var source = SOURCES['mapnik'];

  return {
    type: source.type,
    url: url
  };
};

var TC = function TC(map) {
  var _this = this;

  var self = this;
  this.scene = Tangram.leafletLayer({
    scene: _yaml2.default.getBaseFile()
  }).addTo(map).scene;

  this.scene.subscribe({
    load: function load(e) {
      if (_this.scene.initialized) {
        _this.scene.updateConfig();
      } else {
        setTimeout(function () {
          return _this.scene.updateConfig();
        }, 50);
      }
    }
  });
};

TC.prototype = {
  onLoaded: function onLoaded(cb) {
    this.scene.subscribe({
      view_complete: function view_complete() {
        cb();
      }
    });
  },

  addLayer: function addLayer(layer, i) {
    var _this2 = this;

    var config = _tangramCartocss2.default.carto2Draw(layer.meta.cartocss, i);

    config.forEach(function (l) {
      var ly = {
        data: {
          layer: layer.id,
          source: 'CartoDB'
        },
        draw: l.draw,
        visible: layer.visible
      };

      var layerName = (0, _md2.default)(layer.id + l.name);

      _this2.scene.config.layers[layerName] = ly;

      (0, _assign2.default)(_this2.scene.config.styles, l.styles);

      (0, _assign2.default)(_this2.scene.config.textures, l.textures);
    });

    this.scene.updateConfig({ rebuild: true });
  },

  addDataSource: function addDataSource(url) {
    this.scene.setDataSource('CartoDB', generateSources(url));
  }
};

exports.default = TC;

},{"./yaml":55,"babel-runtime/core-js/object/assign":2,"md5":42,"tangram-cartocss":1}],55:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _yamljs = _dereq_('yamljs');

var _yamljs2 = _interopRequireDefault(_yamljs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SOURCES = {
  mapnik: {
    type: 'MVT',
    url: function url(_url) {
      return _url.replace('{layerIndexes}', 'mapnik').replace('.png', '.mvt');
    }
  }
};

var getBaseProperties = function getBaseProperties() {
  return {
    global: {
      language: 'en'
    },
    fonts: {
      Montserrat: {
        url: 'https://fonts.gstatic.com/s/montserrat/v7/zhcz-_WihjSQC0oHJ9TCYL3hpw3pgy2gAi-Ip7WPMi0.woff'
      }
    },
    layers: {},
    styles: {
      polygons_blend: {
        base: 'polygons',
        blend: 'overlay'
      },
      lines_blend: {
        base: 'lines',
        blend: 'overlay'
      },
      points_blend: {
        base: 'points',
        blend: 'overlay'
      }
    }
  };
};

var generateYAML = function generateYAML() {
  return _yamljs2.default.stringify(getBaseProperties(), 3);
};

var getBaseFile = function getBaseFile() {
  return URL.createObjectURL(new Blob([generateYAML()]));
};

var yaml;
exports.default = yaml = {
  getBaseFile: getBaseFile
};

},{"yamljs":52}]},{},[53])(53)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vZnVuY3Rpb25zLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by9pbmRleC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vcGFyc2VyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by9yZW5kZXJlci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vcmVuZGVyZXJfanMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RvcnF1ZS1yZWZlcmVuY2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvY2FsbC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9jb2xvci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9jb21tZW50LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2RlZmluaXRpb24uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZGltZW5zaW9uLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2VsZW1lbnQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZXhwcmVzc2lvbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9maWVsZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9maWx0ZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZmlsdGVyc2V0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2ZvbnRzZXQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZnJhbWVfb2Zmc2V0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2ltYWdlZmlsdGVyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2ludmFsaWQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUva2V5d29yZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9sYXllci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9saXRlcmFsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL29wZXJhdGlvbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9xdW90ZWQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvcmVmZXJlbmNlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3J1bGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvcnVsZXNldC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9zZWxlY3Rvci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9zdHlsZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS91cmwuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvdmFsdWUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvdmFyaWFibGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvem9vbS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jYXJ0by9wYWNrYWdlLmpzb24iLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9jcnlwdC9jcnlwdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvbWFwbmlrLXJlZmVyZW5jZS9pbmRleC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9tZDUvbWQ1LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvaW5kZXguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL0YuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL1QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL19fLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9hZGQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2FkZEluZGV4LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9hZGp1c3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2FsbC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvYWxsUGFzcy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvYWx3YXlzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9hbmQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2FueS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvYW55UGFzcy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvYXAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2FwZXJ0dXJlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9hcHBlbmQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2FwcGx5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9hcHBseVNwZWMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2FzY2VuZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvYXNzb2MuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2Fzc29jUGF0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvYmluYXJ5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9iaW5kLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9ib3RoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jYWxsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jaGFpbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvY2xhbXAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2Nsb25lLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jb21wYXJhdG9yLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jb21wbGVtZW50LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jb21wb3NlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jb21wb3NlSy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvY29tcG9zZVAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2NvbmNhdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvY29uZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvY29uc3RydWN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jb25zdHJ1Y3ROLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jb250YWlucy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvY29udmVyZ2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2NvdW50QnkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2N1cnJ5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jdXJyeU4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2RlYy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZGVmYXVsdFRvLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kZXNjZW5kLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kaWZmZXJlbmNlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kaWZmZXJlbmNlV2l0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZGlzc29jLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kaXNzb2NQYXRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kaXZpZGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2Ryb3AuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2Ryb3BMYXN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kcm9wTGFzdFdoaWxlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kcm9wUmVwZWF0cy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZHJvcFJlcGVhdHNXaXRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kcm9wV2hpbGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2VpdGhlci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZW1wdHkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2VxQnkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2VxUHJvcHMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2VxdWFscy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZXZvbHZlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9maWx0ZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZpbmQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZpbmRJbmRleC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZmluZExhc3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZpbmRMYXN0SW5kZXguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZsYXR0ZW4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZsaXAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZvckVhY2guanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZvckVhY2hPYmpJbmRleGVkLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9mcm9tUGFpcnMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2dyb3VwQnkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2dyb3VwV2l0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZ3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2d0ZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaGFzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9oYXNJbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaGVhZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaWRlbnRpY2FsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pZGVudGl0eS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaWZFbHNlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbmMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2luZGV4QnkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2luZGV4T2YuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2luaXQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2luc2VydC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW5zZXJ0QWxsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fU2V0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXBlcnR1cmUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19hcml0eS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2FycmF5RnJvbUl0ZXJhdG9yLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXNzaWduLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jbG9uZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2Nsb25lUmVnRXhwLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY29tcGxlbWVudC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2NvbmNhdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2NvbnRhaW5zLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY29udGFpbnNXaXRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTEuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeU4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19kaXNwYXRjaGFibGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19kcm9wTGFzdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2Ryb3BMYXN0V2hpbGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19lcXVhbHMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19maWx0ZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19mbGF0Q2F0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fZm9yY2VSZWR1Y2VkLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fZnVuY3Rpb25OYW1lLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faGFzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faWRlbnRpdHkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pbmRleE9mLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNBcmd1bWVudHMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc0FycmF5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNGdW5jdGlvbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzSW50ZWdlci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzTnVtYmVyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1BsYWNlaG9sZGVyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNSZWdFeHAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1N0cmluZy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzVHJhbnNmb3JtZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19tYWtlRmxhdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX21hcC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX29iamVjdEFzc2lnbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX29mLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcGlwZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3BpcGVQLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcXVvdGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19yZWR1Y2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19yZWR1Y2VkLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fc3RlcENhdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3RvSVNPU3RyaW5nLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fdG9TdHJpbmcuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194YWxsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9feGFueS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3hhcGVydHVyZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3hjaGFpbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3hkcm9wLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9feGRyb3BMYXN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9feGRyb3BMYXN0V2hpbGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZHJvcFJlcGVhdHNXaXRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9feGRyb3BXaGlsZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmQmFzZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmaWx0ZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZmluZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmaW5kSW5kZXguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZmluZExhc3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZmluZExhc3RJbmRleC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3htYXAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194cmVkdWNlQnkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194dGFrZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3h0YWtlV2hpbGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194d3JhcC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJzZWN0aW9uLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcnNlY3Rpb25XaXRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcnNwZXJzZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50by5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW52ZXJ0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnZlcnRPYmouanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludm9rZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2lzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pc0FycmF5TGlrZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaXNFbXB0eS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaXNOaWwuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2pvaW4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2p1eHQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2tleXMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2tleXNJbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbGFzdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbGFzdEluZGV4T2YuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2xlbmd0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbGVucy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbGVuc0luZGV4LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9sZW5zUGF0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbGVuc1Byb3AuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2xpZnQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2xpZnROLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9sdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbHRlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tYXAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL21hcEFjY3VtLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tYXBBY2N1bVJpZ2h0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tYXBPYmpJbmRleGVkLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tYXRjaC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbWF0aE1vZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbWF4LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tYXhCeS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbWVhbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbWVkaWFuLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tZW1vaXplLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tZXJnZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbWVyZ2VBbGwuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL21lcmdlV2l0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbWVyZ2VXaXRoS2V5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9taW4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL21pbkJ5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9tb2R1bG8uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL211bHRpcGx5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9uQXJ5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9uZWdhdGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL25vbmUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL25vdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbnRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9udGhBcmcuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL29iak9mLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9vZi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvb21pdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvb25jZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvb3IuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL292ZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BhaXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BhcnRpYWwuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BhcnRpYWxSaWdodC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGFydGl0aW9uLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wYXRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wYXRoRXEuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BhdGhPci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGF0aFNhdGlzZmllcy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGljay5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGlja0FsbC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGlja0J5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9waXBlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9waXBlSy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGlwZVAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BsdWNrLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcmVwZW5kLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9kdWN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9qZWN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9wLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9wRXEuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3Byb3BJcy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcHJvcE9yLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9wU2F0aXNmaWVzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9wcy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmFuZ2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3JlZHVjZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmVkdWNlQnkuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3JlZHVjZVJpZ2h0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9yZWR1Y2VXaGlsZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmVkdWNlZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmVqZWN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9yZW1vdmUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3JlcGVhdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmVwbGFjZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmV2ZXJzZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvc2Nhbi5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvc2VxdWVuY2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3NldC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvc2xpY2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3NvcnQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3NvcnRCeS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvc29ydFdpdGguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3NwbGl0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9zcGxpdEF0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9zcGxpdEV2ZXJ5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9zcGxpdFdoZW4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3N1YnRyYWN0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9zdW0uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3N5bW1ldHJpY0RpZmZlcmVuY2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3N5bW1ldHJpY0RpZmZlcmVuY2VXaXRoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90YWlsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90YWtlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90YWtlTGFzdC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdGFrZUxhc3RXaGlsZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdGFrZVdoaWxlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90YXAuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3Rlc3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3RpbWVzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90b0xvd2VyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90b1BhaXJzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90b1BhaXJzSW4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3RvU3RyaW5nLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90b1VwcGVyLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90cmFuc2R1Y2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3RyYW5zcG9zZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdHJhdmVyc2UuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3RyaW0uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3RyeUNhdGNoLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90eXBlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy91bmFwcGx5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy91bmFyeS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdW5jdXJyeU4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3VuZm9sZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdW5pb24uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3VuaW9uV2l0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdW5pcS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdW5pcUJ5LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy91bmlxV2l0aC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdW5sZXNzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy91bm5lc3QuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3VudGlsLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy91cGRhdGUuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3VzZVdpdGguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3ZhbHVlcy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdmFsdWVzSW4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3ZpZXcuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3doZW4uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3doZXJlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy93aGVyZUVxLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy93aXRob3V0LmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy94cHJvZC5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvemlwLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy96aXBPYmouanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3ppcFdpdGguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1yZWZlcmVuY2UvMS4wLjAvcmVmZXJlbmNlLmpzb24iLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1yZWZlcmVuY2UvaW5kZXguanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9zcmMvYmFzaWMvbGluZXMuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9zcmMvYmFzaWMvcG9pbnRzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvc3JjL2Jhc2ljL3BvbHlnb25zLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvc3JjL2Jhc2ljL3RleHQuanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9zcmMvY2FydG8uanMiLCIuLi90YW5ncmFtLWNhcnRvL2Rpc3Qvbm9kZV9tb2R1bGVzL3RhbmdyYW0tY2FydG9jc3MvZGlzdC9zcmMvbW9kdWxlLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvc3JjL3N0eWxlL2NvbG9ycy5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L3NyYy91dGlscy9nZW9tLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvc3JjL3V0aWxzL3JlZmVyZW5jZS1oZWxwZXJzLmpzIiwiLi4vdGFuZ3JhbS1jYXJ0by9kaXN0L25vZGVfbW9kdWxlcy90YW5ncmFtLWNhcnRvY3NzL2Rpc3Qvc3JjL3V0aWxzL3JlZmVyZW5jZS5qcyIsIi4uL3RhbmdyYW0tY2FydG8vZGlzdC9ub2RlX21vZHVsZXMvdGFuZ3JhbS1jYXJ0b2Nzcy9kaXN0L3NyYy91dGlscy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jaGFyZW5jL2NoYXJlbmMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0L2NyeXB0LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZDUvbWQ1LmpzIiwibm9kZV9tb2R1bGVzL3lhbWxqcy9saWIvRHVtcGVyLmpzIiwibm9kZV9tb2R1bGVzL3lhbWxqcy9saWIvRXNjYXBlci5qcyIsIm5vZGVfbW9kdWxlcy95YW1sanMvbGliL0V4Y2VwdGlvbi9EdW1wRXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3lhbWxqcy9saWIvRXhjZXB0aW9uL1BhcnNlRXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3lhbWxqcy9saWIvSW5saW5lLmpzIiwibm9kZV9tb2R1bGVzL3lhbWxqcy9saWIvUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL3lhbWxqcy9saWIvUGF0dGVybi5qcyIsIm5vZGVfbW9kdWxlcy95YW1sanMvbGliL1VuZXNjYXBlci5qcyIsIm5vZGVfbW9kdWxlcy95YW1sanMvbGliL1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3lhbWxqcy9saWIvWWFtbC5qcyIsInNyYy9tb2R1bGUuanMiLCJzcmMvdGFuZ3JhbS5qcyIsInNyYy95YW1sLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzE0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDMWpCQTs7QUFNQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUF4QkE7Ozs7Ozs7Ozs7OztBQVlBOzs7O0FBY0EsSUFBTSxRQUFRLGtCQUFNLDhDQUFOLENBQWQ7O0FBUkE7Ozs7QUFVQSxJQUFNLEtBQUssb0JBQWlCLE9BQWpCLENBQXlCLElBQXpCLENBQVgsQyxDQUEyQztBQUMzQzs7OztBQUlBLElBQU0sZUFBZSxvQkFBaUIsZUFBakIsQ0FBaUMsTUFBakMsQ0FBckI7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFNLFdBQVcsa0NBQ2YsMENBQW1CLFFBQW5CLEVBQTZCLEVBQTdCLENBRGUsRUFFZiwwQ0FBbUIsZ0JBQW5CLEVBQXFDLEVBQXJDLENBRmUsQ0FBakI7O0FBS0E7Ozs7Ozs7QUFPQSxJQUFNLFdBQVcsb0JBQ2YsZUFBSyxTQURVLEVBRWYsMENBQW1CLGNBQW5CLEVBQW1DLEVBQW5DLENBRmUsQ0FBakI7O0FBS0E7Ozs7OztBQU1BLElBQU0sU0FBUyxxQ0FBYyxnQkFBZCxFQUFnQyxFQUFoQyxDQUFmOztBQUVBOzs7Ozs7QUFNQSxJQUFNLFVBQVUscUNBQWMsaUJBQWQsRUFBaUMsRUFBakMsQ0FBaEI7O0FBRUE7Ozs7OztBQU1BLElBQU0sY0FBYyxrQ0FBVyxFQUFYLENBQXBCOztBQUVBOzs7Ozs7O0FBT0EsSUFBTSxZQUFZLG9CQUNoQixpQkFBSyxDQUNILENBQUMsTUFBTSxNQUFOLENBQUQsa0JBREcsQ0FBTCxDQURnQixFQUloQixxQ0FBYyxrQkFBZCxFQUFrQyxFQUFsQyxDQUpnQixDQUFsQjs7QUFPQTs7OztBQUlBLElBQUksT0FBTyxFQUFYOztrQkFFZSxJOztBQUVmOzs7Ozs7O0FBT0EsS0FBSyxPQUFMLEdBQWUsVUFBQyxJQUFELEVBQU8sRUFBUCxFQUFjO0FBQzNCLE1BQUksT0FBTyxFQUFYO0FBQ0EsTUFBSSxhQUFhLElBQWIsQ0FBSixFQUF3QjtBQUN0QixTQUFLLFdBQVcsRUFBaEIsSUFBc0I7QUFDcEIsYUFBTyxTQUFTLElBQVQsQ0FEYTtBQUVwQixhQUFPLFNBQVMsSUFBVCxDQUZhO0FBR3BCLFdBQUssT0FBTyxJQUFQLENBSGU7QUFJcEIsWUFBTSxRQUFRLElBQVI7QUFKYyxLQUF0QjtBQU1EOztBQUVELFNBQU8sSUFBUDtBQUNELENBWkQ7O0FBY0E7Ozs7O0FBS0EsS0FBSyxRQUFMLEdBQWdCLFVBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUIsR0FBbkIsRUFBd0I7QUFDdEMsTUFBSSxRQUFRLEVBQVo7O0FBRUEsUUFBTSxXQUFXLEVBQWpCLElBQXVCO0FBQ3JCLFVBQU0sT0FEZTtBQUVyQixXQUFPLFlBQVksSUFBWixDQUZjO0FBR3JCLFVBQU0sVUFBVSxJQUFWLENBSGU7QUFJckIsaUJBQWEsT0FBTyxHQUFQLEtBQWUsUUFBZixHQUEwQixNQUFNLENBQWhDLEdBQW9DO0FBSjVCLEdBQXZCOztBQU9BLFNBQU8sS0FBUDtBQUNELENBWEQ7Ozs7Ozs7OztBQ3JIQTs7OztBQUNBOztBQU1BOztBQUNBOzs7Ozs7QUFMQTs7OztBQWpCQTs7Ozs7Ozs7Ozs7QUFXQTs7O0FBYUEsSUFBTSxLQUFLLG9CQUFpQixRQUFqQixDQUEwQixJQUExQixDQUFYLEMsQ0FBNEM7O0FBRTVDOzs7O0FBSUEsSUFBTSxpQkFBaUIsb0JBQWlCLGVBQWpCLENBQWlDLFNBQWpDLENBQXZCOztBQUVBOzs7Ozs7QUFNQSxJQUFNLFdBQVcsa0NBQ2YsMENBQW1CLE1BQW5CLEVBQTJCLEVBQTNCLENBRGUsRUFFZixxQ0FBYyxjQUFkLEVBQThCLFNBQTlCLEVBQXlDLEVBQXpDLENBRmUsQ0FBakI7O0FBS0EsSUFBTSxrQkFBa0Isa0NBQ3RCLHlDQUFrQixRQUFsQixFQUE0QixFQUE1QixDQURzQixFQUV0QixxQ0FBYyxnQkFBZCxFQUFnQyxTQUFoQyxFQUEyQyxFQUEzQyxDQUZzQixDQUF4Qjs7QUFLQSxJQUFNLFlBQVksb0JBQ2hCLG1CQUFPLDZDQUFQLENBRGdCLEVBRWhCLHNCQUFVO0FBQ1IsU0FBTyxRQURDO0FBRVIsV0FBUztBQUNQLFdBQU87QUFEQTtBQUZELENBQVYsQ0FGZ0IsQ0FBbEI7O0FBVUE7Ozs7OztBQU1BLElBQU0saUJBQWlCLHlDQUFrQixPQUFsQixFQUEyQixFQUEzQixDQUF2Qjs7QUFFQSxJQUFNLGtCQUFrQix5Q0FBa0IsY0FBbEIsRUFBa0MsRUFBbEMsQ0FBeEI7O0FBRUEsSUFBTSxZQUFZLG9CQUNoQixtQkFBTyw2Q0FBUCxDQURnQixFQUVoQixzQkFBVTtBQUNSLFFBQU0sY0FERTtBQUVSLFdBQVM7QUFDUCxXQUFPO0FBREE7QUFGRCxDQUFWLENBRmdCLENBQWxCOztBQVVBOzs7Ozs7QUFNQSxJQUFNLGFBQWEscUNBQWMsZUFBZCxFQUErQixFQUEvQixDQUFuQjs7QUFFQSxJQUFNLGlCQUFpQixxQ0FBYyxNQUFkLEVBQXNCLEVBQXRCLENBQXZCOztBQUVBOzs7OztBQUtBLElBQU0sYUFBYSxrQ0FFakIsY0FGaUIsQ0FBbkI7O0FBS0EsSUFBTSxjQUFjLGtDQUFXLEVBQVgsQ0FBcEI7O0FBRUE7Ozs7QUFJQSxJQUFJLFFBQVEsRUFBWjs7a0JBRWUsSzs7QUFHZjs7Ozs7O0FBS0EsTUFBTSxPQUFOLEdBQWdCLFVBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUI7QUFDbEMsTUFBSSxRQUFRLEVBQVo7QUFBQSxNQUNLLE9BQU8sRUFEWjs7QUFHQSxNQUFJLGVBQWUsSUFBZixDQUFKLEVBQTBCOztBQUV6QixZQUFRLG9DQUVOLFVBQVUsSUFBVixDQUZNLEVBR04sVUFBVSxJQUFWLENBSE0sQ0FBUjs7QUFNRSxVQUFNLE9BQU4sR0FBZ0IsQ0FBQyxXQUFXLElBQVgsQ0FBakI7QUFDRjs7QUFFQSxPQUFLLFlBQVksRUFBakIsSUFBdUIsS0FBdkI7O0FBRUEsU0FBTyxJQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBO0FBQ0E7Ozs7O0FBS0EsTUFBTSxRQUFOLEdBQWlCLFVBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUIsR0FBbkIsRUFBd0I7QUFDdkMsTUFBSSxRQUFRLEVBQVo7QUFDQSxRQUFNLFlBQVksRUFBbEIsSUFBd0I7QUFDdEIsVUFBTSxRQURnQjtBQUV0QixXQUFPLFNBRmU7QUFHdEIsaUJBQWEsT0FBTztBQUhFLEdBQXhCOztBQU1ELE1BQUksZUFBZSxJQUFmLENBQUosRUFBMEI7QUFDdkIsUUFBSSxJQUFJLE1BQU0sWUFBWSxFQUFsQixDQUFSO0FBQ0EsTUFBRSxPQUFGLEdBQVksZUFBZSxJQUFmLE1BQXlCLE1BQXpCLEdBQWtDLFdBQVcsSUFBWCxDQUFsQyxHQUFxRCxLQUFLLENBQXRFO0FBQ0EsTUFBRSxLQUFGLEdBQVUsWUFBWSxJQUFaLENBQVY7QUFDRjs7QUFFRCxTQUFPLEtBQVA7QUFDQSxDQWZEOztBQWlCQSxNQUFNLFdBQU4sR0FBb0IsVUFBUyxJQUFULEVBQWU7QUFDakMsTUFBSSxNQUFNLEVBQVY7QUFDRCxNQUFJLGVBQWUsSUFBZixDQUFKLEVBQTBCO0FBQ3pCLFFBQUksVUFBVSxlQUFlLElBQWYsQ0FBZDs7QUFFQSxRQUFJLFlBQVksTUFBaEIsRUFBd0I7QUFDdkIsVUFBSSxrQkFBSSxPQUFKLENBQUosSUFBb0IsRUFBQyxLQUFLLE9BQU4sRUFBcEI7QUFDQTs7QUFFRCxXQUFPLEdBQVA7QUFDQTtBQUNELENBWEQ7Ozs7Ozs7OztBQzlJQTs7OztBQUNBOztBQU1BOztBQUNBOzs7Ozs7QUFMQTs7OztBQWxCQTs7Ozs7Ozs7Ozs7O0FBWUE7OztBQWFBLElBQU0sS0FBSyxvQkFBaUIsVUFBakIsQ0FBNEIsSUFBNUIsQ0FBWCxDLENBQThDO0FBQzlDLElBQU0sTUFBTSxvQkFBaUIsaUJBQWpCLENBQW1DLElBQW5DLENBQVo7O0FBRUE7Ozs7QUFJQSxJQUFNLGtCQUFrQixvQkFBaUIsZUFBakIsQ0FBaUMsU0FBakMsQ0FBeEI7QUFDQSxJQUFNLHFCQUFxQixvQkFBaUIsZUFBakIsQ0FBaUMsaUJBQWpDLENBQTNCOztBQUVBOzs7Ozs7QUFNQSxJQUFNLFdBQVcsa0NBQ2YsMENBQW1CLE1BQW5CLEVBQTJCLEVBQTNCLENBRGUsRUFFZiwwQ0FBbUIsY0FBbkIsRUFBbUMsRUFBbkMsQ0FGZSxDQUFqQjs7QUFLQSxJQUFNLGlCQUFpQixxQ0FBYyxNQUFkLEVBQXNCLEdBQXRCLENBQXZCOztBQUVBLElBQU0sYUFBYSxrQ0FFakIsY0FGaUIsQ0FBbkI7O0FBS0EsSUFBTSxjQUFjLGtDQUFXLEVBQVgsQ0FBcEI7O0FBRUE7Ozs7QUFJQSxJQUFJLFVBQVUsRUFBZDs7a0JBRWUsTzs7QUFFZjs7Ozs7OztBQU1BLFFBQVEsT0FBUixHQUFrQixVQUFDLElBQUQsRUFBTyxFQUFQLEVBQWM7QUFDOUIsTUFBSSxPQUFPLEVBQVg7O0FBRUEsTUFBSSxnQkFBZ0IsSUFBaEIsQ0FBSixFQUEyQjtBQUN6QixTQUFLLGNBQWMsRUFBbkIsSUFBeUI7QUFDdkIsYUFBTyxTQUFTLElBQVQ7QUFEZ0IsS0FBekI7QUFHRDs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQVZEOztBQVlBOzs7OztBQUtBLFFBQVEsUUFBUixHQUFtQixVQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CLEdBQW5CLEVBQXdCO0FBQ3pDLE1BQUksUUFBUSxFQUFaOztBQUVBLFFBQU0sY0FBYyxFQUFwQixJQUEwQjtBQUN4QixVQUFNLFVBRGtCO0FBRXhCLFdBQU8sWUFBWSxJQUFaLENBRmlCO0FBR3hCLGlCQUFhLE9BQU87QUFISSxHQUExQjs7QUFNQSxNQUFJLG1CQUFtQixJQUFuQixDQUFKLEVBQThCO0FBQzVCLFVBQU0sY0FBYyxFQUFwQixFQUF3QixRQUF4QixHQUFtQztBQUNqQyxlQUFTO0FBQ1AsaUJBQVMsV0FBVyxJQUFYLENBREY7QUFFUCxpQkFBUztBQUZGO0FBRHdCLEtBQW5DO0FBTUQ7O0FBRUYsU0FBTyxLQUFQO0FBQ0EsQ0FuQkQ7O0FBcUJBLFFBQVEsV0FBUixHQUFzQixnQkFBUTtBQUM1QixNQUFJLE1BQU0sRUFBVjtBQUNBLE1BQUksbUJBQW1CLElBQW5CLENBQUosRUFBOEI7QUFDNUIsUUFBSSxVQUFVLGVBQWUsSUFBZixDQUFkOztBQUVBLFFBQUksT0FBSixFQUFhO0FBQ1gsVUFBSSxrQkFBSSxPQUFKLENBQUosSUFBb0IsRUFBQyxLQUFLLE9BQU4sRUFBcEI7QUFDRDtBQUVGO0FBQ0QsU0FBTyxHQUFQO0FBQ0QsQ0FYRDs7Ozs7Ozs7O0FDdkZBOztBQUNBOzs7Ozs7QUFyQkE7Ozs7Ozs7Ozs7OztBQVlBOzs7O0FBSUE7Ozs7QUFPQSxJQUFNLEtBQUssb0JBQWlCLE9BQWpCLENBQXlCLElBQXpCLENBQVg7O0FBRUE7Ozs7QUFJQSxJQUFNLGVBQWUsb0JBQWlCLGVBQWpCLENBQWlDLE1BQWpDLENBQXJCOztBQUVBLElBQU0sY0FBYyx5Q0FBa0IsTUFBbEIsRUFBMEIsRUFBMUIsQ0FBcEI7O0FBRUEsSUFBTSxVQUFVLHlDQUFrQixNQUFsQixFQUEwQixFQUExQixDQUFoQjs7QUFFQSxJQUFNLFdBQVcsa0NBQ2YseUNBQWtCLE1BQWxCLEVBQTBCLEVBQTFCLENBRGUsRUFFZiwwQ0FBbUIsU0FBbkIsRUFBOEIsRUFBOUIsQ0FGZSxDQUFqQjs7QUFLQSxJQUFJLFlBQVksRUFBaEI7O2tCQUVlLFM7OztBQUVmLFVBQVUsT0FBVixHQUFvQixVQUFDLElBQUQsRUFBTyxFQUFQLEVBQWM7QUFDaEMsTUFBSSxPQUFPLEVBQVg7O0FBRUEsTUFBSSxhQUFhLElBQWIsQ0FBSixFQUF3QjtBQUN0QixTQUFLLFVBQVUsRUFBZixJQUFxQjtBQUNuQixlQUFTLEtBRFU7QUFFbkIsYUFBTyxhQUZZO0FBR25CLFlBQU07QUFDSixxQkFBYSxZQUFZLElBQVosQ0FEVDtBQUVKLGNBQU07QUFDSixnQkFBTSxRQUFRLElBQVIsQ0FERjtBQUVKLGdCQUFNLFNBQVMsSUFBVDtBQUZGLFNBRkY7QUFNSixrQkFBVTtBQU5OO0FBSGEsS0FBckI7QUFZRDs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQW5CRDs7QUFzQkEsVUFBVSxRQUFWLEdBQXFCLFVBQUMsSUFBRCxFQUFPLEVBQVAsRUFBVyxHQUFYLEVBQW1CO0FBQ3RDLE1BQUksUUFBUSxFQUFaOztBQUVBLFFBQU0sVUFBVSxFQUFoQixJQUFzQjtBQUNwQixVQUFNLFFBRGM7QUFFcEIsV0FBTyxTQUZhO0FBR3BCLGlCQUFhLE9BQU87QUFIQSxHQUF0Qjs7QUFNQSxTQUFPLEtBQVA7QUFDRCxDQVZEOzs7Ozs7Ozs7Ozs7O0FDbEVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxtQkFBbUIsSUFBSSxnQkFBTSxVQUFWLEVBQXpCOztBQUVBLElBQU0sa0JBQWtCLFNBQWxCLGVBQWtCLENBQVUsSUFBVixFQUFnQixLQUFoQixFQUF1QjtBQUM3QyxNQUFJLFNBQVMsaUJBQWlCLE1BQWpCLENBQXdCLElBQXhCLEVBQThCLFNBQTlCLEVBQWI7QUFBQSxNQUNJLEtBQUssa0JBQUksSUFBSixDQURUO0FBQUEsTUFFSSxPQUFPLEVBRlg7QUFBQSxNQUdJLFNBQVMsRUFIYjtBQUFBLE1BSUksV0FBVyxFQUpmOztBQU1BO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDeEMsUUFBSSxLQUFLLE9BQU8sQ0FBUCxFQUFVLE1BQW5COztBQUVFLDBCQUNJLElBREosRUFFSSxpQkFBTyxPQUFQLENBQWUsRUFBZixFQUFtQixFQUFuQixDQUZKLEVBR0ksbUJBQVMsT0FBVCxDQUFpQixFQUFqQixFQUFxQixFQUFyQixDQUhKLEVBSUksZ0JBQU0sT0FBTixDQUFjLEVBQWQsRUFBa0IsRUFBbEIsQ0FKSixFQUtJLGVBQVcsT0FBWCxDQUFtQixFQUFuQixFQUF1QixFQUF2QixDQUxKOztBQVFBLDBCQUNJLFFBREosRUFFSSxpQkFBTyxXQUFQLENBQW1CLEVBQW5CLENBRkosRUFHSSxtQkFBUyxXQUFULENBQXFCLEVBQXJCLENBSEo7O0FBTUEsMEJBQ0ksTUFESixFQUVJLGlCQUFPLFFBQVAsQ0FBZ0IsRUFBaEIsRUFBb0IsRUFBcEIsRUFBd0IsS0FBeEIsQ0FGSixFQUdJLG1CQUFTLFFBQVQsQ0FBa0IsRUFBbEIsRUFBc0IsRUFBdEIsRUFBMEIsS0FBMUIsQ0FISixFQUlJLGdCQUFNLFFBQU4sQ0FBZSxFQUFmLEVBQW1CLEVBQW5CLEVBQXVCLEtBQXZCLENBSkosRUFLSSxlQUFXLFFBQVgsQ0FBb0IsRUFBcEIsRUFBd0IsRUFBeEIsRUFBNEIsS0FBNUIsQ0FMSjtBQU9EOztBQUVELFNBQU8sRUFBQyxrQkFBRCxFQUFXLFVBQVgsRUFBaUIsY0FBakIsRUFBUDtBQUNELENBbkNEOztBQXFDQSxJQUFJLEdBQUo7O2tCQUVlLE1BQU07QUFDbkI7QUFEbUIsQzs7Ozs7QUNoRHJCOzs7Ozs7QUFFQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixjQUFZLGdCQUFLO0FBREYsQ0FBakI7Ozs7Ozs7OztBQ0ZBOzs7Ozs7QUFDQSxJQUFJLFNBQVMsRUFBYjs7a0JBRWUsTTs7O0FBRWYsSUFBSSxJQUFJLE1BQVI7O0FBRUEsT0FBTyxNQUFQLEdBQWdCLGdCQUFNLGNBQU4sZ0VBQWhCOztBQU1BLE9BQU8sTUFBUCxHQUFnQixnQkFBTSxjQUFOLDREQUFoQjs7QUFNQSxPQUFPLE9BQVAsR0FBaUIsZ0JBQU0sY0FBTiw2REFBakI7O0FBTUEsT0FBTyxRQUFQLEdBQWtCLGdCQUFNLGNBQU4sMk5BQWxCOztBQWVBLE9BQU8sUUFBUCxHQUFrQixnQkFBTSxjQUFOLDZEQUFsQjs7QUFNQSxPQUFPLEtBQVAsR0FBZSxnQkFBTSxjQUFOLGtDQUVILEVBQUUsUUFGQyw4Q0FHTixFQUFFLFFBSEksOENBSU4sRUFBRSxRQUpJLHdFQUFmOztBQVVBLE9BQU8sTUFBUCxHQUFnQixnQkFBTSxjQUFOLG1IQUFoQjs7QUFNQSxPQUFPLGVBQVAsR0FBeUIsZ0JBQU0sY0FBTiwySUFJTixFQUFFLE1BSkksb0JBS2hCLEVBQUUsT0FMYyx3RUFTZixFQUFFLE1BVGEsNENBVUosRUFBRSxLQVZFLFVBVVEsRUFBRSxRQVZWLHdEQVlWLEVBQUUsTUFaUSxxRUFBekI7O0FBbUJBLE9BQU8sYUFBUCxHQUF1QixVQUFVLEtBQVYsRUFBaUIsT0FBakIsRUFBMEI7QUFDL0MsS0FBSSxTQUFTLE9BQU8sT0FBUCxLQUFtQixRQUFoQyxFQUEwQztBQUN4QyxTQUFPLGdCQUFNLGNBQU4sd0NBRVUsT0FGViw4QkFHUSxFQUFFLGVBSFYsU0FHNkIsS0FIN0Isb0RBQVA7QUFNRDs7QUFFRCxRQUFPLEtBQVA7QUFDRCxDQVhEOzs7Ozs7OztBQ2pGQSxJQUFJLE9BQU8sRUFBWDs7a0JBRWUsSTs7O0FBRWYsS0FBSyxTQUFMLEdBQWlCLFVBQVUsRUFBVixFQUFjO0FBQzdCLFNBQU8sc0NBQ1EsRUFEUix5REFHSCxPQUhHLENBR0ssT0FITCxFQUdjLEVBSGQsQ0FBUDtBQUlELENBTEQ7Ozs7Ozs7Ozs7QUNKQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBR0E7Ozs7QUFJQSxJQUFNLFlBQVksZ0JBQU0sYUFBeEI7O0FBRUE7Ozs7QUFJQSxJQUFNLHlCQUF5QixTQUF6QixzQkFBeUIsQ0FBUyxHQUFULEVBQWMsSUFBZCxFQUFvQjtBQUNsRCxTQUFPLEVBQUUsSUFBSSxnQkFBTSxlQUFOLE9BQTBCLElBQUksSUFBSixFQUFVLGVBQVYsQ0FBMUIsT0FBTixFQUFQO0FBQ0EsQ0FGRDs7QUFJQSxJQUFNLGFBQWEsZ0JBQUUsS0FBRixDQUFRLFVBQUMsSUFBRCxFQUFPLEdBQVAsRUFBZTtBQUN4QyxTQUFPLHVCQUF1QixHQUF2QixFQUE0QixJQUE1QixDQUFQO0FBQ0QsQ0FGa0IsQ0FBbkI7O0FBSUE7QUFDQTtBQUNBLElBQU0sVUFBVSxnQkFBRSxLQUFGLENBQVEsVUFBQyxJQUFELEVBQU8sR0FBUCxFQUFZLElBQVosRUFBcUI7QUFDM0MsU0FBTyxnQkFBTSxJQUFOLENBQVcsZ0JBQU0sSUFBTixDQUFXLE9BQU8sTUFBbEIsRUFBMEIsR0FBMUIsQ0FBWCxFQUEyQyxJQUEzQyxDQUFQO0FBQ0QsQ0FGZSxDQUFoQjs7QUFJQSxJQUFNLGVBQWUsZ0JBQUUsTUFBRixDQUFTLE9BQVQsRUFBa0IsVUFBbEIsQ0FBckI7O0FBR0EsSUFBTSxnQkFBZ0IsVUFBVSxnQkFBRSxPQUFGLENBQzlCLGdCQUFNLFdBRHdCLEVBRTlCLGdCQUFFLElBQUYsQ0FBTyxJQUFQLENBRjhCLEVBRWhCO0FBQ2QsT0FIOEIsQ0FBVixDQUF0Qjs7QUFNQSxJQUFNLG9CQUFvQixnQkFBRSxNQUFGLENBQ3hCLE9BRHdCLEVBRXhCLGFBRndCLEVBR3hCO0FBQUEsU0FBTSxLQUFLLENBQVg7QUFBQSxDQUh3QixDQUExQjs7QUFNQSxJQUFNLHFCQUFxQixVQUFVLGdCQUFFLE9BQUYsQ0FDbkMsZ0JBQU0sV0FENkIsRUFFbkMsZ0JBQUUsSUFBRixDQUFPLElBQVAsQ0FGbUMsRUFHbkMsWUFIbUMsQ0FBVixDQUEzQjs7QUFNQSxJQUFNLGdCQUFnQixTQUFoQixhQUFnQixDQUFDLEtBQUQsRUFBUSxLQUFSLEVBQWUsR0FBZjtBQUFBLFNBQXVCLGdCQUFFLE1BQUYsQ0FDM0Msa0JBQWtCLEtBQWxCLEVBQXlCLEdBQXpCLENBRDJDLEVBRTNDLG1CQUFtQixLQUFuQixFQUEwQixHQUExQixDQUYyQyxDQUF2QjtBQUFBLENBQXRCOztBQUtBLElBQU0sZ0JBQWdCLFVBQVUsZ0JBQUUsT0FBRixDQUM5QixnQkFBTSxpQkFEd0IsRUFFOUIsZ0JBQUUsSUFBRixDQUFPLElBQVAsQ0FGOEIsRUFHOUIsWUFIOEIsQ0FBVixDQUF0Qjs7QUFNQSxJQUFNLGFBQWEsZ0JBQUUsS0FBRixDQUFRLFVBQUMsR0FBRCxFQUFNLElBQU47QUFBQSxTQUFlLGdCQUFFLE9BQUYsQ0FDeEMsZ0JBQUUsU0FBRixDQUFZLFNBQVosQ0FEd0MsRUFFeEMsb0JBQWlCLFNBQWpCLENBQTJCLElBQUksU0FBSixDQUEzQixDQUZ3QyxFQUd4QyxjQUFjLFNBQWQsQ0FId0MsRUFJeEMsR0FKd0MsRUFJbkMsSUFKbUMsQ0FBZjtBQUFBLENBQVIsQ0FBbkI7O0FBTUEsSUFBTSxhQUFhLFNBQWIsVUFBYSxDQUFDLElBQUQsRUFBTyxLQUFQLEVBQWlCO0FBQ2xDLFNBQU8sZ0JBQUUsT0FBRixDQUNMLGdCQUFFLEtBQUYsQ0FBUSxpQkFBTyxhQUFmLENBREssRUFFTCxnQkFBRSxNQUZHLEVBR0wsZ0JBQUUsU0FBRixDQUFZO0FBQ1YsVUFBTSxJQURJO0FBRVYsV0FBTztBQUZHLEdBQVosQ0FISyxDQUFQO0FBUUQsQ0FURDs7UUFZRSxzQixHQUFBLHNCO1FBQ0EsVSxHQUFBLFU7UUFDQSxPLEdBQUEsTztRQUNBLFksR0FBQSxZO1FBQ0EsYSxHQUFBLGE7UUFDQSxpQixHQUFBLGlCO1FBQ0Esa0IsR0FBQSxrQjtRQUNBLGEsR0FBQSxhO1FBQ0EsYSxHQUFBLGE7UUFDQSxVLEdBQUEsVTtRQUNBLFUsR0FBQSxVOzs7Ozs7Ozs7QUMxRkY7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxNQUFNLDJCQUFVLElBQVYsQ0FBZSxPQUFmLENBQVo7O0FBRUEsSUFBSSxtQkFBbUIsRUFBdkI7O2tCQUVlLGdCOzs7QUFFZixJQUFNLGNBQWMsZ0JBQUUsS0FBRixDQUFRLFVBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQjtBQUNqRCxLQUFNLE1BQU0sSUFBSSxXQUFKLENBQWdCLElBQWhCLENBQVo7QUFDQSxRQUFPLE9BQU8sSUFBSSxJQUFKLENBQVAsR0FBbUIsR0FBMUI7QUFDQSxDQUhtQixDQUFwQjs7QUFLQSxpQkFBaUIsUUFBakIsR0FBNEIsWUFBWSxTQUFaLENBQTVCOztBQUVBLGlCQUFpQixPQUFqQixHQUEyQixZQUFZLE1BQVosQ0FBM0I7O0FBRUEsaUJBQWlCLFVBQWpCLEdBQThCLFlBQVksU0FBWixDQUE5Qjs7QUFFQSxpQkFBaUIsT0FBakIsR0FBMkIsWUFBWSxNQUFaLENBQTNCOztBQUVBLGlCQUFpQixpQkFBakIsR0FBcUMsWUFBWSxpQkFBWixDQUFyQzs7QUFFQSxpQkFBaUIsZUFBakIsR0FBbUMsZ0JBQUUsS0FBRixDQUFRLFVBQVMsR0FBVCxFQUFjLElBQWQsRUFBb0I7QUFDOUQsUUFBTyxLQUFLLFdBQUwsQ0FBaUIsT0FBakIsQ0FBeUIsR0FBekIsTUFBa0MsQ0FBQyxDQUFuQyxHQUF1QyxJQUF2QyxHQUE4QyxJQUFyRDtBQUNBLENBRmtDLENBQW5DOztBQUlBLGlCQUFpQixTQUFqQixHQUE2QixnQkFBRSxLQUFGLENBQVEsVUFBUyxHQUFULEVBQWMsR0FBZCxFQUFtQjtBQUN2RCxRQUFPLElBQUksSUFBSixDQUFTLE9BQVQsQ0FBaUIsR0FBakIsTUFBMEIsQ0FBQyxDQUEzQixHQUErQixHQUEvQixHQUFxQyxJQUE1QztBQUNBLENBRjRCLENBQTdCOzs7Ozs7Ozs7Ozs7O0FDNUJBOzs7Ozs7QUFFQSxJQUFJLFFBQVEsRUFBWjs7a0JBRWUsSzs7O0FBRWYsSUFBTSxVQUFVLGdCQUFFLEtBQUYsQ0FBUSxnQkFBRSxPQUFWLENBQWhCOztBQUVBLElBQU0sYUFBYTtBQUNqQixPQUFLLFNBRFk7QUFFakIsT0FBSyxRQUZZO0FBR2pCLE9BQUs7QUFIWSxDQUFuQjs7QUFNQSxNQUFNLGFBQU4sR0FBc0IsVUFBVSxPQUFWLEVBQW1CO0FBQ3ZDLFNBQU8sZ0JBQUUsS0FBRixDQUFRLFVBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMO0FBQUEsV0FBVyxRQUFRLENBQVIsRUFBVSxDQUFWLEVBQVksQ0FBWixDQUFYO0FBQUEsR0FBUixDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxNQUFNLGtCQUFOLEdBQTJCLFVBQVMsU0FBVCxFQUFrQztBQUFBLE1BQWQsSUFBYyx1RUFBUCxDQUFDLEdBQUQsQ0FBTzs7QUFDNUQsU0FBTyxLQUFLLElBQUwsQ0FBVSxHQUFWLENBQVA7O0FBRUEsU0FBTyxnQkFBYSxJQUFiLGlEQUVGLFNBRkUsd0NBSUYsT0FKRSxDQUlNLE9BSk4sRUFJZSxFQUpmLENBQVA7QUFLQSxDQVJEOztBQVVBLE1BQU0sY0FBTixHQUF1QixVQUFTLEVBQVQsRUFBYTtBQUNuQyxNQUFJLE9BQU8sR0FDUixTQURRLENBQ0csR0FBRyxPQUFILENBQVcsR0FBWCxJQUFrQixDQURyQixFQUN3QixHQUFHLE9BQUgsQ0FBVyxHQUFYLENBRHhCLEVBRVIsT0FGUSxDQUVBLEtBRkEsRUFFTyxFQUZQLENBQVg7O0FBSUEsU0FBTyxPQUFPLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBUCxHQUF5QixFQUFoQzs7QUFFQSxNQUFJLE9BQU8sR0FBRyxTQUFILENBQWMsR0FBRyxPQUFILENBQVcsR0FBWCxJQUFrQixDQUFoQyxFQUFtQyxHQUFHLFdBQUgsQ0FBZSxHQUFmLENBQW5DLENBQVg7QUFDQSxNQUFJLDBDQUFXLFFBQVgsaURBQXVCLElBQXZCLElBQTZCLElBQTdCLE1BQUo7O0FBRUEsT0FBSyxRQUFMLEdBQWdCLFlBQVc7QUFDMUIsV0FBTyxFQUFQO0FBQ0EsR0FGRDs7QUFJQSxTQUFPLElBQVA7QUFDQSxDQWZEOztBQWtCQSxNQUFNLGlCQUFOLEdBQTBCLGdCQUFFLE9BQUYsQ0FDeEIsUUFBUSxXQUFSLEVBQXFCLE9BQXJCLENBRHdCLEVBRXhCLFFBQVEsU0FBUixFQUFtQixVQUFuQixDQUZ3QixFQUd4QixRQUFRLDJDQUFSLEVBQXFELFVBQUMsRUFBRCxFQUFLLEVBQUwsRUFBWTtBQUMvRCxTQUFPLG1CQUFtQixXQUFXLEVBQVgsQ0FBMUI7QUFDRCxDQUZELENBSHdCLENBQTFCOztBQVFBLE1BQU0sV0FBTixHQUFvQixVQUFTLEVBQVQsRUFBYSxJQUFiLEVBQW1CO0FBQ3RDLE1BQUksS0FBSyxFQUFUOztBQUVBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFHLE1BQXZCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ25DLFVBQU0sTUFBTSxpQkFBTixDQUF3QixHQUFHLENBQUgsQ0FBeEIsQ0FBTjtBQUNBOztBQUVELFNBQU8sTUFBTSxjQUFOLENBQXFCLE1BQU0sa0JBQU4sQ0FBeUIsRUFBekIsRUFBNkIsSUFBN0IsQ0FBckIsQ0FBUDtBQUNBLENBUkQ7O0FBVUEsTUFBTSxpQkFBTixHQUEyQixVQUFVLEVBQVYsRUFBYztBQUN2QyxTQUFPLE1BQU0sV0FBTixDQUFrQixFQUFsQixFQUFzQixDQUFDLE9BQUQsQ0FBdEIsRUFBaUMsRUFBakMsQ0FBUDtBQUNELENBRkQ7O0FBSUEsTUFBTSxlQUFOLEdBQXdCLFVBQVMsR0FBVCxFQUFjO0FBQ3JDLHFCQUFpQixHQUFqQjtBQUNBLENBRkQ7O0FBSUEsTUFBTSxJQUFOLEdBQWEsZ0JBQUUsS0FBRixDQUFRLFVBQUMsSUFBRCxFQUFPLEdBQVAsRUFBZTtBQUNsQyxTQUFPLGdCQUFFLE1BQUYsQ0FBUyxVQUFDLFdBQUQsRUFBYyxHQUFkLEVBQXNCO0FBQ3BDLFdBQU8sWUFBWSxHQUFaLENBQVA7QUFDRCxHQUZNLEVBRUosR0FGSSxFQUVDLGdCQUFFLEtBQUYsQ0FBUSxHQUFSLEVBQWEsSUFBYixDQUZELENBQVA7QUFHRCxDQUpZLENBQWI7Ozs7Ozs7OztBQ3hFQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hHQTs7Ozs7O0FBRUEsT0FBTyxPQUFQOzs7Ozs7Ozs7Ozs7O0FDRkE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJLFVBQVU7QUFDVixVQUFRO0FBQ0osVUFBTTtBQURGO0FBREUsQ0FBZDs7QUFNQSxJQUFJLGtCQUFrQixTQUFTLGVBQVQsQ0FBeUIsR0FBekIsRUFBOEI7QUFDbEQ7QUFDQSxNQUFJLFNBQVMsUUFBUSxRQUFSLENBQWI7O0FBRUEsU0FBTztBQUNMLFVBQU0sT0FBTyxJQURSO0FBRUwsU0FBSztBQUZBLEdBQVA7QUFJRCxDQVJEOztBQVVBLElBQUksS0FBSyxTQUFMLEVBQUssQ0FBVSxHQUFWLEVBQWU7QUFBQTs7QUFDdEIsTUFBSSxPQUFPLElBQVg7QUFDQSxPQUFLLEtBQUwsR0FBYSxRQUFRLFlBQVIsQ0FBcUI7QUFDaEMsV0FBTyxlQUFLLFdBQUw7QUFEeUIsR0FBckIsRUFFVixLQUZVLENBRUosR0FGSSxFQUVDLEtBRmQ7O0FBSUEsT0FBSyxLQUFMLENBQVcsU0FBWCxDQUFxQjtBQUNuQixVQUFNLGNBQUMsQ0FBRCxFQUFPO0FBQ1gsVUFBSSxNQUFLLEtBQUwsQ0FBVyxXQUFmLEVBQTRCO0FBQzFCLGNBQUssS0FBTCxDQUFXLFlBQVg7QUFDRCxPQUZELE1BR0s7QUFDSCxtQkFBVztBQUFBLGlCQUFNLE1BQUssS0FBTCxDQUFXLFlBQVgsRUFBTjtBQUFBLFNBQVgsRUFBNEMsRUFBNUM7QUFDRDtBQUNGO0FBUmtCLEdBQXJCO0FBVUQsQ0FoQkQ7O0FBa0JBLEdBQUcsU0FBSCxHQUFlO0FBQ2IsWUFBVSxrQkFBVSxFQUFWLEVBQWM7QUFDdEIsU0FBSyxLQUFMLENBQVcsU0FBWCxDQUFxQjtBQUNuQixxQkFBZSx5QkFBWTtBQUN6QjtBQUNEO0FBSGtCLEtBQXJCO0FBS0QsR0FQWTs7QUFTYixZQUFVLGtCQUFVLEtBQVYsRUFBaUIsQ0FBakIsRUFBb0I7QUFBQTs7QUFDNUIsUUFBSSxTQUFTLDBCQUFLLFVBQUwsQ0FBZ0IsTUFBTSxJQUFOLENBQVcsUUFBM0IsRUFBcUMsQ0FBckMsQ0FBYjs7QUFFQSxXQUFPLE9BQVAsQ0FBZSxhQUFLO0FBQ2xCLFVBQUksS0FBSztBQUNQLGNBQU07QUFDSixpQkFBTyxNQUFNLEVBRFQ7QUFFSixrQkFBUTtBQUZKLFNBREM7QUFLUCxjQUFNLEVBQUUsSUFMRDtBQU1QLGlCQUFTLE1BQU07QUFOUixPQUFUOztBQVNBLFVBQU0sWUFBWSxrQkFBSSxNQUFNLEVBQU4sR0FBVyxFQUFFLElBQWpCLENBQWxCOztBQUVBLGFBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsTUFBbEIsQ0FBeUIsU0FBekIsSUFBc0MsRUFBdEM7O0FBRUEsNEJBQ0UsT0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixNQURwQixFQUVFLEVBQUUsTUFGSjs7QUFLQSw0QkFDRSxPQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLFFBRHBCLEVBRUUsRUFBRSxRQUZKO0FBSUQsS0F2QkQ7O0FBeUJBLFNBQUssS0FBTCxDQUFXLFlBQVgsQ0FBd0IsRUFBQyxTQUFTLElBQVYsRUFBeEI7QUFDRCxHQXRDWTs7QUF3Q2IsaUJBQWUsdUJBQVUsR0FBVixFQUFlO0FBQzVCLFNBQUssS0FBTCxDQUFXLGFBQVgsQ0FBeUIsU0FBekIsRUFBb0MsZ0JBQWdCLEdBQWhCLENBQXBDO0FBQ0Q7QUExQ1ksQ0FBZjs7a0JBNkNlLEU7Ozs7Ozs7OztBQ25GZjs7Ozs7O0FBRUEsSUFBTSxVQUFVO0FBQ1osVUFBUTtBQUNKLFVBQU0sS0FERjtBQUVKLFNBQUssYUFBVSxJQUFWLEVBQWdCO0FBQ2pCLGFBQU8sS0FBSSxPQUFKLENBQVksZ0JBQVosRUFBOEIsUUFBOUIsRUFBd0MsT0FBeEMsQ0FBZ0QsTUFBaEQsRUFBd0QsTUFBeEQsQ0FBUDtBQUNIO0FBSkc7QUFESSxDQUFoQjs7QUFTQSxJQUFNLG9CQUFvQixTQUFTLGlCQUFULEdBQTZCO0FBQ3JELFNBQU87QUFDTCxZQUFRO0FBQ04sZ0JBQVU7QUFESixLQURIO0FBSUwsV0FBTztBQUNMLGtCQUFZO0FBQ1YsYUFBSztBQURLO0FBRFAsS0FKRjtBQVNMLFlBQVEsRUFUSDtBQVVMLFlBQVE7QUFDSixzQkFBZ0I7QUFDWixjQUFNLFVBRE07QUFFWixlQUFPO0FBRkssT0FEWjtBQUtKLG1CQUFhO0FBQ1QsY0FBTSxPQURHO0FBRVQsZUFBTztBQUZFLE9BTFQ7QUFTSixvQkFBYztBQUNWLGNBQU0sUUFESTtBQUVWLGVBQU87QUFGRztBQVRWO0FBVkgsR0FBUDtBQXlCRCxDQTFCRDs7QUE0QkEsSUFBTSxlQUFlLFNBQWYsWUFBZSxHQUFZO0FBQy9CLFNBQU8saUJBQU8sU0FBUCxDQUFrQixtQkFBbEIsRUFBdUMsQ0FBdkMsQ0FBUDtBQUNELENBRkQ7O0FBSUEsSUFBTSxjQUFjLFNBQWQsV0FBYyxHQUFZO0FBQzlCLFNBQU8sSUFBSSxlQUFKLENBQXFCLElBQUksSUFBSixDQUFVLENBQUUsY0FBRixDQUFWLENBQXJCLENBQVA7QUFDRCxDQUZEOztBQUlBLElBQUksSUFBSjtrQkFDZSxPQUFPO0FBQ3BCO0FBRG9CLEMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZnJvbSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59OyIsIiIsIihmdW5jdGlvbiAodHJlZSkge1xuXG50cmVlLmZ1bmN0aW9ucyA9IHtcbiAgICByZ2I6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJnYmEociwgZywgYiwgMS4wKTtcbiAgICB9LFxuICAgIHJnYmE6IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XG4gICAgICAgIHZhciByZ2IgPSBbciwgZywgYl0ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBudW1iZXIoYyk7IH0pO1xuICAgICAgICBhID0gbnVtYmVyKGEpO1xuICAgICAgICBpZiAocmdiLnNvbWUoaXNOYU4pIHx8IGlzTmFOKGEpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbG9yKHJnYiwgYSk7XG4gICAgfSxcbiAgICAvLyBPbmx5IHJlcXVpcmUgdmFsXG4gICAgc3RvcDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgY29sb3IsIG1vZGU7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgY29sb3IgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgbW9kZSA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXM6ICd0YWcnLFxuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXFxuXFx0PHN0b3AgdmFsdWU9XCInICsgdmFsLmV2KGVudikgKyAnXCInICtcbiAgICAgICAgICAgICAgICAgICAgKGNvbG9yID8gJyBjb2xvcj1cIicgKyBjb2xvci5ldihlbnYpICsgJ1wiICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAobW9kZSA/ICcgbW9kZT1cIicgKyBtb2RlLmV2KGVudikgKyAnXCIgJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICcvPic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBoc2w6IGZ1bmN0aW9uIChoLCBzLCBsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhzbGEoaCwgcywgbCwgMS4wKTtcbiAgICB9LFxuICAgIGhzbGE6IGZ1bmN0aW9uIChoLCBzLCBsLCBhKSB7XG4gICAgICAgIGggPSAobnVtYmVyKGgpICUgMzYwKSAvIDM2MDtcbiAgICAgICAgcyA9IG51bWJlcihzKTsgbCA9IG51bWJlcihsKTsgYSA9IG51bWJlcihhKTtcbiAgICAgICAgaWYgKFtoLCBzLCBsLCBhXS5zb21lKGlzTmFOKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgICBtMSA9IGwgKiAyIC0gbTI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmdiYShodWUoaCArIDEvMykgKiAyNTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaHVlKGgpICAgICAgICogMjU1LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGh1ZShoIC0gMS8zKSAqIDI1NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhKTtcblxuICAgICAgICBmdW5jdGlvbiBodWUoaCkge1xuICAgICAgICAgICAgaCA9IGggPCAwID8gaCArIDEgOiAoaCA+IDEgPyBoIC0gMSA6IGgpO1xuICAgICAgICAgICAgaWYgICAgICAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICAgICAgICAgICAgZWxzZSBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICByZXR1cm4gbTE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkRpbWVuc2lvbihNYXRoLnJvdW5kKGNvbG9yLnRvSFNMKCkuaCkpO1xuICAgIH0sXG4gICAgc2F0dXJhdGlvbjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkRpbWVuc2lvbihNYXRoLnJvdW5kKGNvbG9yLnRvSFNMKCkucyAqIDEwMCksICclJyk7XG4gICAgfSxcbiAgICBsaWdodG5lc3M6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24oTWF0aC5yb3VuZChjb2xvci50b0hTTCgpLmwgKiAxMDApLCAnJScpO1xuICAgIH0sXG4gICAgYWxwaGE6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24oY29sb3IudG9IU0woKS5hKTtcbiAgICB9LFxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGhzbC5zICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLnMgPSBjbGFtcChoc2wucyk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBkZXNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGhzbC5zIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLnMgPSBjbGFtcChoc2wucyk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBsaWdodGVuOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGhzbC5sICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLmwgPSBjbGFtcChoc2wubCk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBkYXJrZW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaHNsLmwgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICBoc2wubCA9IGNsYW1wKGhzbC5sKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIGZhZGVpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wuYSArPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5hID0gY2xhbXAoaHNsLmEpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgZmFkZW91dDogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wuYSAtPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5hID0gY2xhbXAoaHNsLmEpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcbiAgICAgICAgdmFyIGh1ZSA9IChoc2wuaCArIGFtb3VudC52YWx1ZSkgJSAzNjA7XG5cbiAgICAgICAgaHNsLmggPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoZW50aXR5LCBhLCBiKSB7XG4gICAgICAgIGlmIChlbnRpdHkuaXMgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHkudG9TdHJpbmcgKyAnLnJlcGxhY2UoJyArIGEudG9TdHJpbmcoKSArICcsICcgKyBiLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXR5LnJlcGxhY2UoYSwgYik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vXG4gICAgLy8gQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgSGFtcHRvbiBDYXRsaW4sIE5hdGhhbiBXZWl6ZW5iYXVtLCBhbmQgQ2hyaXMgRXBwc3RlaW5cbiAgICAvLyBodHRwOi8vc2Fzcy1sYW5nLmNvbVxuICAgIC8vXG4gICAgbWl4OiBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIsIHdlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHdlaWdodC52YWx1ZSAvIDEwMC4wO1xuICAgICAgICB2YXIgdyA9IHAgKiAyIC0gMTtcbiAgICAgICAgdmFyIGEgPSBjb2xvcjEudG9IU0woKS5hIC0gY29sb3IyLnRvSFNMKCkuYTtcblxuICAgICAgICB2YXIgdzEgPSAoKCh3ICogYSA9PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuICAgICAgICB2YXIgdzIgPSAxIC0gdzE7XG5cbiAgICAgICAgdmFyIHJnYiA9IFtjb2xvcjEucmdiWzBdICogdzEgKyBjb2xvcjIucmdiWzBdICogdzIsXG4gICAgICAgICAgICAgICAgICAgY29sb3IxLnJnYlsxXSAqIHcxICsgY29sb3IyLnJnYlsxXSAqIHcyLFxuICAgICAgICAgICAgICAgICAgIGNvbG9yMS5yZ2JbMl0gKiB3MSArIGNvbG9yMi5yZ2JbMl0gKiB3Ml07XG5cbiAgICAgICAgdmFyIGFscGhhID0gY29sb3IxLmFscGhhICogcCArIGNvbG9yMi5hbHBoYSAqICgxIC0gcCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbG9yKHJnYiwgYWxwaGEpO1xuICAgIH0sXG4gICAgZ3JleXNjYWxlOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzYXR1cmF0ZShjb2xvciwgbmV3IHRyZWUuRGltZW5zaW9uKDEwMCkpO1xuICAgIH0sXG4gICAgJyUnOiBmdW5jdGlvbiAocXVvdGVkIC8qIGFyZywgYXJnLCAuLi4qLykge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBzdHIgPSBxdW90ZWQudmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvJXMvLCAgICBhcmdzW2ldLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyVbZGFdLywgYXJnc1tpXS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvJSUvZywgJyUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlF1b3RlZChzdHIpO1xuICAgIH1cbn07XG5cbnZhciBpbWFnZV9maWx0ZXJfZnVuY3RvcnMgPSBbXG4gICAgJ2VtYm9zcycsICdibHVyJywgJ2dyYXknLCAnc29iZWwnLCAnZWRnZS1kZXRlY3QnLFxuICAgICd4LWdyYWRpZW50JywgJ3ktZ3JhZGllbnQnLCAnc2hhcnBlbiddO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IGltYWdlX2ZpbHRlcl9mdW5jdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmID0gaW1hZ2VfZmlsdGVyX2Z1bmN0b3JzW2ldO1xuICAgIHRyZWUuZnVuY3Rpb25zW2ZdID0gKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkltYWdlRmlsdGVyKGYpO1xuICAgICAgICB9O1xuICAgIH0pKGYpO1xufVxuXG50cmVlLmZ1bmN0aW9uc1snYWdnLXN0YWNrLWJsdXInXSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IHRyZWUuSW1hZ2VGaWx0ZXIoJ2FnZy1zdGFjay1ibHVyJywgW3gsIHldKTtcbn07XG5cbnRyZWUuZnVuY3Rpb25zWydzY2FsZS1oc2xhJ10gPSBmdW5jdGlvbihoMCxoMSxzMCxzMSxsMCxsMSxhMCxhMSkge1xuICAgIHJldHVybiBuZXcgdHJlZS5JbWFnZUZpbHRlcignc2NhbGUtaHNsYScsIFtoMCxoMSxzMCxzMSxsMCxsMSxhMCxhMV0pO1xufTtcblxuZnVuY3Rpb24gaHNsYShoKSB7XG4gICAgcmV0dXJuIHRyZWUuZnVuY3Rpb25zLmhzbGEoaC5oLCBoLnMsIGgubCwgaC5hKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIHRyZWUuRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4udW5pdCA9PSAnJScgPyBuLnZhbHVlIC8gMTAwIDogbi52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YobikgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGFtcCh2YWwpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdmFsKSk7XG59XG5cbn0pKHJlcXVpcmUoJy4vdHJlZScpKTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5cbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIH0gZWxzZSBpZiAocGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJylbMV0sIDEwKSA+IDQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGRlciBub2RlXG4gICAgICAgIHZhciBwYWNrYWdlX2pzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oX19kaXJuYW1lLCcuLi8uLi9wYWNrYWdlLmpzb24nKSkpO1xuICAgICAgICByZXR1cm4gcGFja2FnZV9qc29uLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICB9XG59XG5cbnZhciBjYXJ0byA9IHtcbiAgICB2ZXJzaW9uOiBnZXRWZXJzaW9uKCksXG4gICAgUGFyc2VyOiByZXF1aXJlKCcuL3BhcnNlcicpLlBhcnNlcixcbiAgICBSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcicpLlJlbmRlcmVyLFxuICAgIHRyZWU6IHJlcXVpcmUoJy4vdHJlZScpLFxuICAgIFJlbmRlcmVySlM6IHJlcXVpcmUoJy4vcmVuZGVyZXJfanMnKSxcbiAgICBkZWZhdWx0X3JlZmVyZW5jZTogcmVxdWlyZSgnLi90b3JxdWUtcmVmZXJlbmNlJyksXG5cbiAgICAvLyBAVE9ET1xuICAgIHdyaXRlRXJyb3I6IGZ1bmN0aW9uKGN0eCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICB2YXIgZXh0cmFjdCA9IGN0eC5leHRyYWN0O1xuICAgICAgICB2YXIgZXJyb3IgPSBbXTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgb3B0aW9ucy5pbmRlbnQgPSBvcHRpb25zLmluZGVudCB8fCAnJztcblxuICAgICAgICBpZiAoISgnaW5kZXgnIGluIGN0eCkgfHwgIWV4dHJhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsLmVycm9yKG9wdGlvbnMuaW5kZW50ICsgKGN0eC5zdGFjayB8fCBjdHgubWVzc2FnZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihleHRyYWN0WzBdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yLnB1c2goc3R5bGl6ZSgoY3R4LmxpbmUgLSAxKSArICcgJyArIGV4dHJhY3RbMF0sICdncmV5JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhY3RbMV0gPT09ICcnICYmIHR5cGVvZiBleHRyYWN0WzJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXh0cmFjdFsxXSA9ICfCtic7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IucHVzaChjdHgubGluZSArICcgJyArIGV4dHJhY3RbMV0uc2xpY2UoMCwgY3R4LmNvbHVtbikgK1xuICAgICAgICAgICAgc3R5bGl6ZShzdHlsaXplKGV4dHJhY3RbMV1bY3R4LmNvbHVtbl0sICdib2xkJykgK1xuICAgICAgICAgICAgZXh0cmFjdFsxXS5zbGljZShjdHguY29sdW1uICsgMSksICd5ZWxsb3cnKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZihleHRyYWN0WzJdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yLnB1c2goc3R5bGl6ZSgoY3R4LmxpbmUgKyAxKSArICcgJyArIGV4dHJhY3RbMl0sICdncmV5JykpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gb3B0aW9ucy5pbmRlbnQgKyBlcnJvci5qb2luKCdcXG4nICsgb3B0aW9ucy5pbmRlbnQpICsgJ1xcMDMzWzBtXFxuJztcblxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5pbmRlbnQgKyBtZXNzYWdlICsgc3R5bGl6ZShjdHgubWVzc2FnZSwgJ3JlZCcpO1xuICAgICAgICBpZiAoY3R4LmZpbGVuYW1lKSAobWVzc2FnZSArPSBzdHlsaXplKCcgaW4gJywgJ3JlZCcpICsgY3R4LmZpbGVuYW1lKTtcblxuICAgICAgICB1dGlsLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcblxuICAgICAgICBpZiAoY3R4LmNhbGxMaW5lKSB7XG4gICAgICAgICAgICB1dGlsLmVycm9yKHN0eWxpemUoJ2Zyb20gJywgJ3JlZCcpICsgKGN0eC5maWxlbmFtZSB8fCAnJykpO1xuICAgICAgICAgICAgdXRpbC5lcnJvcihzdHlsaXplKGN0eC5jYWxsTGluZSwgJ2dyZXknKSArICcgJyArIGN0eC5jYWxsRXh0cmFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5zdGFjaykgeyB1dGlsLmVycm9yKHN0eWxpemUoY3R4LnN0YWNrLCAncmVkJykpOyB9XG4gICAgfVxufTtcblxucmVxdWlyZSgnLi90cmVlL2NhbGwnKTtcbnJlcXVpcmUoJy4vdHJlZS9jb2xvcicpO1xucmVxdWlyZSgnLi90cmVlL2NvbW1lbnQnKTtcbnJlcXVpcmUoJy4vdHJlZS9kZWZpbml0aW9uJyk7XG5yZXF1aXJlKCcuL3RyZWUvZGltZW5zaW9uJyk7XG5yZXF1aXJlKCcuL3RyZWUvZWxlbWVudCcpO1xucmVxdWlyZSgnLi90cmVlL2V4cHJlc3Npb24nKTtcbnJlcXVpcmUoJy4vdHJlZS9maWx0ZXJzZXQnKTtcbnJlcXVpcmUoJy4vdHJlZS9maWx0ZXInKTtcbnJlcXVpcmUoJy4vdHJlZS9maWVsZCcpO1xucmVxdWlyZSgnLi90cmVlL2tleXdvcmQnKTtcbnJlcXVpcmUoJy4vdHJlZS9sYXllcicpO1xucmVxdWlyZSgnLi90cmVlL2xpdGVyYWwnKTtcbnJlcXVpcmUoJy4vdHJlZS9vcGVyYXRpb24nKTtcbnJlcXVpcmUoJy4vdHJlZS9xdW90ZWQnKTtcbnJlcXVpcmUoJy4vdHJlZS9pbWFnZWZpbHRlcicpO1xucmVxdWlyZSgnLi90cmVlL3JlZmVyZW5jZScpO1xucmVxdWlyZSgnLi90cmVlL3J1bGUnKTtcbnJlcXVpcmUoJy4vdHJlZS9ydWxlc2V0Jyk7XG5yZXF1aXJlKCcuL3RyZWUvc2VsZWN0b3InKTtcbnJlcXVpcmUoJy4vdHJlZS9zdHlsZScpO1xucmVxdWlyZSgnLi90cmVlL3VybCcpO1xucmVxdWlyZSgnLi90cmVlL3ZhbHVlJyk7XG5yZXF1aXJlKCcuL3RyZWUvdmFyaWFibGUnKTtcbnJlcXVpcmUoJy4vdHJlZS96b29tJyk7XG5yZXF1aXJlKCcuL3RyZWUvaW52YWxpZCcpO1xucmVxdWlyZSgnLi90cmVlL2ZvbnRzZXQnKTtcbnJlcXVpcmUoJy4vdHJlZS9mcmFtZV9vZmZzZXQnKTtcbnJlcXVpcmUoJy4vZnVuY3Rpb25zJyk7XG5cbmZvciAodmFyIGsgaW4gY2FydG8pIHsgZXhwb3J0c1trXSA9IGNhcnRvW2tdOyB9XG5cbi8vIFN0eWxpemUgYSBzdHJpbmdcbmZ1bmN0aW9uIHN0eWxpemUoc3RyLCBzdHlsZSkge1xuICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSxcbiAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAncmVkJyA6IFszMSwgMzldLFxuICAgICAgICAnZ3JleScgOiBbOTAsIDM5XVxuICAgIH07XG4gICAgcmV0dXJuICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbn1cbiIsInZhciBjYXJ0byA9IGV4cG9ydHMsXG4gICAgdHJlZSA9IHJlcXVpcmUoJy4vdHJlZScpLFxuICAgIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8vICAgIFRva2VuIG1hdGNoaW5nIGlzIGRvbmUgd2l0aCB0aGUgYCRgIGZ1bmN0aW9uLCB3aGljaCBlaXRoZXIgdGFrZXNcbi8vICAgIGEgdGVybWluYWwgc3RyaW5nIG9yIHJlZ2V4cCwgb3IgYSBub24tdGVybWluYWwgZnVuY3Rpb24gdG8gY2FsbC5cbi8vICAgIEl0IGFsc28gdGFrZXMgY2FyZSBvZiBtb3ZpbmcgYWxsIHRoZSBpbmRpY2VzIGZvcndhcmRzLlxuY2FydG8uUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKGVudikge1xuICAgIHZhciBpbnB1dCwgICAgICAgLy8gTGVTUyBpbnB1dCBzdHJpbmdcbiAgICAgICAgaSwgICAgICAgICAgIC8vIGN1cnJlbnQgaW5kZXggaW4gYGlucHV0YFxuICAgICAgICBqLCAgICAgICAgICAgLy8gY3VycmVudCBjaHVua1xuICAgICAgICB0ZW1wLCAgICAgICAgLy8gdGVtcG9yYXJpbHkgaG9sZHMgYSBjaHVuaydzIHN0YXRlLCBmb3IgYmFja3RyYWNraW5nXG4gICAgICAgIG1lbW8sICAgICAgICAvLyB0ZW1wb3JhcmlseSBob2xkcyBgaWAsIHdoZW4gYmFja3RyYWNraW5nXG4gICAgICAgIGZ1cnRoZXN0LCAgICAvLyBmdXJ0aGVzdCBpbmRleCB0aGUgcGFyc2VyIGhhcyBnb25lIHRvXG4gICAgICAgIGNodW5rcywgICAgICAvLyBjaHVua2lmaWVkIGlucHV0XG4gICAgICAgIGN1cnJlbnQsICAgICAvLyBpbmRleCBvZiBjdXJyZW50IGNodW5rLCBpbiBgaW5wdXRgXG4gICAgICAgIHBhcnNlcjtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGFsbCBmaWxlc1xuICAgIC8vIGhhdmUgYmVlbiBpbXBvcnRlZCB0aHJvdWdoIGBAaW1wb3J0YC5cbiAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIGZ1bmN0aW9uIHNhdmUoKSAgICB7XG4gICAgICAgIHRlbXAgPSBjaHVua3Nbal07XG4gICAgICAgIG1lbW8gPSBpO1xuICAgICAgICBjdXJyZW50ID0gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgY2h1bmtzW2pdID0gdGVtcDtcbiAgICAgICAgaSA9IG1lbW87XG4gICAgICAgIGN1cnJlbnQgPSBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgIGlmIChpID4gY3VycmVudCkge1xuICAgICAgICAgICAgY2h1bmtzW2pdID0gY2h1bmtzW2pdLnNsaWNlKGkgLSBjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vXG4gICAgLy8gUGFyc2UgZnJvbSBhIHRva2VuLCByZWdleHAgb3Igc3RyaW5nLCBhbmQgbW92ZSBmb3J3YXJkIGlmIG1hdGNoXG4gICAgLy9cbiAgICBmdW5jdGlvbiAkKHRvaykge1xuICAgICAgICB2YXIgbWF0Y2gsIGFyZ3MsIGxlbmd0aCwgYywgaW5kZXgsIGVuZEluZGV4LCBrO1xuXG4gICAgICAgIC8vIE5vbi10ZXJtaW5hbFxuICAgICAgICBpZiAodG9rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2suY2FsbChwYXJzZXIucGFyc2Vycyk7XG4gICAgICAgIC8vIFRlcm1pbmFsXG4gICAgICAgIC8vIEVpdGhlciBtYXRjaCBhIHNpbmdsZSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0LFxuICAgICAgICAvLyBvciBtYXRjaCBhIHJlZ2V4cCBpbiB0aGUgY3VycmVudCBjaHVuayAoY2h1bmtbal0pLlxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZih0b2spID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5jaGFyQXQoaSkgPT09IHRvayA/IHRvayA6IG51bGw7XG4gICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgICAgc3luYygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3luYygpO1xuXG4gICAgICAgICAgICBtYXRjaCA9IHRvay5leGVjKGNodW5rc1tqXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hdGNoIGlzIGNvbmZpcm1lZCwgYWRkIHRoZSBtYXRjaCBsZW5ndGggdG8gYGlgLFxuICAgICAgICAvLyBhbmQgY29uc3VtZSBhbnkgZXh0cmEgd2hpdGUtc3BhY2UgY2hhcmFjdGVycyAoJyAnIHx8ICdcXG4nKVxuICAgICAgICAvLyB3aGljaCBjb21lIGFmdGVyIHRoYXQuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBMZVNTJ3NcbiAgICAgICAgLy8gZ3JhbW1hciBpcyBtb3N0bHkgd2hpdGUtc3BhY2UgaW5zZW5zaXRpdmUuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIG1lbSA9IGkgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgZW5kSW5kZXggPSBpICsgY2h1bmtzW2pdLmxlbmd0aCAtIGxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGkgPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgICAgIGMgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICghIChjID09PSAzMiB8fCBjID09PSAxMCB8fCBjID09PSA5KSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rc1tqXSA9IGNodW5rc1tqXS5zbGljZShsZW5ndGggKyAoaSAtIG1lbSkpO1xuICAgICAgICAgICAgY3VycmVudCA9IGk7XG5cbiAgICAgICAgICAgIGlmIChjaHVua3Nbal0ubGVuZ3RoID09PSAwICYmIGogPCBjaHVua3MubGVuZ3RoIC0gMSkgeyBqKys7IH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZihtYXRjaCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2gubGVuZ3RoID09PSAxID8gbWF0Y2hbMF0gOiBtYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhbWUgYXMgJCgpLCBidXQgZG9uJ3QgY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgcGFyc2VyLFxuICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBtYXRjaC5cbiAgICBmdW5jdGlvbiBwZWVrKHRvaykge1xuICAgICAgICBpZiAodHlwZW9mKHRvaykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KGkpID09PSB0b2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gISF0b2sudGVzdChjaHVua3Nbal0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEVycm9yTGluZShzdHlsZSwgZXJyb3JJbmRleCkge1xuICAgICAgICByZXR1cm4gKHN0eWxlLnNsaWNlKDAsIGVycm9ySW5kZXgpLm1hdGNoKC9cXG4vZykgfHwgJycpLmxlbmd0aCArIDE7XG4gICAgfVxuXG5cbiAgICAvLyBNYWtlIGFuIGVycm9yIG9iamVjdCBmcm9tIGEgcGFzc2VkIHNldCBvZiBwcm9wZXJ0aWVzLlxuICAgIC8vIEFjY2VwdGVkIHByb3BlcnRpZXM6XG4gICAgLy8gLSBgbWVzc2FnZWA6IFRleHQgb2YgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgLy8gLSBgZmlsZW5hbWVgOiBGaWxlbmFtZSB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgLy8gLSBgaW5kZXhgOiBDaGFyLiBpbmRleCB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgZnVuY3Rpb24gbWFrZUVycm9yKGVycikge1xuICAgICAgICB2YXIgZWlucHV0O1xuICAgICAgICB2YXIgZXJyb3JUZW1wbGF0ZTtcblxuICAgICAgICBfLmRlZmF1bHRzKGVyciwge1xuICAgICAgICAgICAgaW5kZXg6IGZ1cnRoZXN0LFxuICAgICAgICAgICAgZmlsZW5hbWU6IGVudi5maWxlbmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQYXJzZSBlcnJvci4nLFxuICAgICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICAgIGNvbHVtbjogLTFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVyci5maWxlbmFtZSAmJiB0aGF0LmVudi5pbnB1dHMgJiYgdGhhdC5lbnYuaW5wdXRzW2Vyci5maWxlbmFtZV0pIHtcbiAgICAgICAgICAgIGVpbnB1dCA9IHRoYXQuZW52LmlucHV0c1tlcnIuZmlsZW5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWlucHV0ID0gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBlcnIubGluZSA9IGV4dHJhY3RFcnJvckxpbmUoZWlucHV0LCBlcnIuaW5kZXgpO1xuICAgICAgICBmb3IgKHZhciBuID0gZXJyLmluZGV4OyBuID49IDAgJiYgZWlucHV0LmNoYXJBdChuKSAhPT0gJ1xcbic7IG4tLSkge1xuICAgICAgICAgICAgZXJyLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGVtcGxhdGUgPSBfLnRlbXBsYXRlKCc8JT1maWxlbmFtZSU+OjwlPWxpbmUlPjo8JT1jb2x1bW4lPiA8JT1tZXNzYWdlJT4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihlcnJvclRlbXBsYXRlKGVycikpO1xuICAgIH1cblxuICAgIHRoaXMuZW52ID0gZW52ID0gZW52IHx8IHt9O1xuICAgIHRoaXMuZW52LmZpbGVuYW1lID0gdGhpcy5lbnYuZmlsZW5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLmVudi5pbnB1dHMgPSB0aGlzLmVudi5pbnB1dHMgfHwge307XG5cbiAgICAvLyBUaGUgUGFyc2VyXG4gICAgcGFyc2VyID0ge1xuXG4gICAgICAgIGV4dHJhY3RFcnJvckxpbmU6IGV4dHJhY3RFcnJvckxpbmUsXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnNlIGFuIGlucHV0IHN0cmluZyBpbnRvIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlLlxuICAgICAgICAvLyBUaHJvd3MgYW4gZXJyb3Igb24gcGFyc2UgZXJyb3JzLlxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCwgc3RhcnQsIGVuZCwgem9uZSwgbGluZSwgbGluZXMsIGJ1ZmYgPSBbXSwgYywgZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICBpID0gaiA9IGN1cnJlbnQgPSBmdXJ0aGVzdCA9IDA7XG4gICAgICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGlucHV0ID0gc3RyLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgICAgICAgICBpZiAoZW52LmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbnYuaW5wdXRzW2Vudi5maWxlbmFtZV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVhcmx5X2V4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIGlucHV0IGludG8gY2h1bmtzLlxuICAgICAgICAgICAgY2h1bmtzID0gKGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHNraXAgPSAvKD86QFxce1tcXHctXStcXH18W15cIidgXFx7XFx9XFwvXFwoXFwpXFxcXF0pKy9nLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gL1xcL1xcKig/OlteKl18XFwqK1teXFwvKl0pKlxcKitcXC98XFwvXFwvLiovZyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gL1wiKCg/OlteXCJcXFxcXFxyXFxuXXxcXFxcLikqKVwifCcoKD86W14nXFxcXFxcclxcbl18XFxcXC4pKiknfGAoKD86W15gXXxcXFxcLikqKWAvZyxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSAwLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVua3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIGluUGFyYW07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYywgY2M7IGkgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAubGFzdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gc2tpcC5leGVjKGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsucHVzaChtYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYyA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5sYXN0SW5kZXggPSBzdHJpbmcubGFzdEluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSBzdHJpbmcuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpblBhcmFtICYmIGMgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBpbnB1dC5jaGFyQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjID09PSAnLycgfHwgY2MgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IGNvbW1lbnQuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3snOiBpZiAoISBpblBhcmFtKSB7IGxldmVsICsrOyAgICAgICAgY2h1bmsucHVzaChjKTsgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnfSc6IGlmICghIGluUGFyYW0pIHsgbGV2ZWwgLS07ICAgICAgICBjaHVuay5wdXNoKGMpOyBjaHVua3NbKytqXSA9IGNodW5rID0gW107IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzogaWYgKCEgaW5QYXJhbSkgeyBpblBhcmFtID0gdHJ1ZTsgIGNodW5rLnB1c2goYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOiBpZiAoICBpblBhcmFtKSB7IGluUGFyYW0gPSBmYWxzZTsgY2h1bmsucHVzaChjKTsgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUGFyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKGxldmVsID4gMCkgPyBcIm1pc3NpbmcgY2xvc2luZyBgfWBcIiA6IFwibWlzc2luZyBvcGVuaW5nIGB7YFwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuam9pbignJyk7IH0pO1xuICAgICAgICAgICAgfSkoW1tdXSk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIHByaW1hcnkgcnVsZS5cbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBzeW50YXggdHJlZSBpcyBoZWxkIHVuZGVyIGEgUnVsZXNldCBub2RlLFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHJvb3RgIHByb3BlcnR5IHNldCB0byB0cnVlLCBzbyBubyBge31gIGFyZVxuICAgICAgICAgICAgLy8gb3V0cHV0LlxuICAgICAgICAgICAgcm9vdCA9IG5ldyB0cmVlLlJ1bGVzZXQoW10sICQodGhpcy5wYXJzZXJzLnByaW1hcnkpKTtcbiAgICAgICAgICAgIHJvb3Qucm9vdCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEdldCBhbiBhcnJheSBvZiBSdWxlc2V0IG9iamVjdHMsIGZsYXR0ZW5lZFxuICAgICAgICAgICAgLy8gYW5kIHNvcnRlZCBhY2NvcmRpbmcgdG8gc3BlY2lmaWNpdHlTb3J0XG4gICAgICAgICAgICByb290LnRvTGlzdCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSwgbGluZXMsIGNvbHVtbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZW52KSB7XG4gICAgICAgICAgICAgICAgICAgIGVudi5lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW52LmVycm9ycykgZW52LmVycm9ycyA9IG5ldyBFcnJvcignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW52LmVycm9ycy5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52LmVycm9ycy5tZXNzYWdlICs9ICdcXG4nICsgbWFrZUVycm9yKGUpLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudi5lcnJvcnMubWVzc2FnZSA9IG1ha2VFcnJvcihlKS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBlbnYuZnJhbWVzID0gZW52LmZyYW1lcyB8fCBbXTtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgcG9wdWxhdGVzIEludmFsaWQtY2F1c2VkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbnMgPSB0aGlzLmZsYXR0ZW4oW10sIFtdLCBlbnYpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9ucy5zb3J0KHNwZWNpZmljaXR5U29ydCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9ucztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgLy8gU29ydCBydWxlcyBieSBzcGVjaWZpY2l0eTogdGhpcyBmdW5jdGlvbiBleHBlY3RzIHNlbGVjdG9ycyB0byBiZVxuICAgICAgICAgICAgLy8gc3BsaXQgYWxyZWFkeS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXcml0dGVuIHRvIGJlIHVzZWQgYXMgYSAuc29ydChGdW5jdGlvbik7XG4gICAgICAgICAgICAvLyBhcmd1bWVudC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBbMSwgMCwgMCwgNDY3XSA+IFswLCAwLCAxLCA1MjBdXG4gICAgICAgICAgICB2YXIgc3BlY2lmaWNpdHlTb3J0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhcyA9IGEuc3BlY2lmaWNpdHk7XG4gICAgICAgICAgICAgICAgdmFyIGJzID0gYi5zcGVjaWZpY2l0eTtcblxuICAgICAgICAgICAgICAgIGlmIChhc1swXSAhPSBic1swXSkgcmV0dXJuIGJzWzBdIC0gYXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGFzWzFdICE9IGJzWzFdKSByZXR1cm4gYnNbMV0gLSBhc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoYXNbMl0gIT0gYnNbMl0pIHJldHVybiBic1syXSAtIGFzWzJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBic1szXSAtIGFzWzNdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSGVyZSBpbiwgdGhlIHBhcnNpbmcgcnVsZXMvZnVuY3Rpb25zXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHN5bnRheCB0cmVlIGdlbmVyYXRlZCBpcyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIFJ1bGVzZXQgLT4gIFJ1bGUgLT4gVmFsdWUgLT4gRXhwcmVzc2lvbiAtPiBFbnRpdHlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gIEluIGdlbmVyYWwsIG1vc3QgcnVsZXMgd2lsbCB0cnkgdG8gcGFyc2UgYSB0b2tlbiB3aXRoIHRoZSBgJCgpYCBmdW5jdGlvbiwgYW5kIGlmIHRoZSByZXR1cm5cbiAgICAgICAgLy8gIHZhbHVlIGlzIHRydWx5LCB3aWxsIHJldHVybiBhIG5ldyBub2RlLCBvZiB0aGUgcmVsZXZhbnQgdHlwZS4gU29tZXRpbWVzLCB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgIC8vICBmaXJzdCwgYmVmb3JlIHBhcnNpbmcsIHRoYXQncyB3aGVuIHdlIHVzZSBgcGVlaygpYC5cbiAgICAgICAgcGFyc2Vyczoge1xuICAgICAgICAgICAgLy8gVGhlIGBwcmltYXJ5YCBydWxlIGlzIHRoZSAqZW50cnkqIGFuZCAqZXhpdCogcG9pbnQgb2YgdGhlIHBhcnNlci5cbiAgICAgICAgICAgIC8vIFRoZSBydWxlcyBoZXJlIGNhbiBhcHBlYXIgYXQgYW55IGxldmVsIG9mIHRoZSBwYXJzZSB0cmVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSByZWN1cnNpdmUgbmF0dXJlIG9mIHRoZSBncmFtbWFyIGlzIGFuIGludGVycGxheSBiZXR3ZWVuIHRoZSBgYmxvY2tgXG4gICAgICAgICAgICAvLyBydWxlLCB3aGljaCByZXByZXNlbnRzIGB7IC4uLiB9YCwgdGhlIGBydWxlc2V0YCBydWxlLCBhbmQgdGhpcyBgcHJpbWFyeWAgcnVsZSxcbiAgICAgICAgICAgIC8vIGFzIHJlcHJlc2VudGVkIGJ5IHRoaXMgc2ltcGxpZmllZCBncmFtbWFyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBwcmltYXJ5ICDihpIgIChydWxlc2V0IHwgcnVsZSkrXG4gICAgICAgICAgICAvLyAgICAgcnVsZXNldCAg4oaSICBzZWxlY3RvcisgYmxvY2tcbiAgICAgICAgICAgIC8vICAgICBibG9jayAgICDihpIgICd7JyBwcmltYXJ5ICd9J1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE9ubHkgYXQgb25lIHBvaW50IGlzIHRoZSBwcmltYXJ5IHJ1bGUgbm90IGNhbGxlZCBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gYmxvY2sgcnVsZTogYXQgdGhlIHJvb3QgbGV2ZWwuXG4gICAgICAgICAgICBwcmltYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSwgcm9vdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gJCh0aGlzLnJ1bGUpIHx8ICQodGhpcy5ydWxlc2V0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5jb21tZW50KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKC9eW1xcc1xcbl0rLykgfHwgKG5vZGUgPSAkKHRoaXMuaW52YWxpZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSByb290LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW52YWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaHVuayA9ICQoL15bXjtcXG5dKls7XFxuXS8pO1xuXG4gICAgICAgICAgICAgICAgLy8gVG8gZmFpbCBncmFjZWZ1bGx5LCBtYXRjaCBldmVyeXRoaW5nIHVudGlsIGEgc2VtaWNvbG9uIG9yIGxpbmVicmVhay5cbiAgICAgICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkludmFsaWQoY2h1bmssIG1lbW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFdlIGNyZWF0ZSBhIENvbW1lbnQgbm9kZSBmb3IgQ1NTIGNvbW1lbnRzIGAvKiAqL2AsXG4gICAgICAgICAgICAvLyBidXQga2VlcCB0aGUgTGVTUyBjb21tZW50cyBgLy9gIHNpbGVudCwgYnkganVzdCBza2lwcGluZ1xuICAgICAgICAgICAgLy8gb3ZlciB0aGVtLlxuICAgICAgICAgICAgY29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkpICE9PSAnLycpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSArIDEpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbW1lbnQoJCgvXlxcL1xcLy4qLyksIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudCA9ICQoL15cXC9cXCooPzpbXipdfFxcKitbXlxcLypdKSpcXCorXFwvXFxuPy8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Db21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0b2tlbnMgd2hpY2ggY2FuIGJlIGZvdW5kIGluc2lkZSBhbiBFeHByZXNzaW9uXG4gICAgICAgICAgICBlbnRpdGllczoge1xuXG4gICAgICAgICAgICAgICAgLy8gQSBzdHJpbmcsIHdoaWNoIHN1cHBvcnRzIGVzY2FwaW5nIFwiIGFuZCAnIFwibWlsa3kgd2F5XCIgJ2hlXFwncyB0aGUgb25lISdcbiAgICAgICAgICAgICAgICBxdW90ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkpICE9PSAnXCInICYmIGlucHV0LmNoYXJBdChpKSAhPT0gXCInXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9ICQoL15cIigoPzpbXlwiXFxcXFxcclxcbl18XFxcXC4pKilcInwnKCg/OlteJ1xcXFxcXHJcXG5dfFxcXFwuKSopJy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuUXVvdGVkKHN0clsxXSB8fCBzdHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEEgcmVmZXJlbmNlIHRvIGEgTWFwbmlrIGZpZWxkLCBsaWtlIFtOQU1FXVxuICAgICAgICAgICAgICAgIC8vIEJlaGluZCB0aGUgc2NlbmVzLCB0aGlzIGhhcyB0aGUgc2FtZSByZXByZXNlbnRhdGlvbiwgYnV0IENhcnRvXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gYmUgY2FyZWZ1bCB0byB3YXJuIHdoZW4gdW5zdXBwb3J0ZWQgb3BlcmF0aW9ucyBhcmUgdXNlZC5cbiAgICAgICAgICAgICAgICBmaWVsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghICQoJ1snKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9ICQoLyheW15cXF1dKykvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnXScpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF9uYW1lKSByZXR1cm4gbmV3IHRyZWUuRmllbGQoZmllbGRfbmFtZVsxXSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjb21wYXJpc29uIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSAkKC9ePX58PXwhPXw8PXw+PXw8fD4vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIGNhdGNoLWFsbCB3b3JkLCBzdWNoIGFzOiBoYXJkLWxpZ2h0XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgY2FuIHN0YXJ0IHdpdGggZWl0aGVyIGEgbGV0dGVyIG9yIGEgZGFzaCAoLSksXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gY29udGFpbiBudW1iZXJzLCB1bmRlcnNjb3JlcywgYW5kIGxldHRlcnMuXG4gICAgICAgICAgICAgICAga2V5d29yZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gJCgvXltBLVphLXotXStbQS1aYS16LTAtOV9dKi8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaykgeyByZXR1cm4gbmV3IHRyZWUuS2V5d29yZChrKTsgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgbGlrZSByZ2IoMjU1LCAwLCAyNTUpXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIHdpdGggdGhlIGBlbnRpdGllcy5hcmd1bWVudHNgIHBhcnNlci5cbiAgICAgICAgICAgICAgICBjYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobmFtZSA9IC9eKFtcXHdcXC1dK3wlKVxcKC8uZXhlYyhjaHVua3Nbal0pKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAndXJsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXJsKCkgaXMgaGFuZGxlZCBieSB0aGUgdXJsIHBhcnNlciBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkKCcoJyk7IC8vIFBhcnNlIHRoZSAnKCcgYW5kIGNvbnN1bWUgd2hpdGVzcGFjZS5cblxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gJCh0aGlzLmVudGl0aWVzWydhcmd1bWVudHMnXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkKCcpJykpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNhbGwobmFtZSwgYXJncywgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50cyBhcmUgY29tbWEtc2VwYXJhdGVkIGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFyZyA9ICQodGhpcy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMuZW50aXRpZXMuZGltZW5zaW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmtleXdvcmRjb2xvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5oZXhjb2xvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5xdW90ZWQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB1cmwoKSB0b2tlbnNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHNwZWNpZmljIHJ1bGUgZm9yIHVybHMsIGJlY2F1c2UgdGhleSBkb24ndCByZWFsbHkgYmVoYXZlIGxpa2VcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZCBmdW5jdGlvbiBjYWxscy4gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCB0aGUgYXJndW1lbnQgZG9lc24ndCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gdG8gYmUgZW5jbG9zZWQgd2l0aGluIGEgc3RyaW5nLCBzbyBpdCBjYW4ndCBiZSBwYXJzZWQgYXMgYW4gRXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpKSAhPT0gJ3UnIHx8ICEkKC9edXJsXFwoLykpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkKHRoaXMuZW50aXRpZXMucXVvdGVkKSB8fCAkKHRoaXMuZW50aXRpZXMudmFyaWFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgvXltcXC1cXHclQCRcXC8uJj06OyMrP35dKy8pIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5JbnZhbGlkKHZhbHVlLCBtZW1vLCAnTWlzc2luZyBjbG9zaW5nICkgaW4gVVJMLicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlVSTCgodHlwZW9mIHZhbHVlLnZhbHVlICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogbmV3IHRyZWUuUXVvdGVkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQSBWYXJpYWJsZSBlbnRpdHksIHN1Y2ggYXMgYEBmaW5rYCwgaW5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICB3aWR0aDogQGZpbmsgKyAycHhcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIGRpZmZlcmVudCBwYXJzZXIgZm9yIHZhcmlhYmxlIGRlZmluaXRpb25zLFxuICAgICAgICAgICAgICAgIC8vIHNlZSBgcGFyc2Vycy52YXJpYWJsZWAuXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSwgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSkgPT09ICdAJyAmJiAobmFtZSA9ICQoL15AW1xcdy1dKy8pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhcmlhYmxlKG5hbWUsIGluZGV4LCBlbnYuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGhleGNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJnYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpKSA9PT0gJyMnICYmIChyZ2IgPSAkKC9eIyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSkvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Db2xvcihyZ2JbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGtleXdvcmRjb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZ2IgPSBjaHVua3Nbal0ubWF0Y2goL15bYS16XSsvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJnYiAmJiByZ2JbMF0gaW4gdHJlZS5SZWZlcmVuY2UuZGF0YS5jb2xvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Db2xvcih0cmVlLlJlZmVyZW5jZS5kYXRhLmNvbG9yc1skKC9eW2Etel0rLyldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIERpbWVuc2lvbiwgdGhhdCBpcywgYSBudW1iZXIgYW5kIGEgdW5pdC4gVGhlIG9ubHlcbiAgICAgICAgICAgICAgICAvLyB1bml0IHRoYXQgaGFzIGFuIGVmZmVjdCBpcyAlXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPiA1NyB8fCBjIDwgNDUpIHx8IGMgPT09IDQ3KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICQoL14oLT9cXGQqXFwuP1xcZCsoPzpbZUVdWy0rXT9cXGQrKT8pKFxcJXxcXHcrKT8vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGltZW5zaW9uKHZhbHVlWzFdLCB2YWx1ZVsyXSwgbWVtbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRoZSB2YXJpYWJsZSBwYXJ0IG9mIGEgdmFyaWFibGUgZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIC8vIFVzZWQgaW4gdGhlIGBydWxlYCBwYXJzZXIuIExpa2UgQGZpbms6XG4gICAgICAgICAgICB2YXJpYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkpID09PSAnQCcgJiYgKG5hbWUgPSAkKC9eKEBbXFx3LV0rKVxccyo6LykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0aGUgc21hbGxlc3QgcmVjb2duaXplZCB0b2tlbixcbiAgICAgICAgICAgIC8vIGFuZCBjYW4gYmUgZm91bmQgaW5zaWRlIGEgcnVsZSdzIHZhbHVlLlxuICAgICAgICAgICAgZW50aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzLmVudGl0aWVzLmNhbGwpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5saXRlcmFsKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMuZmllbGQpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy52YXJpYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLnVybCkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmtleXdvcmQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQSBSdWxlIHRlcm1pbmF0b3IuIE5vdGUgdGhhdCB3ZSB1c2UgYHBlZWsoKWAgdG8gY2hlY2sgZm9yICd9JyxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGBibG9ja2AgcnVsZSB3aWxsIGJlIGV4cGVjdGluZyBpdCwgYnV0IHdlIHN0aWxsIG5lZWQgdG8gbWFrZSBzdXJlXG4gICAgICAgICAgICAvLyBpdCdzIHRoZXJlLCBpZiAnOycgd2FzIG9tbWl0dGVkLlxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCgnOycpIHx8IHBlZWsoJ30nKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEVsZW1lbnRzIGFyZSB0aGUgYnVpbGRpbmcgYmxvY2tzIGZvciBTZWxlY3RvcnMuIFRoZXkgY29uc2lzdCBvZlxuICAgICAgICAgICAgLy8gYW4gZWxlbWVudCBuYW1lLCBzdWNoIGFzIGEgdGFnIGEgY2xhc3MsIG9yIGAqYC5cbiAgICAgICAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gJCgvXig/OlsuI11bXFx3XFwtXSt8XFwqfE1hcCkvKTtcbiAgICAgICAgICAgICAgICBpZiAoZSkgcmV0dXJuIG5ldyB0cmVlLkVsZW1lbnQoZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBdHRhY2htZW50cyBhbGxvdyBhZGRpbmcgbXVsdGlwbGUgbGluZXMsIHBvbHlnb25zIGV0Yy4gdG8gYW5cbiAgICAgICAgICAgIC8vIG9iamVjdC4gVGhlcmUgY2FuIG9ubHkgYmUgb25lIGF0dGFjaG1lbnQgcGVyIHNlbGVjdG9yLlxuICAgICAgICAgICAgYXR0YWNobWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSAkKC9eOjooW1xcd1xcLV0rKD86XFwvW1xcd1xcLV0rKSopLyk7XG4gICAgICAgICAgICAgICAgaWYgKHMpIHJldHVybiBzWzFdO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gU2VsZWN0b3JzIGFyZSBtYWRlIG91dCBvZiBvbmUgb3IgbW9yZSBFbGVtZW50cywgc2VlIGFib3ZlLlxuICAgICAgICAgICAgc2VsZWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBhdHRhY2htZW50LFxuICAgICAgICAgICAgICAgICAgICBlLCBlbGVtZW50cyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBmLCBmaWx0ZXJzID0gbmV3IHRyZWUuRmlsdGVyc2V0KCksXG4gICAgICAgICAgICAgICAgICAgIHosIHpvb21zID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lX29mZnNldCA9IHRyZWUuRnJhbWVPZmZzZXQubm9uZTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMgPSAwLCBjb25kaXRpb25zID0gMDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlID0gJCh0aGlzLmVsZW1lbnQpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHogPSAkKHRoaXMuem9vbSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm8gPSAkKHRoaXMuZnJhbWVfb2Zmc2V0KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChmID0gJCh0aGlzLmZpbHRlcikpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYSA9ICQodGhpcy5hdHRhY2htZW50KSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21zLnB1c2goeik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lX29mZnNldCA9IGZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBmaWx0ZXJzLmFkZChmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0VuY291bnRlcmVkIHNlY29uZCBhdHRhY2htZW50IG5hbWUuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudCA9IGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICd7JyB8fCBjID09PSAnfScgfHwgYyA9PT0gJzsnIHx8IGMgPT09ICcsJykgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuU2VsZWN0b3IoZmlsdGVycywgem9vbXMsIGZyYW1lX29mZnNldCwgZWxlbWVudHMsIGF0dGFjaG1lbnQsIGNvbmRpdGlvbnMsIG1lbW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBrZXksIG9wLCB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKCEgJCgnWycpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9ICQoL15bYS16QS1aMC05XFwtX10rLykgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLnF1b3RlZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLnZhcmlhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMua2V5d29yZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgYXQgMS4wLjBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIHRyZWUuUXVvdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXcgdHJlZS5GaWVsZChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChvcCA9ICQodGhpcy5lbnRpdGllcy5jb21wYXJpc29uKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWwgPSAkKHRoaXMuZW50aXRpZXMucXVvdGVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMudmFyaWFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5kaW1lbnNpb24pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5rZXl3b3JkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMuZmllbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ01pc3NpbmcgY2xvc2luZyBdIG9mIGZpbHRlci4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbWVtbyAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5LmlzKSBrZXkgPSBuZXcgdHJlZS5GaWVsZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkZpbHRlcihrZXksIG9wLCB2YWwsIG1lbW8sIGVudi5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmcmFtZV9vZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3AsIHZhbDtcbiAgICAgICAgICAgICAgICBpZiAoJCgvXlxcW1xccypmcmFtZS1vZmZzZXQvZykgJiZcbiAgICAgICAgICAgICAgICAgICAgKG9wID0gJCh0aGlzLmVudGl0aWVzLmNvbXBhcmlzb24pKSAmJlxuICAgICAgICAgICAgICAgICAgICAodmFsID0gJCgvXlxcZCsvKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgJCgnXScpKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyZWUuRnJhbWVPZmZzZXQob3AsIHZhbCwgbWVtbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgem9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBvcCwgdmFsO1xuICAgICAgICAgICAgICAgIGlmICgkKC9eXFxbXFxzKnpvb20vZykgJiZcbiAgICAgICAgICAgICAgICAgICAgKG9wID0gJCh0aGlzLmVudGl0aWVzLmNvbXBhcmlzb24pKSAmJlxuICAgICAgICAgICAgICAgICAgICAodmFsID0gJCh0aGlzLmVudGl0aWVzLnZhcmlhYmxlKSB8fCAkKHRoaXMuZW50aXRpZXMuZGltZW5zaW9uKSkgJiYgJCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuWm9vbShvcCwgdmFsLCBtZW1vKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRoZSBgYmxvY2tgIHJ1bGUgaXMgdXNlZCBieSBgcnVsZXNldGBcbiAgICAgICAgICAgIC8vIEl0J3MgYSB3cmFwcGVyIGFyb3VuZCB0aGUgYHByaW1hcnlgIHJ1bGUsIHdpdGggYWRkZWQgYHt9YC5cbiAgICAgICAgICAgIGJsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudDtcblxuICAgICAgICAgICAgICAgIGlmICgkKCd7JykgJiYgKGNvbnRlbnQgPSAkKHRoaXMucHJpbWFyeSkpICYmICQoJ30nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBkaXYsIC5jbGFzcywgYm9keSA+IHAgey4uLn1cbiAgICAgICAgICAgIHJ1bGVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSBbXSwgcywgZiwgbCwgcnVsZXMsIGZpbHRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBzYXZlKCk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocyA9ICQodGhpcy5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgkKHRoaXMuY29tbWVudCkpIHt9XG4gICAgICAgICAgICAgICAgICAgIGlmICghICQoJywnKSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoJCh0aGlzLmNvbW1lbnQpKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoJCh0aGlzLmNvbW1lbnQpKSB7fVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAocnVsZXMgPSAkKHRoaXMuYmxvY2spKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzWzBdLmVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzWzBdLmVsZW1lbnRzWzBdLnZhbHVlID09PSAnTWFwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJzID0gbmV3IHRyZWUuUnVsZXNldChzZWxlY3RvcnMsIHJ1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJzLmlzTWFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBycztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuUnVsZXNldChzZWxlY3RvcnMsIHJ1bGVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJ1bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lLCB2YWx1ZSwgYyA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBzYXZlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJy4nIHx8IGMgPT09ICcjJykgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIGlmIChuYW1lID0gJCh0aGlzLnZhcmlhYmxlKSB8fCAkKHRoaXMucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJCh0aGlzLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgJCh0aGlzLmVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5SdWxlKG5hbWUsIHZhbHVlLCBtZW1vLCBlbnYuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVydGhlc3QgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZm9udDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gW10sIGV4cHJlc3Npb24gPSBbXSwgd2VpZ2h0LCBmb250LCBlO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGUgPSAkKHRoaXMuZW50aXR5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChuZXcgdHJlZS5FeHByZXNzaW9uKGV4cHJlc3Npb24pKTtcblxuICAgICAgICAgICAgICAgIGlmICgkKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGUgPSAkKHRoaXMuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQSBWYWx1ZSBpcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIEV4cHJlc3Npb25zXG4gICAgICAgICAgICAvLyBJbiBhIFJ1bGUsIGEgVmFsdWUgcmVwcmVzZW50cyBldmVyeXRoaW5nIGFmdGVyIHRoZSBgOmAsXG4gICAgICAgICAgICAvLyBhbmQgYmVmb3JlIHRoZSBgO2AuXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUsIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZSA9ICQodGhpcy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWUoZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhbHVlKGV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQSBzdWItZXhwcmVzc2lvbiwgY29udGFpbmVkIGJ5IHBhcmVudGhlbnNpc1xuICAgICAgICAgICAgc3ViOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgZXhwcmVzc2lvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICgkKCcoJykpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChlID0gJCh0aGlzLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICQoJyknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWUoZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhbHVlKGV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1pc25vbWVyIGJlY2F1c2UgaXQgYWN0dWFsbHkgaGFuZGxlcyBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgICAgLy8gYW5kIGRpdmlzaW9uLlxuICAgICAgICAgICAgbXVsdGlwbGljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtLCBhLCBvcCwgb3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChtID0gJCh0aGlzLm9wZXJhbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgob3AgPSAoJCgnLycpIHx8ICQoJyonKSB8fCAkKCclJykpKSAmJiAoYSA9ICQodGhpcy5vcGVyYW5kKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG5ldyB0cmVlLk9wZXJhdGlvbihvcCwgW29wZXJhdGlvbiB8fCBtLCBhXSwgbWVtbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbiB8fCBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0sIGEsIG9wLCBvcGVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKG0gPSAkKHRoaXMubXVsdGlwbGljYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgob3AgPSAkKC9eWy0rXVxccysvKSB8fCAoaW5wdXQuY2hhckF0KGkgLSAxKSAhPSAnICcgJiYgKCQoJysnKSB8fCAkKCctJykpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChhID0gJCh0aGlzLm11bHRpcGxpY2F0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG5ldyB0cmVlLk9wZXJhdGlvbihvcCwgW29wZXJhdGlvbiB8fCBtLCBhXSwgbWVtbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbiB8fCBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEFuIG9wZXJhbmQgaXMgYW55dGhpbmcgdGhhdCBjYW4gYmUgcGFydCBvZiBhbiBvcGVyYXRpb24sXG4gICAgICAgICAgICAvLyBzdWNoIGFzIGEgQ29sb3IsIG9yIGEgVmFyaWFibGVcbiAgICAgICAgICAgIG9wZXJhbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMuc3ViKSB8fCAkKHRoaXMuZW50aXR5KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEV4cHJlc3Npb25zIGVpdGhlciByZXByZXNlbnQgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMsXG4gICAgICAgICAgICAvLyBvciB3aGl0ZS1zcGFjZSBkZWxpbWl0ZWQgRW50aXRpZXMuICBAdmFyICogMlxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUsIGRlbGltLCBlbnRpdGllcyA9IFtdLCBkO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGUgPSAkKHRoaXMuYWRkaXRpb24pIHx8ICQodGhpcy5lbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVudGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkV4cHJlc3Npb24oZW50aXRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSAkKC9eKChbYS16XVstYS16XzAtOV0qXFwvKT9cXCo/LT9bLWEtel8wLTldKylcXHMqOi8pO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSByZXR1cm4gbmFtZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlcjtcbn07XG4iLCJ2YXIgXyA9IGdsb2JhbC5fIHx8IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBjYXJ0byA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2FydG8uUmVuZGVyZXIgPSBmdW5jdGlvbiBSZW5kZXJlcihlbnYsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVudiA9IGVudiB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbiA9IHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbiB8fCAnMy4wLjAnO1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIGEgTVNTIGRvY3VtZW50IChnaXZlbiBhcyBhbiBzdHJpbmcpIGludG8gYVxuICogWE1MIFN0eWxlIGZyYWdtZW50IChtb3N0bHkgdXNlZnVsIGZvciBkZWJ1Z2dpbmcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdGhlIG1zcyBjb250ZW50cyBhcyBhIHN0cmluZy5cbiAqL1xuY2FydG8uUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlck1TUyA9IGZ1bmN0aW9uIHJlbmRlcihkYXRhKSB7XG4gICAgLy8gZWZmZWN0cyBpcyBhIGNvbnRhaW5lciBmb3Igc2lkZS1lZmZlY3RzLCB3aGljaCBjdXJyZW50bHlcbiAgICAvLyBhcmUgbGltaXRlZCB0byBGb250U2V0cy5cbiAgICB2YXIgZW52ID0gXy5kZWZhdWx0cyh0aGlzLmVudiwge1xuICAgICAgICBiZW5jaG1hcms6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW9uX2RhdGE6IGZhbHNlLFxuICAgICAgICBlZmZlY3RzOiBbXVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYXJ0by50cmVlLlJlZmVyZW5jZS5zZXRWZXJzaW9uKHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHNldCBtYXBuaWsgdmVyc2lvbiB0byBcIiArIHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbik7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciBzdHlsZXMgPSBbXTtcblxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWUoJ1BhcnNpbmcgTVNTJyk7XG4gICAgdmFyIHBhcnNlciA9IChjYXJ0by5QYXJzZXIoZW52KSkucGFyc2UoZGF0YSk7XG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZUVuZCgnUGFyc2luZyBNU1MnKTtcblxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWUoJ1J1bGUgZ2VuZXJhdGlvbicpO1xuICAgIHZhciBydWxlX2xpc3QgPSBwYXJzZXIudG9MaXN0KGVudik7XG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZUVuZCgnUnVsZSBnZW5lcmF0aW9uJyk7XG5cbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lKCdSdWxlIGluaGVyaXRhbmNlJyk7XG4gICAgdmFyIHJ1bGVzID0gaW5oZXJpdERlZmluaXRpb25zKHJ1bGVfbGlzdCwgZW52KTtcbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lRW5kKCdSdWxlIGluaGVyaXRhbmNlJyk7XG5cbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lKCdTdHlsZSBzb3J0Jyk7XG4gICAgdmFyIHNvcnRlZCA9IHNvcnRTdHlsZXMocnVsZXMsZW52KTtcbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lRW5kKCdTdHlsZSBzb3J0Jyk7XG5cbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lKCdUb3RhbCBTdHlsZSBnZW5lcmF0aW9uJyk7XG4gICAgZm9yICh2YXIgayA9IDAsIHJ1bGUsIHN0eWxlX25hbWU7IGsgPCBzb3J0ZWQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcnVsZSA9IHNvcnRlZFtrXTtcbiAgICAgICAgc3R5bGVfbmFtZSA9ICdzdHlsZScgKyAocnVsZS5hdHRhY2htZW50ICE9PSAnX19kZWZhdWx0X18nID8gJy0nICsgcnVsZS5hdHRhY2htZW50IDogJycpO1xuICAgICAgICBzdHlsZXMucHVzaChzdHlsZV9uYW1lKTtcbiAgICAgICAgdmFyIGJlbmNoX25hbWUgPSAnXFx0U3R5bGUgXCInK3N0eWxlX25hbWUrJ1wiICgjJytrKycpIHRvWE1MJztcbiAgICAgICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZShiZW5jaF9uYW1lKTtcbiAgICAgICAgLy8gZW52LmVmZmVjdHMgY2FuIGJlIG1vZGlmaWVkIGJ5IHRoaXMgY2FsbFxuICAgICAgICBvdXRwdXQucHVzaChjYXJ0by50cmVlLlN0eWxlWE1MKHN0eWxlX25hbWUsIHJ1bGUuYXR0YWNobWVudCwgcnVsZSwgZW52KSk7XG4gICAgICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWVFbmQoYmVuY2hfbmFtZSk7XG4gICAgfVxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWVFbmQoJ1RvdGFsIFN0eWxlIGdlbmVyYXRpb24nKTtcbiAgICBpZiAoZW52LmVycm9ycykgdGhyb3cgZW52LmVycm9ycztcbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcbicpO1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIGEgTU1MIGRvY3VtZW50IChnaXZlbiBhcyBhbiBvYmplY3QpIGludG8gYVxuICogZnVsbHktbG9jYWxpemVkIFhNTCBmaWxlIHJlYWR5IGZvciBNYXBuaWsyIGNvbnN1bXB0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG0gLSB0aGUgSlNPTiBmaWxlIGFzIGEgc3RyaW5nLlxuICovXG5jYXJ0by5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKG0pIHtcbiAgICAvLyBlZmZlY3RzIGlzIGEgY29udGFpbmVyIGZvciBzaWRlLWVmZmVjdHMsIHdoaWNoIGN1cnJlbnRseVxuICAgIC8vIGFyZSBsaW1pdGVkIHRvIEZvbnRTZXRzLlxuICAgIHZhciBlbnYgPSBfLmRlZmF1bHRzKHRoaXMuZW52LCB7XG4gICAgICAgIGJlbmNobWFyazogZmFsc2UsXG4gICAgICAgIHZhbGlkYXRpb25fZGF0YTogZmFsc2UsXG4gICAgICAgIGVmZmVjdHM6IFtdLFxuICAgICAgICBwcGk6IDkwLjcxNFxuICAgIH0pO1xuXG4gICAgaWYgKCFjYXJ0by50cmVlLlJlZmVyZW5jZS5zZXRWZXJzaW9uKHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHNldCBtYXBuaWsgdmVyc2lvbiB0byBcIiArIHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbik7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgLy8gVHJhbnNmb3JtIHN0eWxlc2hlZXRzIGludG8gZGVmaW5pdGlvbnMuXG4gICAgdmFyIGRlZmluaXRpb25zID0gXy5jaGFpbihtLlN0eWxlc2hlZXQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3R5bGVzaGVldCBvYmplY3QgaXMgZXhwZWN0ZWQgbm90IGEgc3RyaW5nOiAnXCIgKyBzICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW52aXJvbm1lbnQgZnJvbSBzdHlsZXNoZWV0IHRvIHN0eWxlc2hlZXQsXG4gICAgICAgICAgICAvLyBhbGxvd3MgZnJhbWVzIGFuZCBlZmZlY3RzIHRvIGJlIG1haW50YWluZWQuXG4gICAgICAgICAgICBlbnYgPSBfLmV4dGVuZChlbnYsIHtmaWxlbmFtZTpzLmlkfSk7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gK25ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgcm9vdCA9IChjYXJ0by5QYXJzZXIoZW52KSkucGFyc2Uocy5kYXRhKTtcbiAgICAgICAgICAgIGlmIChlbnYuYmVuY2htYXJrKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyc2luZyB0aW1lOiAnICsgKG5ldyBEYXRlKCkgLSB0aW1lKSArICdtcycpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QudG9MaXN0KGVudik7XG4gICAgICAgIH0pXG4gICAgICAgIC5mbGF0dGVuKClcbiAgICAgICAgLnZhbHVlKCk7XG5cbiAgICBmdW5jdGlvbiBhcHBsaWVzVG8obmFtZSwgY2xhc3NJbmRleCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb24uYXBwbGllc1RvKGwubmFtZSwgY2xhc3NJbmRleCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGxheWVycyBhbmQgY3JlYXRlIHN0eWxlcyBjdXN0b20tYnVpbHRcbiAgICAvLyBmb3IgZWFjaCBvZiB0aGVtLCBhbmQgYXBwbHkgdGhvc2Ugc3R5bGVzIHRvIHRoZSBsYXllcnMuXG4gICAgdmFyIHN0eWxlcywgbCwgY2xhc3NJbmRleCwgcnVsZXMsIHNvcnRlZCwgbWF0Y2hpbmc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLkxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGwgPSBtLkxheWVyW2ldO1xuICAgICAgICBzdHlsZXMgPSBbXTtcbiAgICAgICAgY2xhc3NJbmRleCA9IHt9O1xuXG4gICAgICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLndhcm4oJ3Byb2Nlc3NpbmcgbGF5ZXI6ICcgKyBsLmlkKTtcbiAgICAgICAgLy8gQ2xhc3NlcyBhcmUgZ2l2ZW4gYXMgc3BhY2Utc2VwYXJhdGVkIGFscGhhbnVtZXJpYyBzdHJpbmdzLlxuICAgICAgICB2YXIgY2xhc3NlcyA9IChsWydjbGFzcyddIHx8ICcnKS5zcGxpdCgvXFxzKy9nKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjbGFzc0luZGV4W2NsYXNzZXNbal1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGluZyA9IGRlZmluaXRpb25zLmZpbHRlcihhcHBsaWVzVG8obC5uYW1lLCBjbGFzc0luZGV4KSk7XG4gICAgICAgIHJ1bGVzID0gaW5oZXJpdERlZmluaXRpb25zKG1hdGNoaW5nLCBlbnYpO1xuICAgICAgICBzb3J0ZWQgPSBzb3J0U3R5bGVzKHJ1bGVzLCBlbnYpO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBydWxlLCBzdHlsZV9uYW1lOyBrIDwgc29ydGVkLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBydWxlID0gc29ydGVkW2tdO1xuICAgICAgICAgICAgc3R5bGVfbmFtZSA9IGwubmFtZSArIChydWxlLmF0dGFjaG1lbnQgIT09ICdfX2RlZmF1bHRfXycgPyAnLScgKyBydWxlLmF0dGFjaG1lbnQgOiAnJyk7XG5cbiAgICAgICAgICAgIC8vIGVudi5lZmZlY3RzIGNhbiBiZSBtb2RpZmllZCBieSB0aGlzIGNhbGxcbiAgICAgICAgICAgIHZhciBzdHlsZVhNTCA9IGNhcnRvLnRyZWUuU3R5bGVYTUwoc3R5bGVfbmFtZSwgcnVsZS5hdHRhY2htZW50LCBydWxlLCBlbnYpO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGVYTUwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHlsZVhNTCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goc3R5bGVfbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaChjYXJ0by50cmVlLkxheWVyWE1MKGwsIHN0eWxlcykpO1xuICAgIH1cblxuICAgIG91dHB1dC51bnNoaWZ0KGVudi5lZmZlY3RzLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnRvWE1MKGVudik7XG4gICAgfSkuam9pbignXFxuJykpO1xuXG4gICAgdmFyIG1hcF9wcm9wZXJ0aWVzID0gZ2V0TWFwUHJvcGVydGllcyhtLCBkZWZpbml0aW9ucywgZW52KTtcblxuICAgIC8vIEV4aXQgb24gZXJyb3JzLlxuICAgIGlmIChlbnYuZXJyb3JzKSB0aHJvdyBlbnYuZXJyb3JzO1xuXG4gICAgLy8gUGFzcyBUaWxlSlNPTiBhbmQgb3RoZXIgY3VzdG9tIHBhcmFtZXRlcnMgdGhyb3VnaCB0byBNYXBuaWsgWE1MLlxuICAgIHZhciBwYXJhbWV0ZXJzID0gXy5yZWR1Y2UobSwgZnVuY3Rpb24obWVtbywgdiwgaykge1xuICAgICAgICBpZiAoIXYgJiYgdiAhPT0gMCkgcmV0dXJuIG1lbW87XG5cbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIC8vIEtub3duIHNraXBwYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgICBjYXNlICdzcnMnOlxuICAgICAgICBjYXNlICdMYXllcic6XG4gICAgICAgIGNhc2UgJ1N0eWxlc2hlZXQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE5vbiBVUkwtYm91bmQgVGlsZUpTT04gcHJvcGVydGllcy5cbiAgICAgICAgY2FzZSAnYm91bmRzJzpcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgY2FzZSAnbWluem9vbSc6XG4gICAgICAgIGNhc2UgJ21heHpvb20nOlxuICAgICAgICBjYXNlICd2ZXJzaW9uJzpcbiAgICAgICAgICAgIG1lbW8ucHVzaCgnICA8UGFyYW1ldGVyIG5hbWU9XCInICsgayArICdcIj4nICsgdiArICc8L1BhcmFtZXRlcj4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBDREFUQS5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgIGNhc2UgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICAgY2FzZSAnbGVnZW5kJzpcbiAgICAgICAgY2FzZSAnYXR0cmlidXRpb24nOlxuICAgICAgICBjYXNlICd0ZW1wbGF0ZSc6XG4gICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+PCFbQ0RBVEFbJyArIHYgKyAnXV0+PC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gTWFwbmlrIGltYWdlIGZvcm1hdC5cbiAgICAgICAgY2FzZSAnZm9ybWF0JzpcbiAgICAgICAgICAgIG1lbW8ucHVzaCgnICA8UGFyYW1ldGVyIG5hbWU9XCInICsgayArICdcIj4nICsgdiArICc8L1BhcmFtZXRlcj4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNYXBuaWsgaW50ZXJhY3Rpdml0eSBzZXR0aW5ncy5cbiAgICAgICAgY2FzZSAnaW50ZXJhY3Rpdml0eSc6XG4gICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiaW50ZXJhY3Rpdml0eV9sYXllclwiPicgKyB2LmxheWVyICsgJzwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cImludGVyYWN0aXZpdHlfZmllbGRzXCI+JyArIHYuZmllbGRzICsgJzwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFN1cHBvcnQgYW55IGFkZGl0aW9uYWwgc2NhbGFyIHByb3BlcnRpZXMuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cIicgKyBrICsgJ1wiPjwhW0NEQVRBWycgKyB2ICsgJ11dPjwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+JyArIHYgKyAnPC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+JyArIHYgKyAnPC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSk7XG4gICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoKSBvdXRwdXQudW5zaGlmdChcbiAgICAgICAgJzxQYXJhbWV0ZXJzPlxcbicgK1xuICAgICAgICBwYXJhbWV0ZXJzLmpvaW4oJ1xcbicpICtcbiAgICAgICAgJ1xcbjwvUGFyYW1ldGVycz5cXG4nXG4gICAgKTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gXy5tYXAobWFwX3Byb3BlcnRpZXMsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuICcgJyArIHY7IH0pLmpvaW4oJycpO1xuXG4gICAgb3V0cHV0LnVuc2hpZnQoXG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgJyArXG4gICAgICAgICdlbmNvZGluZz1cInV0Zi04XCI/PlxcbicgK1xuICAgICAgICAnPCFET0NUWVBFIE1hcFtdPlxcbicgK1xuICAgICAgICAnPE1hcCcgKyBwcm9wZXJ0aWVzICsnPlxcbicpO1xuICAgIG91dHB1dC5wdXNoKCc8L01hcD4nKTtcbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcbicpO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGN1cnJlbnRseSBtb2RpZmllcyAnY3VycmVudCdcbiAqIEBwYXJhbSB7QXJyYXl9ICBjdXJyZW50ICBjdXJyZW50IGxpc3Qgb2YgcnVsZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIGEgRGVmaW5pdGlvbiBvYmplY3QgdG8gYWRkIHRvIHRoZSBydWxlc1xuICogQHBhcmFtIHtPYmplY3R9IGJ5RmlsdGVyIGFuIG9iamVjdC9kaWN0aW9uYXJ5IG9mIGV4aXN0aW5nIGZpbHRlcnMuIFRoaXMgaXNcbiAqIGFjdHVhbGx5IGtleWVkIGBhdHRhY2htZW50LT5maWx0ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gZW52IHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4qL1xuZnVuY3Rpb24gYWRkUnVsZXMoY3VycmVudCwgZGVmaW5pdGlvbiwgYnlGaWx0ZXIsIGVudikge1xuICAgIHZhciBuZXdGaWx0ZXJzID0gZGVmaW5pdGlvbi5maWx0ZXJzLFxuICAgICAgICBuZXdSdWxlcyA9IGRlZmluaXRpb24ucnVsZXMsXG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzLCBjbG9uZSwgcHJldmlvdXM7XG5cbiAgICAvLyBUaGUgY3VycmVudCBkZWZpbml0aW9uIG1pZ2h0IGhhdmUgYmVlbiBzcGxpdCB1cCBpbnRvXG4gICAgLy8gbXVsdGlwbGUgZGVmaW5pdGlvbnMgYWxyZWFkeS5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGN1cnJlbnQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdXBkYXRlZEZpbHRlcnMgPSBjdXJyZW50W2tdLmZpbHRlcnMuY2xvbmVXaXRoKG5ld0ZpbHRlcnMpO1xuICAgICAgICBpZiAodXBkYXRlZEZpbHRlcnMpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gYnlGaWx0ZXJbdXBkYXRlZEZpbHRlcnNdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgZGVmaW5pdGlvbiB3aXRoIHRob3NlIGV4YWN0XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVycy4gQWRkIHRoZSBjdXJyZW50IGRlZmluaXRpb25zJyBydWxlc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBzdG9wIHByb2Nlc3NpbmcgaXQgYXMgdGhlIGV4aXN0aW5nIHJ1bGVcbiAgICAgICAgICAgICAgICAvLyBoYXMgYWxyZWFkeSBnb25lIGRvd24gdGhlIGluaGVyaXRhbmNlIGNoYWluLlxuICAgICAgICAgICAgICAgIHByZXZpb3VzLmFkZFJ1bGVzKG5ld1J1bGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBjdXJyZW50W2tdLmNsb25lKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSBvbmx5IG1haW50YWluaW5nIHRoZSBjbG9uZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgZGlkIGFjdHVhbGx5IGFkZCBydWxlcy4gSWYgbm90LCB0aGVyZSdzXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBrZWVwIHRoZSBjbG9uZSBhcm91bmQuXG4gICAgICAgICAgICAgICAgaWYgKGNsb25lLmFkZFJ1bGVzKG5ld1J1bGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBpbnNlcnRlZCBhbiBlbGVtZW50IGJlZm9yZSB0aGlzIG9uZSwgc28gd2UgbmVlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCBpbiB0aGUgbmV4dCBsb29wIGl0ZXJhdGlvbiwgd2UncmVcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHBlcmZvcm1pbmcgdGhlIHNhbWUgdGFzayBmb3IgdGhpcyBlbGVtZW50IGFnYWluLFxuICAgICAgICAgICAgICAgICAgICAvLyBoZW5jZSB0aGUgaysrLlxuICAgICAgICAgICAgICAgICAgICBieUZpbHRlclt1cGRhdGVkRmlsdGVyc10gPSBjbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaywgMCwgY2xvbmUpO1xuICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGaWx0ZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpZiB1cGRhdGVkRmlsdGVycyBpcyBudWxsLCB0aGVuIGFkZGluZyB0aGUgZmlsdGVycyBkb2Vzbid0XG4gICAgICAgICAgICAvLyBpbnZhbGlkYXRlIG9yIHNwbGl0IHRoZSBzZWxlY3Rvciwgc28gd2UgYWRkUnVsZXMgdG8gdGhlXG4gICAgICAgICAgICAvLyBjb21iaW5lZCBzZWxlY3RvclxuXG4gICAgICAgICAgICAvLyBGaWx0ZXJzIGNhbiBiZSBhZGRlZCwgYnV0IHRoZXkgZG9uJ3QgY2hhbmdlIHRoZVxuICAgICAgICAgICAgLy8gZmlsdGVycy4gVGhpcyBtZWFucyB3ZSBkb24ndCBoYXZlIHRvIHNwbGl0IHRoZVxuICAgICAgICAgICAgLy8gZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGNsb25lZCBoZXJlIGJlY2F1c2Ugb2Ygc2hhcmVkIGNsYXNzZXMsIHNlZVxuICAgICAgICAgICAgLy8gc2hhcmVkY2xhc3MubXNzXG4gICAgICAgICAgICBjdXJyZW50W2tdID0gY3VycmVudFtrXS5jbG9uZSgpO1xuICAgICAgICAgICAgY3VycmVudFtrXS5hZGRSdWxlcyhuZXdSdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXBkYXRlZEZlYXR1cmVzIGlzIGZhbHNlLCB0aGVuIHRoZSBmaWx0ZXJzIHNwbGl0IHRoZSBydWxlLFxuICAgICAgICAvLyBzbyB0aGV5IGFyZW4ndCB0aGUgc2FtZSBpbmhlcml0YW5jZSBjaGFpblxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cblxuLyoqXG4gKiBBcHBseSBpbmhlcml0ZWQgc3R5bGVzIGZyb20gdGhlaXIgYW5jZXN0b3JzIHRvIHRoZW0uXG4gKlxuICogY2FsbGVkIGVpdGhlciBvbmNlIHBlciByZW5kZXIgKGluIHRoZSBjYXNlIG9mIG1zcykgb3IgcGVyIGxheWVyXG4gKiAoZm9yIG1tbClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbnMgLSBhIGxpc3Qgb2YgZGVmaW5pdGlvbnMgb2JqZWN0c1xuICogICB0aGF0IGNvbnRhaW4gLnJ1bGVzXG4gKiBAcGFyYW0ge09iamVjdH0gZW52IC0gdGhlIGVudmlyb25tZW50XG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheT59IGFuIGFycmF5IG9mIGFycmF5cyBpcyByZXR1cm5lZCxcbiAqICAgaW4gd2hpY2ggZWFjaCBhcnJheSByZWZlcnMgdG8gYSBzcGVjaWZpYyBhdHRhY2htZW50XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXREZWZpbml0aW9ucyhkZWZpbml0aW9ucywgZW52KSB7XG4gICAgdmFyIGluaGVyaXRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgLy8gZGVmaW5pdGlvbnMgYXJlIG9yZGVyZWQgYnkgc3BlY2lmaWNpdHksXG4gICAgLy8gaGlnaCAoaW5kZXggMCkgdG8gbG93XG4gICAgdmFyIGJ5QXR0YWNobWVudCA9IHt9LFxuICAgICAgICBieUZpbHRlciA9IHt9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgY3VycmVudCwgcHJldmlvdXMsIGF0dGFjaG1lbnQ7XG5cbiAgICAvLyBFdmFsdWF0ZSB0aGUgZmlsdGVycyBzcGVjaWZpZWQgYnkgZWFjaCBkZWZpbml0aW9uIHdpdGggdGhlIGdpdmVuXG4gICAgLy8gZW52aXJvbm1lbnQgdG8gY29ycmVjdGx5IHJlc29sdmUgdmFyaWFibGUgcmVmZXJlbmNlc1xuICAgIGRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICBkLmZpbHRlcnMuZXYoZW52KTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmaW5pdGlvbnMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBhdHRhY2htZW50ID0gZGVmaW5pdGlvbnNbaV0uYXR0YWNobWVudDtcbiAgICAgICAgY3VycmVudCA9IFtkZWZpbml0aW9uc1tpXV07XG5cbiAgICAgICAgaWYgKCFieUF0dGFjaG1lbnRbYXR0YWNobWVudF0pIHtcbiAgICAgICAgICAgIGJ5QXR0YWNobWVudFthdHRhY2htZW50XSA9IFtdO1xuICAgICAgICAgICAgYnlBdHRhY2htZW50W2F0dGFjaG1lbnRdLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgYnlGaWx0ZXJbYXR0YWNobWVudF0gPSB7fTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJ5QXR0YWNobWVudFthdHRhY2htZW50XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIHN1YnNlcXVlbnQgcnVsZXMuXG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGRlZmluaXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbal0uYXR0YWNobWVudCA9PT0gYXR0YWNobWVudCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgaW5oZXJpdCBydWxlcyBmcm9tIHRoZSBzYW1lIGF0dGFjaG1lbnQuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGFkZFJ1bGVzKGN1cnJlbnQsIGRlZmluaXRpb25zW2pdLCBieUZpbHRlclthdHRhY2htZW50XSwgZW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY3VycmVudC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgYnlGaWx0ZXJbYXR0YWNobWVudF1bY3VycmVudFtrXS5maWx0ZXJzXSA9IGN1cnJlbnRba107XG4gICAgICAgICAgICBieUF0dGFjaG1lbnRbYXR0YWNobWVudF0ucHVzaChjdXJyZW50W2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLndhcm4oJ0luaGVyaXRhbmNlIHRpbWU6ICcgKyAoKG5ldyBEYXRlKCkgLSBpbmhlcml0VGltZSkpICsgJ21zJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG59XG5cbi8vIFNvcnQgc3R5bGVzIGJ5IHRoZSBtaW5pbXVtIGluZGV4IG9mIHRoZWlyIHJ1bGVzLlxuLy8gVGhpcyBzb3J0cyBhIHNsaWNlIG9mIHRoZSBzdHlsZXMsIHNvIGl0IHJldHVybnMgYSBzb3J0ZWRcbi8vIGFycmF5IGJ1dCBkb2VzIG5vdCBjaGFuZ2UgdGhlIGlucHV0LlxuZnVuY3Rpb24gc29ydFN0eWxlc0luZGV4KGEsIGIpIHsgcmV0dXJuIGIuaW5kZXggLSBhLmluZGV4OyB9XG5mdW5jdGlvbiBzb3J0U3R5bGVzKHN0eWxlcywgZW52KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICBzdHlsZS5pbmRleCA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IHN0eWxlLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBzdHlsZVtiXS5ydWxlcztcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnVsZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW3JdO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmluZGV4IDwgc3R5bGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5kZXggPSBydWxlLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBzdHlsZXMuc2xpY2UoKTtcbiAgICByZXN1bHQuc29ydChzb3J0U3R5bGVzSW5kZXgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRmluZCBhIHJ1bGUgbGlrZSBNYXAgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9LFxuICogaWYgYW55LCBhbmQgcmV0dXJuIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGJlIGluc2VydGVkXG4gKiBpbnRvIHRoZSA8TWFwIGVsZW1lbnQgb2YgdGhlIHJlc3VsdGluZyBYTUwuIFRyYW5zbGF0ZXNcbiAqIHByb3BlcnRpZXMgb2YgdGhlIG1tbCBvYmplY3QgYXQgYG1gIGRpcmVjdGx5IGludG8gWE1MXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtIHRoZSBtbWwgb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheX0gZGVmaW5pdGlvbnMgdGhlIG91dHB1dCBvZiB0b0xpc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gZW52XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJlbmRlcmVkIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcFByb3BlcnRpZXMobSwgZGVmaW5pdGlvbnMsIGVudikge1xuICAgIHZhciBydWxlcyA9IHt9O1xuICAgIHZhciBzeW1ib2xpemVycyA9IGNhcnRvLnRyZWUuUmVmZXJlbmNlLmRhdGEuc3ltYm9saXplcnMubWFwO1xuXG4gICAgXyhtKS5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiBzeW1ib2xpemVycykgcnVsZXNba2V5XSA9IGtleSArICc9XCInICsgdmFsdWUgKyAnXCInO1xuICAgIH0pO1xuXG4gICAgZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuZWxlbWVudHMuam9pbignJykgPT09ICdNYXAnO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHIucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSByLnJ1bGVzW2ldLm5hbWU7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gc3ltYm9saXplcnMpKSB7XG4gICAgICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1J1bGUgJyArIGtleSArICcgbm90IGFsbG93ZWQgZm9yIE1hcC4nLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogci5ydWxlc1tpXS5pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZXNba2V5XSA9IHIucnVsZXNbaV0uZXYoZW52KS50b1hNTChlbnYpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJ1bGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhcnRvO1xubW9kdWxlLmV4cG9ydHMuYWRkUnVsZXMgPSBhZGRSdWxlcztcbm1vZHVsZS5leHBvcnRzLmluaGVyaXREZWZpbml0aW9ucyA9IGluaGVyaXREZWZpbml0aW9ucztcbm1vZHVsZS5leHBvcnRzLnNvcnRTdHlsZXMgPSBzb3J0U3R5bGVzO1xuIiwiKGZ1bmN0aW9uKGNhcnRvKSB7XG52YXIgdHJlZSA9IHJlcXVpcmUoJy4vdHJlZScpO1xudmFyIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cblxuZnVuY3Rpb24gQ2FydG9DU1Moc3R5bGUsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5pbWFnZVVSTHMgPSBbXTtcbiAgaWYoc3R5bGUpIHtcbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbiAgfVxufVxuXG5DYXJ0b0NTUy5MYXllciA9IGZ1bmN0aW9uKHNoYWRlciwgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbn07XG5cblxuQ2FydG9DU1MuTGF5ZXIucHJvdG90eXBlID0ge1xuXG4gIGZ1bGxOYW1lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIuYXR0YWNobWVudDtcbiAgfSxcblxuICBuYW1lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsTmFtZSgpLnNwbGl0KCc6OicpWzBdO1xuICB9LFxuXG4gIC8vIGZyYW1lcyB0aGlzIGxheWVyIG5lZWQgdG8gYmUgcmVuZGVyZWRcbiAgZnJhbWVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIuZnJhbWVzO1xuICB9LFxuXG4gIGF0dGFjaG1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxOYW1lKCkuc3BsaXQoJzo6JylbMV07XG4gIH0sXG5cbiAgZXZhbDogZnVuY3Rpb24ocHJvcCkge1xuICAgIHZhciBwID0gdGhpcy5zaGFkZXJbcHJvcF07XG4gICAgaWYgKCFwIHx8ICFwLnN0eWxlKSByZXR1cm47XG4gICAgcmV0dXJuIHAuc3R5bGUoe30sIHsgem9vbTogMCwgJ2ZyYW1lLW9mZnNldCc6IDAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogYHByb3BzYDogZmVhdHVyZSBwcm9wZXJ0aWVzXG4gICAqIGBjb250ZXh0YDogcmVuZGVyaW5nIHByb3BlcnRpZXMsIGkuZSB6b29tXG4gICAqL1xuICBnZXRTdHlsZTogZnVuY3Rpb24ocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICBmb3IodmFyIGkgaW4gdGhpcy5zaGFkZXIpIHtcbiAgICAgIGlmKGkgIT09ICdhdHRhY2htZW50JyAmJiBpICE9PSAnem9vbScgJiYgaSAhPT0gJ2ZyYW1lcycgJiYgaSAhPT0gJ3N5bWJvbGl6ZXJzJykge1xuICAgICAgICBzdHlsZVtpXSA9IHRoaXMuc2hhZGVyW2ldLnN0eWxlKHByb3BzLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIHN5bWJvbGl6ZXJzIHRoYXQgbmVlZCB0byBiZSByZW5kZXJlZCB3aXRoIFxuICAgKiB0aGlzIHN0eWxlLiBUaGUgb3JkZXIgaXMgdGhlIHJlbmRlcmluZyBvcmRlci5cbiAgICogQHJldHVybnMgYSBsaXN0IHdpdGggMyBwb3NzaWJsZSB2YWx1ZXMgJ2xpbmUnLCAnbWFya2VyJywgJ3BvbHlnb24nXG4gICAqL1xuICBnZXRTeW1ib2xpemVyczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLnN5bWJvbGl6ZXJzO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGlmIHRoZSBzdHlsZSB2YXJpZXMgd2l0aCBzb21lIGZlYXR1cmUgcHJvcGVydHkuXG4gICAqIFVzZWZ1bCB0byBvcHRpbWl6ZSByZW5kZXJpbmdcbiAgICovXG4gIGlzVmFyaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgaSBpbiB0aGlzLnNoYWRlcikge1xuICAgICAgaWYoaSAhPT0gJ2F0dGFjaG1lbnQnICYmIGkgIT09ICd6b29tJyAmJiBpICE9PSAnZnJhbWVzJyAmJiBpICE9PSAnc3ltYm9saXplcnMnKSB7XG4gICAgICAgIGlmICghdGhpcy5zaGFkZXJbaV0uY29uc3RhbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgZ2V0U2hhZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybnMgdHJ1ZSBpZiBhIGZlYXR1cmUgbmVlZHMgdG8gYmUgcmVuZGVyZWRcbiAgICovXG4gIGZpbHRlcjogZnVuY3Rpb24oZmVhdHVyZVR5cGUsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgZm9yKHZhciBpIGluIHRoaXMuc2hhZGVyKSB7XG4gICAgIHZhciBzID0gdGhpcy5zaGFkZXJbaV0ocHJvcHMsIGNvbnRleHQpO1xuICAgICBpZihzKSB7XG4gICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8vXG4gIC8vIGdpdmVuIGEgZ2VvZW10cnkgdHlwZSByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCBvbmUgYWNvcmRpbmcgdGhlIENhcnRvQ1NTXG4gIC8vIEZvciBwb2ludHMgdGhlcmUgYXJlIHR3byBraW5kIG9mIHR5cGVzOiBwb2ludCBhbmQgc3ByaXRlLCB0aGUgZmlyc3Qgb25lIFxuICAvLyBpcyBhIGNpcmNsZSwgc2Vjb25kIG9uZSBpcyBhbiBpbWFnZSBzcHJpdGVcbiAgLy9cbiAgLy8gdGhlIG90aGVyIGdlb21ldHJ5IHR5cGVzIGFyZSB0aGUgc2FtZSB0aGFuIGdlb2pzb24gKHBvbHlnb24sIGxpbmVzdHJpbmcuLi4pXG4gIC8vXG4gIHRyYW5zZm9ybUdlb21ldHJ5OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH0sXG5cbiAgdHJhbnNmb3JtR2VvbWV0cmllczogZnVuY3Rpb24oZ2VvanNvbikge1xuICAgIHJldHVybiBnZW9qc29uO1xuICB9XG5cbn07XG5cbkNhcnRvQ1NTLnByb3RvdHlwZSA9IHtcblxuICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5wYXJzZShzdHlsZSk7XG4gICAgaWYoIWxheWVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMucGFyc2VfZW52LmVycm9ycyk7XG4gICAgfVxuICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzLm1hcChmdW5jdGlvbihzaGFkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJ0b0NTUy5MYXllcihzaGFkZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIGdldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICB9LFxuXG4gIGdldERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRMYXllcih7IGF0dGFjaG1lbnQ6ICdfX2RlZmF1bHRfXycgfSk7XG4gIH0sXG5cbiAgZmluZExheWVyOiBmdW5jdGlvbih3aGVyZSkge1xuICAgIHJldHVybiBfLmZpbmQodGhpcy5sYXllcnMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gd2hlcmUpIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mKHYpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdiA9IHYuY2FsbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoZXJlW2tleV0gIT09IHYpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9LFxuXG4gIF9jcmVhdGVGbjogZnVuY3Rpb24ob3BzKSB7XG4gICAgdmFyIGJvZHkgPSBvcHMuam9pbignXFxuJyk7XG4gICAgaWYodGhpcy5vcHRpb25zLmRlYnVnKSBjb25zb2xlLmxvZyhib2R5KTtcbiAgICByZXR1cm4gRnVuY3Rpb24oXCJkYXRhXCIsXCJjdHhcIiwgXCJ2YXIgX3ZhbHVlID0gbnVsbDsgXCIgKyAgYm9keSArIFwiOyByZXR1cm4gX3ZhbHVlOyBcIik7XG4gIH0sXG5cbiAgX2NvbXBpbGU6IGZ1bmN0aW9uKHNoYWRlcikge1xuICAgIGlmKHR5cGVvZiBzaGFkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNoYWRlciA9IGV2YWwoXCIoZnVuY3Rpb24oKSB7IHJldHVybiBcIiArIHNoYWRlciArXCI7IH0pKClcIik7XG4gICAgfVxuICAgIHRoaXMuc2hhZGVyX3NyYyA9IHNoYWRlcjtcbiAgICBmb3IodmFyIGF0dHIgaW4gc2hhZGVyKSB7XG4gICAgICAgIHZhciBjID0gbWFwcGVyW2F0dHJdO1xuICAgICAgICBpZihjKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVkW2NdID0gZXZhbChcIihmdW5jdGlvbigpIHsgcmV0dXJuIHNoYWRlclthdHRyXTsgfSkoKTtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdldEltYWdlVVJMczogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVVSTHM7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGNhcnRvY3NzKSB7XG4gICAgdmFyIHBhcnNlX2VudiA9IHtcbiAgICAgIGZyYW1lczogW10sXG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnBhcnNlX2VudiA9IHBhcnNlX2VudjtcblxuICAgIHZhciBydWxlc2V0ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcnVsZXNldCA9IChuZXcgY2FydG8uUGFyc2VyKHBhcnNlX2VudikpLnBhcnNlKGNhcnRvY3NzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIGFkZCB0aGUgc3R5bGUubXNzIHN0cmluZyB0byBtYXRjaCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICBwYXJzZV9lbnYuZXJyb3JzLnB1c2goZS5tZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYocnVsZXNldCkge1xuXG4gICAgICBmdW5jdGlvbiBkZWZLZXkoZGVmKSB7XG4gICAgICAgIHJldHVybiBkZWYuZWxlbWVudHNbMF0gKyBcIjo6XCIgKyBkZWYuYXR0YWNobWVudDtcbiAgICAgIH1cbiAgICAgIHZhciBkZWZzID0gcnVsZXNldC50b0xpc3QocGFyc2VfZW52KTtcbiAgICAgIGRlZnMucmV2ZXJzZSgpO1xuICAgICAgLy8gZ3JvdXAgYnkgZWxlbWVudHNbMF0udmFsdWU6OmF0dGFjaG1lbnRcbiAgICAgIHZhciBsYXllcnMgPSB7fTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkZWZzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2ldO1xuICAgICAgICB2YXIga2V5ID0gZGVmS2V5KGRlZik7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1trZXldID0gKGxheWVyc1trZXldIHx8IHtcbiAgICAgICAgICBzeW1ib2xpemVyczogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGZvcih2YXIgdSA9IDA7IHU8ZGVmLnJ1bGVzLmxlbmd0aDsgdSsrKXtcbiAgICAgICAgICAgIGlmKGRlZi5ydWxlc1t1XS5uYW1lID09PSBcIm1hcmtlci1maWxlXCIgfHwgZGVmLnJ1bGVzW3VdLm5hbWUgPT09IFwicG9pbnQtZmlsZVwiKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkZWYucnVsZXNbdV0udmFsdWUudmFsdWVbMF0udmFsdWVbMF0udmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZVVSTHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIGxheWVyLmZyYW1lcyA9IFtdO1xuICAgICAgICBsYXllci56b29tID0gdHJlZS5ab29tLmFsbDtcbiAgICAgICAgdmFyIHByb3BzID0gZGVmLnRvSlMocGFyc2VfZW52KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZykgY29uc29sZS5sb2coXCJwcm9wc1wiLCBwcm9wcyk7XG4gICAgICAgIGZvcih2YXIgdiBpbiBwcm9wcykge1xuICAgICAgICAgIHZhciBseXIgPSBsYXllclt2XSA9IGxheWVyW3ZdIHx8IHtcbiAgICAgICAgICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICAgICAgICAgIHN5bWJvbGl6ZXI6IG51bGwsXG4gICAgICAgICAgICBqczogW10sXG4gICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gYnVpbGQgamF2YXNjcmlwdCBzdGF0ZW1lbnRzXG4gICAgICAgICAgbHlyLmpzLnB1c2gocHJvcHNbdl0ubWFwKGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGEuanM7IH0pLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAvLyBnZXQgc3ltYm9saXplciBmb3IgcHJvcFxuICAgICAgICAgIGx5ci5zeW1ib2xpemVyID0gXy5maXJzdChwcm9wc1t2XS5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5zeW1ib2xpemVyOyB9KSk7XG4gICAgICAgICAgLy8gc2VyYWNoIHRoZSBtYXggaW5kZXggdG8ga25vdyByZW5kZXJpbmcgb3JkZXJcbiAgICAgICAgICBseXIuaW5kZXggPSBfLm1heChwcm9wc1t2XS5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5pbmRleDsgfSkuY29uY2F0KGx5ci5pbmRleCkpO1xuICAgICAgICAgIGx5ci5jb25zdGFudCA9ICFfLmFueShwcm9wc1t2XS5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gIWEuY29uc3RhbnQ7IH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JkZXJlZF9sYXllcnMgPSBbXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIGNvbnNvbGUubG9nKGxheWVycyk7XG5cbiAgICAgIHZhciBkb25lID0ge307XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgdmFyIGsgPSBkZWZLZXkoZGVmKTtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2tdO1xuICAgICAgICBpZighZG9uZVtrXSkge1xuICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kZWJ1ZykgY29uc29sZS5sb2coXCIqKlwiLCBrKTtcbiAgICAgICAgICBmb3IodmFyIHByb3AgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnem9vbScgJiYgcHJvcCAhPT0gJ2ZyYW1lcycgJiYgcHJvcCAhPT0gJ3N5bWJvbGl6ZXJzJykge1xuICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGVidWcpIGNvbnNvbGUubG9nKFwiKlwiLCBwcm9wKTtcbiAgICAgICAgICAgICAgbGF5ZXJbcHJvcF0uc3R5bGUgPSB0aGlzLl9jcmVhdGVGbihsYXllcltwcm9wXS5qcyk7XG4gICAgICAgICAgICAgIGxheWVyLnN5bWJvbGl6ZXJzLnB1c2gobGF5ZXJbcHJvcF0uc3ltYm9saXplcik7XG4gICAgICAgICAgICAgIGxheWVyLnN5bWJvbGl6ZXJzID0gXy51bmlxKGxheWVyLnN5bWJvbGl6ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGF5ZXIuYXR0YWNobWVudCA9IGs7XG4gICAgICAgICAgb3JkZXJlZF9sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgZG9uZVtrXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIuem9vbSB8PSBkZWYuem9vbTtcbiAgICAgICAgbGF5ZXIuZnJhbWVzLnB1c2goZGVmLmZyYW1lX29mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVuaXEgdGhlIGZyYW1lc1xuICAgICAgZm9yKGkgPSAwOyBpIDwgb3JkZXJlZF9sYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgb3JkZXJlZF9sYXllcnNbaV0uZnJhbWVzID0gXy51bmlxKG9yZGVyZWRfbGF5ZXJzW2ldLmZyYW1lcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmRlcmVkX2xheWVycztcblxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG5jYXJ0by5SZW5kZXJlckpTID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbiA9IHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbiB8fCAnbGF0ZXN0Jztcbn07XG5cbi8vIFByZXBhcmUgYSBqYXZhc2NyaXB0IG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgbGF5ZXJzXG5jYXJ0by5SZW5kZXJlckpTLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2FydG9jc3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vdG9ycXVlLXJlZmVyZW5jZScpO1xuICAgIHRyZWUuUmVmZXJlbmNlLnNldERhdGEocmVmZXJlbmNlLnZlcnNpb24ubGF0ZXN0KTtcbiAgICByZXR1cm4gbmV3IENhcnRvQ1NTKGNhcnRvY3NzLCB0aGlzLm9wdGlvbnMpO1xufVxuXG5pZih0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjYXJ0by5SZW5kZXJlckpTO1xufVxuXG5cbn0pKHJlcXVpcmUoJy4uL2NhcnRvJykpO1xuIiwidmFyIF9tYXBuaWtfcmVmZXJlbmNlX2xhdGVzdCA9IHtcbiAgICBcInZlcnNpb25cIjogXCIyLjEuMVwiLFxuICAgIFwic3R5bGVcIjoge1xuICAgICAgICBcImZpbHRlci1tb2RlXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgXCJhbGxcIixcbiAgICAgICAgICAgICAgICBcImZpcnN0XCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgdGhlIHByb2Nlc3NpbmcgYmVoYXZpb3Igb2YgUnVsZSBmaWx0ZXJzIHdpdGhpbiBhIFN0eWxlLiBJZiAnYWxsJyBpcyB1c2VkIHRoZW4gYWxsIFJ1bGVzIGFyZSBwcm9jZXNzZWQgc2VxdWVudGlhbGx5IGluZGVwZW5kZW50IG9mIHdoZXRoZXIgYW55IHByZXZpb3VzIGZpbHRlcnMgbWF0Y2hlZC4gSWYgJ2ZpcnN0JyBpcyB1c2VkIHRoZW4gaXQgbWVhbnMgcHJvY2Vzc2luZyBlbmRzIGFmdGVyIHRoZSBmaXJzdCBtYXRjaCAoYSBwb3NpdGl2ZSBmaWx0ZXIgZXZhbHVhdGlvbikgYW5kIG5vIGZ1cnRoZXIgUnVsZXMgaW4gdGhlIFN0eWxlIGFyZSBwcm9jZXNzZWQgKCdmaXJzdCcgaXMgdXN1YWxseSB0aGUgZGVmYXVsdCBmb3IgQ1NTIGltcGxlbWVudGF0aW9ucyBvbiB0b3Agb2YgTWFwbmlrIHRvIHNpbXBsaWZ5IHRyYW5zbGF0aW9uIGZyb20gQ1NTIHRvIE1hcG5payBYTUwpXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJhbGxcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiQWxsIFJ1bGVzIGluIGEgU3R5bGUgYXJlIHByb2Nlc3NlZCB3aGV0aGVyIHRoZXkgaGF2ZSBmaWx0ZXJzIG9yIG5vdCBhbmQgd2hldGhlciBvciBub3QgdGhlIGZpbHRlciBjb25kaXRpb25zIGV2YWx1YXRlIHRvIHRydWUuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbWFnZS1maWx0ZXJzXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiaW1hZ2UtZmlsdGVyc1wiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBmaWx0ZXJzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb25zXCI6IFtcbiAgICAgICAgICAgICAgICBbXCJhZ2ctc3RhY2stYmx1clwiLCAyXSxcbiAgICAgICAgICAgICAgICBbXCJlbWJvc3NcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wiYmx1clwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJncmF5XCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcInNvYmVsXCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImVkZ2UtZGV0ZWN0XCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcIngtZ3JhZGllbnRcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wieS1ncmFkaWVudFwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJpbnZlcnRcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wic2hhcnBlblwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJjb2xvcml6ZS1hbHBoYVwiLCAtMV0sXG4gICAgICAgICAgICAgICAgW1wiY29sb3ItdG8tYWxwaGFcIiwgMV0sXG4gICAgICAgICAgICAgICAgW1wic2NhbGUtaHNsYVwiLCA4XVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBsaXN0IG9mIGltYWdlIGZpbHRlcnMuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiY29tcC1vcFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IGxheWVyIG9uIHRvcCBvZiBvdGhlciBsYXllcnNcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIGxheWVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gbGF5ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogW1wiY2xlYXJcIixcbiAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwic291cmNlLW92ZXJcIiwgLy8gYWRkZWQgZm9yIHRvcnF1ZVxuICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgIFwibGlnaHRlclwiLCAvLyBhZGRlZCBmb3IgdG9ycXVlXG4gICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCJvcGFjaXR5XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBhbHBoYSB2YWx1ZSBmb3IgdGhlIHN0eWxlICh3aGljaCBtZWFucyBhbiBhbHBoYSBhcHBsaWVkIHRvIGFsbCBmZWF0dXJlcyBpbiBzZXBhcmF0ZSBidWZmZXIgYW5kIHRoZW4gY29tcG9zaXRlZCBiYWNrIHRvIG1haW4gYnVmZmVyKVwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNlcGFyYXRlIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYW5kIG5vIGFscGhhIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgc3R5bGUgYWZ0ZXIgcmVuZGVyaW5nXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJsYXllclwiIDoge1xuICAgICAgICBcIm5hbWVcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICBcInR5cGVcIjpcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiIDogdHJ1ZSxcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gbGF5ZXIgbmFtZSBoYXMgYmVlbiBwcm92aWRlZFwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbmFtZSBvZiBhIGxheWVyLiBDYW4gYmUgYW55dGhpbmcgeW91IHdpc2ggYW5kIGlzIG5vdCBzdHJpY3RseSB2YWxpZGF0ZWQsIGJ1dCBpZGVhbGx5IHVuaXF1ZSAgaW4gdGhlIG1hcFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3JzXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gc3JzIHZhbHVlIGlzIHByb3ZpZGVkIGFuZCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgTWFwJ3Mgc3JzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW0gZGVmaW5pdGlvbiBmb3IgdGhlIGxheWVyLCBha2EgdGhlIHByb2plY3Rpb24uIENhbiBlaXRoZXIgYmUgYSBwcm9qNCBsaXRlcmFsIHN0cmluZyBsaWtlICcrcHJvaj1sb25nbGF0ICtlbGxwcz1XR1M4NCArZGF0dW09V0dTODQgK25vX2RlZnMnIG9yLCBpZiB0aGUgcHJvcGVyIHByb2o0IGVwc2cvbmFkL2V0YyBpZGVudGlmaWVyIGZpbGVzIGFyZSBpbnN0YWxsZWQsIGEgc3RyaW5nIHRoYXQgdXNlcyBhbiBpZCBsaWtlOiAnK2luaXQ9ZXBzZzo0MzI2J1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoaXMgbGF5ZXIgd2lsbCBiZSBtYXJrZWQgYXMgYWN0aXZlIGFuZCBhdmFpbGFibGUgZm9yIHByb2Nlc3NpbmdcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBwcm9wZXJ0eSB0aGF0IGNhbiBiZSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGxheWVyIGZyb20gYmVpbmcgcHJvY2Vzc2VkXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtaW56b29tXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjBcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwiZmxvYXRcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIGxheWVyIHdpbGwgYmUgdmlzaWJsZSBhdCB0aGUgbWluaW11bSBwb3NzaWJsZSBzY2FsZVwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSBzY2FsZSBkZW5vbWluYXRvciB0aGF0IHRoaXMgbGF5ZXIgd2lsbCBiZSB2aXNpYmxlIGF0LiBBIGxheWVyJ3MgdmlzaWJpbGl0eSBpcyBkZXRlcm1pbmVkIGJ5IHdoZXRoZXIgaXRzIHN0YXR1cyBpcyB0cnVlIGFuZCBpZiB0aGUgTWFwIHNjYWxlID49IG1pbnpvb20gLSAxZS02IGFuZCBzY2FsZSA8IG1heHpvb20gKyAxZS02XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXh6b29tXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjEuNzk3NjllKzMwOFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgbGF5ZXIgd2lsbCBiZSB2aXNpYmxlIGF0IHRoZSBtYXhpbXVtIHBvc3NpYmxlIHNjYWxlXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHNjYWxlIGRlbm9taW5hdG9yIHRoYXQgdGhpcyBsYXllciB3aWxsIGJlIHZpc2libGUgYXQuIFRoZSBkZWZhdWx0IGlzIHRoZSBudW1lcmljIGxpbWl0IG9mIHRoZSBDKysgZG91YmxlIHR5cGUsIHdoaWNoIG1heSB2YXJ5IHNsaWdodGx5IGJ5IHN5c3RlbSwgYnV0IGlzIGxpa2VseSBhIG1hc3NpdmUgbnVtYmVyIGxpa2UgMS43OTc2OWUrMzA4IGFuZCBlbnN1cmVzIHRoYXQgdGhpcyBsYXllciB3aWxsIGFsd2F5cyBiZSB2aXNpYmxlIHVubGVzcyB0aGUgdmFsdWUgaXMgcmVkdWNlZC4gQSBsYXllcidzIHZpc2liaWxpdHkgaXMgZGV0ZXJtaW5lZCBieSB3aGV0aGVyIGl0cyBzdGF0dXMgaXMgdHJ1ZSBhbmQgaWYgdGhlIE1hcCBzY2FsZSA+PSBtaW56b29tIC0gMWUtNiBhbmQgc2NhbGUgPCBtYXh6b29tICsgMWUtNlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicXVlcnlhYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwidHlwZVwiOlwiYm9vbGVhblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgbGF5ZXIgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGZvciB0aGUgZGlyZWN0IHF1ZXJ5aW5nIG9mIGRhdGEgdmFsdWVzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoaXMgcHJvcGVydHkgd2FzIGFkZGVkIGZvciBHZXRGZWF0dXJlSW5mby9XTVMgY29tcGF0aWJpbGl0eSBhbmQgaXMgcmFyZWx5IHVzZWQuIEl0IGlzIG9mZiBieSBkZWZhdWx0IG1lYW5pbmcgdGhhdCBpbiBhIFdNUyBjb250ZXh0IHRoZSBsYXllciB3aWxsIG5vdCBiZSBhYmxlIHRvIGJlIHF1ZXJpZWQgdW5sZXNzIHRoZSBwcm9wZXJ0eSBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjbGVhci1sYWJlbC1jYWNoZVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICBcInR5cGVcIjpcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIHJlbmRlcmVyJ3MgY29sbGlzaW9uIGRldGVjdG9yIGNhY2hlICh1c2VkIGZvciBhdm9pZGluZyBkdXBsaWNhdGUgbGFiZWxzIGFuZCBvdmVybGFwcGluZyBtYXJrZXJzKSB3aWxsIG5vdCBiZSBjbGVhcmVkIGltbWVkaWF0ZWx5IGJlZm9yZSBwcm9jZXNzaW5nIHRoaXMgbGF5ZXJcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhpcyBwcm9wZXJ0eSwgYnkgZGVmYXVsdCBvZmYsIGNhbiBiZSBlbmFibGVkIHRvIGFsbG93IGEgdXNlciB0byBjbGVhciB0aGUgY29sbGlzaW9uIGRldGVjdG9yIGNhY2hlIGJlZm9yZSBhIGdpdmVuIGxheWVyIGlzIHByb2Nlc3NlZC4gVGhpcyBtYXkgYmUgZGVzaXJhYmxlIHRvIGVuc3VyZSB0aGF0IGEgZ2l2ZW4gbGF5ZXJzIGRhdGEgc2hvd3MgdXAgb24gdGhlIG1hcCBldmVuIGlmIGl0IG5vcm1hbGx5IHdvdWxkIG5vdCBiZWNhdXNlIG9mIGNvbGxpc2lvbnMgd2l0aCBwcmV2aW91c2x5IHJlbmRlcmVkIGxhYmVscyBvciBtYXJrZXJzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJncm91cC1ieVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIHNwZWNpYWwgbGF5ZXIgZ3JvdXBpbmcgd2lsbCBiZSB1c2VkIGR1cmluZyByZW5kZXJpbmdcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL21hcG5pay9tYXBuaWsvd2lraS9Hcm91cGVkLXJlbmRlcmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYnVmZmVyLXNpemVcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBidWZmZXIgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkV4dHJhIHRvbGVyYW5jZSBhcm91bmQgdGhlIExheWVyIGV4dGVudCAoaW4gcGl4ZWxzKSB1c2VkIHRvIHdoZW4gcXVlcnlpbmcgYW5kIChwb3RlbnRpYWxseSkgY2xpcHBpbmcgdGhlIGxheWVyIGRhdGEgZHVyaW5nIHJlbmRlcmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4aW11bS1leHRlbnRcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJiYm94XCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIGNsaXBwaW5nIGV4dGVudCB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gZXh0ZW50IHRvIGJlIHVzZWQgdG8gbGltaXQgdGhlIGJvdW5kcyB1c2VkIHRvIHF1ZXJ5IHRoaXMgc3BlY2lmaWMgbGF5ZXIgZGF0YSBkdXJpbmcgcmVuZGVyaW5nLiBTaG91bGQgYmUgbWlueCwgbWlueSwgbWF4eCwgbWF4eSBpbiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIExheWVyLlwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwic3ltYm9saXplcnNcIiA6IHtcbiAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICAgIFwiaW1hZ2UtZmlsdGVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJpbWFnZS1maWx0ZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gZmlsdGVyc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uc1wiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgW1wiYWdnLXN0YWNrLWJsdXJcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcImVtYm9zc1wiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiYmx1clwiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiZ3JheVwiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic29iZWxcIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcImVkZ2UtZGV0ZWN0XCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJ4LWdyYWRpZW50XCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJ5LWdyYWRpZW50XCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJpbnZlcnRcIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNoYXJwZW5cIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcImNvbG9yaXplLWFscGhhXCIsIC0xXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiY29sb3ItdG8tYWxwaGFcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNjYWxlLWhzbGFcIiwgOF0sXG4gICAgICAgICAgICAgICAgICAgIFtcImJ1Y2tldHNcIiwgLTFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJjYXRlZ29yeVwiLCAtMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcImVxdWFsXCIsIC0xXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiaGVhZHRhaWxzXCIsIC0xXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiamVua3NcIiwgLTFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJxdWFudGlsZXNcIiwgLTFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJjYXJ0b2NvbG9yXCIsIC0xXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiY29sb3JicmV3ZXJcIiwgLTFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJyYW5nZVwiLCAtMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJhbXBcIiwgLTFdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgbGlzdCBvZiBpbWFnZSBmaWx0ZXJzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImNvbXAtb3BcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IGxheWVyIG9uIHRvcCBvZiBvdGhlciBsYXllcnNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBsYXllciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIGxheWVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic291cmNlLW92ZXJcIiwgLy8gYWRkZWQgZm9yIHRvcnF1ZVxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJvdmVybGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGFya2VuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZXJcIiwgLy8gYWRkZWQgZm9yIHRvcnF1ZVxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWRvZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhcmQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb2Z0LWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImV4Y2x1c2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbnRyYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0LXJnYlwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLW1lcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImh1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNhdHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gYWxwaGEgdmFsdWUgZm9yIHRoZSBzdHlsZSAod2hpY2ggbWVhbnMgYW4gYWxwaGEgYXBwbGllZCB0byBhbGwgZmVhdHVyZXMgaW4gc2VwYXJhdGUgYnVmZmVyIGFuZCB0aGVuIGNvbXBvc2l0ZWQgYmFjayB0byBtYWluIGJ1ZmZlcilcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNlcGFyYXRlIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYW5kIG5vIGFscGhhIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgc3R5bGUgYWZ0ZXIgcmVuZGVyaW5nXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJhY2tncm91bmQtY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJNYXAgQmFja2dyb3VuZCBjb2xvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWltYWdlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJhY2tncm91bmQtaW1hZ2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBpbWFnZSB0aGF0IGlzIHJlcGVhdGVkIGJlbG93IGFsbCBmZWF0dXJlcyBvbiBhIG1hcCBhcyBhIGJhY2tncm91bmQuXCIsXG4gICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk1hcCBCYWNrZ3JvdW5kIGltYWdlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzcnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIrcHJvaj1sb25nbGF0ICtlbGxwcz1XR1M4NCArZGF0dW09V0dTODQgK25vX2RlZnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBwcm9qNCBsaXRlcmFsIG9mIEVQU0c6NDMyNiBpcyBhc3N1bWVkIHRvIGJlIHRoZSBNYXAncyBzcGF0aWFsIHJlZmVyZW5jZSBhbmQgYWxsIGRhdGEgZnJvbSBsYXllcnMgd2l0aGluIHRoaXMgbWFwIHdpbGwgYmUgcGxvdHRlZCB1c2luZyB0aGlzIGNvb3JkaW5hdGUgc3lzdGVtLiBJZiBhbnkgbGF5ZXJzIGRvIG5vdCBkZWNsYXJlIGFuIHNycyB2YWx1ZSB0aGVuIHRoZXkgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHNycyBhcyB0aGUgTWFwIGFuZCBub3QgdHJhbnNmb3JtYXRpb25zIHdpbGwgYmUgbmVlZGVkIHRvIHBsb3QgdGhlbSBpbiB0aGUgTWFwJ3MgY29vcmRpbmF0ZSBzcGFjZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTWFwIHNwYXRpYWwgcmVmZXJlbmNlIChwcm9qNCBzdHJpbmcpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJ1ZmZlci1zaXplXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJ1ZmZlci1zaXplXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOlwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIGJ1ZmZlciB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkV4dHJhIHRvbGVyYW5jZSBhcm91bmQgdGhlIG1hcCAoaW4gcGl4ZWxzKSB1c2VkIHRvIGVuc3VyZSBsYWJlbHMgY3Jvc3NpbmcgdGlsZSBib3VuZGFyaWVzIGFyZSBlcXVhbGx5IHJlbmRlcmVkIGluIGVhY2ggdGlsZSAoZS5nLiBjdXQgaW4gZWFjaCB0aWxlKS4gTm90IGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBcXFwiYXZvaWQtZWRnZXNcXFwiLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtYXhpbXVtLWV4dGVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJiYm94XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBjbGlwcGluZyBleHRlbnQgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBleHRlbnQgdG8gYmUgdXNlZCB0byBsaW1pdCB0aGUgYm91bmRzIHVzZWQgdG8gcXVlcnkgYWxsIGxheWVycyBkdXJpbmcgcmVuZGVyaW5nLiBTaG91bGQgYmUgbWlueCwgbWlueSwgbWF4eCwgbWF4eSBpbiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIE1hcC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYmFzZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJiYXNlXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGlzIGJhc2UgcGF0aCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcgbWVhbmluZyB0aGF0IGFueSByZWxhdGl2ZSBwYXRocyB0byBmaWxlcyByZWZlcmVuY2VkIGluIHN0eWxlcyBvciBsYXllcnMgd2lsbCBiZSBpbnRlcnByZXRlZCByZWxhdGl2ZSB0byB0aGUgYXBwbGljYXRpb24gcHJvY2Vzcy5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFueSByZWxhdGl2ZSBwYXRocyB1c2VkIHRvIHJlZmVyZW5jZSBmaWxlcyB3aWxsIGJlIHVuZGVyc3Rvb2QgYXMgcmVsYXRpdmUgdG8gdGhpcyBkaXJlY3RvcnkgcGF0aCBpZiB0aGUgbWFwIGlzIGxvYWRlZCBmcm9tIGFuIGluIG1lbW9yeSBvYmplY3QgcmF0aGVyIHRoYW4gZnJvbSB0aGUgZmlsZXN5c3RlbS4gSWYgdGhlIG1hcCBpcyBsb2FkZWQgZnJvbSB0aGUgZmlsZXN5c3RlbSBhbmQgdGhpcyBvcHRpb24gaXMgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBkaXJlY3Rvcnkgb2YgdGhlIHN0eWxlc2hlZXQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBhdGhzLWZyb20teG1sXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiUGF0aHMgcmVhZCBmcm9tIFhNTCB3aWxsIGJlIGludGVycHJldGVkIGZyb20gdGhlIGxvY2F0aW9uIG9mIHRoZSBYTUxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJ2YWx1ZSB0byBjb250cm9sIHdoZXRoZXIgcGF0aHMgaW4gdGhlIFhNTCB3aWxsIGJlIGludGVycHJldGVkIGZyb20gdGhlIGxvY2F0aW9uIG9mIHRoZSBYTUwgb3IgZnJvbSB0aGUgd29ya2luZyBkaXJlY3Rvcnkgb2YgdGhlIHByb2dyYW0gdGhhdCBjYWxscyBsb2FkX21hcCgpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1pbmltdW0tdmVyc2lvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJNYXBuaWsgdmVyc2lvbiB3aWxsIG5vdCBiZSBkZXRlY3RlZCBhbmQgbm8gZXJyb3Igd2lsbCBiZSB0aHJvd24gYWJvdXQgY29tcGF0aWJpbGl0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbnVtdW0gTWFwbmlrIHZlcnNpb24gKGUuZy4gMC43LjIpIG5lZWRlZCB0byB1c2UgY2VydGFpbiBmdW5jdGlvbmFsaXR5IGluIHRoZSBzdHlsZXNoZWV0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZvbnQtZGlyZWN0b3J5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImZvbnQtZGlyZWN0b3J5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gbWFwLXNwZWNpZmljIGZvbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiUGF0aCB0byBhIGRpcmVjdG9yeSB3aGljaCBob2xkcyBmb250cyB3aGljaCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aGVuIHRoZSBNYXAgaXMgbG9hZGVkIChpbiBhZGRpdGlvbiB0byBhbnkgZm9udHMgdGhhdCBtYXkgYmUgYXV0b21hdGljYWxseSByZWdpc3RlcmVkKS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvbHlnb25cIjoge1xuICAgICAgICAgICAgXCJmaWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgxMjgsMTI4LDEyOCwxKVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ3JheSBhbmQgZnVsbHkgb3BhcXVlIChhbHBoYSA9IDEpLCBzYW1lIGFzIHJnYigxMjgsMTI4LDEyOClcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkZpbGwgY29sb3IgdG8gYXNzaWduIHRvIGEgcG9seWdvblwiLFxuICAgICAgICAgICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBwb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2FtbWFcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1nYW1tYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJmdWxseSBhbnRpYWxpYXNlZFwiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkxldmVsIG9mIGFudGlhbGlhc2luZyBvZiBwb2x5Z29uIGVkZ2VzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdhbW1hLW1ldGhvZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLWdhbW1hLW1ldGhvZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwicG93ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaW5lYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGhyZXNob2xkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicG93ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInBvdyh4LGdhbW1hKSBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBwaXhlbCBnYW1tYSwgd2hpY2ggcHJvZHVjZXMgc2xpZ2h0bHkgc21vb3RoZXIgbGluZSBhbmQgcG9seWdvbiBhbnRpYWxpYXNpbmcgdGhhbiB0aGUgJ2xpbmVhcicgbWV0aG9kLCB3aGlsZSBvdGhlciBtZXRob2RzIGFyZSB1c3VhbGx5IG9ubHkgdXNlZCB0byBkaXNhYmxlIEFBXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBBbnRpZ3JhaW4gR2VvbWV0cnkgc3BlY2lmaWMgcmVuZGVyaW5nIGhpbnQgdG8gY29udHJvbCB0aGUgcXVhbGl0eSBvZiBhbnRpYWxpYXNpbmcuIFVuZGVyIHRoZSBob29kIGluIE1hcG5payB0aGlzIG1ldGhvZCBpcyB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlICdnYW1tYScgdmFsdWUgKHdoaWNoIGRlZmF1bHRzIHRvIDEpLiBUaGUgbWV0aG9kcyBhcmUgaW4gdGhlIEFHRyBzb3VyY2UgYXQgaHR0cHM6Ly9naXRodWIuY29tL21hcG5pay9tYXBuaWsvYmxvYi9tYXN0ZXIvZGVwcy9hZ2cvaW5jbHVkZS9hZ2dfZ2FtbWFfZnVuY3Rpb25zLmhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLWNsaXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIGJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBiZWZvcmUgcmVuZGVyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJnZW9tZXRyaWVzIGFyZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYnkgZGVmYXVsdCBmb3IgYmVzdCByZW5kZXJpbmcgcGVyZm9ybWFuY2UuIEluIHNvbWUgY2FzZXMgdXNlcnMgbWF5IHdpc2ggdG8gZGlzYWJsZSB0aGlzIHRvIGF2b2lkIHJlbmRlcmluZyBhcnRpZmFjdHMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNtb290aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXNtb290aFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzbW9vdGhpbmdcIixcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IFwiMC0xXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTbW9vdGhzIG91dCBnZW9tZXRyeSBhbmdsZXMuIDAgaXMgbm8gc21vb3RoaW5nLCAxIGlzIGZ1bGx5IHNtb290aGVkLiBWYWx1ZXMgZ3JlYXRlciB0aGFuIDEgd2lsbCBwcm9kdWNlIHdpbGQsIGxvb3BpbmcgZ2VvbWV0cmllcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbWV0cnktdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tZ2VvbWV0cnktdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFsbG93cyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgZ2VvbWV0cnkuXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLWNvbXAtb3BcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IHN5bWJvbGl6ZXIgb24gdG9wIG9mIG90aGVyIHN5bWJvbGl6ZXJcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBzeW1ib2xpemVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gc3ltYm9saXplcnMgYXRvcCBvciBiZWxvdyBpdC5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1wiY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJvdmVybGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGFya2VuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWRvZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhcmQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb2Z0LWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImV4Y2x1c2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbnRyYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0LXJnYlwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLW1lcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImh1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNhdHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZVwiOiB7XG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgwLDAsMCwxKVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJibGFjayBhbmQgZnVsbHkgb3BhcXVlIChhbHBoYSA9IDEpLCBzYW1lIGFzIHJnYigwLDAsMClcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiBhIGRyYXduIGxpbmVcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHdpZHRoIG9mIGEgbGluZSBpbiBwaXhlbHNcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgYSBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWpvaW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJtaXRlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibWl0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcImJldmVsXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGJlaGF2aW9yIG9mIGxpbmVzIHdoZW4gam9pbmluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWNhcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJ1dHRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImJ1dHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNxdWFyZVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5nc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtZ2FtbWFcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1nYW1tYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJmdWxseSBhbnRpYWxpYXNlZFwiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkxldmVsIG9mIGFudGlhbGlhc2luZyBvZiBzdHJva2UgbGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtZ2FtbWEtbWV0aG9kXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtZ2FtbWEtbWV0aG9kXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb3dlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0aHJlc2hvbGRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb3dlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwicG93KHgsZ2FtbWEpIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHBpeGVsIGdhbW1hLCB3aGljaCBwcm9kdWNlcyBzbGlnaHRseSBzbW9vdGhlciBsaW5lIGFuZCBwb2x5Z29uIGFudGlhbGlhc2luZyB0aGFuIHRoZSAnbGluZWFyJyBtZXRob2QsIHdoaWxlIG90aGVyIG1ldGhvZHMgYXJlIHVzdWFsbHkgb25seSB1c2VkIHRvIGRpc2FibGUgQUFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIEFudGlncmFpbiBHZW9tZXRyeSBzcGVjaWZpYyByZW5kZXJpbmcgaGludCB0byBjb250cm9sIHRoZSBxdWFsaXR5IG9mIGFudGlhbGlhc2luZy4gVW5kZXIgdGhlIGhvb2QgaW4gTWFwbmlrIHRoaXMgbWV0aG9kIGlzIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgJ2dhbW1hJyB2YWx1ZSAod2hpY2ggZGVmYXVsdHMgdG8gMSkuIFRoZSBtZXRob2RzIGFyZSBpbiB0aGUgQUdHIHNvdXJjZSBhdCBodHRwczovL2dpdGh1Yi5jb20vbWFwbmlrL21hcG5pay9ibG9iL21hc3Rlci9kZXBzL2FnZy9pbmNsdWRlL2FnZ19nYW1tYV9mdW5jdGlvbnMuaFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtZGFzaGFycmF5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyc1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBwYWlyIG9mIGxlbmd0aCB2YWx1ZXMgW2EsYl0sIHdoZXJlIChhKSBpcyB0aGUgZGFzaCBsZW5ndGggYW5kIChiKSBpcyB0aGUgZ2FwIGxlbmd0aCByZXNwZWN0aXZlbHkuIE1vcmUgdGhhbiB0d28gdmFsdWVzIGFyZSBzdXBwb3J0ZWQgZm9yIG1vcmUgY29tcGxleCBwYXR0ZXJucy5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJzb2xpZCBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtZGFzaC1vZmZzZXRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJ2YWxpZCBwYXJhbWV0ZXIgYnV0IG5vdCBjdXJyZW50bHkgdXNlZCBpbiByZW5kZXJlcnMgKG9ubHkgZXhpc3RzIGZvciBleHBlcmltZW50YWwgc3ZnIHN1cHBvcnQgaW4gTWFwbmlrIHdoaWNoIGlzIG5vdCB5ZXQgZW5hYmxlZClcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJzb2xpZCBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtbWl0ZXJsaW1pdFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbGltaXQgb24gdGhlIHJhdGlvIG9mIHRoZSBtaXRlciBsZW5ndGggdG8gdGhlIHN0cm9rZS13aWR0aC4gVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcyB0byBhdm9pZCB0aGUgbWl0ZXIgZXh0ZW5kaW5nIGJleW9uZCB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2luZyBwYXRoLiBOb3JtYWxseSB3aWxsIG5vdCBuZWVkIHRvIGJlIHNldCwgYnV0IGEgbGFyZ2VyIHZhbHVlIGNhbiBzb21ldGltZXMgaGVscCBhdm9pZCBqYWdneSBhcnRpZmFjdHMuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDQuMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIldpbGwgYXV0by1jb252ZXJ0IG1pdGVycyB0byBiZXZlbCBsaW5lIGpvaW5zIHdoZW4gdGhldGEgaXMgbGVzcyB0aGFuIDI5IGRlZ3JlZXMgYXMgcGVyIHRoZSBTVkcgc3BlYzogJ21pdGVyTGVuZ3RoIC8gc3Ryb2tlLXdpZHRoID0gMSAvIHNpbiAoIHRoZXRhIC8gMiApJ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic21vb3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtc21vb3RoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNtb290aGluZ1wiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNtb290aHMgb3V0IGdlb21ldHJ5IGFuZ2xlcy4gMCBpcyBubyBzbW9vdGhpbmcsIDEgaXMgZnVsbHkgc21vb3RoZWQuIFZhbHVlcyBncmVhdGVyIHRoYW4gMSB3aWxsIHByb2R1Y2Ugd2lsZCwgbG9vcGluZyBnZW9tZXRyaWVzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvZmZzZXRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1vZmZzZXRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gb2Zmc2V0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJPZmZzZXRzIGEgbGluZSBhIG51bWJlciBvZiBwaXhlbHMgcGFyYWxsZWwgdG8gaXRzIGFjdHVhbCBwYXRoLiBQb3N0aXZlIHZhbHVlcyBtb3ZlIHRoZSBsaW5lIGxlZnQsIG5lZ2F0aXZlIHZhbHVlcyBtb3ZlIGl0IHJpZ2h0IChyZWxhdGl2ZSB0byB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgdGhlIGxpbmUpLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyYXN0ZXJpemVyXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcmFzdGVyaXplclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiZnVsbFwiLFxuICAgICAgICAgICAgICAgICAgICBcImZhc3RcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiZnVsbFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRXhwb3NlcyBhbiBhbHRlcm5hdGUgQUdHIHJlbmRlcmluZyBtZXRob2QgdGhhdCBzYWNyaWZpY2VzIHNvbWUgYWNjdXJhY3kgZm9yIHNwZWVkLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tZXRyeS10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1nZW9tZXRyeS10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXJrZXJzXCI6IHtcbiAgICAgICAgICAgIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gU1ZHIGZpbGUgdGhhdCB0aGlzIG1hcmtlciBzaG93cyBhdCBlYWNoIHBsYWNlbWVudC4gSWYgbm8gZmlsZSBpcyBnaXZlbiwgdGhlIG1hcmtlciB3aWxsIHNob3cgYW4gZWxsaXBzZS5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkFuIGVsbGlwc2Ugb3IgY2lyY2xlLCBpZiB3aWR0aCBlcXVhbHMgaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvdmVyYWxsIG9wYWNpdHkgb2YgdGhlIG1hcmtlciwgaWYgc2V0LCBvdmVycmlkZXMgYm90aCB0aGUgb3BhY2l0eSBvZiBib3RoIHRoZSBmaWxsIGFuZCBzdHJva2VcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBzdHJva2Utb3BhY2l0eSBhbmQgZmlsbC1vcGFjaXR5IHdpbGwgYmUgdXNlZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsbC1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgZmlsbCBvcGFjaXR5IG9mIHRoZSBtYXJrZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbGluZS1jb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBzdHJva2UgYXJvdW5kIGEgbWFya2VyIHNoYXBlLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJsYWNrXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLXdpZHRoXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgd2lkdGggb2YgdGhlIHN0cm9rZSBhcm91bmQgYSBtYXJrZXIgc2hhcGUsIGluIHBpeGVscy4gVGhpcyBpcyBwb3NpdGlvbmVkIG9uIHRoZSBib3VuZGFyeSwgc28gaGlnaCB2YWx1ZXMgY2FuIGNvdmVyIHRoZSBhcmVhIGl0c2VsZi5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbGluZS1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IG9mIGEgbGluZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmlvclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiUGxhY2UgbWFya2VycyBhdCB0aGUgY2VudGVyIHBvaW50IChjZW50cm9pZCkgb2YgdGhlIGdlb21ldHJ5XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBdHRlbXB0IHRvIHBsYWNlIG1hcmtlcnMgb24gYSBwb2ludCwgaW4gdGhlIGNlbnRlciBvZiBhIHBvbHlnb24sIG9yIGlmIG1hcmtlcnMtcGxhY2VtZW50OmxpbmUsIHRoZW4gbXVsdGlwbGUgdGltZXMgYWxvbmcgYSBsaW5lLiAnaW50ZXJpb3InIHBsYWNlbWVudCBjYW4gYmUgdXNlZCB0byBlbnN1cmUgdGhhdCBwb2ludHMgcGxhY2VkIG9uIHBvbHlnb25zIGFyZSBmb3JjZWQgdG8gYmUgaW5zaWRlIHRoZSBwb2x5Z29uIGludGVyaW9yXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm11bHRpLXBvbGljeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbXVsdGktcG9saWN5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJlYWNoXCIsXG4gICAgICAgICAgICAgICAgICAgIFwid2hvbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsYXJnZXN0XCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImVhY2hcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIklmIGEgZmVhdHVyZSBjb250YWlucyBtdWx0aXBsZSBnZW9tZXRyaWVzIGFuZCB0aGUgcGxhY2VtZW50IHR5cGUgaXMgZWl0aGVyIHBvaW50IG9yIGludGVyaW9yIHRoZW4gYSBtYXJrZXIgd2lsbCBiZSByZW5kZXJlZCBmb3IgZWFjaFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBzcGVjaWFsIHNldHRpbmcgdG8gYWxsb3cgdGhlIHVzZXIgdG8gY29udHJvbCByZW5kZXJpbmcgYmVoYXZpb3IgZm9yICdtdWx0aS1nZW9tZXRyaWVzJyAod2hlbiBhIGZlYXR1cmUgY29udGFpbnMgbXVsdGlwbGUgZ2VvbWV0cmllcykuIFRoaXMgc2V0dGluZyBkb2VzIG5vdCBhcHBseSB0byBtYXJrZXJzIHBsYWNlZCBhbG9uZyBsaW5lcy4gVGhlICdlYWNoJyBwb2xpY3kgaXMgZGVmYXVsdCBhbmQgbWVhbnMgYWxsIGdlb21ldHJpZXMgd2lsbCBnZXQgYSBtYXJrZXIuIFRoZSAnd2hvbGUnIHBvbGljeSBtZWFucyB0aGF0IHRoZSBhZ2dyZWdhdGUgY2VudHJvaWQgYmV0d2VlbiBhbGwgZ2VvbWV0cmllcyB3aWxsIGJlIHVzZWQuIFRoZSAnbGFyZ2VzdCcgcG9saWN5IG1lYW5zIHRoYXQgb25seSB0aGUgbGFyZ2VzdCAoYnkgYm91bmRpbmcgYm94IGFyZWFzKSBmZWF0dXJlIHdpbGwgZ2V0IGEgcmVuZGVyZWQgbWFya2VyICh0aGlzIGlzIGhvdyB0ZXh0IGxhYmVsaW5nIGJlaGF2ZXMgYnkgZGVmYXVsdCkuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1hcmtlci10eXBlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci10eXBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJhcnJvd1wiLFxuICAgICAgICAgICAgICAgICAgICBcImVsbGlwc2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZWN0YW5nbGVcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGRlZmF1bHQgbWFya2VyLXR5cGUuIElmIGEgU1ZHIGZpbGUgaXMgbm90IGdpdmVuIGFzIHRoZSBtYXJrZXItZmlsZSBwYXJhbWV0ZXIsIHRoZSByZW5kZXJlciBwcm92aWRlcyBlaXRoZXIgYW4gYXJyb3cgb3IgYW4gZWxsaXBzZSAoYSBjaXJjbGUgaWYgaGVpZ2h0IGlzIGVxdWFsIHRvIHdpZHRoKVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ3aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgaWYgdXNpbmcgb25lIG9mIHRoZSBkZWZhdWx0IHR5cGVzLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhlaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGhlaWdodCBvZiB0aGUgbWFya2VyLCBpZiB1c2luZyBvbmUgb2YgdGhlIGRlZmF1bHQgdHlwZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJsdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgYXJlYSBvZiB0aGUgbWFya2VyLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWFsbG93LW92ZXJsYXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIG92ZXJsYXBwaW5nIG1hcmtlcnMgYXJlIHNob3duIG9yIGhpZGRlbi5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkRvIG5vdCBhbGxvdyBtYWtlcnMgdG8gb3ZlcmxhcCB3aXRoIGVhY2ggb3RoZXIgLSBvdmVybGFwcGluZyBtYXJrZXJzIHdpbGwgbm90IGJlIHNob3duLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1pZ25vcmUtcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImRvIG5vdCBzdG9yZSB0aGUgYmJveCBvZiB0aGlzIGdlb21ldHJ5IGluIHRoZSBjb2xsaXNpb24gZGV0ZWN0b3IgY2FjaGVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcInZhbHVlIHRvIGNvbnRyb2wgd2hldGhlciB0aGUgcGxhY2VtZW50IG9mIHRoZSBmZWF0dXJlIHdpbGwgcHJldmVudCB0aGUgcGxhY2VtZW50IG9mIG90aGVyIGZlYXR1cmVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNwYWNpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLXNwYWNpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNwYWNlIGJldHdlZW4gcmVwZWF0ZWQgbGFiZWxzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEwMCxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtYXgtZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLW1heC1lcnJvclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAuMixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGRpZmZlcmVuY2UgYmV0d2VlbiBhY3R1YWwgbWFya2VyIHBsYWNlbWVudCBhbmQgdGhlIG1hcmtlci1zcGFjaW5nIHBhcmFtZXRlci4gU2V0dGluZyBhIGhpZ2ggdmFsdWUgY2FuIGFsbG93IHRoZSByZW5kZXJlciB0byB0cnkgdG8gcmVzb2x2ZSBwbGFjZW1lbnQgY29uZmxpY3RzIHdpdGggb3RoZXIgc3ltYm9saXplcnMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIHRyYW5zZm9ybWF0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTVkcgdHJhbnNmb3JtYXRpb24gZGVmaW5pdGlvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1jbGlwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBiZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYmVmb3JlIHJlbmRlcmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiZ2VvbWV0cmllcyBhcmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJ5IGRlZmF1bHQgZm9yIGJlc3QgcmVuZGVyaW5nIHBlcmZvcm1hbmNlLiBJbiBzb21lIGNhc2VzIHVzZXJzIG1heSB3aXNoIHRvIGRpc2FibGUgdGhpcyB0byBhdm9pZCByZW5kZXJpbmcgYXJ0aWZhY3RzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzbW9vdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLXNtb290aFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzbW9vdGhpbmdcIixcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IFwiMC0xXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTbW9vdGhzIG91dCBnZW9tZXRyeSBhbmdsZXMuIDAgaXMgbm8gc21vb3RoaW5nLCAxIGlzIGZ1bGx5IHNtb290aGVkLiBWYWx1ZXMgZ3JlYXRlciB0aGFuIDEgd2lsbCBwcm9kdWNlIHdpbGQsIGxvb3BpbmcgZ2VvbWV0cmllcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbWV0cnktdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1nZW9tZXRyeS10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNoaWVsZFwiOiB7XG4gICAgICAgICAgICBcIm5hbWVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLW5hbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInNlcmlhbGl6YXRpb25cIjogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJWYWx1ZSB0byB1c2UgZm9yIGEgc2hpZWxkXFxcInMgdGV4dCBsYWJlbC4gRGF0YSBjb2x1bW5zIGFyZSBzcGVjaWZpZWQgdXNpbmcgYnJhY2tldHMgbGlrZSBbY29sdW1uX25hbWVdXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWZpbGVcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSW1hZ2UgZmlsZSB0byByZW5kZXIgYmVoaW5kIHRoZSBzaGllbGQgdGV4dFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmYWNlLW5hbWVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWZhY2UtbmFtZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwidmFsaWRhdGVcIjogXCJmb250XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJGb250IG5hbWUgYW5kIHN0eWxlIHRvIHVzZSBmb3IgdGhlIHNoaWVsZCB0ZXh0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bmxvY2staW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXVubG9jay1pbWFnZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoaXMgcGFyYW1ldGVyIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBpZiB5b3UgYXJlIHRyeWluZyB0byBwb3NpdGlvbiB0ZXh0IGJlc2lkZSByYXRoZXIgdGhhbiBvbiB0b3Agb2YgdGhlIHNoaWVsZCBpbWFnZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRleHQgYWxpZ25tZW50IHJlbGF0aXZlIHRvIHRoZSBzaGllbGQgaW1hZ2UgdXNlcyB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZSBhcyB0aGUgYW5jaG9yIGZvciB0ZXh0IHBvc2l0aW9uaW5nLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzaXplXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1zaXplXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzaXplIG9mIHRoZSBzaGllbGQgdGV4dCBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHNoaWVsZCB0ZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZXJ0ZXhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmlvclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSG93IHRoaXMgc2hpZWxkIHNob3VsZCBiZSBwbGFjZWQuIFBvaW50IHBsYWNlbWVudCBhdHRlbXB0cyB0byBwbGFjZSBpdCBvbiB0b3Agb2YgcG9pbnRzLCBsaW5lIHBsYWNlcyBhbG9uZyBsaW5lcyBtdWx0aXBsZSB0aW1lcyBwZXIgZmVhdHVyZSwgdmVydGV4IHBsYWNlcyBvbiB0aGUgdmVydGV4ZXMgb2YgcG9seWdvbnMsIGFuZCBpbnRlcmlvciBhdHRlbXB0cyB0byBwbGFjZSBpbnNpZGUgb2YgcG9seWdvbnMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1hdm9pZC1lZGdlc1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGVsbCBwb3NpdGlvbmluZyBhbGdvcml0aG0gdG8gYXZvaWQgbGFiZWxpbmcgbmVhciBpbnRlcnNlY3Rpb24gZWRnZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtYWxsb3ctb3ZlcmxhcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgb3ZlcmxhcHBpbmcgc2hpZWxkcyBhcmUgc2hvd24gb3IgaGlkZGVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRG8gbm90IGFsbG93IHNoaWVsZHMgdG8gb3ZlcmxhcCB3aXRoIG90aGVyIG1hcCBlbGVtZW50cyBhbHJlYWR5IHBsYWNlZC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWluaW11bS1kaXN0YW5jZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtbWluLWRpc3RhbmNlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIk1pbmltdW0gZGlzdGFuY2UgdG8gdGhlIG5leHQgc2hpZWxkIHN5bWJvbCwgbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIHNoaWVsZC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3BhY2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtc3BhY2luZ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgc3BhY2luZyBiZXR3ZWVuIHJlcGVhdGVkIG9jY3VycmVuY2VzIG9mIHRoZSBzYW1lIHNoaWVsZCBvbiBhIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWluaW11bS1wYWRkaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1taW4tcGFkZGluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGV0ZXJtaW5lcyB0aGUgbWluaW11bSBhbW91bnQgb2YgcGFkZGluZyB0aGF0IGEgc2hpZWxkIGdldHMgcmVsYXRpdmUgdG8gb3RoZXIgc2hpZWxkc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtd2lkdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXdyYXAtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTGVuZ3RoIG9mIGEgY2h1bmsgb2YgdGV4dCBpbiBjaGFyYWN0ZXJzIGJlZm9yZSB3cmFwcGluZyB0ZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtYmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC13cmFwLWJlZm9yZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJXcmFwIHRleHQgYmVmb3JlIHdyYXAtd2lkdGggaXMgcmVhY2hlZC4gSWYgZmFsc2UsIHdyYXBwZWQgbGluZXMgd2lsbCBiZSBhIGJpdCBsb25nZXIgdGhhbiB3cmFwLXdpZHRoLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ3cmFwLWNoYXJhY3RlclwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtd3JhcC1jaGFyYWN0ZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJVc2UgdGhpcyBjaGFyYWN0ZXIgaW5zdGVhZCBvZiBhIHNwYWNlIHRvIHdyYXAgbG9uZyBuYW1lcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGFsby1maWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1oYWxvLWZpbGxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIiNGRkZGRkZcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGNvbG9yIG9mIHRoZSBoYWxvIGFyb3VuZCB0aGUgdGV4dC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGFsby1yYWRpdXNcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWhhbG8tcmFkaXVzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZ5IHRoZSByYWRpdXMgb2YgdGhlIGhhbG8gaW4gcGl4ZWxzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBoYWxvXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2hhcmFjdGVyLXNwYWNpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWNoYXJhY3Rlci1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkhvcml6b250YWwgc3BhY2luZyBiZXR3ZWVuIGNoYXJhY3RlcnMgKGluIHBpeGVscykuIEN1cnJlbnRseSB3b3JrcyBmb3IgcG9pbnQgcGxhY2VtZW50IG9ubHksIG5vdCBsaW5lIHBsYWNlbWVudC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibGluZS1zcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1saW5lLXNwYWNpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlZlcnRpY2FsIHNwYWNpbmcgYmV0d2VlbiBsaW5lcyBvZiBtdWx0aWxpbmUgbGFiZWxzIChpbiBwaXhlbHMpXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZHhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXRleHQtZHhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGlzcGxhY2UgdGV4dCB3aXRoaW4gc2hpZWxkIGJ5IGZpeGVkIGFtb3VudCwgaW4gcGl4ZWxzLCArLy0gYWxvbmcgdGhlIFggYXhpcy4gIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBzaGlmdCB0aGUgdGV4dCByaWdodFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtdGV4dC1keVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXNwbGFjZSB0ZXh0IHdpdGhpbiBzaGllbGQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWSBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IGRvd25cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2hpZWxkLWR4XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1keFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXNwbGFjZSBzaGllbGQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWCBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNoaWVsZC1keVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtZHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGlzcGxhY2Ugc2hpZWxkIGJ5IGZpeGVkIGFtb3VudCwgaW4gcGl4ZWxzLCArLy0gYWxvbmcgdGhlIFkgYXhpcy4gIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBzaGlmdCB0aGUgdGV4dCBkb3duXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiKERlZmF1bHQgMS4wKSAtIG9wYWNpdHkgb2YgdGhlIGltYWdlIHVzZWQgZm9yIHRoZSBzaGllbGRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC10ZXh0LW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiKERlZmF1bHQgMS4wKSAtIG9wYWNpdHkgb2YgdGhlIHRleHQgcGxhY2VkIG9uIHRvcCBvZiB0aGUgc2hpZWxkXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhvcml6b250YWwtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1ob3Jpem9udGFsLWFsaWdubWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pZGRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzaGllbGQncyBob3Jpem9udGFsIGFsaWdubWVudCBmcm9tIGl0cyBjZW50ZXJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidmVydGljYWwtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC12ZXJ0aWNhbC1hbGlnbm1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcInRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pZGRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgICBcImF1dG9cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgc2hpZWxkJ3MgdmVydGljYWwgYWxpZ25tZW50IGZyb20gaXRzIGNlbnRlcnBvaW50XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibWlkZGxlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC10ZXh0LXRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInVwcGVyY2FzZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxvd2VyY2FzZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNhcGl0YWxpemVcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUcmFuc2Zvcm0gdGhlIGNhc2Ugb2YgdGhlIGNoYXJhY3RlcnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImp1c3RpZnktYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1qdXN0aWZ5LWFsaWdubWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRlZmluZSBob3cgdGV4dCBpbiBhIHNoaWVsZCdzIGxhYmVsIGlzIGp1c3RpZmllZFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lLXBhdHRlcm5cIjoge1xuICAgICAgICAgICAgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcGF0dGVybi1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIGltYWdlIGZpbGUgdG8gYmUgcmVwZWF0ZWQgYW5kIHdhcnBlZCBhbG9uZyBhIGxpbmVcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLXBhdHRlcm4tY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic21vb3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcGF0dGVybi1zbW9vdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gc21vb3RoaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU21vb3RocyBvdXQgZ2VvbWV0cnkgYW5nbGVzLiAwIGlzIG5vIHNtb290aGluZywgMSBpcyBmdWxseSBzbW9vdGhlZC4gVmFsdWVzIGdyZWF0ZXIgdGhhbiAxIHdpbGwgcHJvZHVjZSB3aWxkLCBsb29waW5nIGdlb21ldHJpZXMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21ldHJ5LXRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLXBhdHRlcm4tZ2VvbWV0cnktdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFsbG93cyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgZ2VvbWV0cnkuXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLXBhdHRlcm4tY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2x5Z29uLXBhdHRlcm5cIjoge1xuICAgICAgICAgICAgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkltYWdlIHRvIHVzZSBhcyBhIHJlcGVhdGVkIHBhdHRlcm4gZmlsbCB3aXRoaW4gYSBwb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tYWxpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJsb2NhbFwiLFxuICAgICAgICAgICAgICAgICAgICBcImdsb2JhbFwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJsb2NhbFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BlY2lmeSB3aGV0aGVyIHRvIGFsaWduIHBhdHRlcm4gZmlsbHMgdG8gdGhlIGxheWVyIG9yIHRvIHRoZSBtYXAuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdhbW1hXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1nYW1tYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJmdWxseSBhbnRpYWxpYXNlZFwiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkxldmVsIG9mIGFudGlhbGlhc2luZyBvZiBwb2x5Z29uIHBhdHRlcm4gZWRnZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCIoRGVmYXVsdCAxLjApIC0gQXBwbHkgYW4gb3BhY2l0eSBsZXZlbCB0byB0aGUgaW1hZ2UgdXNlZCBmb3IgdGhlIHBhdHRlcm5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBpbWFnZSBpcyByZW5kZXJlZCB3aXRob3V0IG1vZGlmaWNhdGlvbnNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic21vb3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1zbW9vdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gc21vb3RoaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU21vb3RocyBvdXQgZ2VvbWV0cnkgYW5nbGVzLiAwIGlzIG5vIHNtb290aGluZywgMSBpcyBmdWxseSBzbW9vdGhlZC4gVmFsdWVzIGdyZWF0ZXIgdGhhbiAxIHdpbGwgcHJvZHVjZSB3aWxkLCBsb29waW5nIGdlb21ldHJpZXMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21ldHJ5LXRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tZ2VvbWV0cnktdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFsbG93cyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgZ2VvbWV0cnkuXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbnNcIjogW1xuICAgICAgICAgICAgICAgICAgICBbXCJtYXRyaXhcIiwgNl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInRyYW5zbGF0ZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2NhbGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJvdGF0ZVwiLCAzXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1hcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdZXCIsIDFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLXBhdHRlcm4tY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJyYXN0ZXJcIjoge1xuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInJhc3Rlci1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIHJhc3RlciBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVycy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsdGVyLWZhY3RvclwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJyYXN0ZXItZmlsdGVyLWZhY3RvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAtMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkFsbG93IHRoZSBkYXRhc291cmNlIHRvIGNob29zZSBhcHByb3ByaWF0ZSBkb3duc2NhbGluZy5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhpcyBpcyB1c2VkIGJ5IHRoZSBSYXN0ZXIgb3IgR2RhbCBkYXRhc291cmNlcyB0byBwcmUtZG93bnNjYWxlIGltYWdlcyB1c2luZyBvdmVydmlld3MuIEhpZ2hlciBudW1iZXJzIGNhbiBzb21ldGltZXMgY2F1c2UgbXVjaCBiZXR0ZXIgc2NhbGVkIGltYWdlIG91dHB1dCwgYXQgdGhlIGNvc3Qgb2Ygc3BlZWQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNjYWxpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicmFzdGVyLXNjYWxpbmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIm5lYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJmYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYmlsaW5lYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiaWxpbmVhcjhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiaWN1YmljXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3BsaW5lMTZcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcGxpbmUzNlwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhbm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYW1taW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGVybWl0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImthaXNlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInF1YWRyaWNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjYXRyb21cIixcbiAgICAgICAgICAgICAgICAgICAgXCJnYXVzc2lhblwiLFxuICAgICAgICAgICAgICAgICAgICBcImJlc3NlbFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pdGNoZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2luY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImxhbmN6b3NcIixcbiAgICAgICAgICAgICAgICAgICAgXCJibGFja21hblwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJuZWFyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgc2NhbGluZyBhbGdvcml0aG0gdXNlZCB0byBtYWtpbmcgZGlmZmVyZW50IHJlc29sdXRpb24gdmVyc2lvbnMgb2YgdGhpcyByYXN0ZXIgbGF5ZXIuIEJpbGluZWFyIGlzIGEgZ29vZCBjb21wcm9taXNlIGJldHdlZW4gc3BlZWQgYW5kIGFjY3VyYWN5LCB3aGlsZSBsYW5jem9zIGdpdmVzIHRoZSBoaWdoZXN0IHF1YWxpdHkuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1lc2gtc2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJyYXN0ZXItbWVzaC1zaXplXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDE2LFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiUmVwcm9qZWN0aW9uIG1lc2ggd2lsbCBiZSAxLzE2IG9mIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBzb3VyY2UgaW1hZ2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSByZWR1Y2VkIHJlc29sdXRpb24gbWVzaCBpcyB1c2VkIGZvciByYXN0ZXIgcmVwcm9qZWN0aW9uLCBhbmQgdGhlIHRvdGFsIGltYWdlIHNpemUgaXMgZGl2aWRlZCBieSB0aGUgbWVzaC1zaXplIHRvIGRldGVybWluZSB0aGUgcXVhbGl0eSBvZiB0aGF0IG1lc2guIFZhbHVlcyBmb3IgbWVzaC1zaXplIGxhcmdlciB0aGFuIHRoZSBkZWZhdWx0IHdpbGwgcmVzdWx0IGluIGZhc3RlciByZXByb2plY3Rpb24gYnV0IG1pZ2h0IGxlYWQgdG8gZGlzdG9ydGlvbi5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJyYXN0ZXItY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2ludFwiOiB7XG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtZmlsZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVyaVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSW1hZ2UgZmlsZSB0byByZXByZXNlbnQgYSBwb2ludFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LWFsbG93LW92ZXJsYXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIG92ZXJsYXBwaW5nIHBvaW50cyBhcmUgc2hvd24gb3IgaGlkZGVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRG8gbm90IGFsbG93IHBvaW50cyB0byBvdmVybGFwIHdpdGggZWFjaCBvdGhlciAtIG92ZXJsYXBwaW5nIG1hcmtlcnMgd2lsbCBub3QgYmUgc2hvd24uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtaWdub3JlLXBsYWNlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJkbyBub3Qgc3RvcmUgdGhlIGJib3ggb2YgdGhpcyBnZW9tZXRyeSBpbiB0aGUgY29sbGlzaW9uIGRldGVjdG9yIGNhY2hlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJ2YWx1ZSB0byBjb250cm9sIHdoZXRoZXIgdGhlIHBsYWNlbWVudCBvZiB0aGUgZmVhdHVyZSB3aWxsIHByZXZlbnQgdGhlIHBsYWNlbWVudCBvZiBvdGhlciBmZWF0dXJlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLjAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJGdWxseSBvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgdmFsdWUgZnJvbSAwIHRvIDEgdG8gY29udHJvbCB0aGUgb3BhY2l0eSBvZiB0aGUgcG9pbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LXBsYWNlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiY2VudHJvaWRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmlvclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkhvdyB0aGlzIHBvaW50IHNob3VsZCBiZSBwbGFjZWQuIENlbnRyb2lkIGNhbGN1bGF0ZXMgdGhlIGdlb21ldHJpYyBjZW50ZXIgb2YgYSBwb2x5Z29uLCB3aGljaCBjYW4gYmUgb3V0c2lkZSBvZiBpdCwgd2hpbGUgaW50ZXJpb3IgYWx3YXlzIHBsYWNlcyBpbnNpZGUgb2YgYSBwb2x5Z29uLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImNlbnRyb2lkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2ludC10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gdHJhbnNmb3JtYXRpb25cIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNWRyB0cmFuc2Zvcm1hdGlvbiBkZWZpbml0aW9uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgIFwibmFtZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LW5hbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJzZXJpYWxpemF0aW9uXCI6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIERhdGEgY29sdW1ucyBhcmUgc3BlY2lmaWVkIHVzaW5nIGJyYWNrZXRzIGxpa2UgW2NvbHVtbl9uYW1lXVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmYWNlLW5hbWVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1mYWNlLW5hbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcInZhbGlkYXRlXCI6IFwiZm9udFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRm9udCBuYW1lIGFuZCBzdHlsZSB0byByZW5kZXIgYSBsYWJlbCBpblwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXNpemVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRleHQgc2l6ZSBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidGV4dC1yYXRpb1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXJhdGlvXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEZWZpbmUgdGhlIGFtb3VudCBvZiB0ZXh0IChvZiB0aGUgdG90YWwpIHByZXNlbnQgb24gc3VjY2Vzc2l2ZSBsaW5lcyB3aGVuIHdyYXBwaW5nIG9jY3Vyc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtd2lkdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC13cmFwLXdpZHRoXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJMZW5ndGggb2YgYSBjaHVuayBvZiB0ZXh0IGluIGNoYXJhY3RlcnMgYmVmb3JlIHdyYXBwaW5nIHRleHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ3cmFwLWJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXdyYXAtYmVmb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIldyYXAgdGV4dCBiZWZvcmUgd3JhcC13aWR0aCBpcyByZWFjaGVkLiBJZiBmYWxzZSwgd3JhcHBlZCBsaW5lcyB3aWxsIGJlIGEgYml0IGxvbmdlciB0aGFuIHdyYXAtd2lkdGguXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtY2hhcmFjdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtd3JhcC1jaGFyYWN0ZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJVc2UgdGhpcyBjaGFyYWN0ZXIgaW5zdGVhZCBvZiBhIHNwYWNlIHRvIHdyYXAgbG9uZyB0ZXh0LlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtc3BhY2luZ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBiZXR3ZWVuIHJlcGVhdGVkIHRleHQgbGFiZWxzIG9uIGEgbGluZSAoYWthLiBsYWJlbC1zcGFjaW5nKVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjaGFyYWN0ZXItc3BhY2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWNoYXJhY3Rlci1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkhvcml6b250YWwgc3BhY2luZyBhZGp1c3RtZW50IGJldHdlZW4gY2hhcmFjdGVycyBpbiBwaXhlbHNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibGluZS1zcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbGluZS1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlZlcnRpY2FsIHNwYWNpbmcgYWRqdXN0bWVudCBiZXR3ZWVuIGxpbmVzIGluIHBpeGVsc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJsYWJlbC1wb3NpdGlvbi10b2xlcmFuY2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1sYWJlbC1wb3NpdGlvbi10b2xlcmFuY2VcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRoZSBsYWJlbCB0byBiZSBkaXNwbGFjZWQgZnJvbSBpdHMgaWRlYWwgcG9zaXRpb24gYnkgYSBudW1iZXIgb2YgcGl4ZWxzIChvbmx5IHdvcmtzIHdpdGggcGxhY2VtZW50OmxpbmUpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1heC1jaGFyLWFuZ2xlLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWF4LWNoYXItYW5nbGUtZGVsdGFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjIyLjVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGFuZ2xlIGNoYW5nZSwgaW4gZGVncmVlcywgYWxsb3dlZCBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMgaW4gYSBsYWJlbC4gVGhpcyB2YWx1ZSBpbnRlcm5hbGx5IGlzIGNvbnZlcnRlZCB0byByYWRpYW5zIHRvIHRoZSBkZWZhdWx0IGlzIDIyLjUqbWF0aC5waS8xODAuMC4gVGhlIGhpZ2hlciB0aGUgdmFsdWUgdGhlIGZld2VyIGxhYmVscyB3aWxsIGJlIHBsYWNlZCBhcm91bmQgYXJvdW5kIHNoYXJwIGNvcm5lcnMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGxcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGNvbG9yIGZvciB0aGUgdGV4dFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBudW1iZXIgZnJvbSAwIHRvIDEgc3BlY2lmeWluZyB0aGUgb3BhY2l0eSBmb3IgdGhlIHRleHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMS4wLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRnVsbHkgb3BhcXVlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGFsby1maWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtaGFsby1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWVzIHRoZSBjb2xvciBvZiB0aGUgaGFsbyBhcm91bmQgdGhlIHRleHQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhhbG8tcmFkaXVzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtaGFsby1yYWRpdXNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNwZWNpZnkgdGhlIHJhZGl1cyBvZiB0aGUgaGFsbyBpbiBwaXhlbHNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIGhhbG9cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkeFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWR4XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRpc3BsYWNlIHRleHQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWCBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtZHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGlzcGxhY2UgdGV4dCBieSBmaXhlZCBhbW91bnQsIGluIHBpeGVscywgKy8tIGFsb25nIHRoZSBZIGF4aXMuICBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgc2hpZnQgdGhlIHRleHQgZG93blwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ2ZXJ0aWNhbC1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC12ZXJ0aWNhbC1hbGlnbm1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgXCJ0b3BcIixcbiAgICAgICAgICAgICAgICAgIFwibWlkZGxlXCIsXG4gICAgICAgICAgICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgXCJhdXRvXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiUG9zaXRpb24gb2YgbGFiZWwgcmVsYXRpdmUgdG8gcG9pbnQgcG9zaXRpb24uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRGVmYXVsdCBhZmZlY3RlZCBieSB2YWx1ZSBvZiBkeTsgXFxcImJvdHRvbVxcXCIgZm9yIGR5PjAsIFxcXCJ0b3BcXFwiIGZvciBkeTwwLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhdm9pZC1lZGdlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWF2b2lkLWVkZ2VzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUZWxsIHBvc2l0aW9uaW5nIGFsZ29yaXRobSB0byBhdm9pZCBsYWJlbGluZyBuZWFyIGludGVyc2VjdGlvbiBlZGdlcy5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtaW5pbXVtLWRpc3RhbmNlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWluLWRpc3RhbmNlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIHBlcm1pdHRlZCBkaXN0YW5jZSB0byB0aGUgbmV4dCB0ZXh0IHN5bWJvbGl6ZXIuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWluaW11bS1wYWRkaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWluLXBhZGRpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRldGVybWluZXMgdGhlIG1pbmltdW0gYW1vdW50IG9mIHBhZGRpbmcgdGhhdCBhIHRleHQgc3ltYm9saXplciBnZXRzIHJlbGF0aXZlIHRvIG90aGVyIHRleHRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtaW5pbXVtLXBhdGgtbGVuZ3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbWluLXBhdGgtbGVuZ3RoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInBsYWNlIGxhYmVscyBvbiBhbGwgcGF0aHNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlBsYWNlIGxhYmVscyBvbmx5IG9uIHBhdGhzIGxvbmdlciB0aGFuIHRoaXMgdmFsdWUuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1hbGxvdy1vdmVybGFwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciBvdmVybGFwcGluZyB0ZXh0IGlzIHNob3duIG9yIGhpZGRlbi5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkRvIG5vdCBhbGxvdyB0ZXh0IHRvIG92ZXJsYXAgd2l0aCBvdGhlciB0ZXh0IC0gb3ZlcmxhcHBpbmcgbWFya2VycyB3aWxsIG5vdCBiZSBzaG93bi5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3JpZW50YXRpb25cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1vcmllbnRhdGlvblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJSb3RhdGUgdGhlIHRleHQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXBsYWNlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwicG9pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmVydGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJpb3JcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicG9pbnRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgdGhlIHN0eWxlIG9mIHBsYWNlbWVudCBvZiBhIHBvaW50IHZlcnN1cyB0aGUgZ2VvbWV0cnkgaXQgaXMgYXR0YWNoZWQgdG8uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudC10eXBlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtcGxhY2VtZW50LXR5cGVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlJlLXBvc2l0aW9uIGFuZC9vciByZS1zaXplIHRleHQgdG8gYXZvaWQgb3ZlcmxhcHMuIFxcXCJzaW1wbGVcXFwiIGZvciBiYXNpYyBhbGdvcml0aG0gKHVzaW5nIHRleHQtcGxhY2VtZW50cyBzdHJpbmcsKSBcXFwiZHVtbXlcXFwiIHRvIHR1cm4gdGhpcyBmZWF0dXJlIG9mZi5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImR1bW15XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2ltcGxlXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImR1bW15XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBsYWNlbWVudHNcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1wbGFjZW1lbnRzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJJZiBcXFwicGxhY2VtZW50LXR5cGVcXFwiIGlzIHNldCB0byBcXFwic2ltcGxlXFxcIiwgdXNlIHRoaXMgXFxcIlBPU0lUSU9OUyxbU0laRVNdXFxcIiBzdHJpbmcuIEFuIGV4YW1wbGUgaXMgYHRleHQtcGxhY2VtZW50czogXFxcIkUsTkUsU0UsVyxOVyxTV1xcXCI7YCBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidGV4dC10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1cHBlcmNhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsb3dlcmNhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjYXBpdGFsaXplXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVHJhbnNmb3JtIHRoZSBjYXNlIG9mIHRoZSBjaGFyYWN0ZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJob3Jpem9udGFsLWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWhvcml6b250YWwtYWxpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWlkZGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhdXRvXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHRleHQncyBob3Jpem9udGFsIGFsaWdubWVudCBmcm9tIGl0cyBjZW50ZXJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwianVzdGlmeS1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1hbGlnblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRlZmluZSBob3cgdGV4dCBpcyBqdXN0aWZpZWRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJBdXRvIGFsaWdubWVudCBtZWFucyB0aGF0IHRleHQgd2lsbCBiZSBjZW50ZXJlZCBieSBkZWZhdWx0IGV4Y2VwdCB3aGVuIHVzaW5nIHRoZSBgcGxhY2VtZW50LXR5cGVgIHBhcmFtZXRlciAtIGluIHRoYXQgY2FzZSBlaXRoZXIgcmlnaHQgb3IgbGVmdCBqdXN0aWZpY2F0aW9uIHdpbGwgYmUgdXNlZCBhdXRvbWF0aWNhbGx5IGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgdGV4dCBjb3VsZCBiZSBmaXQgZ2l2ZW4gdGhlIGB0ZXh0LXBsYWNlbWVudHNgIGRpcmVjdGl2ZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY2xpcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWNsaXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIGJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBiZWZvcmUgcmVuZGVyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJnZW9tZXRyaWVzIGFyZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYnkgZGVmYXVsdCBmb3IgYmVzdCByZW5kZXJpbmcgcGVyZm9ybWFuY2UuIEluIHNvbWUgY2FzZXMgdXNlcnMgbWF5IHdpc2ggdG8gZGlzYWJsZSB0aGlzIHRvIGF2b2lkIHJlbmRlcmluZyBhcnRpZmFjdHMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJ1aWxkaW5nXCI6IHtcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJidWlsZGluZy1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBidWlsZGluZ3Mgd2FsbHMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJ1aWxkaW5nLWZpbGwtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBvZiB0aGUgYnVpbGRpbmcgYXMgYSB3aG9sZSwgaW5jbHVkaW5nIGFsbCB3YWxscy5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJ1aWxkaW5nLWhlaWdodFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGhlaWdodCBvZiB0aGUgYnVpbGRpbmcgaW4gcGl4ZWxzLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidG9ycXVlXCI6IHtcbiAgICAgICAgICBcIi10b3JxdWUtY2xlYXItY29sb3JcIjoge1xuICAgICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtY2xlYXItY29sb3JcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKVwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImZ1bGwgY2xlYXJcIixcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJjb2xvciB1c2VkIHRvIGNsZWFyIGNhbnZhcyBvbiBlYWNoIGZyYW1lXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS1mcmFtZS1jb3VudFwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1mcmFtZS1jb3VudFwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIxMjhcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSBkYXRhIGlzIGJyb2tlbiBpbnRvIDEyOCB0aW1lIGZyYW1lc1wiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIk51bWJlciBvZiBhbmltYXRpb24gc3RlcHMvZnJhbWVzIHVzZWQgaW4gdGhlIGFuaW1hdGlvbi4gSWYgdGhlIGRhdGEgY29udGFpbnMgYSBmZXdlcmUgbnVtYmVyIG9mIHRvdGFsIGZyYW1lcywgdGhlIGxlc3NlciB2YWx1ZSB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS1yZXNvbHV0aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLXJlc29sdXRpb25cIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMlwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjpcImZsb2F0XCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiXCIsXG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BhdGlhbCByZXNvbHV0aW9uIGluIHBpeGVscy4gQSByZXNvbHV0aW9uIG9mIDEgbWVhbnMgbm8gc3BhdGlhbCBhZ2dyZWdhdGlvbiBvZiB0aGUgZGF0YS4gQW55IG90aGVyIHJlc29sdXRpb24gb2YgTiByZXN1bHRzIGluIHNwYXRpYWwgYWdncmVnYXRpb24gaW50byBjZWxscyBvZiBOeE4gcGl4ZWxzLiBUaGUgdmFsdWUgTiBtdXN0IGJlIHBvd2VyIG9mIDJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCItdG9ycXVlLWFuaW1hdGlvbi1kdXJhdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1hbmltYXRpb24tZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMzBcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSBhbmltYXRpb24gbGFzdHMgMzAgc2Vjb25kc1wiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuaW1hdGlvbiBkdXJhdGlvbiBpbiBzZWNvbmRzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS1hZ2dyZWdhdGlvbi1mdW5jdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1hZ2dyZWdhdGlvbi1mdW5jdGlvblwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJjb3VudChjYXJ0b2RiX2lkKVwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJ0aGUgdmFsdWUgZm9yIGVhY2ggY2VsbCBpcyB0aGUgY291bnQgb2YgcG9pbnRzIGluIHRoYXQgY2VsbFwiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgZnVuY3Rpb24gdXNlZCB0byBjYWxjdWxhdGUgYSB2YWx1ZSBmcm9tIHRoZSBhZ2dyZWdhdGUgZGF0YSBmb3IgZWFjaCBjZWxsLiBTZWUgLXRvcnF1ZS1yZXNvbHV0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS10aW1lLWF0dHJpYnV0ZVwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS10aW1lLWF0dHJpYnV0ZVwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSBkYXRhIGNvbHVtbiBpbiB5b3VyIHRhYmxlIHRoYXQgaXMgb2YgYSB0aW1lIGJhc2VkIHR5cGVcIixcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGFibGUgY29sdW1uIHRoYXQgY29udGFpbnMgdGhlIHRpbWUgaW5mb3JtYXRpb24gdXNlZCBjcmVhdGUgdGhlIGFuaW1hdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIi10b3JxdWUtZGF0YS1hZ2dyZWdhdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1kYXRhLWFnZ3JlZ2F0aW9uXCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImxpbmVhclwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgIFwibGluZWFyXCIsXG4gICAgICAgICAgICAgICAgXCJjdW11bGF0aXZlXCJcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJwcmV2aW91cyB2YWx1ZXMgYXJlIGRpc2NhcmRlZFwiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgbGluZWFyIGFuaW1hdGlvbiB3aWxsIGRpc2NhcmQgcHJldmlvdXMgdmFsdWVzIHdoaWxlIGEgY3VtdWxhdGl2ZSBhbmltYXRpb24gd2lsbCBhY2N1bXVsYXRlIHRoZW0gdW50aWwgaXQgcmVzdGFydHNcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJjb2xvcnNcIjoge1xuICAgICAgICBcImFsaWNlYmx1ZVwiOiAgWzI0MCwgMjQ4LCAyNTVdLFxuICAgICAgICBcImFudGlxdWV3aGl0ZVwiOiAgWzI1MCwgMjM1LCAyMTVdLFxuICAgICAgICBcImFxdWFcIjogIFswLCAyNTUsIDI1NV0sXG4gICAgICAgIFwiYXF1YW1hcmluZVwiOiAgWzEyNywgMjU1LCAyMTJdLFxuICAgICAgICBcImF6dXJlXCI6ICBbMjQwLCAyNTUsIDI1NV0sXG4gICAgICAgIFwiYmVpZ2VcIjogIFsyNDUsIDI0NSwgMjIwXSxcbiAgICAgICAgXCJiaXNxdWVcIjogIFsyNTUsIDIyOCwgMTk2XSxcbiAgICAgICAgXCJibGFja1wiOiAgWzAsIDAsIDBdLFxuICAgICAgICBcImJsYW5jaGVkYWxtb25kXCI6ICBbMjU1LDIzNSwyMDVdLFxuICAgICAgICBcImJsdWVcIjogIFswLCAwLCAyNTVdLFxuICAgICAgICBcImJsdWV2aW9sZXRcIjogIFsxMzgsIDQzLCAyMjZdLFxuICAgICAgICBcImJyb3duXCI6ICBbMTY1LCA0MiwgNDJdLFxuICAgICAgICBcImJ1cmx5d29vZFwiOiAgWzIyMiwgMTg0LCAxMzVdLFxuICAgICAgICBcImNhZGV0Ymx1ZVwiOiAgWzk1LCAxNTgsIDE2MF0sXG4gICAgICAgIFwiY2hhcnRyZXVzZVwiOiAgWzEyNywgMjU1LCAwXSxcbiAgICAgICAgXCJjaG9jb2xhdGVcIjogIFsyMTAsIDEwNSwgMzBdLFxuICAgICAgICBcImNvcmFsXCI6ICBbMjU1LCAxMjcsIDgwXSxcbiAgICAgICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiAgWzEwMCwgMTQ5LCAyMzddLFxuICAgICAgICBcImNvcm5zaWxrXCI6ICBbMjU1LCAyNDgsIDIyMF0sXG4gICAgICAgIFwiY3JpbXNvblwiOiAgWzIyMCwgMjAsIDYwXSxcbiAgICAgICAgXCJjeWFuXCI6ICBbMCwgMjU1LCAyNTVdLFxuICAgICAgICBcImRhcmtibHVlXCI6ICBbMCwgMCwgMTM5XSxcbiAgICAgICAgXCJkYXJrY3lhblwiOiAgWzAsIDEzOSwgMTM5XSxcbiAgICAgICAgXCJkYXJrZ29sZGVucm9kXCI6ICBbMTg0LCAxMzQsIDExXSxcbiAgICAgICAgXCJkYXJrZ3JheVwiOiAgWzE2OSwgMTY5LCAxNjldLFxuICAgICAgICBcImRhcmtncmVlblwiOiAgWzAsIDEwMCwgMF0sXG4gICAgICAgIFwiZGFya2dyZXlcIjogIFsxNjksIDE2OSwgMTY5XSxcbiAgICAgICAgXCJkYXJra2hha2lcIjogIFsxODksIDE4MywgMTA3XSxcbiAgICAgICAgXCJkYXJrbWFnZW50YVwiOiAgWzEzOSwgMCwgMTM5XSxcbiAgICAgICAgXCJkYXJrb2xpdmVncmVlblwiOiAgWzg1LCAxMDcsIDQ3XSxcbiAgICAgICAgXCJkYXJrb3JhbmdlXCI6ICBbMjU1LCAxNDAsIDBdLFxuICAgICAgICBcImRhcmtvcmNoaWRcIjogIFsxNTMsIDUwLCAyMDRdLFxuICAgICAgICBcImRhcmtyZWRcIjogIFsxMzksIDAsIDBdLFxuICAgICAgICBcImRhcmtzYWxtb25cIjogIFsyMzMsIDE1MCwgMTIyXSxcbiAgICAgICAgXCJkYXJrc2VhZ3JlZW5cIjogIFsxNDMsIDE4OCwgMTQzXSxcbiAgICAgICAgXCJkYXJrc2xhdGVibHVlXCI6ICBbNzIsIDYxLCAxMzldLFxuICAgICAgICBcImRhcmtzbGF0ZWdyZXlcIjogIFs0NywgNzksIDc5XSxcbiAgICAgICAgXCJkYXJrdHVycXVvaXNlXCI6ICBbMCwgMjA2LCAyMDldLFxuICAgICAgICBcImRhcmt2aW9sZXRcIjogIFsxNDgsIDAsIDIxMV0sXG4gICAgICAgIFwiZGVlcHBpbmtcIjogIFsyNTUsIDIwLCAxNDddLFxuICAgICAgICBcImRlZXBza3libHVlXCI6ICBbMCwgMTkxLCAyNTVdLFxuICAgICAgICBcImRpbWdyYXlcIjogIFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgICAgXCJkaW1ncmV5XCI6ICBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICAgIFwiZG9kZ2VyYmx1ZVwiOiAgWzMwLCAxNDQsIDI1NV0sXG4gICAgICAgIFwiZmlyZWJyaWNrXCI6ICBbMTc4LCAzNCwgMzRdLFxuICAgICAgICBcImZsb3JhbHdoaXRlXCI6ICBbMjU1LCAyNTAsIDI0MF0sXG4gICAgICAgIFwiZm9yZXN0Z3JlZW5cIjogIFszNCwgMTM5LCAzNF0sXG4gICAgICAgIFwiZnVjaHNpYVwiOiAgWzI1NSwgMCwgMjU1XSxcbiAgICAgICAgXCJnYWluc2Jvcm9cIjogIFsyMjAsIDIyMCwgMjIwXSxcbiAgICAgICAgXCJnaG9zdHdoaXRlXCI6ICBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgICAgIFwiZ29sZFwiOiAgWzI1NSwgMjE1LCAwXSxcbiAgICAgICAgXCJnb2xkZW5yb2RcIjogIFsyMTgsIDE2NSwgMzJdLFxuICAgICAgICBcImdyYXlcIjogIFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJncmV5XCI6ICBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICAgIFwiZ3JlZW5cIjogIFswLCAxMjgsIDBdLFxuICAgICAgICBcImdyZWVueWVsbG93XCI6ICBbMTczLCAyNTUsIDQ3XSxcbiAgICAgICAgXCJob25leWRld1wiOiAgWzI0MCwgMjU1LCAyNDBdLFxuICAgICAgICBcImhvdHBpbmtcIjogIFsyNTUsIDEwNSwgMTgwXSxcbiAgICAgICAgXCJpbmRpYW5yZWRcIjogIFsyMDUsIDkyLCA5Ml0sXG4gICAgICAgIFwiaW5kaWdvXCI6ICBbNzUsIDAsIDEzMF0sXG4gICAgICAgIFwiaXZvcnlcIjogIFsyNTUsIDI1NSwgMjQwXSxcbiAgICAgICAgXCJraGFraVwiOiAgWzI0MCwgMjMwLCAxNDBdLFxuICAgICAgICBcImxhdmVuZGVyXCI6ICBbMjMwLCAyMzAsIDI1MF0sXG4gICAgICAgIFwibGF2ZW5kZXJibHVzaFwiOiAgWzI1NSwgMjQwLCAyNDVdLFxuICAgICAgICBcImxhd25ncmVlblwiOiAgWzEyNCwgMjUyLCAwXSxcbiAgICAgICAgXCJsZW1vbmNoaWZmb25cIjogIFsyNTUsIDI1MCwgMjA1XSxcbiAgICAgICAgXCJsaWdodGJsdWVcIjogIFsxNzMsIDIxNiwgMjMwXSxcbiAgICAgICAgXCJsaWdodGNvcmFsXCI6ICBbMjQwLCAxMjgsIDEyOF0sXG4gICAgICAgIFwibGlnaHRjeWFuXCI6ICBbMjI0LCAyNTUsIDI1NV0sXG4gICAgICAgIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogIFsyNTAsIDI1MCwgMjEwXSxcbiAgICAgICAgXCJsaWdodGdyYXlcIjogIFsyMTEsIDIxMSwgMjExXSxcbiAgICAgICAgXCJsaWdodGdyZWVuXCI6ICBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgICAgIFwibGlnaHRncmV5XCI6ICBbMjExLCAyMTEsIDIxMV0sXG4gICAgICAgIFwibGlnaHRwaW5rXCI6ICBbMjU1LCAxODIsIDE5M10sXG4gICAgICAgIFwibGlnaHRzYWxtb25cIjogIFsyNTUsIDE2MCwgMTIyXSxcbiAgICAgICAgXCJsaWdodHNlYWdyZWVuXCI6ICBbMzIsIDE3OCwgMTcwXSxcbiAgICAgICAgXCJsaWdodHNreWJsdWVcIjogIFsxMzUsIDIwNiwgMjUwXSxcbiAgICAgICAgXCJsaWdodHNsYXRlZ3JheVwiOiAgWzExOSwgMTM2LCAxNTNdLFxuICAgICAgICBcImxpZ2h0c2xhdGVncmV5XCI6ICBbMTE5LCAxMzYsIDE1M10sXG4gICAgICAgIFwibGlnaHRzdGVlbGJsdWVcIjogIFsxNzYsIDE5NiwgMjIyXSxcbiAgICAgICAgXCJsaWdodHllbGxvd1wiOiAgWzI1NSwgMjU1LCAyMjRdLFxuICAgICAgICBcImxpbWVcIjogIFswLCAyNTUsIDBdLFxuICAgICAgICBcImxpbWVncmVlblwiOiAgWzUwLCAyMDUsIDUwXSxcbiAgICAgICAgXCJsaW5lblwiOiAgWzI1MCwgMjQwLCAyMzBdLFxuICAgICAgICBcIm1hZ2VudGFcIjogIFsyNTUsIDAsIDI1NV0sXG4gICAgICAgIFwibWFyb29uXCI6ICBbMTI4LCAwLCAwXSxcbiAgICAgICAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6ICBbMTAyLCAyMDUsIDE3MF0sXG4gICAgICAgIFwibWVkaXVtYmx1ZVwiOiAgWzAsIDAsIDIwNV0sXG4gICAgICAgIFwibWVkaXVtb3JjaGlkXCI6ICBbMTg2LCA4NSwgMjExXSxcbiAgICAgICAgXCJtZWRpdW1wdXJwbGVcIjogIFsxNDcsIDExMiwgMjE5XSxcbiAgICAgICAgXCJtZWRpdW1zZWFncmVlblwiOiAgWzYwLCAxNzksIDExM10sXG4gICAgICAgIFwibWVkaXVtc2xhdGVibHVlXCI6ICBbMTIzLCAxMDQsIDIzOF0sXG4gICAgICAgIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogIFswLCAyNTAsIDE1NF0sXG4gICAgICAgIFwibWVkaXVtdHVycXVvaXNlXCI6ICBbNzIsIDIwOSwgMjA0XSxcbiAgICAgICAgXCJtZWRpdW12aW9sZXRyZWRcIjogIFsxOTksIDIxLCAxMzNdLFxuICAgICAgICBcIm1pZG5pZ2h0Ymx1ZVwiOiAgWzI1LCAyNSwgMTEyXSxcbiAgICAgICAgXCJtaW50Y3JlYW1cIjogIFsyNDUsIDI1NSwgMjUwXSxcbiAgICAgICAgXCJtaXN0eXJvc2VcIjogIFsyNTUsIDIyOCwgMjI1XSxcbiAgICAgICAgXCJtb2NjYXNpblwiOiAgWzI1NSwgMjI4LCAxODFdLFxuICAgICAgICBcIm5hdmFqb3doaXRlXCI6ICBbMjU1LCAyMjIsIDE3M10sXG4gICAgICAgIFwibmF2eVwiOiAgWzAsIDAsIDEyOF0sXG4gICAgICAgIFwib2xkbGFjZVwiOiAgWzI1MywgMjQ1LCAyMzBdLFxuICAgICAgICBcIm9saXZlXCI6ICBbMTI4LCAxMjgsIDBdLFxuICAgICAgICBcIm9saXZlZHJhYlwiOiAgWzEwNywgMTQyLCAzNV0sXG4gICAgICAgIFwib3JhbmdlXCI6ICBbMjU1LCAxNjUsIDBdLFxuICAgICAgICBcIm9yYW5nZXJlZFwiOiAgWzI1NSwgNjksIDBdLFxuICAgICAgICBcIm9yY2hpZFwiOiAgWzIxOCwgMTEyLCAyMTRdLFxuICAgICAgICBcInBhbGVnb2xkZW5yb2RcIjogIFsyMzgsIDIzMiwgMTcwXSxcbiAgICAgICAgXCJwYWxlZ3JlZW5cIjogIFsxNTIsIDI1MSwgMTUyXSxcbiAgICAgICAgXCJwYWxldHVycXVvaXNlXCI6ICBbMTc1LCAyMzgsIDIzOF0sXG4gICAgICAgIFwicGFsZXZpb2xldHJlZFwiOiAgWzIxOSwgMTEyLCAxNDddLFxuICAgICAgICBcInBhcGF5YXdoaXBcIjogIFsyNTUsIDIzOSwgMjEzXSxcbiAgICAgICAgXCJwZWFjaHB1ZmZcIjogIFsyNTUsIDIxOCwgMTg1XSxcbiAgICAgICAgXCJwZXJ1XCI6ICBbMjA1LCAxMzMsIDYzXSxcbiAgICAgICAgXCJwaW5rXCI6ICBbMjU1LCAxOTIsIDIwM10sXG4gICAgICAgIFwicGx1bVwiOiAgWzIyMSwgMTYwLCAyMjFdLFxuICAgICAgICBcInBvd2RlcmJsdWVcIjogIFsxNzYsIDIyNCwgMjMwXSxcbiAgICAgICAgXCJwdXJwbGVcIjogIFsxMjgsIDAsIDEyOF0sXG4gICAgICAgIFwicmVkXCI6ICBbMjU1LCAwLCAwXSxcbiAgICAgICAgXCJyb3N5YnJvd25cIjogIFsxODgsIDE0MywgMTQzXSxcbiAgICAgICAgXCJyb3lhbGJsdWVcIjogIFs2NSwgMTA1LCAyMjVdLFxuICAgICAgICBcInNhZGRsZWJyb3duXCI6ICBbMTM5LCA2OSwgMTldLFxuICAgICAgICBcInNhbG1vblwiOiAgWzI1MCwgMTI4LCAxMTRdLFxuICAgICAgICBcInNhbmR5YnJvd25cIjogIFsyNDQsIDE2NCwgOTZdLFxuICAgICAgICBcInNlYWdyZWVuXCI6ICBbNDYsIDEzOSwgODddLFxuICAgICAgICBcInNlYXNoZWxsXCI6ICBbMjU1LCAyNDUsIDIzOF0sXG4gICAgICAgIFwic2llbm5hXCI6ICBbMTYwLCA4MiwgNDVdLFxuICAgICAgICBcInNpbHZlclwiOiAgWzE5MiwgMTkyLCAxOTJdLFxuICAgICAgICBcInNreWJsdWVcIjogIFsxMzUsIDIwNiwgMjM1XSxcbiAgICAgICAgXCJzbGF0ZWJsdWVcIjogIFsxMDYsIDkwLCAyMDVdLFxuICAgICAgICBcInNsYXRlZ3JheVwiOiAgWzExMiwgMTI4LCAxNDRdLFxuICAgICAgICBcInNsYXRlZ3JleVwiOiAgWzExMiwgMTI4LCAxNDRdLFxuICAgICAgICBcInNub3dcIjogIFsyNTUsIDI1MCwgMjUwXSxcbiAgICAgICAgXCJzcHJpbmdncmVlblwiOiAgWzAsIDI1NSwgMTI3XSxcbiAgICAgICAgXCJzdGVlbGJsdWVcIjogIFs3MCwgMTMwLCAxODBdLFxuICAgICAgICBcInRhblwiOiAgWzIxMCwgMTgwLCAxNDBdLFxuICAgICAgICBcInRlYWxcIjogIFswLCAxMjgsIDEyOF0sXG4gICAgICAgIFwidGhpc3RsZVwiOiAgWzIxNiwgMTkxLCAyMTZdLFxuICAgICAgICBcInRvbWF0b1wiOiAgWzI1NSwgOTksIDcxXSxcbiAgICAgICAgXCJ0dXJxdW9pc2VcIjogIFs2NCwgMjI0LCAyMDhdLFxuICAgICAgICBcInZpb2xldFwiOiAgWzIzOCwgMTMwLCAyMzhdLFxuICAgICAgICBcIndoZWF0XCI6ICBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgICAgIFwid2hpdGVcIjogIFsyNTUsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJ3aGl0ZXNtb2tlXCI6ICBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgICAgIFwieWVsbG93XCI6ICBbMjU1LCAyNTUsIDBdLFxuICAgICAgICBcInllbGxvd2dyZWVuXCI6ICBbMTU0LCAyMDUsIDUwXSxcbiAgICAgICAgXCJ0cmFuc3BhcmVudFwiOiAgWzAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBcImZpbHRlclwiOiB7XG4gICAgICAgIFwidmFsdWVcIjogW1xuICAgICAgICAgICAgXCJ0cnVlXCIsXG4gICAgICAgICAgICBcImZhbHNlXCIsXG4gICAgICAgICAgICBcIm51bGxcIixcbiAgICAgICAgICAgIFwicG9pbnRcIixcbiAgICAgICAgICAgIFwibGluZXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJwb2x5Z29uXCIsXG4gICAgICAgICAgICBcImNvbGxlY3Rpb25cIlxuICAgICAgICBdXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvbjoge1xuICAgIGxhdGVzdDogX21hcG5pa19yZWZlcmVuY2VfbGF0ZXN0LFxuICAgICcyLjEuMSc6IF9tYXBuaWtfcmVmZXJlbmNlX2xhdGVzdFxuICB9XG59O1xuIiwiLyoqXG4gKiBUT0RPOiBkb2N1bWVudCB0aGlzLiBXaGF0IGRvZXMgdGhpcyBkbz9cbiAqL1xuaWYodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uIChvYmosIGZ1bikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAociA9IGZ1bi5jYWxsKG9iaiwgb2JqW2ldKSkgeyByZXR1cm4gcjsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG4iLCIoZnVuY3Rpb24odHJlZSkge1xudmFyIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG50cmVlLkNhbGwgPSBmdW5jdGlvbiBDYWxsKG5hbWUsIGFyZ3MsIGluZGV4KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbn07XG5cbnRyZWUuQ2FsbC5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdjYWxsJyxcbiAgICAvLyBXaGVuIGV2dWF0aW5nIGEgZnVuY3Rpb24gY2FsbCxcbiAgICAvLyB3ZSBlaXRoZXIgZmluZCB0aGUgZnVuY3Rpb24gaW4gYHRyZWUuZnVuY3Rpb25zYCBbMV0sXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBjYWxsIGl0LCBwYXNzaW5nIHRoZSAgZXZhbHVhdGVkIGFyZ3VtZW50cyxcbiAgICAvLyBvciB3ZSBzaW1wbHkgcHJpbnQgaXQgb3V0IGFzIGl0IGFwcGVhcmVkIG9yaWdpbmFsbHkgWzJdLlxuICAgIC8vIFRoZSAqZnVuY3Rpb25zLmpzKiBmaWxlIGNvbnRhaW5zIHRoZSBidWlsdC1pbiBmdW5jdGlvbnMuXG4gICAgLy8gVGhlIHJlYXNvbiB3aHkgd2UgZXZhbHVhdGUgdGhlIGFyZ3VtZW50cywgaXMgaW4gdGhlIGNhc2Ugd2hlcmVcbiAgICAvLyB3ZSB0cnkgdG8gcGFzcyBhIHZhcmlhYmxlIHRvIGEgZnVuY3Rpb24sIGxpa2U6IGBzYXR1cmF0ZShAY29sb3IpYC5cbiAgICAvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJlY2VpdmUgdGhlIHZhbHVlLCBub3QgdGhlIHZhcmlhYmxlLlxuICAgICdldic6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncy5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5ldihlbnYpOyB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2ldLmlzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5hbWUgaW4gdHJlZS5mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0cmVlLmZ1bmN0aW9uc1t0aGlzLm5hbWVdLmxlbmd0aCA8PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0cmVlLmZ1bmN0aW9uc1t0aGlzLm5hbWVdLmFwcGx5KHRyZWUuZnVuY3Rpb25zLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5jb3JyZWN0IGFyZ3VtZW50cyBnaXZlbiB0byAnICsgdGhpcy5uYW1lICsgJygpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlzOiAndW5kZWZpbmVkJywgdmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCkuICcgKyB0cmVlLmZ1bmN0aW9uc1t0aGlzLm5hbWVdLmxlbmd0aCArICcgZXhwZWN0ZWQuJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm4gPSB0cmVlLlJlZmVyZW5jZS5tYXBuaWtGdW5jdGlvbnNbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IF8ucGFpcnModHJlZS5SZWZlcmVuY2UubWFwbmlrRnVuY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVhcCBjbG9zZXN0LCBuZWVkcyBpbXByb3ZlbWVudC5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgbWVhbiA9IGZ1bmN0aW9ucy5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZbMF0sIHRyZWUuUmVmZXJlbmNlLmVkaXREaXN0YW5jZShuYW1lLCBmWzBdKSwgZlsxXV07XG4gICAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhWzFdIC0gYlsxXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAndW5rbm93biBmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJygpLCBkaWQgeW91IG1lYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFuWzBdWzBdICsgJygnICsgbWVhblswXVsyXSArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm4gIT09IGFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgIShBcnJheS5pc0FycmF5KGZuKSAmJiBfLmluY2x1ZGUoZm4sIGFyZ3MubGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IHZhcmlhYmxlLWFyZyBmdW5jdGlvbnMgbGlrZSBgY29sb3JpemUtYWxwaGFgXG4gICAgICAgICAgICAgICAgZm4gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2Z1bmN0aW9uICcgKyB0aGlzLm5hbWUgKyAnKCkgdGFrZXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBmbiArICcgYXJndW1lbnRzIGFuZCB3YXMgZ2l2ZW4gJyArIGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgZXZhbHVhdGVkIHZlcnNpb25zIG9mIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudiwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0aGlzLmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgJygnICsgdGhpcy5hcmdzLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcbi8vIFJHQiBDb2xvcnMgLSAjZmYwMDE0LCAjZWVlXG4vLyBjYW4gYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIDMgb3IgNiBjaGFyIHN0cmluZyBvciBhIDMgb3IgNCBlbGVtZW50XG4vLyBudW1lcmljYWwgYXJyYXlcbnRyZWUuQ29sb3IgPSBmdW5jdGlvbiBDb2xvcihyZ2IsIGEpIHtcbiAgICAvLyBUaGUgZW5kIGdvYWwgaGVyZSwgaXMgdG8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICAgIC8vIGludG8gYW4gaW50ZWdlciB0cmlwbGV0LCBzdWNoIGFzIGAxMjgsIDI1NSwgMGBcbiAgICAvL1xuICAgIC8vIFRoaXMgZmFjaWxpdGF0ZXMgb3BlcmF0aW9ucyBhbmQgY29udmVyc2lvbnMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmdiKSkge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYi5zbGljZSgwLCAzKTtcbiAgICB9IGVsc2UgaWYgKHJnYi5sZW5ndGggPT0gNikge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYi5tYXRjaCgvLnsyfS9nKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGMsIDE2KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZ2IgPSByZ2Iuc3BsaXQoJycpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYyArIGMsIDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IGE7XG4gICAgfSBlbHNlIGlmIChyZ2IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHRoaXMuYWxwaGEgPSByZ2JbM107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgfVxufTtcblxudHJlZS5Db2xvci5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdjb2xvcicsXG4gICAgJ2V2JzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gSWYgd2UgaGF2ZSBzb21lIHRyYW5zcGFyZW5jeSwgdGhlIG9ubHkgd2F5IHRvIHJlcHJlc2VudCBpdFxuICAgIC8vIGlzIHZpYSBgcmdiYWAuIE90aGVyd2lzZSwgd2UgdXNlIHRoZSBoZXggcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2hpY2ggaGFzIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgYnJvd3NlcnMuXG4gICAgLy8gVmFsdWVzIGFyZSBjYXBwZWQgYmV0d2VlbiBgMGAgYW5kIGAyNTVgLCByb3VuZGVkIGFuZCB6ZXJvLXBhZGRlZC5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFscGhhIDwgMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHRoaXMucmdiLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYyk7XG4gICAgICAgICAgICB9KS5jb25jYXQodGhpcy5hbHBoYSkuam9pbignLCAnKSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnIycgKyB0aGlzLnJnYi5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAoaSA+IDI1NSA/IDI1NSA6IChpIDwgMCA/IDAgOiBpKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmxlbmd0aCA9PT0gMSA/ICcwJyArIGkgOiBpO1xuICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gT3BlcmF0aW9ucyBoYXZlIHRvIGJlIGRvbmUgcGVyLWNoYW5uZWwsIGlmIG5vdCxcbiAgICAvLyBjaGFubmVscyB3aWxsIHNwaWxsIG9udG8gZWFjaCBvdGhlci4gT25jZSB3ZSBoYXZlXG4gICAgLy8gb3VyIHJlc3VsdCwgaW4gdGhlIGZvcm0gb2YgYW4gaW50ZWdlciB0cmlwbGV0LFxuICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBDb2xvciBub2RlIHRvIGhvbGQgdGhlIHJlc3VsdC5cbiAgICBvcGVyYXRlOiBmdW5jdGlvbihlbnYsIG9wLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgdHJlZS5Db2xvcikpIHtcbiAgICAgICAgICAgIG90aGVyID0gb3RoZXIudG9Db2xvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAzOyBjKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtjXSA9IHRyZWUub3BlcmF0ZShvcCwgdGhpcy5yZ2JbY10sIG90aGVyLnJnYltjXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbG9yKHJlc3VsdCk7XG4gICAgfSxcblxuICAgIHRvSFNMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSxcbiAgICAgICAgICAgIGcgPSB0aGlzLnJnYlsxXSAvIDI1NSxcbiAgICAgICAgICAgIGIgPSB0aGlzLnJnYlsyXSAvIDI1NSxcbiAgICAgICAgICAgIGEgPSB0aGlzLmFscGhhO1xuXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyLCBkID0gbWF4IC0gbWluO1xuXG4gICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgaCA9IHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoIC89IDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaDogaCAqIDM2MCwgczogcywgbDogbCwgYTogYSB9O1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLkNvbW1lbnQgPSBmdW5jdGlvbiBDb21tZW50KHZhbHVlLCBzaWxlbnQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5zaWxlbnQgPSAhIXNpbGVudDtcbn07XG5cbnRyZWUuQ29tbWVudC5wcm90b3R5cGUgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICByZXR1cm4gJzwhLS0nICsgdGhpcy52YWx1ZSArICctLT4nO1xuICAgIH0sXG4gICAgJ2V2JzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKSxcbiAgICBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vLyBBIGRlZmluaXRpb24gaXMgdGhlIGNvbWJpbmF0aW9uIG9mIGEgc2VsZWN0b3IgYW5kIHJ1bGVzLCBsaWtlXG4vLyAjZm9vIHtcbi8vICAgICBwb2x5Z29uLW9wYWNpdHk6MS4wO1xuLy8gfVxuLy9cbi8vIFRoZSBzZWxlY3RvciBjYW4gaGF2ZSBmaWx0ZXJzXG50cmVlLkRlZmluaXRpb24gPSBmdW5jdGlvbiBEZWZpbml0aW9uKHNlbGVjdG9yLCBydWxlcykge1xuICAgIHRoaXMuZWxlbWVudHMgPSBzZWxlY3Rvci5lbGVtZW50cztcbiAgICBhc3NlcnQub2soc2VsZWN0b3IuZmlsdGVycyBpbnN0YW5jZW9mIHRyZWUuRmlsdGVyc2V0KTtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5ydWxlSW5kZXggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCd6b29tJyBpbiB0aGlzLnJ1bGVzW2ldKSB0aGlzLnJ1bGVzW2ldID0gdGhpcy5ydWxlc1tpXS5jbG9uZSgpO1xuICAgICAgICB0aGlzLnJ1bGVzW2ldLnpvb20gPSBzZWxlY3Rvci56b29tO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleFt0aGlzLnJ1bGVzW2ldLnVwZGF0ZUlEKCldID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5maWx0ZXJzID0gc2VsZWN0b3IuZmlsdGVycztcbiAgICB0aGlzLnpvb20gPSBzZWxlY3Rvci56b29tO1xuICAgIHRoaXMuZnJhbWVfb2Zmc2V0ID0gc2VsZWN0b3IuZnJhbWVfb2Zmc2V0O1xuICAgIHRoaXMuYXR0YWNobWVudCA9IHNlbGVjdG9yLmF0dGFjaG1lbnQgfHwgJ19fZGVmYXVsdF9fJztcbiAgICB0aGlzLnNwZWNpZmljaXR5ID0gc2VsZWN0b3Iuc3BlY2lmaWNpdHkoKTtcbn07XG5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5maWx0ZXJzLnRvU3RyaW5nKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSAnXFxuICAgICcgKyB0aGlzLnJ1bGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICBpZiAoZmlsdGVycykgYXNzZXJ0Lm9rKGZpbHRlcnMgaW5zdGFuY2VvZiB0cmVlLkZpbHRlcnNldCk7XG4gICAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0cmVlLkRlZmluaXRpb24ucHJvdG90eXBlKTtcbiAgICBjbG9uZS5ydWxlcyA9IHRoaXMucnVsZXMuc2xpY2UoKTtcbiAgICBjbG9uZS5ydWxlSW5kZXggPSBfLmNsb25lKHRoaXMucnVsZUluZGV4KTtcbiAgICBjbG9uZS5maWx0ZXJzID0gZmlsdGVycyA/IGZpbHRlcnMgOiB0aGlzLmZpbHRlcnMuY2xvbmUoKTtcbiAgICBjbG9uZS5hdHRhY2htZW50ID0gdGhpcy5hdHRhY2htZW50O1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUuYWRkUnVsZXMgPSBmdW5jdGlvbihydWxlcykge1xuICAgIHZhciBhZGRlZCA9IDA7XG5cbiAgICAvLyBBZGQgb25seSB1bmlxdWUgcnVsZXMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMucnVsZUluZGV4W3J1bGVzW2ldLmlkXSkge1xuICAgICAgICAgICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGVzW2ldKTtcbiAgICAgICAgICAgIHRoaXMucnVsZUluZGV4W3J1bGVzW2ldLmlkXSA9IHRydWU7XG4gICAgICAgICAgICBhZGRlZCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkO1xufTtcblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBzZWxlY3RvciBtYXRjaGVzIGEgZ2l2ZW4gaWRcbi8vIGFuZCBhcnJheSBvZiBjbGFzc2VzLCBieSBkZXRlcm1pbmluZyB3aGV0aGVyXG4vLyBhbGwgZWxlbWVudHMgaXQgY29udGFpbnMgbWF0Y2guXG50cmVlLkRlZmluaXRpb24ucHJvdG90eXBlLmFwcGxpZXNUbyA9IGZ1bmN0aW9uKGlkLCBjbGFzc2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgICAgIGlmICghKGVsZW0ud2lsZGNhcmQgfHxcbiAgICAgICAgICAgIChlbGVtLnR5cGUgPT09ICdjbGFzcycgJiYgY2xhc3Nlc1tlbGVtLmNsZWFuXSkgfHxcbiAgICAgICAgICAgIChlbGVtLnR5cGUgPT09ICdpZCcgJiYgaWQgPT09IGVsZW0uY2xlYW4pKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIHN5bWJvbGl6ZXJOYW1lKHN5bWJvbGl6ZXIpIHtcbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cikgeyByZXR1cm4gc3RyWzFdLnRvVXBwZXJDYXNlKCk7IH1cbiAgICByZXR1cm4gc3ltYm9saXplci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgIHN5bWJvbGl6ZXIuc2xpY2UoMSkucmVwbGFjZSgvXFwtLi8sIGNhcGl0YWxpemUpICsgJ1N5bWJvbGl6ZXInO1xufVxuXG4vLyBHZXQgYSBzaW1wbGUgbGlzdCBvZiB0aGUgc3ltYm9saXplcnMsIGluIG9yZGVyXG5mdW5jdGlvbiBzeW1ib2xpemVyTGlzdChzeW1fb3JkZXIpIHtcbiAgICByZXR1cm4gc3ltX29yZGVyLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdlswXTsgfSk7XG59XG5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUuc3ltYm9saXplcnNUb1hNTCA9IGZ1bmN0aW9uKGVudiwgc3ltYm9saXplcnMsIHpvb20pIHtcbiAgICB2YXIgeG1sID0gem9vbS50b1hNTChlbnYpLmpvaW4oJycpICsgdGhpcy5maWx0ZXJzLnRvWE1MKGVudik7XG5cbiAgICAvLyBTb3J0IHN5bWJvbGl6ZXJzIGJ5IHRoZSBpbmRleCBvZiB0aGVpciBmaXJzdCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gICAgdmFyIHN5bV9vcmRlciA9IFtdLCBpbmRleGVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHN5bWJvbGl6ZXJzKSB7XG4gICAgICAgIGluZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzeW1ib2xpemVyc1trZXldKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goc3ltYm9saXplcnNba2V5XVtwcm9wXS5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbl9pZHggPSBNYXRoLm1pbi5hcHBseShNYXRoLCBpbmRleGVzKTtcbiAgICAgICAgc3ltX29yZGVyLnB1c2goW2tleSwgbWluX2lkeF0pO1xuICAgIH1cblxuICAgIHN5bV9vcmRlciA9IHN5bWJvbGl6ZXJMaXN0KHN5bV9vcmRlcik7XG4gICAgdmFyIHN5bV9jb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bV9vcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHN5bWJvbGl6ZXJzW3N5bV9vcmRlcltpXV07XG4gICAgICAgIHZhciBzeW1ib2xpemVyID0gc3ltX29yZGVyW2ldLnNwbGl0KCcvJykucG9wKCk7XG5cbiAgICAgICAgLy8gU2tpcCB0aGUgbWFnaWNhbCAqIHN5bWJvbGl6ZXIgd2hpY2ggaXMgdXNlZCBmb3IgdW5pdmVyc2FsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gd2hpY2ggYXJlIGJ1YmJsZWQgdXAgdG8gU3R5bGUgZWxlbWVudHMgaW50ZWFkIG9mIFN5bWJvbGl6ZXIgZWxlbWVudHMuXG4gICAgICAgIGlmIChzeW1ib2xpemVyID09PSAnKicpIGNvbnRpbnVlO1xuICAgICAgICBzeW1fY291bnQrKztcblxuICAgICAgICB2YXIgZmFpbCA9IHRyZWUuUmVmZXJlbmNlLnJlcXVpcmVkUHJvcGVydGllcyhzeW1ib2xpemVyLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGZhaWwpIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gYXR0cmlidXRlc1tPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zaGlmdCgpXTtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZmFpbCxcbiAgICAgICAgICAgICAgICBpbmRleDogcnVsZS5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogcnVsZS5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IHN5bWJvbGl6ZXJOYW1lKHN5bWJvbGl6ZXIpO1xuXG4gICAgICAgIHZhciBzZWxmY2xvc2luZyA9IHRydWUsIHRhZ2NvbnRlbnQ7XG4gICAgICAgIHhtbCArPSAnICAgIDwnICsgbmFtZSArICcgJztcbiAgICAgICAgZm9yICh2YXIgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9saXplciA9PT0gJ21hcCcpIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ01hcCBwcm9wZXJ0aWVzIGFyZSBub3QgcGVybWl0dGVkIGluIG90aGVyIHJ1bGVzJyxcbiAgICAgICAgICAgICAgICBpbmRleDogYXR0cmlidXRlc1tqXS5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogYXR0cmlidXRlc1tqXS5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgeCA9IHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKGF0dHJpYnV0ZXNbal0ubmFtZSk7XG4gICAgICAgICAgICBpZiAoeCAmJiB4LnNlcmlhbGl6YXRpb24gJiYgeC5zZXJpYWxpemF0aW9uID09PSAnY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmY2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRhZ2NvbnRlbnQgPSBhdHRyaWJ1dGVzW2pdLmV2KGVudikudG9YTUwoZW52LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCAmJiB4LnNlcmlhbGl6YXRpb24gJiYgeC5zZXJpYWxpemF0aW9uID09PSAndGFnJykge1xuICAgICAgICAgICAgICAgIHNlbGZjbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFnY29udGVudCA9IGF0dHJpYnV0ZXNbal0uZXYoZW52KS50b1hNTChlbnYsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWwgKz0gYXR0cmlidXRlc1tqXS5ldihlbnYpLnRvWE1MKGVudikgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGZjbG9zaW5nKSB7XG4gICAgICAgICAgICB4bWwgKz0gJy8+XFxuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFnY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHRhZ2NvbnRlbnQuaW5kZXhPZignPCcpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgeG1sICs9ICc+JyArIHRhZ2NvbnRlbnQgKyAnPC8nICsgbmFtZSArICc+XFxuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeG1sICs9ICc+PCFbQ0RBVEFbJyArIHRhZ2NvbnRlbnQgKyAnXV0+PC8nICsgbmFtZSArICc+XFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN5bV9jb3VudCB8fCAheG1sKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuICcgIDxSdWxlPlxcbicgKyB4bWwgKyAnICA8L1J1bGU+XFxuJztcbn07XG5cbi8vIFRha2UgYSB6b29tIHJhbmdlIG9mIHpvb21zIGFuZCAnaScsIHRoZSBpbmRleCBvZiBhIHJ1bGUgaW4gdGhpcy5ydWxlcyxcbi8vIGFuZCBmaW5kcyBhbGwgYXBwbGljYWJsZSBzeW1ib2xpemVyc1xudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS5jb2xsZWN0U3ltYm9saXplcnMgPSBmdW5jdGlvbih6b29tcywgaSkge1xuICAgIHZhciBzeW1ib2xpemVycyA9IHt9LCBjaGlsZDtcblxuICAgIGZvciAodmFyIGogPSBpOyBqIDwgdGhpcy5ydWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjaGlsZCA9IHRoaXMucnVsZXNbal07XG4gICAgICAgIHZhciBrZXkgPSBjaGlsZC5pbnN0YW5jZSArICcvJyArIGNoaWxkLnN5bWJvbGl6ZXI7XG4gICAgICAgIGlmICh6b29tcy5jdXJyZW50ICYgY2hpbGQuem9vbSAmJlxuICAgICAgICAgICAoIShrZXkgaW4gc3ltYm9saXplcnMpIHx8XG4gICAgICAgICAgICghKGNoaWxkLm5hbWUgaW4gc3ltYm9saXplcnNba2V5XSkpKSkge1xuICAgICAgICAgICAgem9vbXMuY3VycmVudCAmPSBjaGlsZC56b29tO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHN5bWJvbGl6ZXJzKSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbGl6ZXJzW2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN5bWJvbGl6ZXJzW2tleV1bY2hpbGQubmFtZV0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhzeW1ib2xpemVycykubGVuZ3RoKSB7XG4gICAgICAgIHpvb21zLnJ1bGUgJj0gKHpvb21zLmF2YWlsYWJsZSAmPSB+em9vbXMuY3VycmVudCk7XG4gICAgICAgIHJldHVybiBzeW1ib2xpemVycztcbiAgICB9XG59O1xuXG4vLyBUaGUgdHJlZS5ab29tLnRvU3RyaW5nIGZ1bmN0aW9uIGlnbm9yZXMgdGhlIGhvbGVzIGluIHpvb20gcmFuZ2VzIGFuZCBvdXRwdXRzXG4vLyBzY2FsZWRlbm9taW5hdG9ycyB0aGF0IGNvdmVyIHRoZSB3aG9sZSByYW5nZSBmcm9tIHRoZSBmaXJzdCB0byBsYXN0IGJpdCBzZXQuXG4vLyBUaGlzIGFsZ29yaXRobSBjYW4gcHJvZHVjZXMgem9vbSByYW5nZXMgdGhhdCBtYXkgaGF2ZSBob2xlcy4gSG93ZXZlcixcbi8vIHdoZW4gdXNpbmcgdGhlIGZpbHRlci1tb2RlPVwiZmlyc3RcIiwgbW9yZSBzcGVjaWZpYyB6b29tIGZpbHRlcnMgd2lsbCBhbHdheXNcbi8vIGVuZCB1cCBiZWZvcmUgYnJvYWRlciByYW5nZXMuIFRoZSBmaWx0ZXItbW9kZSB3aWxsIHBpY2sgdGhvc2UgZmlyc3QgYmVmb3JlXG4vLyByZXNvcnRpbmcgdG8gdGhlIHpvb20gcmFuZ2Ugd2l0aCB0aGUgaG9sZSBhbmQgc3RvcCBwcm9jZXNzaW5nIGZ1cnRoZXIgcnVsZXMuXG50cmVlLkRlZmluaXRpb24ucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZW52LCBleGlzdGluZykge1xuICAgIHZhciBmaWx0ZXIgPSB0aGlzLmZpbHRlcnMudG9TdHJpbmcoKTtcbiAgICBpZiAoIShmaWx0ZXIgaW4gZXhpc3RpbmcpKSBleGlzdGluZ1tmaWx0ZXJdID0gdHJlZS5ab29tLmFsbDtcblxuICAgIHZhciBhdmFpbGFibGUgPSB0cmVlLlpvb20uYWxsLCB4bWwgPSAnJywgem9vbSwgc3ltYm9saXplcnMsXG4gICAgICAgIHpvb21zID0geyBhdmFpbGFibGU6IHRyZWUuWm9vbS5hbGwgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoICYmIGF2YWlsYWJsZTsgaSsrKSB7XG4gICAgICAgIHpvb21zLnJ1bGUgPSB0aGlzLnJ1bGVzW2ldLnpvb207XG4gICAgICAgIGlmICghKGV4aXN0aW5nW2ZpbHRlcl0gJiB6b29tcy5ydWxlKSkgY29udGludWU7XG5cbiAgICAgICAgd2hpbGUgKHpvb21zLmN1cnJlbnQgPSB6b29tcy5ydWxlICYgYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9saXplcnMgPSB0aGlzLmNvbGxlY3RTeW1ib2xpemVycyh6b29tcywgaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShleGlzdGluZ1tmaWx0ZXJdICYgem9vbXMuY3VycmVudCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHhtbCArPSB0aGlzLnN5bWJvbGl6ZXJzVG9YTUwoZW52LCBzeW1ib2xpemVycyxcbiAgICAgICAgICAgICAgICAgICAgKG5ldyB0cmVlLlpvb20oKSkuc2V0Wm9vbShleGlzdGluZ1tmaWx0ZXJdICYgem9vbXMuY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nW2ZpbHRlcl0gJj0gfnpvb21zLmN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geG1sO1xufTtcblxudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS50b0pTID0gZnVuY3Rpb24oZW52KSB7XG4gIHZhciBzaGFkZXJBdHRycyA9IHt9O1xuXG4gIC8vIG1lcmdlIGNvbmRpdGlvbnMgZnJvbSBmaWx0ZXJzIHdpdGggem9vbSBjb25kaXRpb24gb2YgdGhlXG4gIC8vIGRlZmluaXRpb25cbiAgdmFyIHpvb20gPSBcIihcIiArIHRoaXMuem9vbSArIFwiICYgKDEgPDwgY3R4Lnpvb20pKVwiO1xuICB2YXIgZnJhbWVfb2Zmc2V0ID0gdGhpcy5mcmFtZV9vZmZzZXQ7XG4gIHZhciBfaWYgPSB0aGlzLmZpbHRlcnMudG9KUyhlbnYpO1xuICB2YXIgZmlsdGVycyA9IFt6b29tXTtcbiAgaWYoX2lmKSBmaWx0ZXJzLnB1c2goX2lmKTtcbiAgaWYoZnJhbWVfb2Zmc2V0KSBmaWx0ZXJzLnB1c2goJ2N0eFtcImZyYW1lLW9mZnNldFwiXSA9PT0gJyArIGZyYW1lX29mZnNldCk7XG4gIF9pZiA9IGZpbHRlcnMuam9pbihcIiAmJiBcIik7XG4gIF8uZWFjaCh0aGlzLnJ1bGVzLCBmdW5jdGlvbihydWxlKSB7XG4gICAgICBpZihydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlKSB7XG4gICAgICAgIHNoYWRlckF0dHJzW3J1bGUubmFtZV0gPSBzaGFkZXJBdHRyc1tydWxlLm5hbWVdIHx8IFtdO1xuXG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgIGluZGV4OiBydWxlLmluZGV4LFxuICAgICAgICAgIHN5bWJvbGl6ZXI6IHJ1bGUuc3ltYm9saXplclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfaWYpIHtcbiAgICAgICAgICByLmpzID0gXCJpZihcIiArIF9pZiArIFwiKXtcIiArIHJ1bGUudmFsdWUudG9KUyhlbnYpICsgXCJ9XCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByLmpzID0gcnVsZS52YWx1ZS50b0pTKGVudik7XG4gICAgICAgIH1cblxuICAgICAgICByLmNvbnN0YW50ID0gcnVsZS52YWx1ZS5ldihlbnYpLmlzICE9PSAnZmllbGQnO1xuICAgICAgICByLmZpbHRlcmVkID0gISFfaWY7XG5cbiAgICAgICAgc2hhZGVyQXR0cnNbcnVsZS5uYW1lXS5wdXNoKHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZXNldCBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAvL2lmIChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlc2V0KSB7XG4gICAgICAgICAgLy92YXIgc2ggPSBydWxlLnRvSlMoZW52KTtcbiAgICAgICAgICAvL2Zvcih2YXIgdiBpbiBzaCkge1xuICAgICAgICAgICAgLy9zaGFkZXJBdHRyc1t2XSA9IHNoYWRlckF0dHJzW3ZdIHx8IFtdO1xuICAgICAgICAgICAgLy9mb3IodmFyIGF0dHIgaW4gc2hbdl0pIHtcbiAgICAgICAgICAgICAgLy9zaGFkZXJBdHRyc1t2XS5wdXNoKHNoW3ZdW2F0dHJdKTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgIC8vfVxuICAgICAgICAvL31cbiAgICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaGFkZXJBdHRycztcbn07XG5cblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG52YXIgXyA9IGdsb2JhbC5fIHx8IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbi8vXG4vLyBBIG51bWJlciB3aXRoIGEgdW5pdFxuLy9cbnRyZWUuRGltZW5zaW9uID0gZnVuY3Rpb24gRGltZW5zaW9uKHZhbHVlLCB1bml0LCBpbmRleCkge1xuICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB0aGlzLnVuaXQgPSB1bml0IHx8IG51bGw7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxudHJlZS5EaW1lbnNpb24ucHJvdG90eXBlID0ge1xuICAgIGlzOiAnZmxvYXQnLFxuICAgIHBoeXNpY2FsX3VuaXRzOiBbJ20nLCAnY20nLCAnaW4nLCAnbW0nLCAncHQnLCAncGMnXSxcbiAgICBzY3JlZW5fdW5pdHM6IFsncHgnLCAnJSddLFxuICAgIGFsbF91bml0czogWydtJywgJ2NtJywgJ2luJywgJ21tJywgJ3B0JywgJ3BjJywgJ3B4JywgJyUnXSxcbiAgICBkZW5zaXRpZXM6IHtcbiAgICAgICAgbTogMC4wMjU0LFxuICAgICAgICBtbTogMjUuNCxcbiAgICAgICAgY206IDIuNTQsXG4gICAgICAgIHB0OiA3MixcbiAgICAgICAgcGM6IDZcbiAgICB9LFxuICAgIGV2OiBmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIGlmICh0aGlzLnVuaXQgJiYgIV8uY29udGFpbnModGhpcy5hbGxfdW5pdHMsIHRoaXMudW5pdCkpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHVuaXQ6ICdcIiArIHRoaXMudW5pdCArIFwiJ1wiLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGlzOiAndW5kZWZpbmVkJywgdmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgdW5pdHMgd2hpY2ggYXJlIG5vdCBweCBvciAlXG4gICAgICAgIGlmICh0aGlzLnVuaXQgJiYgXy5jb250YWlucyh0aGlzLnBoeXNpY2FsX3VuaXRzLCB0aGlzLnVuaXQpKSB7XG4gICAgICAgICAgICBpZiAoIWVudi5wcGkpIHtcbiAgICAgICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcInBwaSBpcyBub3Qgc2V0LCBzbyBtZXRyaWMgdW5pdHMgY2FuJ3QgYmUgdXNlZFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzOiAndW5kZWZpbmVkJywgdmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGFsbCB1bml0cyB0byBpbmNoXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGluY2ggdG8gcHggdXNpbmcgcHBpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gKHRoaXMudmFsdWUgLyB0aGlzLmRlbnNpdGllc1t0aGlzLnVuaXRdKSAqIGVudi5wcGk7XG4gICAgICAgICAgICB0aGlzLnVuaXQgPSAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuQ29sb3IoW3RoaXMudmFsdWUsIHRoaXMudmFsdWUsIHRoaXMudmFsdWVdKTtcbiAgICB9LFxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgucm91bmQodGhpcy52YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgb3BlcmF0ZTogZnVuY3Rpb24oZW52LCBvcCwgb3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudW5pdCA9PT0gJyUnICYmIG90aGVyLnVuaXQgIT09ICclJykge1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSWYgdHdvIG9wZXJhbmRzIGRpZmZlciwgdGhlIGZpcnN0IG11c3Qgbm90IGJlICUnLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnVuaXQgIT09ICclJyAmJiBvdGhlci51bml0ID09PSAnJScpIHtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJyonIHx8IG9wID09PSAnLycgfHwgb3AgPT09ICclJykge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQZXJjZW50IHZhbHVlcyBjYW4gb25seSBiZSBhZGRlZCBvciBzdWJ0cmFjdGVkIGZyb20gb3RoZXIgdmFsdWVzJyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24odHJlZS5vcGVyYXRlKG9wLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLCB0aGlzLnZhbHVlICogb3RoZXIudmFsdWUgKiAwLjAxKSxcbiAgICAgICAgICAgICAgICB0aGlzLnVuaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9oZXJlIHRoZSBvcGVyYW5kcyBhcmUgZWl0aGVyIHRoZSBzYW1lICglIG9yIHVuZGVmaW5lZCBvciBweCksIG9yIG9uZSBpcyB1bmRlZmluZWQgYW5kIHRoZSBvdGhlciBpcyBweFxuICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGltZW5zaW9uKHRyZWUub3BlcmF0ZShvcCwgdGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpLFxuICAgICAgICAgICAgdGhpcy51bml0IHx8IG90aGVyLnVuaXQpO1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG4vLyBBbiBlbGVtZW50IGlzIGFuIGlkIG9yIGNsYXNzIHNlbGVjdG9yXG50cmVlLkVsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICBpZiAodGhpcy52YWx1ZVswXSA9PT0gJyMnKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdpZCc7XG4gICAgICAgIHRoaXMuY2xlYW4gPSB0aGlzLnZhbHVlLnJlcGxhY2UoL14jLywgJycpO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWx1ZVswXSA9PT0gJy4nKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdjbGFzcyc7XG4gICAgICAgIHRoaXMuY2xlYW4gPSB0aGlzLnZhbHVlLnJlcGxhY2UoL15cXC4vLCAnJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbHVlLmluZGV4T2YoJyonKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3dpbGRjYXJkJztcbiAgICB9XG59O1xuXG4vLyBEZXRlcm1pbmUgdGhlICdzcGVjaWZpY2l0eSBtYXRyaXgnIG9mIHRoaXNcbi8vIHNwZWNpZmljIHNlbGVjdG9yXG50cmVlLkVsZW1lbnQucHJvdG90eXBlLnNwZWNpZmljaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHRoaXMudHlwZSA9PT0gJ2lkJykgPyAxIDogMCwgLy8gYVxuICAgICAgICAodGhpcy50eXBlID09PSAnY2xhc3MnKSA/IDEgOiAwICAvLyBiXG4gICAgXTtcbn07XG5cbnRyZWUuRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmFsdWU7IH07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLkV4cHJlc3Npb24gPSBmdW5jdGlvbiBFeHByZXNzaW9uKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcblxudHJlZS5FeHByZXNzaW9uLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ2V4cHJlc3Npb24nLFxuICAgIGV2OiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkV4cHJlc3Npb24odGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmV2KGVudik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXS5ldihlbnYpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvU3RyaW5nKGVudik7XG4gICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5GaWVsZCA9IGZ1bmN0aW9uIEZpZWxkKGNvbnRlbnQpIHtcbiAgICB0aGlzLnZhbHVlID0gY29udGVudCB8fCAnJztcbn07XG5cbnRyZWUuRmllbGQucHJvdG90eXBlID0ge1xuICAgIGlzOiAnZmllbGQnLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdbJyArIHRoaXMudmFsdWUgKyAnXSc7XG4gICAgfSxcbiAgICAnZXYnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuRmlsdGVyID0gZnVuY3Rpb24gRmlsdGVyKGtleSwgb3AsIHZhbCwgaW5kZXgsIGZpbGVuYW1lKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG5cbiAgICB0aGlzLmlkID0gdGhpcy5rZXkgKyB0aGlzLm9wICsgdGhpcy52YWw7XG59O1xuXG4vLyB4bWxzYWZlLCBudW1lcmljLCBzdWZmaXhcbnZhciBvcHMgPSB7XG4gICAgJzwnOiBbJyAmbHQ7ICcsICdudW1lcmljJ10sXG4gICAgJz4nOiBbJyAmZ3Q7ICcsICdudW1lcmljJ10sXG4gICAgJz0nOiBbJyA9ICcsICdib3RoJ10sXG4gICAgJyE9JzogWycgIT0gJywgJ2JvdGgnXSxcbiAgICAnPD0nOiBbJyAmbHQ7PSAnLCAnbnVtZXJpYyddLFxuICAgICc+PSc6IFsnICZndDs9ICcsICdudW1lcmljJ10sXG4gICAgJz1+JzogWycubWF0Y2goJywgJ3N0cmluZycsICcpJ11cbn07XG5cbnRyZWUuRmlsdGVyLnByb3RvdHlwZS5ldiA9IGZ1bmN0aW9uKGVudikge1xuICAgIHRoaXMua2V5ID0gdGhpcy5rZXkuZXYoZW52KTtcbiAgICB0aGlzLnZhbCA9IHRoaXMudmFsLmV2KGVudik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG50cmVlLkZpbHRlci5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbnYpIHtcbiAgICBpZiAodHJlZS5SZWZlcmVuY2UuZGF0YS5maWx0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5LmlzID09PSAna2V5d29yZCcgJiYgLTEgPT09IHRyZWUuUmVmZXJlbmNlLmRhdGEuZmlsdGVyLnZhbHVlLmluZGV4T2YodGhpcy5rZXkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5rZXkudG9TdHJpbmcoKSArICcgaXMgbm90IGEgdmFsaWQga2V5d29yZCBpbiBhIGZpbHRlciBleHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsLmlzID09PSAna2V5d29yZCcgJiYgLTEgPT09IHRyZWUuUmVmZXJlbmNlLmRhdGEuZmlsdGVyLnZhbHVlLmluZGV4T2YodGhpcy52YWwudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy52YWwudG9TdHJpbmcoKSArICcgaXMgbm90IGEgdmFsaWQga2V5d29yZCBpbiBhIGZpbHRlciBleHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtleSA9IHRoaXMua2V5LnRvU3RyaW5nKGZhbHNlKTtcbiAgICB2YXIgdmFsID0gdGhpcy52YWwudG9TdHJpbmcodGhpcy52YWwuaXMgPT0gJ3N0cmluZycpO1xuXG4gICAgaWYgKFxuICAgICAgICAob3BzW3RoaXMub3BdWzFdID09ICdudW1lcmljJyAmJiBpc05hTih2YWwpICYmIHRoaXMudmFsLmlzICE9PSAnZmllbGQnKSB8fFxuICAgICAgICAob3BzW3RoaXMub3BdWzFdID09ICdzdHJpbmcnICYmICh2YWwpWzBdICE9IFwiJ1wiKVxuICAgICkge1xuICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCB1c2Ugb3BlcmF0b3IgXCInICsgdGhpcy5vcCArICdcIiB3aXRoIHZhbHVlICcgKyB0aGlzLnZhbCxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleSArIG9wc1t0aGlzLm9wXVswXSArIHZhbCArIChvcHNbdGhpcy5vcF1bMl0gfHwgJycpO1xufTtcblxudHJlZS5GaWx0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdbJyArIHRoaXMuaWQgKyAnXSc7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwidmFyIHRyZWUgPSByZXF1aXJlKCcuLi90cmVlJyk7XG52YXIgXyA9IGdsb2JhbC5fIHx8IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxudHJlZS5GaWx0ZXJzZXQgPSBmdW5jdGlvbiBGaWx0ZXJzZXQoKSB7XG4gICAgdGhpcy5maWx0ZXJzID0ge307XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbnYpIHtcbiAgICB2YXIgZmlsdGVycyA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICBmaWx0ZXJzLnB1c2goJygnICsgdGhpcy5maWx0ZXJzW2lkXS50b1hNTChlbnYpLnRyaW0oKSArICcpJyk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyAgICA8RmlsdGVyPicgKyBmaWx0ZXJzLmpvaW4oJyBhbmQgJykgKyAnPC9GaWx0ZXI+XFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufTtcblxudHJlZS5GaWx0ZXJzZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuZmlsdGVycykgYXJyLnB1c2godGhpcy5maWx0ZXJzW2lkXS5pZCk7XG4gICAgcmV0dXJuIGFyci5zb3J0KCkuam9pbignXFx0Jyk7XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuZXYgPSBmdW5jdGlvbihlbnYpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnNbaV0uZXYoZW52KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgdHJlZS5GaWx0ZXJzZXQoKTtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgY2xvbmUuZmlsdGVyc1tpZF0gPSB0aGlzLmZpbHRlcnNbaWRdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG4vLyBOb3RlOiBvdGhlciBoYXMgdG8gYmUgYSB0cmVlLkZpbHRlcnNldC5cbnRyZWUuRmlsdGVyc2V0LnByb3RvdHlwZS5jbG9uZVdpdGggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpZCBpbiBvdGhlci5maWx0ZXJzKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLmFkZGFibGUob3RoZXIuZmlsdGVyc1tpZF0pO1xuICAgICAgICAvLyBzdGF0dXMgaXMgdHJ1ZSwgZmFsc2Ugb3IgbnVsbC4gaWYgaXQncyBudWxsIHdlIGRvbid0IGZhaWwgdGhpc1xuICAgICAgICAvLyBjbG9uZSBub3IgZG8gd2UgYWRkIHRoZSBmaWx0ZXIuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSBmaWx0ZXIgd2lsbCBvdmVycmlkZSBhbm90aGVyIHZhbHVlLlxuICAgICAgICAgICAgYWRkaXRpb25zLnB1c2gob3RoZXIuZmlsdGVyc1tpZF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkaW5nIHRoZSBvdGhlciBmaWx0ZXJzIGRvZXNuJ3QgbWFrZSB0aGlzIGZpbHRlcnNldCBpbnZhbGlkLCBidXQgaXRcbiAgICAvLyBkb2Vzbid0IGFkZCBhbnl0aGluZyB0byBpdCBlaXRoZXIuXG4gICAgaWYgKCFhZGRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbiBzdWNjZXNzZnVsbHkgYWRkIGFsbCBmaWx0ZXJzLiBOb3cgY2xvbmUgdGhlIGZpbHRlcnNldCBhbmQgYWRkIHRoZVxuICAgIC8vIG5ldyBydWxlcy5cbiAgICB2YXIgY2xvbmUgPSBuZXcgdHJlZS5GaWx0ZXJzZXQoKTtcblxuICAgIC8vIFdlIGNhbiBhZGQgdGhlIHJ1bGVzIHRoYXQgYXJlIGFscmVhZHkgcHJlc2VudCB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlXG4gICAgLy8gYWRkIGZ1bmN0aW9uIGFzIGEgRmlsdGVyc2V0IGlzIGFsd2F5cyBpbiBpdCdzIHNpbXBsZXN0IGNhbm9uaWNhbCBmb3JtLlxuICAgIGZvciAoaWQgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgIGNsb25lLmZpbHRlcnNbaWRdID0gdGhpcy5maWx0ZXJzW2lkXTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGFkZCBuZXcgZmlsdGVycyB0aGF0IGFjdHVhbGx5IGNoYW5nZSB0aGUgZmlsdGVyLlxuICAgIHdoaWxlIChpZCA9IGFkZGl0aW9ucy5zaGlmdCgpKSB7XG4gICAgICAgIGNsb25lLmFkZChpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxudHJlZS5GaWx0ZXJzZXQucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbihlbnYpIHtcbiAgdmFyIG9wTWFwID0ge1xuICAgICc9JzogJz09PSdcbiAgfTtcbiAgcmV0dXJuIF8ubWFwKHRoaXMuZmlsdGVycywgZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIG9wID0gZmlsdGVyLm9wO1xuICAgIGlmKG9wIGluIG9wTWFwKSB7XG4gICAgICBvcCA9IG9wTWFwW29wXTtcbiAgICB9XG4gICAgdmFyIHZhbCA9IGZpbHRlci52YWw7XG4gICAgaWYoZmlsdGVyLl92YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsID0gZmlsdGVyLl92YWwudG9TdHJpbmcodHJ1ZSk7XG4gICAgfVxuICAgIHZhciBhdHRycyA9IFwiZGF0YVwiO1xuICAgIGlmIChvcCA9PT0gJz1+Jykge1xuICAgICAgcmV0dXJuIFwiKFwiICsgYXR0cnMgKyBcIlsnXCIgKyBmaWx0ZXIua2V5LnZhbHVlICArIFwiJ10gKyAnJykubWF0Y2goXCIgKyAodmFsLmlzID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsLnRvU3RyaW5nKCkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpICsgXCInXCIgOiB2YWwpICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBhdHRycyArIFwiWydcIiArIGZpbHRlci5rZXkudmFsdWUgICsgXCInXSBcIiArIG9wICsgXCIgXCIgKyAodmFsLmlzID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsLnRvU3RyaW5nKCkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpICsgXCInXCIgOiB2YWwpO1xuICB9KS5qb2luKCcgJiYgJyk7XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGUgbmV3IGZpbHRlciBjYW4gYmUgYWRkZWQsIGZhbHNlIG90aGVyd2lzZS5cbi8vIEl0IGNhbiBhbHNvIHJldHVybiBudWxsLCBhbmQgb24gdGhlIG90aGVyIHNpZGUgd2UgdGVzdCBmb3IgPT09IHRydWUgb3Jcbi8vIGZhbHNlXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuYWRkYWJsZSA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBrZXkgPSBmaWx0ZXIua2V5LnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlID0gZmlsdGVyLnZhbC50b1N0cmluZygpO1xuXG4gICAgaWYgKHZhbHVlLm1hdGNoKC9eWzAtOV0rKFxcLlswLTldKik/JC8pKSB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgc3dpdGNoIChmaWx0ZXIub3ApIHtcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbHJlYWR5IGZvbz0gYW5kIHdlJ3JlIGFkZGluZyBmb289XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9J10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwudG9TdHJpbmcoKSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgdmFsdWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8J10udmFsIDw9IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+PSddICE9PSB1bmRlZmluZWQgICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPiB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10udmFsIDwgdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgJz1+JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gKHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbCA9PSB2YWx1ZSkgPyBmYWxzZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICchPScgKyB2YWx1ZV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXS52YWwgPj0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8J10udmFsIDw9IHZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz49J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz49J10udmFsID4gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPCB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIGlmIChrZXkgKyAnPScgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbCA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8J10udmFsIDw9IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc8PSddICE9PSB1bmRlZmluZWQgICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPD0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+PSddICE9PSB1bmRlZmluZWQgICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPiB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9JyBdICE9PSB1bmRlZmluZWQpIHJldHVybiAodGhpcy5maWx0ZXJzW2tleSArICc9J10udmFsIDwgdmFsdWUpID8gZmFsc2UgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCcgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPCddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPCB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPicgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+PSddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc+PSddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nIF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwgPj0gdmFsdWUpID8gZmFsc2UgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPicgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPj0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzwnIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXS52YWwgPD0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPCB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9JyBdICE9PSB1bmRlZmluZWQpIHJldHVybiAodGhpcy5maWx0ZXJzW2tleSArICc9J10udmFsID4gdmFsdWUpID8gZmFsc2UgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPicgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPiB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCcgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPCddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc8PSddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8PSddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vLyBEb2VzIHRoZSBuZXcgZmlsdGVyIGNvbnN0aXR1dGUgYSBjb25mbGljdD9cbnRyZWUuRmlsdGVyc2V0LnByb3RvdHlwZS5jb25mbGljdCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBrZXkgPSBmaWx0ZXIua2V5LnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlID0gZmlsdGVyLnZhbC50b1N0cmluZygpO1xuXG4gICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkpIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAvLyBpZiAoYT1iKSAmJiAoYT1jKVxuICAgIC8vIGlmIChhPWIpICYmIChhIT1iKVxuICAgIC8vIG9yIChhIT1iKSAmJiAoYT1iKVxuICAgIGlmICgoZmlsdGVyLm9wID09PSAnPScgJiYgdGhpcy5maWx0ZXJzW2tleSArICc9J10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB2YWx1ZSAhPSB0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwudG9TdHJpbmcoKSkgfHxcbiAgICAgICAgKGZpbHRlci5vcCA9PT0gJyE9JyAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz0nXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHZhbHVlID09IHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbC50b1N0cmluZygpKSB8fFxuICAgICAgICAoZmlsdGVyLm9wID09PSAnPScgJiYgdGhpcy5maWx0ZXJzW2tleSArICchPSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdmFsdWUgPT0gdGhpcy5maWx0ZXJzW2tleSArICchPSddLnZhbC50b1N0cmluZygpKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyLnRvU3RyaW5nKCkgKyAnIGFkZGVkIHRvICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnIHByb2R1Y2VzIGFuIGludmFsaWQgZmlsdGVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBPbmx5IGNhbGwgdGhpcyBmdW5jdGlvbiBmb3IgZmlsdGVycyB0aGF0IGhhdmUgYmVlbiBjbGVhcmVkIGJ5IC5hZGRhYmxlKCkuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZmlsdGVyLCBlbnYpIHtcbiAgICB2YXIga2V5ID0gZmlsdGVyLmtleS50b1N0cmluZygpLFxuICAgICAgICBpZCxcbiAgICAgICAgb3AgPSBmaWx0ZXIub3AsXG4gICAgICAgIGNvbmZsaWN0ID0gdGhpcy5jb25mbGljdChmaWx0ZXIpLFxuICAgICAgICBudW12YWw7XG5cbiAgICBpZiAoY29uZmxpY3QpIHJldHVybiBjb25mbGljdDtcblxuICAgIGlmIChvcCA9PT0gJz0nKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2ldLmtleSA9PSBrZXkpIGRlbGV0ZSB0aGlzLmZpbHRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc9J10gPSBmaWx0ZXI7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyE9Jykge1xuICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJyE9JyArIGZpbHRlci52YWxdID0gZmlsdGVyO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICc9ficpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc9ficgKyBmaWx0ZXIudmFsXSA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPicpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG90aGVyIGZpbHRlcnMgdGhhdCBhcmUgYWxzbyA+XG4gICAgICAgIC8vIGJ1dCBhcmUgbGVzcyB0aGFuIHRoaXMgb25lLCB0aGV5IGRvbid0IG1hdHRlciwgc29cbiAgICAgICAgLy8gcmVtb3ZlIHRoZW0uXG4gICAgICAgIGZvciAodmFyIGogaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2pdLmtleSA9PSBrZXkgJiYgdGhpcy5maWx0ZXJzW2pdLnZhbCA8PSBmaWx0ZXIudmFsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPj0nKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBudW12YWwgPSAoK3RoaXMuZmlsdGVyc1trXS52YWwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tdLmtleSA9PSBrZXkgJiYgbnVtdmFsIDwgZmlsdGVyLnZhbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF07XG4gICAgICAgICAgICBmaWx0ZXIub3AgPSAnPic7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3AgPT09ICc8Jykge1xuICAgICAgICBmb3IgKHZhciBsIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgbnVtdmFsID0gKCt0aGlzLmZpbHRlcnNbbF0udmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1tsXS5rZXkgPT0ga2V5ICYmIG51bXZhbCA+PSBmaWx0ZXIudmFsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1tsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXSA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPD0nKSB7XG4gICAgICAgIGZvciAodmFyIG0gaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBudW12YWwgPSAoK3RoaXMuZmlsdGVyc1ttXS52YWwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW21dLmtleSA9PSBrZXkgJiYgbnVtdmFsID4gZmlsdGVyLnZhbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNbbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF07XG4gICAgICAgICAgICBmaWx0ZXIub3AgPSAnPCc7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLl9nZXRGb250U2V0ID0gZnVuY3Rpb24oZW52LCBmb250cykge1xuICAgIHZhciBmb250S2V5ID0gZm9udHMuam9pbignJyk7XG4gICAgaWYgKGVudi5fZm9udE1hcCAmJiBlbnYuX2ZvbnRNYXBbZm9udEtleV0pIHtcbiAgICAgICAgcmV0dXJuIGVudi5fZm9udE1hcFtmb250S2V5XTtcbiAgICB9XG5cbiAgICB2YXIgbmV3X2ZvbnRzZXQgPSBuZXcgdHJlZS5Gb250U2V0KGVudiwgZm9udHMpO1xuICAgIGVudi5lZmZlY3RzLnB1c2gobmV3X2ZvbnRzZXQpO1xuICAgIGlmICghZW52Ll9mb250TWFwKSBlbnYuX2ZvbnRNYXAgPSB7fTtcbiAgICBlbnYuX2ZvbnRNYXBbZm9udEtleV0gPSBuZXdfZm9udHNldDtcbiAgICByZXR1cm4gbmV3X2ZvbnRzZXQ7XG59O1xuXG50cmVlLkZvbnRTZXQgPSBmdW5jdGlvbiBGb250U2V0KGVudiwgZm9udHMpIHtcbiAgICB0aGlzLmZvbnRzID0gZm9udHM7XG4gICAgdGhpcy5uYW1lID0gJ2ZvbnRzZXQtJyArIGVudi5lZmZlY3RzLmxlbmd0aDtcbn07XG5cbnRyZWUuRm9udFNldC5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbnYpIHtcbiAgICByZXR1cm4gJzxGb250U2V0IG5hbWU9XCInICtcbiAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgJ1wiPlxcbicgK1xuICAgICAgICB0aGlzLmZvbnRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgPEZvbnQgZmFjZS1uYW1lPVwiJyArIGYgKydcIi8+JztcbiAgICAgICAgfSkuam9pbignXFxuJykgK1xuICAgICAgICAnXFxuPC9Gb250U2V0Pic7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwidmFyIHRyZWUgPSByZXF1aXJlKCcuLi90cmVlJyk7XG5cbi8vIFN0b3JhZ2UgZm9yIEZyYW1lIG9mZnNldCB2YWx1ZVxuLy8gYW5kIHN0b3JlcyB0aGVtIGFzIGJpdC1zZXF1ZW5jZXMgc28gdGhhdCB0aGV5IGNhbiBiZSBjb21iaW5lZCxcbi8vIGludmVydGVkLCBhbmQgY29tcGFyZWQgcXVpY2tseS5cbnRyZWUuRnJhbWVPZmZzZXQgPSBmdW5jdGlvbihvcCwgdmFsdWUsIGluZGV4KSB7XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIGlmICh2YWx1ZSA+IHRyZWUuRnJhbWVPZmZzZXQubWF4IHx8IHZhbHVlIDw9IDApIHtcbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbWVzc2FnZTogJ09ubHkgZnJhbWUtb2Zmc2V0IGxldmVscyBiZXR3ZWVuIDEgYW5kICcgK1xuICAgICAgICAgICAgICAgIHRyZWUuRnJhbWVPZmZzZXQubWF4ICsgJyBzdXBwb3J0ZWQuJyxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcCAhPT0gJz0nKSB7XG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdvbmx5ID0gb3BlcmF0b3IgaXMgc3VwcG9ydGVkIGZvciBmcmFtZS1vZmZzZXQnLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbnRyZWUuRnJhbWVPZmZzZXQubWF4ID0gMzI7XG50cmVlLkZyYW1lT2Zmc2V0Lm5vbmUgPSAwO1xuXG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLkltYWdlRmlsdGVyID0gZnVuY3Rpb24gSW1hZ2VGaWx0ZXIoZmlsdGVyLCBhcmdzKSB7XG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgdGhpcy5hcmdzID0gYXJncyB8fCBudWxsO1xufTtcblxudHJlZS5JbWFnZUZpbHRlci5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdpbWFnZWZpbHRlcicsXG4gICAgZXY6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyICsgJygnICsgdGhpcy5hcmdzLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbiAodHJlZSkge1xudHJlZS5JbnZhbGlkID0gZnVuY3Rpb24gSW52YWxpZChjaHVuaywgaW5kZXgsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudHlwZSA9ICdzeW50YXgnO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJJbnZhbGlkIGNvZGU6IFwiICsgdGhpcy5jaHVuaztcbn07XG5cbnRyZWUuSW52YWxpZC5wcm90b3R5cGUuaXMgPSAnaW52YWxpZCc7XG5cbnRyZWUuSW52YWxpZC5wcm90b3R5cGUuZXYgPSBmdW5jdGlvbihlbnYpIHtcbiAgICBlbnYuZXJyb3Ioe1xuICAgICAgICBjaHVuazogdGhpcy5jaHVuayxcbiAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgIHR5cGU6ICdzeW50YXgnLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfHwgXCJJbnZhbGlkIGNvZGU6IFwiICsgdGhpcy5jaHVua1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzOiAndW5kZWZpbmVkJ1xuICAgIH07XG59O1xufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuS2V5d29yZCA9IGZ1bmN0aW9uIEtleXdvcmQodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdmFyIHNwZWNpYWwgPSB7XG4gICAgICAgICd0cmFuc3BhcmVudCc6ICdjb2xvcicsXG4gICAgICAgICd0cnVlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAnZmFsc2UnOiAnYm9vbGVhbidcbiAgICB9O1xuICAgIHRoaXMuaXMgPSBzcGVjaWFsW3ZhbHVlXSA/IHNwZWNpYWxbdmFsdWVdIDogJ2tleXdvcmQnO1xufTtcbnRyZWUuS2V5d29yZC5wcm90b3R5cGUgPSB7XG4gICAgZXY6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5MYXllclhNTCA9IGZ1bmN0aW9uKG9iaiwgc3R5bGVzKSB7XG4gICAgdmFyIGRzb3B0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gb2JqLkRhdGFzb3VyY2UpIHtcbiAgICAgICAgZHNvcHRpb25zLnB1c2goJzxQYXJhbWV0ZXIgbmFtZT1cIicgKyBpICsgJ1wiPjwhW0NEQVRBWycgK1xuICAgICAgICAgICAgb2JqLkRhdGFzb3VyY2VbaV0gKyAnXV0+PC9QYXJhbWV0ZXI+Jyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3Bfc3RyaW5nID0gJyc7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmoucHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcCA9PT0gJ21pbnpvb20nKSB7XG4gICAgICAgICAgICBwcm9wX3N0cmluZyArPSAnICBtYXh6b29tPVwiJyArIHRyZWUuWm9vbS5yYW5nZXNbb2JqLnByb3BlcnRpZXNbcHJvcF1dICsgJ1wiXFxuJztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnbWF4em9vbScpIHtcbiAgICAgICAgICAgIHByb3Bfc3RyaW5nICs9ICcgIG1pbnpvb209XCInICsgdHJlZS5ab29tLnJhbmdlc1tvYmoucHJvcGVydGllc1twcm9wXSsxXSArICdcIlxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wX3N0cmluZyArPSAnICAnICsgcHJvcCArICc9XCInICsgb2JqLnByb3BlcnRpZXNbcHJvcF0gKyAnXCJcXG4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICc8TGF5ZXInICtcbiAgICAgICAgJyBuYW1lPVwiJyArIG9iai5uYW1lICsgJ1wiXFxuJyArXG4gICAgICAgIHByb3Bfc3RyaW5nICtcbiAgICAgICAgKCh0eXBlb2Ygb2JqLnN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcpID8gJycgOiAnICBzdGF0dXM9XCInICsgb2JqLnN0YXR1cyArICdcIlxcbicpICtcbiAgICAgICAgKCh0eXBlb2Ygb2JqLnNycyA9PT0gJ3VuZGVmaW5lZCcpID8gJycgOiAnICBzcnM9XCInICsgb2JqLnNycyArICdcIicpICsgJz5cXG4gICAgJyArXG4gICAgICAgIHN0eWxlcy5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnPFN0eWxlTmFtZT4nICsgcyArICc8L1N0eWxlTmFtZT4nO1xuICAgICAgICB9KS5qb2luKCdcXG4gICAgJykgK1xuICAgICAgICAoZHNvcHRpb25zLmxlbmd0aCA/XG4gICAgICAgICdcXG4gICAgPERhdGFzb3VyY2U+XFxuICAgICAgICcgK1xuICAgICAgICBkc29wdGlvbnMuam9pbignXFxuICAgICAgICcpICtcbiAgICAgICAgJ1xcbiAgICA8L0RhdGFzb3VyY2U+XFxuJ1xuICAgICAgICA6ICcnKSArXG4gICAgICAgICcgIDwvTGF5ZXI+XFxuJztcbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIvLyBBIGxpdGVyYWwgaXMgYSBsaXRlcmFsIHN0cmluZyBmb3IgTWFwbmlrIC0gdGhlXG4vLyByZXN1bHQgb2YgdGhlIGNvbWJpbmF0aW9uIG9mIGEgYHRyZWUuRmllbGRgIHdpdGggYW55XG4vLyBvdGhlciB0eXBlLlxuKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5MaXRlcmFsID0gZnVuY3Rpb24gRmllbGQoY29udGVudCkge1xuICAgIHRoaXMudmFsdWUgPSBjb250ZW50IHx8ICcnO1xuICAgIHRoaXMuaXMgPSAnZmllbGQnO1xufTtcblxudHJlZS5MaXRlcmFsLnByb3RvdHlwZSA9IHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgJ2V2JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIvLyBBbiBvcGVyYXRpb24gaXMgYW4gZXhwcmVzc2lvbiB3aXRoIGFuIG9wIGluIGJldHdlZW4gdHdvIG9wZXJhbmRzLFxuLy8gbGlrZSAyICsgMS5cbihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuT3BlcmF0aW9uID0gZnVuY3Rpb24gT3BlcmF0aW9uKG9wLCBvcGVyYW5kcywgaW5kZXgpIHtcbiAgICB0aGlzLm9wID0gb3AudHJpbSgpO1xuICAgIHRoaXMub3BlcmFuZHMgPSBvcGVyYW5kcztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG59O1xuXG50cmVlLk9wZXJhdGlvbi5wcm90b3R5cGUuaXMgPSAnb3BlcmF0aW9uJztcblxudHJlZS5PcGVyYXRpb24ucHJvdG90eXBlLmV2ID0gZnVuY3Rpb24oZW52KSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wZXJhbmRzWzBdLmV2KGVudiksXG4gICAgICAgIGIgPSB0aGlzLm9wZXJhbmRzWzFdLmV2KGVudiksXG4gICAgICAgIHRlbXA7XG5cbiAgICBpZiAoYS5pcyA9PT0gJ3VuZGVmaW5lZCcgfHwgYi5pcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChhIGluc3RhbmNlb2YgdHJlZS5EaW1lbnNpb24gJiYgYiBpbnN0YW5jZW9mIHRyZWUuQ29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMub3AgPT09ICcqJyB8fCB0aGlzLm9wID09PSAnKycpIHtcbiAgICAgICAgICAgIHRlbXAgPSBiLCBiID0gYSwgYSA9IHRlbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiT3BlcmF0aW9uRXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNhbid0IHN1YnN0cmFjdCBvciBkaXZpZGUgYSBjb2xvciBmcm9tIGEgbnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSBjb25jYXRlbmF0ZSBwbGFpbiBzdHJpbmdzLCBiZWNhdXNlIHRoaXMgaXMgZWFzaWx5XG4gICAgLy8gcHJlLXByb2Nlc3NlZFxuICAgIGlmIChhIGluc3RhbmNlb2YgdHJlZS5RdW90ZWQgJiYgYiBpbnN0YW5jZW9mIHRyZWUuUXVvdGVkICYmIHRoaXMub3AgIT09ICcrJykge1xuICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICBtZXNzYWdlOiBcIkNhbid0IHN1YnRyYWN0LCBkaXZpZGUsIG9yIG11bHRpcGx5IHN0cmluZ3MuXCIsXG4gICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICB0eXBlOiAncnVudGltZScsXG4gICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRmllbGRzLCBsaXRlcmFscywgZGltZW5zaW9ucywgYW5kIHF1b3RlZCBzdHJpbmdzIGNhbiBiZSBjb21iaW5lZC5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIHRyZWUuRmllbGQgfHwgYiBpbnN0YW5jZW9mIHRyZWUuRmllbGQgfHxcbiAgICAgICAgYSBpbnN0YW5jZW9mIHRyZWUuTGl0ZXJhbCB8fCBiIGluc3RhbmNlb2YgdHJlZS5MaXRlcmFsKSB7XG4gICAgICAgIGlmIChhLmlzID09PSAnY29sb3InIHx8IGIuaXMgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNhbid0IHN1YnRyYWN0LCBkaXZpZGUsIG9yIG11bHRpcGx5IGNvbG9ycyBpbiBleHByZXNzaW9ucy5cIixcbiAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkxpdGVyYWwoYS5ldihlbnYpLnRvU3RyaW5nKHRydWUpICsgdGhpcy5vcCArIGIuZXYoZW52KS50b1N0cmluZyh0cnVlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5vcGVyYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBkbyBtYXRoIHdpdGggdHlwZSAnICsgYS5pcyArICcuJyxcbiAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICB2YWx1ZTogJ3VuZGVmaW5lZCdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYS5vcGVyYXRlKGVudiwgdGhpcy5vcCwgYik7XG59O1xuXG50cmVlLm9wZXJhdGUgPSBmdW5jdGlvbihvcCwgYSwgYikge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSAnKyc6IHJldHVybiBhICsgYjtcbiAgICAgICAgY2FzZSAnLSc6IHJldHVybiBhIC0gYjtcbiAgICAgICAgY2FzZSAnKic6IHJldHVybiBhICogYjtcbiAgICAgICAgY2FzZSAnJSc6IHJldHVybiBhICUgYjtcbiAgICAgICAgY2FzZSAnLyc6IHJldHVybiBhIC8gYjtcbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5RdW90ZWQgPSBmdW5jdGlvbiBRdW90ZWQoY29udGVudCkge1xuICAgIHRoaXMudmFsdWUgPSBjb250ZW50IHx8ICcnO1xufTtcblxudHJlZS5RdW90ZWQucHJvdG90eXBlID0ge1xuICAgIGlzOiAnc3RyaW5nJyxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihxdW90ZXMpIHtcbiAgICAgICAgdmFyIGVzY2FwZWRWYWx1ZSA9IHRoaXMudmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIHZhciB4bWx2YWx1ZSA9IGVzY2FwZWRWYWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJy9nLCAnXFxcXFxcJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXD4vZywgJyZndDsnKTtcbiAgICAgICAgcmV0dXJuIChxdW90ZXMgPT09IHRydWUpID8gXCInXCIgKyB4bWx2YWx1ZSArIFwiJ1wiIDogZXNjYXBlZFZhbHVlO1xuICAgIH0sXG5cbiAgICAnZXYnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9wZXJhdGU6IGZ1bmN0aW9uKGVudiwgb3AsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5RdW90ZWQodHJlZS5vcGVyYXRlKG9wLCB0aGlzLnRvU3RyaW5nKCksIG90aGVyLnRvU3RyaW5nKHRoaXMuY29udGFpbnNfZmllbGQpKSk7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIi8vIENhcnRvIHB1bGxzIGluIGEgcmVmZXJlbmNlIGZyb20gdGhlIGBtYXBuaWstcmVmZXJlbmNlYFxuLy8gbW9kdWxlLiBUaGlzIGZpbGUgYnVpbGRzIGluZGV4ZXMgZnJvbSB0aGF0IGZpbGUgZm9yIGl0cyB2YXJpb3VzXG4vLyBvcHRpb25zLCBhbmQgcHJvdmlkZXMgdmFsaWRhdGlvbiBtZXRob2RzIGZvciBwcm9wZXJ0eTogdmFsdWVcbi8vIGNvbWJpbmF0aW9ucy5cbihmdW5jdGlvbih0cmVlKSB7XG5cbnZhciBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpLFxuICAgIHJlZiA9IHt9O1xuXG5yZWYuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZWYuZGF0YSA9IGRhdGE7XG4gICAgcmVmLnNlbGVjdG9yX2NhY2hlID0gZ2VuZXJhdGVTZWxlY3RvckNhY2hlKGRhdGEpO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMgPSBnZW5lcmF0ZU1hcG5pa0Z1bmN0aW9ucyhkYXRhKTtcblxuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMubWF0cml4ID0gWzZdO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMudHJhbnNsYXRlID0gWzEsIDJdO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMuc2NhbGUgPSBbMSwgMl07XG4gICAgcmVmLm1hcG5pa0Z1bmN0aW9ucy5yb3RhdGUgPSBbMSwgM107XG4gICAgcmVmLm1hcG5pa0Z1bmN0aW9ucy5za2V3WCA9IFsxXTtcbiAgICByZWYubWFwbmlrRnVuY3Rpb25zLnNrZXdZID0gWzFdO1xuXG4gICAgcmVmLnJlcXVpcmVkX2NhY2hlID0gZ2VuZXJhdGVSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSk7XG59O1xuXG5yZWYuc2V0VmVyc2lvbiA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgICB2YXIgbWFwbmlrX3JlZmVyZW5jZSA9IHJlcXVpcmUoJ21hcG5pay1yZWZlcmVuY2UnKTtcbiAgICBpZiAobWFwbmlrX3JlZmVyZW5jZS52ZXJzaW9uLmhhc093blByb3BlcnR5KHZlcnNpb24pKSB7XG4gICAgICAgIHJlZi5zZXREYXRhKG1hcG5pa19yZWZlcmVuY2UudmVyc2lvblt2ZXJzaW9uXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5yZWYuc2VsZWN0b3JEYXRhID0gZnVuY3Rpb24oc2VsZWN0b3IsIGkpIHtcbiAgICBpZiAocmVmLnNlbGVjdG9yX2NhY2hlW3NlbGVjdG9yXSkgcmV0dXJuIHJlZi5zZWxlY3Rvcl9jYWNoZVtzZWxlY3Rvcl1baV07XG59O1xuXG5yZWYudmFsaWRTZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiAhIXJlZi5zZWxlY3Rvcl9jYWNoZVtzZWxlY3Rvcl07IH07XG5yZWYuc2VsZWN0b3JOYW1lID0gZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHJlZi5zZWxlY3RvckRhdGEoc2VsZWN0b3IsIDIpOyB9O1xucmVmLnNlbGVjdG9yID0gZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHJlZi5zZWxlY3RvckRhdGEoc2VsZWN0b3IsIDApOyB9O1xucmVmLnN5bWJvbGl6ZXIgPSBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gcmVmLnNlbGVjdG9yRGF0YShzZWxlY3RvciwgMSk7IH07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VsZWN0b3JDYWNoZShkYXRhKSB7XG4gICAgdmFyIGluZGV4ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBkYXRhLnN5bWJvbGl6ZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gZGF0YS5zeW1ib2xpemVyc1tpXSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuc3ltYm9saXplcnNbaV1bal0uaGFzT3duUHJvcGVydHkoJ2NzcycpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhbZGF0YS5zeW1ib2xpemVyc1tpXVtqXS5jc3NdID0gW2RhdGEuc3ltYm9saXplcnNbaV1bal0sIGksIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXBuaWtGdW5jdGlvbnMoZGF0YSkge1xuICAgIHZhciBmdW5jdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpIGluIGRhdGEuc3ltYm9saXplcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBkYXRhLnN5bWJvbGl6ZXJzW2ldKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zeW1ib2xpemVyc1tpXVtqXS50eXBlID09PSAnZnVuY3Rpb25zJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGF0YS5zeW1ib2xpemVyc1tpXVtqXS5mdW5jdGlvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gZGF0YS5zeW1ib2xpemVyc1tpXVtqXS5mdW5jdGlvbnNba107XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1tmblswXV0gPSBmblsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9ucztcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSkge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIGZvciAodmFyIHN5bWJvbGl6ZXJfbmFtZSBpbiBkYXRhLnN5bWJvbGl6ZXJzKSB7XG4gICAgICAgIGNhY2hlW3N5bWJvbGl6ZXJfbmFtZV0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBkYXRhLnN5bWJvbGl6ZXJzW3N5bWJvbGl6ZXJfbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnN5bWJvbGl6ZXJzW3N5bWJvbGl6ZXJfbmFtZV1bal0ucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtzeW1ib2xpemVyX25hbWVdLnB1c2goZGF0YS5zeW1ib2xpemVyc1tzeW1ib2xpemVyX25hbWVdW2pdLmNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xufVxuXG5yZWYucmVxdWlyZWRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3ltYm9saXplcl9uYW1lLCBydWxlcykge1xuICAgIHZhciByZXEgPSByZWYucmVxdWlyZWRfY2FjaGVbc3ltYm9saXplcl9uYW1lXTtcbiAgICBmb3IgKHZhciBpIGluIHJlcSkge1xuICAgICAgICBpZiAoIShyZXFbaV0gaW4gcnVsZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1Byb3BlcnR5ICcgKyByZXFbaV0gKyAnIHJlcXVpcmVkIGZvciBkZWZpbmluZyAnICtcbiAgICAgICAgICAgICAgICBzeW1ib2xpemVyX25hbWUgKyAnIHN0eWxlcy4nO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gVE9ETzogZmluaXNoIGltcGxlbWVudGF0aW9uIC0gdGhpcyBpcyBkZWFkIGNvZGVcbnJlZi5fdmFsaWRhdGVWYWx1ZSA9IHtcbiAgICAnZm9udCc6IGZ1bmN0aW9uKGVudiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVudi52YWxpZGF0aW9uX2RhdGEgJiYgZW52LnZhbGlkYXRpb25fZGF0YS5mb250cykge1xuICAgICAgICAgICAgcmV0dXJuIGVudi52YWxpZGF0aW9uX2RhdGEuZm9udHMuaW5kZXhPZih2YWx1ZSkgIT0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnJlZi5pc0ZvbnQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiByZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnZhbGlkYXRlID09ICdmb250Jztcbn07XG5cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk4MjkyN1xucmVmLmVkaXREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGIubGVuZ3RoO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7IG1hdHJpeFtpXSA9IFtpXTsgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHsgbWF0cml4WzBdW2pdID0gajsgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChiLmNoYXJBdChpLTEpID09IGEuY2hhckF0KGotMSkpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaS0xXVtqLTFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihtYXRyaXhbaS0xXVtqLTFdICsgMSwgLy8gc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqLTFdICsgMSwgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeFtpLTFdW2pdICsgMSkpOyAvLyBkZWxldGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25zKHZhbHVlLCBzZWxlY3Rvcikge1xuICAgIGlmICh2YWx1ZS52YWx1ZVswXS5pcyA9PT0gJ3N0cmluZycpIHJldHVybiB0cnVlO1xuICAgIGZvciAodmFyIGkgaW4gdmFsdWUudmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiB2YWx1ZS52YWx1ZVtpXS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlW2ldLnZhbHVlW2pdLmlzICE9PSAnY2FsbCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBmID0gXy5maW5kKHJlZlxuICAgICAgICAgICAgICAgIC5zZWxlY3RvcihzZWxlY3RvcikuZnVuY3Rpb25zLCBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4WzBdID09IHZhbHVlLnZhbHVlW2ldLnZhbHVlW2pdLm5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIShmICYmIGZbMV0gPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmaWx0ZXIgaXMgdW5rbm93biBvciBnaXZlbiBhbiBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGlmICghZiB8fCBmWzFdICE9PSB2YWx1ZS52YWx1ZVtpXS52YWx1ZVtqXS5hcmdzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQodmFsdWUsIHNlbGVjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiByZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiByZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnR5cGVcbiAgICAgICAgICAgIC5pbmRleE9mKHZhbHVlLnZhbHVlWzBdLnZhbHVlKSAhPT0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxsb3cgdW5xdW90ZWQga2V5d29yZHMgYXMgc3RyaW5nc1xuICAgICAgICByZXR1cm4gcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09PSAnc3RyaW5nJztcbiAgICB9XG59XG5cbnJlZi52YWxpZFZhbHVlID0gZnVuY3Rpb24oZW52LCBzZWxlY3RvciwgdmFsdWUpIHtcbiAgICB2YXIgaSwgajtcbiAgICAvLyBUT0RPOiBoYW5kbGUgaW4gcmV1c2FibGUgd2F5XG4gICAgaWYgKCFyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnZhbHVlWzBdLmlzID09ICdrZXl3b3JkJykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVLZXl3b3JkKHZhbHVlLCBzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS52YWx1ZVswXS5pcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBjYXVnaHQgZWFybGllciBpbiB0aGUgY2hhaW4gLSBpZ25vcmUgaGVyZSBzbyB0aGF0XG4gICAgICAgIC8vIGVycm9yIGlzIG5vdCBvdmVycmlkZGVuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09ICdudW1iZXJzJykge1xuICAgICAgICBmb3IgKGkgaW4gdmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZVtpXS5pcyAhPT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PSAndGFncycpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXZhbHVlLnZhbHVlWzBdLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWVbMF0uaXMgPT09ICd0YWcnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS52YWx1ZVswXS52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlWzBdLnZhbHVlW2ldLmlzICE9PSAndGFnJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09ICdmdW5jdGlvbnMnKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgeW91IGNhbiBzcGVjaWZ5IGEgc3RyaW5nIGZvciBgZnVuY3Rpb25zYC1jb21wYXRpYmxlXG4gICAgICAgIC8vIHZhbHVlcywgdGhvdWdoIHRoZXkgd2lsbCBub3QgYmUgdmFsaWRhdGVkLlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVGdW5jdGlvbnModmFsdWUsIHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgICBpZiAodmFsdWUudmFsdWVbMF0uaXMgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgIHZhbHVlLnZhbHVlWzBdLnJvdW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHJlZi5zZWxlY3RvcihzZWxlY3RvcikuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PSB2YWx1ZS52YWx1ZVtpXS5pcyAmJlxuICAgICAgICAgICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fdmFsaWRhdGVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnZhbGlkYXRlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbnYsIHZhbHVlLnZhbHVlW2ldLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09IHZhbHVlLnZhbHVlWzBdLmlzO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudHJlZS5SZWZlcmVuY2UgPSByZWY7XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuLy8gYSBydWxlIGlzIGEgc2luZ2xlIHByb3BlcnR5IGFuZCB2YWx1ZSBjb21iaW5hdGlvbiwgb3IgdmFyaWFibGVcbi8vIG5hbWUgYW5kIHZhbHVlIGNvbWJpbmF0aW9uLCBsaWtlXG4vLyBwb2x5Z29uLW9wYWNpdHk6IDEuMDsgb3IgQG9wYWNpdHk6IDEuMDtcbnRyZWUuUnVsZSA9IGZ1bmN0aW9uIFJ1bGUobmFtZSwgdmFsdWUsIGluZGV4LCBmaWxlbmFtZSkge1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy8nKTtcbiAgICB0aGlzLm5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICB0aGlzLmluc3RhbmNlID0gcGFydHMubGVuZ3RoID8gcGFydHNbMF0gOiAnX19kZWZhdWx0X18nO1xuICAgIHRoaXMudmFsdWUgPSAodmFsdWUgaW5zdGFuY2VvZiB0cmVlLlZhbHVlKSA/XG4gICAgICAgIHZhbHVlIDogbmV3IHRyZWUuVmFsdWUoW3ZhbHVlXSk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuc3ltYm9saXplciA9IHRyZWUuUmVmZXJlbmNlLnN5bWJvbGl6ZXIodGhpcy5uYW1lKTtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgdGhpcy52YXJpYWJsZSA9IChuYW1lLmNoYXJBdCgwKSA9PT0gJ0AnKTtcbn07XG5cbnRyZWUuUnVsZS5wcm90b3R5cGUuaXMgPSAncnVsZSc7XG5cbnRyZWUuUnVsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRyZWUuUnVsZS5wcm90b3R5cGUpO1xuICAgIGNsb25lLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY2xvbmUudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIGNsb25lLmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBjbG9uZS5pbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG4gICAgY2xvbmUuc3ltYm9saXplciA9IHRoaXMuc3ltYm9saXplcjtcbiAgICBjbG9uZS5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgY2xvbmUudmFyaWFibGUgPSB0aGlzLnZhcmlhYmxlO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbnRyZWUuUnVsZS5wcm90b3R5cGUudXBkYXRlSUQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pZCA9IHRoaXMuem9vbSArICcjJyArIHRoaXMuaW5zdGFuY2UgKyAnIycgKyB0aGlzLm5hbWU7XG59O1xuXG50cmVlLlJ1bGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdbJyArIHRyZWUuWm9vbS50b1N0cmluZyh0aGlzLnpvb20pICsgJ10gJyArIHRoaXMubmFtZSArICc6ICcgKyB0aGlzLnZhbHVlO1xufTtcblxuZnVuY3Rpb24gZ2V0TWVhbihuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yX2NhY2hlKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gW2YsIHRyZWUuUmVmZXJlbmNlLmVkaXREaXN0YW5jZShuYW1lLCBmKV07XG4gICAgfSkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhWzFdIC0gYlsxXTsgfSk7XG59XG5cbi8vIHNlY29uZCBhcmd1bWVudCwgaWYgdHJ1ZSwgb3V0cHV0cyB0aGUgdmFsdWUgb2YgdGhpc1xuLy8gcnVsZSB3aXRob3V0IHRoZSB1c3VhbCBhdHRyaWJ1dGU9XCJjb250ZW50XCIgd3JhcHBpbmcuIFJpZ2h0XG4vLyBub3cgdGhpcyBpcyBqdXN0IGZvciB0aGUgVGV4dFN5bWJvbGl6ZXIsIGJ1dCBhcHBsaWVzIHRvIG90aGVyXG4vLyBwcm9wZXJ0aWVzIGluIHJlZmVyZW5jZS5qc29uIHdoaWNoIHNwZWNpZnkgc2VyaWFsaXphdGlvbj1jb250ZW50XG50cmVlLlJ1bGUucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZW52LCBjb250ZW50LCBzZXAsIGZvcm1hdCkge1xuICAgIGlmICghdHJlZS5SZWZlcmVuY2UudmFsaWRTZWxlY3Rvcih0aGlzLm5hbWUpKSB7XG4gICAgICAgIHZhciBtZWFuID0gZ2V0TWVhbih0aGlzLm5hbWUpO1xuICAgICAgICB2YXIgbWVhbl9tZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChtZWFuWzBdWzFdIDwgMykge1xuICAgICAgICAgICAgbWVhbl9tZXNzYWdlID0gJy4gRGlkIHlvdSBtZWFuICcgKyBtZWFuWzBdWzBdICsgJz8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbnJlY29nbml6ZWQgcnVsZTogXCIgKyB0aGlzLm5hbWUgKyBtZWFuX21lc3NhZ2UsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgIHR5cGU6ICdzeW50YXgnLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLnZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYWx1ZSkgJiZcbiAgICAgICAgIXRyZWUuUmVmZXJlbmNlLnZhbGlkVmFsdWUoZW52LCB0aGlzLm5hbWUsIHRoaXMudmFsdWUpKSB7XG4gICAgICAgIGlmICghdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VucmVjb2duaXplZCBwcm9wZXJ0eTogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ludGF4JyxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWU7XG4gICAgICAgICAgICBpZiAodHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS52YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHR5cGVuYW1lID0gdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS52YWxpZGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKHRoaXMubmFtZSkudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0eXBlbmFtZSA9ICdrZXl3b3JkIChvcHRpb25zOiAnICsgdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS50eXBlLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVuYW1lID0gdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgdmFsdWUgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnLCB0aGUgdHlwZSAnICsgdHlwZW5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnIGlzIGV4cGVjdGVkLiAnICsgdGhpcy52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICcgKG9mIHR5cGUgJyArIHRoaXMudmFsdWUudmFsdWVbMF0uaXMgKyAnKSAnICtcbiAgICAgICAgICAgICAgICAgICAgJyB3YXMgZ2l2ZW4uJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ludGF4JyxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICh0cmVlLlJlZmVyZW5jZS5pc0ZvbnQodGhpcy5uYW1lKSAmJiB0aGlzLnZhbHVlLnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGYgPSB0cmVlLl9nZXRGb250U2V0KGVudiwgdGhpcy52YWx1ZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiAnZm9udHNldC1uYW1lPVwiJyArIGYubmFtZSArICdcIic7XG4gICAgfSBlbHNlIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKGVudiwgdGhpcy5uYW1lLCBzZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmVlLlJlZmVyZW5jZS5zZWxlY3Rvck5hbWUodGhpcy5uYW1lKSArXG4gICAgICAgICAgICAnPVwiJyArXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnRvU3RyaW5nKGVudiwgdGhpcy5uYW1lKSArXG4gICAgICAgICAgICAnXCInO1xuICAgIH1cbn07XG5cbi8vIFRPRE86IFJ1bGUgZXYgY2hhaW4gc2hvdWxkIGFkZCBmb250c2V0cyB0byBlbnYuZnJhbWVzXG50cmVlLlJ1bGUucHJvdG90eXBlLmV2ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgdHJlZS5SdWxlKHRoaXMubmFtZSxcbiAgICAgICAgdGhpcy52YWx1ZS5ldihjb250ZXh0KSxcbiAgICAgICAgdGhpcy5pbmRleCxcbiAgICAgICAgdGhpcy5maWxlbmFtZSk7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5SdWxlc2V0ID0gZnVuY3Rpb24gUnVsZXNldChzZWxlY3RvcnMsIHJ1bGVzKSB7XG4gICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIC8vIHN0YXRpYyBjYWNoZSBvZiBmaW5kKCkgZnVuY3Rpb25cbiAgICB0aGlzLl9sb29rdXBzID0ge307XG59O1xudHJlZS5SdWxlc2V0LnByb3RvdHlwZSA9IHtcbiAgICBpczogJ3J1bGVzZXQnLFxuICAgICdldic6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHJ1bGVzZXQgPSBuZXcgdHJlZS5SdWxlc2V0KHRoaXMuc2VsZWN0b3JzLCB0aGlzLnJ1bGVzLnNsaWNlKDApKTtcbiAgICAgICAgcnVsZXNldC5yb290ID0gdGhpcy5yb290O1xuXG4gICAgICAgIC8vIHB1c2ggdGhlIGN1cnJlbnQgcnVsZXNldCB0byB0aGUgZnJhbWVzIHN0YWNrXG4gICAgICAgIGVudi5mcmFtZXMudW5zaGlmdChydWxlc2V0KTtcblxuICAgICAgICAvLyBFdmFsdWF0ZSBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgZm9yIChpID0gMCwgcnVsZTsgaSA8IHJ1bGVzZXQucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJ1bGUgPSBydWxlc2V0LnJ1bGVzW2ldO1xuICAgICAgICAgICAgcnVsZXNldC5ydWxlc1tpXSA9IHJ1bGUuZXYgPyBydWxlLmV2KGVudikgOiBydWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9wIHRoZSBzdGFja1xuICAgICAgICBlbnYuZnJhbWVzLnNoaWZ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzZXQ7XG4gICAgfSxcbiAgICBtYXRjaDogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDA7XG4gICAgfSxcbiAgICB2YXJpYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVzKSB7IHJldHVybiB0aGlzLl92YXJpYWJsZXM7IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzID0gdGhpcy5ydWxlcy5yZWR1Y2UoZnVuY3Rpb24oaGFzaCwgcikge1xuICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgdHJlZS5SdWxlICYmIHIudmFyaWFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFtyLm5hbWVdID0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZhcmlhYmxlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcygpW25hbWVdO1xuICAgIH0sXG4gICAgcnVsZXNldHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcnVsZXNldHMpIHsgcmV0dXJuIHRoaXMuX3J1bGVzZXRzOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzZXRzID0gdGhpcy5ydWxlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHJldHVybiAociBpbnN0YW5jZW9mIHRyZWUuUnVsZXNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIHNlbGYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYgfHwgdGhpcztcbiAgICAgICAgdmFyIHJ1bGVzID0gW10sIHJ1bGUsIG1hdGNoLFxuICAgICAgICAgICAga2V5ID0gc2VsZWN0b3IudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2xvb2t1cHMpIHsgcmV0dXJuIHRoaXMuX2xvb2t1cHNba2V5XTsgfVxuXG4gICAgICAgIHRoaXMucnVsZXNldHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIGlmIChydWxlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlLnNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKHJ1bGUuc2VsZWN0b3JzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJ1bGVzLCBydWxlLmZpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyB0cmVlLlNlbGVjdG9yKG51bGwsIG51bGwsIG51bGwsIHNlbGVjdG9yLmVsZW1lbnRzLnNsaWNlKDEpKSwgc2VsZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9va3Vwc1trZXldID0gcnVsZXM7XG4gICAgfSxcbiAgICAvLyBab29tcyBjYW4gdXNlIHZhcmlhYmxlcy4gVGhpcyByZXBsYWNlcyB0cmVlLlpvb20gb2JqZWN0cyBvbiBzZWxlY3RvcnNcbiAgICAvLyB3aXRoIHNpbXBsZSBiaXQtYXJyYXlzIHRoYXQgd2UgY2FuIGNvbXBhcmUgZWFzaWx5LlxuICAgIGV2Wm9vbXM6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgenZhbCA9IHRyZWUuWm9vbS5hbGw7XG4gICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IHRoaXMuc2VsZWN0b3JzW2ldLnpvb20ubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICB6dmFsID0genZhbCAmIHRoaXMuc2VsZWN0b3JzW2ldLnpvb21bel0uZXYoZW52KS56b29tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnNbaV0uem9vbSA9IHp2YWw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uKHJlc3VsdCwgcGFyZW50cywgZW52KSB7XG4gICAgICAgIHZhciBzZWxlY3RvcnMgPSBbXSwgaSwgajtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZW52LmZyYW1lcyA9IGVudi5mcmFtZXMuY29uY2F0KHRoaXMucnVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV2YWx1YXRlIHpvb20gdmFyaWFibGVzIG9uIHRoaXMgb2JqZWN0LlxuICAgICAgICB0aGlzLmV2Wm9vbXMoZW52KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnNlbGVjdG9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZC5maWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBpbnRlcm5hbCBpbmNvbnNpc3RlbmN5P1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW52YWxpZCBmaWx0ZXJzZXQuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXJlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZWRGaWx0ZXJzID0gcGFyZW50LmZpbHRlcnMuY2xvbmVXaXRoKGNoaWxkLmZpbHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2VkRmlsdGVycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVycyBjb3VsZCBiZSBhZGRlZCwgYnV0IHRoZXkgZGlkbid0IGNoYW5nZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlcnMuIFRoaXMgbWVhbnMgdGhhdCB3ZSBvbmx5IGhhdmUgdG8gY2xvbmUgd2hlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHpvb20gbGV2ZWxzIG9yIHRoZSBhdHRhY2htZW50IGlzIGRpZmZlcmVudCB0b28uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Lnpvb20gPT09IChwYXJlbnQuem9vbSAmIGNoaWxkLnpvb20pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZyYW1lX29mZnNldCA9PT0gY2hpbGQuZnJhbWVfb2Zmc2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmF0dGFjaG1lbnQgPT09IGNoaWxkLmF0dGFjaG1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMuam9pbigpID09PSBjaGlsZC5lbGVtZW50cy5qb2luKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRGaWx0ZXJzID0gcGFyZW50LmZpbHRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1lcmdlZEZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtZXJnZWQgZmlsdGVycyBhcmUgaW52YWxpZCwgdGhhdCBtZWFucyB3ZSBkb24ndFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBjbG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0cmVlLlNlbGVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmZpbHRlcnMgPSBtZXJnZWRGaWx0ZXJzO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS56b29tID0gcGFyZW50Lnpvb20gJiBjaGlsZC56b29tO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS5mcmFtZV9vZmZzZXQgPSBjaGlsZC5mcmFtZV9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmVsZW1lbnRzID0gcGFyZW50LmVsZW1lbnRzLmNvbmNhdChjaGlsZC5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuYXR0YWNobWVudCAmJiBjaGlsZC5hdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5hdHRhY2htZW50ID0gcGFyZW50LmF0dGFjaG1lbnQgKyAnLycgKyBjaGlsZC5hdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY2xvbmUuYXR0YWNobWVudCA9IGNoaWxkLmF0dGFjaG1lbnQgfHwgcGFyZW50LmF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmNvbmRpdGlvbnMgPSBwYXJlbnQuY29uZGl0aW9ucyArIGNoaWxkLmNvbmRpdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmluZGV4ID0gY2hpbGQuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGNsb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzW2ldO1xuXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFueSBuZXN0ZWQgcnVsZXNldHNcbiAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlc2V0KSB7XG4gICAgICAgICAgICAgICAgcnVsZS5mbGF0dGVuKHJlc3VsdCwgc2VsZWN0b3JzLCBlbnYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlKSB7XG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIHRyZWUuSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcihydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHJ1bGVzLmxlbmd0aCA/IHJ1bGVzWzBdLmluZGV4IDogZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZvciBzcGVjaWZpY2l0eSBzb3J0LCB1c2UgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBydWxlIHRvIGFsbG93XG4gICAgICAgICAgICAvLyBkZWZpbmluZyBhdHRhY2htZW50cyB0aGF0IGFyZSB1bmRlciBjdXJyZW50IGVsZW1lbnQgYXMgYSBkZXNjZW5kYW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rvci5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnNbaV0uaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyB0cmVlLkRlZmluaXRpb24oc2VsZWN0b3JzW2ldLCBydWxlcy5zbGljZSgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5TZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKGZpbHRlcnMsIHpvb20sIGZyYW1lX29mZnNldCwgZWxlbWVudHMsIGF0dGFjaG1lbnQsIGNvbmRpdGlvbnMsIGluZGV4KSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzIHx8IFtdO1xuICAgIHRoaXMuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycyB8fCB7fTtcbiAgICB0aGlzLmZyYW1lX29mZnNldCA9IGZyYW1lX29mZnNldDtcbiAgICB0aGlzLnpvb20gPSB0eXBlb2Ygem9vbSAhPT0gJ3VuZGVmaW5lZCcgPyB6b29tIDogdHJlZS5ab29tLmFsbDtcbiAgICB0aGlzLmNvbmRpdGlvbnMgPSBjb25kaXRpb25zO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbn07XG5cbi8vIERldGVybWluZSB0aGUgc3BlY2lmaWNpdHkgb2YgdGhpcyBzZWxlY3RvclxuLy8gYmFzZWQgb24gdGhlIHNwZWNpZmljaXR5IG9mIGl0cyBlbGVtZW50cyAtIGNhbGxpbmdcbi8vIEVsZW1lbnQuc3BlY2lmaWNpdHkoKSBpbiBvcmRlciB0byBkbyBzb1xuLy9cbi8vIFtJRCwgQ2xhc3MsIEZpbHRlcnMsIFBvc2l0aW9uIGluIGRvY3VtZW50XVxudHJlZS5TZWxlY3Rvci5wcm90b3R5cGUuc3BlY2lmaWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgZSkge1xuICAgICAgICB2YXIgc3BlYyA9IGUuc3BlY2lmaWNpdHkoKTtcbiAgICAgICAgbWVtb1swXSArPSBzcGVjWzBdO1xuICAgICAgICBtZW1vWzFdICs9IHNwZWNbMV07XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIFswLCAwLCB0aGlzLmNvbmRpdGlvbnMsIHRoaXMuaW5kZXhdKTtcbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xudmFyIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8vIEdpdmVuIGEgc3R5bGUncyBuYW1lLCBhdHRhY2htZW50LCBkZWZpbml0aW9ucywgYW5kIGFuIGVudmlyb25tZW50IG9iamVjdCxcbi8vIHJldHVybiBhIHN0cmluZ2lmaWVkIHN0eWxlIGZvciBNYXBuaWtcbnRyZWUuU3R5bGVYTUwgPSBmdW5jdGlvbihuYW1lLCBhdHRhY2htZW50LCBkZWZpbml0aW9ucywgZW52KSB7XG4gICAgdmFyIGV4aXN0aW5nID0ge307XG4gICAgdmFyIGltYWdlX2ZpbHRlcnMgPSBbXSwgaW1hZ2VfZmlsdGVyc19pbmZsYXRlID0gW10sIGRpcmVjdF9pbWFnZV9maWx0ZXJzID0gW10sIGNvbXBfb3AgPSBbXSwgb3BhY2l0eSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZpbml0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRlZmluaXRpb25zW2ldLnJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0ubmFtZSA9PT0gJ2ltYWdlLWZpbHRlcnMnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VfZmlsdGVycy5wdXNoKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXS5uYW1lID09PSAnaW1hZ2UtZmlsdGVycy1pbmZsYXRlJykge1xuICAgICAgICAgICAgICAgIGltYWdlX2ZpbHRlcnNfaW5mbGF0ZS5wdXNoKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXS5uYW1lID09PSAnZGlyZWN0LWltYWdlLWZpbHRlcnMnKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0X2ltYWdlX2ZpbHRlcnMucHVzaChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0ubmFtZSA9PT0gJ2NvbXAtb3AnKSB7XG4gICAgICAgICAgICAgICAgY29tcF9vcC5wdXNoKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXS5uYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5LnB1c2goZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVzID0gZGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24udG9YTUwoZW52LCBleGlzdGluZyk7XG4gICAgfSk7XG5cbiAgICB2YXIgYXR0cnNfeG1sID0gJyc7XG5cbiAgICBpZiAoaW1hZ2VfZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgYXR0cnNfeG1sICs9ICcgaW1hZ2UtZmlsdGVycz1cIicgKyBfLmNoYWluKGltYWdlX2ZpbHRlcnMpXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGlkZW50aWNhbCBmaWx0ZXJzIGZyb20gYmVpbmcgZHVwbGljYXRlZCBpbiB0aGUgc3R5bGVcbiAgICAgICAgICAgIC51bmlxKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGkuaWQ7IH0pLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICByZXR1cm4gZi5ldihlbnYpLnRvWE1MKGVudiwgdHJ1ZSwgJywnLCAnaW1hZ2UtZmlsdGVyJyk7XG4gICAgICAgIH0pLnZhbHVlKCkuam9pbignLCcpICsgJ1wiJztcbiAgICB9XG5cbiAgICBpZiAoaW1hZ2VfZmlsdGVyc19pbmZsYXRlLmxlbmd0aCkge1xuICAgICAgICBhdHRyc194bWwgKz0gJyBpbWFnZS1maWx0ZXJzLWluZmxhdGU9XCInICsgaW1hZ2VfZmlsdGVyc19pbmZsYXRlWzBdLnZhbHVlLmV2KGVudikudG9TdHJpbmcoKSArICdcIic7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdF9pbWFnZV9maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBhdHRyc194bWwgKz0gJyBkaXJlY3QtaW1hZ2UtZmlsdGVycz1cIicgKyBfLmNoYWluKGRpcmVjdF9pbWFnZV9maWx0ZXJzKVxuICAgICAgICAgICAgLy8gcHJldmVudCBpZGVudGljYWwgZmlsdGVycyBmcm9tIGJlaW5nIGR1cGxpY2F0ZWQgaW4gdGhlIHN0eWxlXG4gICAgICAgICAgICAudW5pcShmdW5jdGlvbihpKSB7IHJldHVybiBpLmlkOyB9KS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuIGYuZXYoZW52KS50b1hNTChlbnYsIHRydWUsICcsJywgJ2RpcmVjdC1pbWFnZS1maWx0ZXInKTtcbiAgICAgICAgfSkudmFsdWUoKS5qb2luKCcsJykgKyAnXCInO1xuICAgIH1cblxuICAgIGlmIChjb21wX29wLmxlbmd0aCAmJiBjb21wX29wWzBdLnZhbHVlLmV2KGVudikudmFsdWUgIT0gJ3NyYy1vdmVyJykge1xuICAgICAgICBhdHRyc194bWwgKz0gJyBjb21wLW9wPVwiJyArIGNvbXBfb3BbMF0udmFsdWUuZXYoZW52KS50b1N0cmluZygpICsgJ1wiJztcbiAgICB9XG5cbiAgICBpZiAob3BhY2l0eS5sZW5ndGggJiYgb3BhY2l0eVswXS52YWx1ZS5ldihlbnYpLnZhbHVlICE9IDEpIHtcbiAgICAgICAgYXR0cnNfeG1sICs9ICcgb3BhY2l0eT1cIicgKyBvcGFjaXR5WzBdLnZhbHVlLmV2KGVudikudG9TdHJpbmcoKSArICdcIic7XG4gICAgfVxuICAgIHZhciBydWxlX3N0cmluZyA9IHJ1bGVzLmpvaW4oJycpO1xuICAgIGlmICghYXR0cnNfeG1sICYmICFydWxlX3N0cmluZykgcmV0dXJuICcnO1xuICAgIHJldHVybiAnPFN0eWxlIG5hbWU9XCInICsgbmFtZSArICdcIiBmaWx0ZXItbW9kZT1cImZpcnN0XCInICsgYXR0cnNfeG1sICsgJz5cXG4nICsgcnVsZV9zdHJpbmcgKyAnPC9TdHlsZT4nO1xufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuVVJMID0gZnVuY3Rpb24gVVJMKHZhbCwgcGF0aHMpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgIHRoaXMucGF0aHMgPSBwYXRocztcbn07XG5cbnRyZWUuVVJMLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ3VyaScsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgZXY6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuVVJMKHRoaXMudmFsdWUuZXYoY3R4KSwgdGhpcy5wYXRocyk7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuVmFsdWUgPSBmdW5jdGlvbiBWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn07XG5cbnRyZWUuVmFsdWUucHJvdG90eXBlID0ge1xuICAgIGlzOiAndmFsdWUnLFxuICAgIGV2OiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXS5ldihlbnYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhbHVlKHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5ldihlbnYpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW52LCBzZWxlY3Rvciwgc2VwLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvU3RyaW5nKGVudiwgZm9ybWF0KTtcbiAgICAgICAgfSkuam9pbihzZXAgfHwgJywgJyk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKHRyZWUuVmFsdWUucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgb2JqLnZhbHVlID0gdGhpcy52YWx1ZS5zbGljZSgpO1xuICAgICAgICBlbHNlIG9iai52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIG9iai5pcyA9IHRoaXMuaXM7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIHRvSlM6IGZ1bmN0aW9uKGVudikge1xuICAgICAgLy92YXIgdiA9IHRoaXMudmFsdWVbMF0udmFsdWVbMF07XG4gICAgICB2YXIgdmFsID0gdGhpcy5ldihlbnYpO1xuICAgICAgdmFyIHYgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgIGlmKHZhbC5pcyA9PT0gXCJjb2xvclwiIHx8IHZhbC5pcyA9PT0gJ3VyaScgfHwgdmFsLmlzID09PSAnc3RyaW5nJyB8fCB2YWwuaXMgPT09ICdrZXl3b3JkJykge1xuICAgICAgICB2ID0gXCInXCIgKyB2ICsgXCInXCI7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5pcyA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAvLyByZXBsYWNlIFt2YXJpYWJsZV0gYnkgY3R4Wyd2YXJpYWJsZSddXG4gICAgICAgIHYgPSB2LnJlcGxhY2UoL1xcWyhbXlxcXV0qKVxcXS9nLCBmdW5jdGlvbihtYXRjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZC5yZXBsYWNlKC9cXFsoLiopXFxdL2csIFwiZGF0YVsnJDEnXVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9ZWxzZSBpZiAodmFsLmlzID09PSAnY2FsbCcpIHtcbiAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG5hbWU6IHZhbC5uYW1lLFxuICAgICAgICAgICAgYXJnczogdmFsLmFyZ3NcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIl92YWx1ZSA9IFwiICsgdiArIFwiO1wiO1xuICAgIH1cblxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuVmFyaWFibGUgPSBmdW5jdGlvbiBWYXJpYWJsZShuYW1lLCBpbmRleCwgZmlsZW5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG59O1xuXG50cmVlLlZhcmlhYmxlLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ3ZhcmlhYmxlJyxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfSxcbiAgICBldjogZnVuY3Rpb24oZW52KSB7XG4gICAgICAgIHZhciB2YXJpYWJsZSxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICAgIGlmICh0aGlzLl9jc3MpIHJldHVybiB0aGlzLl9jc3M7XG5cbiAgICAgICAgdmFyIHRoaXNmcmFtZSA9IGVudi5mcmFtZXMuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmLm5hbWUgPT0gdGhpcy5uYW1lO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpc2ZyYW1lLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNmcmFtZVswXS52YWx1ZS5ldihlbnYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAndmFyaWFibGUgJyArIHRoaXMubmFtZSArICcgaXMgdW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiAncnVudGltZScsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsInZhciB0cmVlID0gcmVxdWlyZSgnLi4vdHJlZScpO1xuXG4vLyBTdG9yYWdlIGZvciB6b29tIHJhbmdlcy4gT25seSBzdXBwb3J0cyBjb250aW51b3VzIHJhbmdlcyxcbi8vIGFuZCBzdG9yZXMgdGhlbSBhcyBiaXQtc2VxdWVuY2VzIHNvIHRoYXQgdGhleSBjYW4gYmUgY29tYmluZWQsXG4vLyBpbnZlcnRlZCwgYW5kIGNvbXBhcmVkIHF1aWNrbHkuXG50cmVlLlpvb20gPSBmdW5jdGlvbihvcCwgdmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5vcCA9IG9wO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG59O1xuXG50cmVlLlpvb20ucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbih6b29tKSB7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnRyZWUuWm9vbS5wcm90b3R5cGUuZXYgPSBmdW5jdGlvbihlbnYpIHtcbiAgICB2YXIgc3RhcnQgPSAwLFxuICAgICAgICBlbmQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh0aGlzLnZhbHVlLmV2KGVudikudG9TdHJpbmcoKSwgMTApLFxuICAgICAgICB6b29tID0gMDtcblxuICAgIGlmICh2YWx1ZSA+IHRyZWUuWm9vbS5tYXhab29tIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ09ubHkgem9vbSBsZXZlbHMgYmV0d2VlbiAwIGFuZCAnICtcbiAgICAgICAgICAgICAgICB0cmVlLlpvb20ubWF4Wm9vbSArICcgc3VwcG9ydGVkLicsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMub3ApIHtcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICB0aGlzLnpvb20gPSAxIDw8IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgc3RhcnQgPSB2YWx1ZSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgc3RhcnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIGVuZCA9IHZhbHVlIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICBlbmQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0cmVlLlpvb20ubWF4Wm9vbTsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IHN0YXJ0ICYmIGkgPD0gZW5kKSB7XG4gICAgICAgICAgICB6b29tIHw9ICgxIDw8IGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG50cmVlLlpvb20ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuem9vbTtcbn07XG5cbi8vIENvdmVycyBhbGwgem9vbWxldmVscyBmcm9tIDAgdG8gMjJcbnRyZWUuWm9vbS5hbGwgPSAweDdGRkZGRjtcblxudHJlZS5ab29tLm1heFpvb20gPSAyMjtcblxudHJlZS5ab29tLnJhbmdlcyA9IHtcbiAgICAgMDogMTAwMDAwMDAwMCxcbiAgICAgMTogNTAwMDAwMDAwLFxuICAgICAyOiAyMDAwMDAwMDAsXG4gICAgIDM6IDEwMDAwMDAwMCxcbiAgICAgNDogNTAwMDAwMDAsXG4gICAgIDU6IDI1MDAwMDAwLFxuICAgICA2OiAxMjUwMDAwMCxcbiAgICAgNzogNjUwMDAwMCxcbiAgICAgODogMzAwMDAwMCxcbiAgICAgOTogMTUwMDAwMCxcbiAgICAxMDogNzUwMDAwLFxuICAgIDExOiA0MDAwMDAsXG4gICAgMTI6IDIwMDAwMCxcbiAgICAxMzogMTAwMDAwLFxuICAgIDE0OiA1MDAwMCxcbiAgICAxNTogMjUwMDAsXG4gICAgMTY6IDEyNTAwLFxuICAgIDE3OiA1MDAwLFxuICAgIDE4OiAyNTAwLFxuICAgIDE5OiAxNTAwLFxuICAgIDIwOiA3NTAsXG4gICAgMjE6IDUwMCxcbiAgICAyMjogMjUwLFxuICAgIDIzOiAxMDBcbn07XG5cbi8vIE9ubHkgd29ya3MgZm9yIHNpbmdsZSByYW5nZSB6b29tcy4gYFtYWFguLi4uWFhYWFguLi4uLi4uLi5dYCBpcyBpbnZhbGlkLlxudHJlZS5ab29tLnByb3RvdHlwZS50b1hNTCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb25kaXRpb25zID0gW107XG4gICAgaWYgKHRoaXMuem9vbSAhPSB0cmVlLlpvb20uYWxsKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG51bGwsIGVuZCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRyZWUuWm9vbS5tYXhab29tOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnpvb20gJiAoMSA8PCBpKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkgc3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID4gMCkgY29uZGl0aW9ucy5wdXNoKCcgICAgPE1heFNjYWxlRGVub21pbmF0b3I+JyArXG4gICAgICAgICAgICB0cmVlLlpvb20ucmFuZ2VzW3N0YXJ0XSArICc8L01heFNjYWxlRGVub21pbmF0b3I+XFxuJyk7XG4gICAgICAgIGlmIChlbmQgPCAyMikgY29uZGl0aW9ucy5wdXNoKCcgICAgPE1pblNjYWxlRGVub21pbmF0b3I+JyArXG4gICAgICAgICAgICB0cmVlLlpvb20ucmFuZ2VzW2VuZCArIDFdICsgJzwvTWluU2NhbGVEZW5vbWluYXRvcj5cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmRpdGlvbnM7XG59O1xuXG50cmVlLlpvb20ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRyZWUuWm9vbS5tYXhab29tOyBpKyspIHtcbiAgICAgICAgc3RyICs9ICh0aGlzLnpvb20gJiAoMSA8PCBpKSkgPyAnWCcgOiAnLic7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICB7XG4gICAgICAgIFwicmF3XCI6IFwiY2FydG9AZ2l0aHViOmNhcnRvZGIvY2FydG8jbWFzdGVyXCIsXG4gICAgICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICAgICAgXCJlc2NhcGVkTmFtZVwiOiBcImNhcnRvXCIsXG4gICAgICAgIFwibmFtZVwiOiBcImNhcnRvXCIsXG4gICAgICAgIFwicmF3U3BlY1wiOiBcImdpdGh1YjpjYXJ0b2RiL2NhcnRvI21hc3RlclwiLFxuICAgICAgICBcInNwZWNcIjogXCJnaXRodWI6Y2FydG9kYi9jYXJ0byNtYXN0ZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaG9zdGVkXCIsXG4gICAgICAgIFwiaG9zdGVkXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJnaXRodWJcIixcbiAgICAgICAgICBcInNzaFwiOiBcImdpdEBnaXRodWIuY29tOmNhcnRvZGIvY2FydG8uZ2l0I21hc3RlclwiLFxuICAgICAgICAgIFwic3NoVXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2NhcnRvZGIvY2FydG8uZ2l0I21hc3RlclwiLFxuICAgICAgICAgIFwiaHR0cHNVcmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2NhcnRvZGIvY2FydG8uZ2l0I21hc3RlclwiLFxuICAgICAgICAgIFwiZ2l0VXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9jYXJ0b2RiL2NhcnRvLmdpdCNtYXN0ZXJcIixcbiAgICAgICAgICBcInNob3J0Y3V0XCI6IFwiZ2l0aHViOmNhcnRvZGIvY2FydG8jbWFzdGVyXCIsXG4gICAgICAgICAgXCJkaXJlY3RVcmxcIjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vY2FydG9kYi9jYXJ0by9tYXN0ZXIvcGFja2FnZS5qc29uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiL1VzZXJzL2RvbmZsb3Blei9Eb2N1bWVudHMvY2FydG8vdGFuZ3JhbS1jYXJ0b1wiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwiY2FydG9kYi9jYXJ0byNtYXN0ZXJcIixcbiAgXCJfaWRcIjogXCJjYXJ0b0AwLjE1LjEtY2RiM1wiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL2NhcnRvXCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInJhd1wiOiBcImNhcnRvQGdpdGh1YjpjYXJ0b2RiL2NhcnRvI21hc3RlclwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiY2FydG9cIixcbiAgICBcIm5hbWVcIjogXCJjYXJ0b1wiLFxuICAgIFwicmF3U3BlY1wiOiBcImdpdGh1YjpjYXJ0b2RiL2NhcnRvI21hc3RlclwiLFxuICAgIFwic3BlY1wiOiBcImdpdGh1YjpjYXJ0b2RiL2NhcnRvI21hc3RlclwiLFxuICAgIFwidHlwZVwiOiBcImhvc3RlZFwiLFxuICAgIFwiaG9zdGVkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImdpdGh1YlwiLFxuICAgICAgXCJzc2hcIjogXCJnaXRAZ2l0aHViLmNvbTpjYXJ0b2RiL2NhcnRvLmdpdCNtYXN0ZXJcIixcbiAgICAgIFwic3NoVXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2NhcnRvZGIvY2FydG8uZ2l0I21hc3RlclwiLFxuICAgICAgXCJodHRwc1VybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0by5naXQjbWFzdGVyXCIsXG4gICAgICBcImdpdFVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0by5naXQjbWFzdGVyXCIsXG4gICAgICBcInNob3J0Y3V0XCI6IFwiZ2l0aHViOmNhcnRvZGIvY2FydG8jbWFzdGVyXCIsXG4gICAgICBcImRpcmVjdFVybFwiOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9jYXJ0b2RiL2NhcnRvL21hc3Rlci9wYWNrYWdlLmpzb25cIlxuICAgIH1cbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJnaXQ6Ly9naXRodWIuY29tL2NhcnRvZGIvY2FydG8uZ2l0Izk0NWY1ZWZiNzRmZDFhZjFmNWUxZjY5ZjQwOWY5NTY3Zjk0ZmI1YTdcIixcbiAgXCJfc2hhc3VtXCI6IFwiM2EzMWU0NTA1NjRjNzU3YjBkNjcwNGM3MjI4MzBlMDU3OTc1MzQzNlwiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJjYXJ0b0BnaXRodWI6Y2FydG9kYi9jYXJ0byNtYXN0ZXJcIixcbiAgXCJfd2hlcmVcIjogXCIvVXNlcnMvZG9uZmxvcGV6L0RvY3VtZW50cy9jYXJ0by90YW5ncmFtLWNhcnRvXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDYXJ0b0RCXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vY2FydG9kYi5jb20vXCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwiY2FydG9cIjogXCIuL2Jpbi9jYXJ0b1wiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0by9pc3N1ZXNcIlxuICB9LFxuICBcImNvbnRyaWJ1dG9yc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiVG9tIE1hY1dyaWdodFwiLFxuICAgICAgXCJlbWFpbFwiOiBcIm1hY3dyaWdodEBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiS29uc3RhbnRpbiBLw6RmZXJcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiQWxleGlzIFNlbGxpZXJcIixcbiAgICAgIFwiZW1haWxcIjogXCJzZWxmQGNsb3VkaGVhZC5uZXRcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiUmF1bCBPY2hvYVwiLFxuICAgICAgXCJlbWFpbFwiOiBcInJvY2hvYUBjYXJ0b2RiLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJKYXZpIFNhbnRhbmFcIixcbiAgICAgIFwiZW1haWxcIjogXCJqc2FudGFuYUBjYXJ0b2RiLmNvbVwiXG4gICAgfVxuICBdLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJtYXBuaWstcmVmZXJlbmNlXCI6IFwifjYuMC4yXCIsXG4gICAgXCJvcHRpbWlzdFwiOiBcIn4wLjYuMFwiLFxuICAgIFwidW5kZXJzY29yZVwiOiBcIjEuOC4zXCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNhcnRvQ1NTIFN0eWxlc2hlZXQgQ29tcGlsZXJcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJvd3NlcmlmeVwiOiBcIn43LjAuMFwiLFxuICAgIFwiY292ZXJhbGxzXCI6IFwifjIuMTAuMVwiLFxuICAgIFwiaXN0YW5idWxcIjogXCJ+MC4yLjE0XCIsXG4gICAgXCJqc2hpbnRcIjogXCIwLjIueFwiLFxuICAgIFwibW9jaGFcIjogXCIxLjEyLnhcIixcbiAgICBcInNheFwiOiBcIjAuMS54XCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCIxLjMuM1wiXG4gIH0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0wLjQueFwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjk0NWY1ZWZiNzRmZDFhZjFmNWUxZjY5ZjQwOWY5NTY3Zjk0ZmI1YTdcIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jYXJ0b2RiL2NhcnRvI3JlYWRtZVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIm1hcHNcIixcbiAgICBcImNzc1wiLFxuICAgIFwic3R5bGVzaGVldHNcIlxuICBdLFxuICBcImxpY2Vuc2VzXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJBcGFjaGVcIlxuICAgIH1cbiAgXSxcbiAgXCJtYWluXCI6IFwiLi9saWIvY2FydG8vaW5kZXhcIixcbiAgXCJtYW5cIjogW1xuICAgIFwiLi9tYW4vY2FydG8uMVwiXG4gIF0sXG4gIFwibmFtZVwiOiBcImNhcnRvXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiIyBDYXJ0b0NTU1xcblxcblshW0J1aWxkIFN0YXR1c10oaHR0cHM6Ly90cmF2aXMtY2kub3JnL0NhcnRvREIvY2FydG8ucG5nP2JyYW5jaD1tYXN0ZXIpXShodHRwczovL3RyYXZpcy1jaS5vcmcvQ2FydG9EQi9jYXJ0bylcXG5cXG5JcyBhcyBzdHlsZXNoZWV0IHJlbmRlcmVyIGZvciBqYXZhc2NyaXB0LCBJdCdzIGFuIGV2b2x1dGlvbiBvZiB0aGUgTWFwbmlrIHJlbmRlcmVyIGZyb20gTWFwYm94LlxcblBsZWFzZSwgc2VlIG9yaWdpbmFsIFtNYXBib3ggcmVwb10oaHR0cDovL2dpdGh1Yi5jb20vbWFwYm94L2NhcnRvKSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgY3JlZGl0c1xcblxcbiMjIFF1aWNrIFN0YXJ0XFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIHNoYWRlciBpcyBhIENhcnRvQ1NTIG9iamVjdFxcblxcbnZhciBjYXJ0b2NzcyA9IFtcXG4gICAgJyNsYXllciB7JyxcXG4gICAgJyBtYXJrZXItd2lkdGg6IFtwcm9wZXJ0eV0nLFxcbiAgICAnIG1hcmtlci1maWxsOiByZWQnLFxcbiAgICAnfSdcXG5dLmpvaW4oJycpXFxudmFyIHNoYWRlciA9IG5ldyBjYXJ0by5SZW5kZXJlckpTKCkucmVuZGVyKGNhcnRvY3NzKTtcXG52YXIgbGF5ZXJzID0gc2hhZGVyLmdldExheWVycygpXFxuZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xcbiAgICBjb25zb2xlLmxvZyhcXFwibGF5ZXIgbmFtZTogXFxcIiwgbGF5ZXIuZnVsbE5hbWUoKSlcXG4gICAgY29uc29sZS5sb2coXFxcIi0gZnJhbWVzOiBcXFwiLCBsYXllci5mcmFtZXMoKSlcXG4gICAgY29uc29sZS5sb2coXFxcIi0gYXR0YWNobWVudDogXFxcIiwgbGF5ZXIuYXR0YWNobWVudCgpKVxcblxcbiAgICB2YXIgbGF5ZXJTaGFkZXIgPSBsYXllci5nZXRTdHlsZSh7IHByb3BlcnR5OiAxIH0sIHsgem9vbTogMTAgfSlcXG4gICAgY29uc29sZS5sb2cobGF5ZXJTaGFkZXJbJ21hcmtlci13aWR0aCddKSAvLyAxXFxuICAgIGNvbnNvbGUubG9nKGxheWVyU2hhZGVyWydtYXJrZXItZmlsbCddKSAvLyAjRkYwMDAwXFxufVxcblxcbmBgYFxcblxcbiMgQVBJXFxuXFxuIyMgUmVuZGVyZXJKU1xcblxcbiMjIyByZW5kZXIoY2FydG9jc3MpXFxuXFxuIyMgQ2FydG9DU1NcXG5cXG5jb21waWxlZCBjYXJ0b2NzcyBvYmplY3RcXG5cXG4jIyMgZ2V0TGF5ZXJzXFxuXFxucmV0dXJuIHRoZSBsYXllcnMsIGFuIGFycmF5IG9mIGBgQ2FydG9DU1MuTGF5ZXJgYCBvYmplY3RcXG5cXG4jIyMgZ2V0RGVmYXVsdFxcblxcbnJldHVybiB0aGUgZGVmYXVsdCBsYXllciAoYGBDYXJ0b0NTUy5MYXllcmBgKSwgdXN1YWxseSB0aGUgTWFwIGxheWVyXFxuXFxuXFxuIyMjIGZpbmRMYXllcih3aGVyZSlcXG5cXG5maW5kIGEgbGF5ZXIgdXNpbmcgd2hlcmUgb2JqZWN0LlxcblxcbmBgYFxcbnNoYWRlci5maW5kTGF5ZXIoeyBuYW1lOiAndGVzdCcgfSlcXG5gYGBcXG5cXG4jIyBDYXJ0b0NTUy5MYXllclxcblxcbiMjIyBnZXRTdHlsZShwcm9wcywgY29udGV4dClcXG5cXG5yZXR1cm4gdGhlIGV2YWx1YXRlZCBzdHlsZTpcXG4gICAgLSBwcm9wczogb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBuZWVkZWQgdG8gcmVuZGVyIHRoZSBzdHlsZS4gSWYgdGhlIGNhcnRvY3NzIHN0eWxlIHVzZXNcXG4gICAgICBzb21lIHZhcmlhYmxlcyB0aGV5IHNob3VsZCBiZSBwYXNzZWQgaW4gdGhpcyBvYmplY3RcXG4gICAgLSBjb250ZXh0OiByZW5kZXJpbmcgY29udGV4dCB2YXJpYWJsZXMgbGlrZSBgYHpvb21gYCBvciBhbmltYXRpb24gYGBmcmFtZWBgXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuIyMgUmVmZXJlbmNlIERvY3VtZW50YXRpb25cXG5cXG4qIFttYXBib3guY29tL2NhcnRvXShodHRwOi8vbWFwYm94LmNvbS9jYXJ0by8pXFxuXFxuXFxuXCIsXG4gIFwicmVhZG1lRmlsZW5hbWVcIjogXCJSRUFETUUubWRcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS9jYXJ0b2RiL2NhcnRvLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJjb3ZlcmFnZVwiOiBcImlzdGFuYnVsIGNvdmVyIC4vbm9kZV9tb2R1bGVzLy5iaW4vX21vY2hhICYmIGNvdmVyYWxscyA8IC4vY292ZXJhZ2UvbGNvdi5pbmZvXCIsXG4gICAgXCJwcmV0ZXN0XCI6IFwibnBtIGluc3RhbGxcIixcbiAgICBcInRlc3RcIjogXCJtb2NoYSAtUiBzcGVjXCJcbiAgfSxcbiAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0b1wiLFxuICBcInZlcnNpb25cIjogXCIwLjE1LjEtY2RiM1wiXG59XG4iLCJ2YXIgY2hhcmVuYyA9IHtcbiAgLy8gVVRGLTggZW5jb2RpbmdcbiAgdXRmODoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gY2hhcmVuYy5iaW4uc3RyaW5nVG9CeXRlcyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjaGFyZW5jLmJpbi5ieXRlc1RvU3RyaW5nKGJ5dGVzKSkpO1xuICAgIH1cbiAgfSxcblxuICAvLyBCaW5hcnkgZW5jb2RpbmdcbiAgYmluOiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN0ciA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSk7XG4gICAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyZW5jO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59OyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59OyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07IiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHt9OyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduOyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTsiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07IiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTsiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07IiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59OyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pOyIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGJhc2U2NG1hcFxuICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsXG5cbiAgY3J5cHQgPSB7XG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gbGVmdFxuICAgIHJvdGw6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCBiKSB8IChuID4+PiAoMzIgLSBiKSk7XG4gICAgfSxcblxuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIHJpZ2h0XG4gICAgcm90cjogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8ICgzMiAtIGIpKSB8IChuID4+PiBiKTtcbiAgICB9LFxuXG4gICAgLy8gU3dhcCBiaWctZW5kaWFuIHRvIGxpdHRsZS1lbmRpYW4gYW5kIHZpY2UgdmVyc2FcbiAgICBlbmRpYW46IGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIElmIG51bWJlciBnaXZlbiwgc3dhcCBlbmRpYW5cbiAgICAgIGlmIChuLmNvbnN0cnVjdG9yID09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gY3J5cHQucm90bChuLCA4KSAmIDB4MDBGRjAwRkYgfCBjcnlwdC5yb3RsKG4sIDI0KSAmIDB4RkYwMEZGMDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEVsc2UsIGFzc3VtZSBhcnJheSBhbmQgc3dhcCBhbGwgaXRlbXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKylcbiAgICAgICAgbltpXSA9IGNyeXB0LmVuZGlhbihuW2ldKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiBhbnkgbGVuZ3RoIG9mIHJhbmRvbSBieXRlc1xuICAgIHJhbmRvbUJ5dGVzOiBmdW5jdGlvbihuKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdOyBuID4gMDsgbi0tKVxuICAgICAgICBieXRlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBiaWctZW5kaWFuIDMyLWJpdCB3b3Jkc1xuICAgIGJ5dGVzVG9Xb3JkczogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHdvcmRzID0gW10sIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpXG4gICAgICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMik7XG4gICAgICByZXR1cm4gd29yZHM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYmlnLWVuZGlhbiAzMi1iaXQgd29yZHMgdG8gYSBieXRlIGFycmF5XG4gICAgd29yZHNUb0J5dGVzOiBmdW5jdGlvbih3b3Jkcykge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KVxuICAgICAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBoZXggc3RyaW5nXG4gICAgYnl0ZXNUb0hleDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGhleCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldICYgMHhGKS50b1N0cmluZygxNikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhleC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgaGV4VG9CeXRlczogZnVuY3Rpb24oaGV4KSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBjID0gMDsgYyA8IGhleC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc3Vic3RyKGMsIDIpLCAxNikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGJhc2UtNjQgc3RyaW5nXG4gICAgYnl0ZXNUb0Jhc2U2NDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGJhc2U2NCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICAgIGlmIChpICogOCArIGogKiA2IDw9IGJ5dGVzLmxlbmd0aCAqIDgpXG4gICAgICAgICAgICBiYXNlNjQucHVzaChiYXNlNjRtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiA2ICogKDMgLSBqKSkgJiAweDNGKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goJz0nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlNjQuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBiYXNlLTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBiYXNlNjRUb0J5dGVzOiBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICAgIC8vIFJlbW92ZSBub24tYmFzZS02NCBjaGFyYWN0ZXJzXG4gICAgICBiYXNlNjQgPSBiYXNlNjQucmVwbGFjZSgvW15BLVowLTkrXFwvXS9pZywgJycpO1xuXG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMCwgaW1vZDQgPSAwOyBpIDwgYmFzZTY0Lmxlbmd0aDtcbiAgICAgICAgICBpbW9kNCA9ICsraSAlIDQpIHtcbiAgICAgICAgaWYgKGltb2Q0ID09IDApIGNvbnRpbnVlO1xuICAgICAgICBieXRlcy5wdXNoKCgoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpIC0gMSkpXG4gICAgICAgICAgICAmIChNYXRoLnBvdygyLCAtMiAqIGltb2Q0ICsgOCkgLSAxKSkgPDwgKGltb2Q0ICogMikpXG4gICAgICAgICAgICB8IChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkpKSA+Pj4gKDYgLSBpbW9kNCAqIDIpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gY3J5cHQ7XG59KSgpO1xuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIGV4aXN0c1N5bmMgPSByZXF1aXJlKCdmcycpLmV4aXN0c1N5bmMgfHwgcmVxdWlyZSgncGF0aCcpLmV4aXN0c1N5bmM7XG5cbi8vIExvYWQgYWxsIHN0YXRlZCB2ZXJzaW9ucyBpbnRvIHRoZSBtb2R1bGUgZXhwb3J0c1xubW9kdWxlLmV4cG9ydHMudmVyc2lvbiA9IHt9O1xuXG52YXIgcmVmcyA9IFtcbiAnMi4wLjAnLFxuICcyLjAuMScsXG4gJzIuMC4yJyxcbiAnMi4xLjAnLFxuICcyLjEuMScsXG4gJzIuMi4wJyxcbiAnMi4zLjAnLFxuICczLjAuMCdcbl07XG5cbnJlZnMubWFwKGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgICBtb2R1bGUuZXhwb3J0cy52ZXJzaW9uW3ZlcnNpb25dID0gcmVxdWlyZShwYXRoLmpvaW4oX19kaXJuYW1lLCB2ZXJzaW9uLCAncmVmZXJlbmNlLmpzb24nKSk7XG4gICAgdmFyIGRzX3BhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCB2ZXJzaW9uLCAnZGF0YXNvdXJjZXMuanNvbicpO1xuICAgIGlmIChleGlzdHNTeW5jKGRzX3BhdGgpKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLnZlcnNpb25bdmVyc2lvbl0uZGF0YXNvdXJjZXMgPSByZXF1aXJlKGRzX3BhdGgpLmRhdGFzb3VyY2VzO1xuICAgIH1cbn0pO1xuIiwiKGZ1bmN0aW9uKCl7XHJcbiAgdmFyIGNyeXB0ID0gcmVxdWlyZSgnY3J5cHQnKSxcclxuICAgICAgdXRmOCA9IHJlcXVpcmUoJ2NoYXJlbmMnKS51dGY4LFxyXG4gICAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpLFxyXG4gICAgICBiaW4gPSByZXF1aXJlKCdjaGFyZW5jJykuYmluLFxyXG5cclxuICAvLyBUaGUgY29yZVxyXG4gIG1kNSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGUgYXJyYXlcclxuICAgIGlmIChtZXNzYWdlLmNvbnN0cnVjdG9yID09IFN0cmluZylcclxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpXHJcbiAgICAgICAgbWVzc2FnZSA9IGJpbi5zdHJpbmdUb0J5dGVzKG1lc3NhZ2UpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbWVzc2FnZSA9IHV0Zjguc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgIGVsc2UgaWYgKGlzQnVmZmVyKG1lc3NhZ2UpKVxyXG4gICAgICBtZXNzYWdlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZSwgMCk7XHJcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudG9TdHJpbmcoKTtcclxuICAgIC8vIGVsc2UsIGFzc3VtZSBieXRlIGFycmF5IGFscmVhZHlcclxuXHJcbiAgICB2YXIgbSA9IGNyeXB0LmJ5dGVzVG9Xb3JkcyhtZXNzYWdlKSxcclxuICAgICAgICBsID0gbWVzc2FnZS5sZW5ndGggKiA4LFxyXG4gICAgICAgIGEgPSAgMTczMjU4NDE5MyxcclxuICAgICAgICBiID0gLTI3MTczMzg3OSxcclxuICAgICAgICBjID0gLTE3MzI1ODQxOTQsXHJcbiAgICAgICAgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gICAgLy8gU3dhcCBlbmRpYW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtW2ldID0gKChtW2ldIDw8ICA4KSB8IChtW2ldID4+PiAyNCkpICYgMHgwMEZGMDBGRiB8XHJcbiAgICAgICAgICAgICAoKG1baV0gPDwgMjQpIHwgKG1baV0gPj4+ICA4KSkgJiAweEZGMDBGRjAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhZGRpbmdcclxuICAgIG1bbCA+Pj4gNV0gfD0gMHg4MCA8PCAobCAlIDMyKTtcclxuICAgIG1bKCgobCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsO1xyXG5cclxuICAgIC8vIE1ldGhvZCBzaG9ydGN1dHNcclxuICAgIHZhciBGRiA9IG1kNS5fZmYsXHJcbiAgICAgICAgR0cgPSBtZDUuX2dnLFxyXG4gICAgICAgIEhIID0gbWQ1Ll9oaCxcclxuICAgICAgICBJSSA9IG1kNS5faWk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xyXG5cclxuICAgICAgdmFyIGFhID0gYSxcclxuICAgICAgICAgIGJiID0gYixcclxuICAgICAgICAgIGNjID0gYyxcclxuICAgICAgICAgIGRkID0gZDtcclxuXHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDBdLCAgNywgLTY4MDg3NjkzNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyA0XSwgIDcsIC0xNzY0MTg4OTcpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgOF0sICA3LCAgMTc3MDAzNTQxNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKzEyXSwgIDcsICAxODA0NjAzNjgyKTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyAxXSwgIDUsIC0xNjU3OTY1MTApO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyA2XSwgIDksIC0xMDY5NTAxNjMyKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgNV0sICA1LCAtNzAxNTU4NjkxKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxMF0sICA5LCAgMzgwMTYwODMpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyA5XSwgIDUsICA1Njg0NDY0MzgpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKzE0XSwgIDksIC0xMDE5ODAzNjkwKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krMTNdLCAgNSwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyAyXSwgIDksIC01MTQwMzc4NCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDVdLCAgNCwgLTM3ODU1OCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKzEzXSwgIDQsICA2ODEyNzkxNzQpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDldLCAgNCwgLTY0MDM2NDQ4Nyk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDYsIC0xOTg2MzA4NDQpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsxMl0sICA2LCAgMTcwMDQ4NTU3MSk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgNF0sICA2LCAtMTQ1NTIzMDcwKTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgICBhID0gKGEgKyBhYSkgPj4+IDA7XHJcbiAgICAgIGIgPSAoYiArIGJiKSA+Pj4gMDtcclxuICAgICAgYyA9IChjICsgY2MpID4+PiAwO1xyXG4gICAgICBkID0gKGQgKyBkZCkgPj4+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyeXB0LmVuZGlhbihbYSwgYiwgYywgZF0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEF1eGlsaWFyeSBmdW5jdGlvbnNcclxuICBtZDUuX2ZmICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGMgfCB+YiAmIGQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2dnICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGQgfCBjICYgfmQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2hoICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9paSAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG5cclxuICAvLyBQYWNrYWdlIHByaXZhdGUgYmxvY2tzaXplXHJcbiAgbWQ1Ll9ibG9ja3NpemUgPSAxNjtcclxuICBtZDUuX2RpZ2VzdHNpemUgPSAxNjtcclxuXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQgJyArIG1lc3NhZ2UpO1xyXG5cclxuICAgIHZhciBkaWdlc3RieXRlcyA9IGNyeXB0LndvcmRzVG9CeXRlcyhtZDUobWVzc2FnZSwgb3B0aW9ucykpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc0J5dGVzID8gZGlnZXN0Ynl0ZXMgOlxyXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA/IGJpbi5ieXRlc1RvU3RyaW5nKGRpZ2VzdGJ5dGVzKSA6XHJcbiAgICAgICAgY3J5cHQuYnl0ZXNUb0hleChkaWdlc3RieXRlcyk7XHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBGOiByZXF1aXJlKCcuL3NyYy9GJyksXG4gIFQ6IHJlcXVpcmUoJy4vc3JjL1QnKSxcbiAgX186IHJlcXVpcmUoJy4vc3JjL19fJyksXG4gIGFkZDogcmVxdWlyZSgnLi9zcmMvYWRkJyksXG4gIGFkZEluZGV4OiByZXF1aXJlKCcuL3NyYy9hZGRJbmRleCcpLFxuICBhZGp1c3Q6IHJlcXVpcmUoJy4vc3JjL2FkanVzdCcpLFxuICBhbGw6IHJlcXVpcmUoJy4vc3JjL2FsbCcpLFxuICBhbGxQYXNzOiByZXF1aXJlKCcuL3NyYy9hbGxQYXNzJyksXG4gIGFsd2F5czogcmVxdWlyZSgnLi9zcmMvYWx3YXlzJyksXG4gIGFuZDogcmVxdWlyZSgnLi9zcmMvYW5kJyksXG4gIGFueTogcmVxdWlyZSgnLi9zcmMvYW55JyksXG4gIGFueVBhc3M6IHJlcXVpcmUoJy4vc3JjL2FueVBhc3MnKSxcbiAgYXA6IHJlcXVpcmUoJy4vc3JjL2FwJyksXG4gIGFwZXJ0dXJlOiByZXF1aXJlKCcuL3NyYy9hcGVydHVyZScpLFxuICBhcHBlbmQ6IHJlcXVpcmUoJy4vc3JjL2FwcGVuZCcpLFxuICBhcHBseTogcmVxdWlyZSgnLi9zcmMvYXBwbHknKSxcbiAgYXBwbHlTcGVjOiByZXF1aXJlKCcuL3NyYy9hcHBseVNwZWMnKSxcbiAgYXNjZW5kOiByZXF1aXJlKCcuL3NyYy9hc2NlbmQnKSxcbiAgYXNzb2M6IHJlcXVpcmUoJy4vc3JjL2Fzc29jJyksXG4gIGFzc29jUGF0aDogcmVxdWlyZSgnLi9zcmMvYXNzb2NQYXRoJyksXG4gIGJpbmFyeTogcmVxdWlyZSgnLi9zcmMvYmluYXJ5JyksXG4gIGJpbmQ6IHJlcXVpcmUoJy4vc3JjL2JpbmQnKSxcbiAgYm90aDogcmVxdWlyZSgnLi9zcmMvYm90aCcpLFxuICBjYWxsOiByZXF1aXJlKCcuL3NyYy9jYWxsJyksXG4gIGNoYWluOiByZXF1aXJlKCcuL3NyYy9jaGFpbicpLFxuICBjbGFtcDogcmVxdWlyZSgnLi9zcmMvY2xhbXAnKSxcbiAgY2xvbmU6IHJlcXVpcmUoJy4vc3JjL2Nsb25lJyksXG4gIGNvbXBhcmF0b3I6IHJlcXVpcmUoJy4vc3JjL2NvbXBhcmF0b3InKSxcbiAgY29tcGxlbWVudDogcmVxdWlyZSgnLi9zcmMvY29tcGxlbWVudCcpLFxuICBjb21wb3NlOiByZXF1aXJlKCcuL3NyYy9jb21wb3NlJyksXG4gIGNvbXBvc2VLOiByZXF1aXJlKCcuL3NyYy9jb21wb3NlSycpLFxuICBjb21wb3NlUDogcmVxdWlyZSgnLi9zcmMvY29tcG9zZVAnKSxcbiAgY29uY2F0OiByZXF1aXJlKCcuL3NyYy9jb25jYXQnKSxcbiAgY29uZDogcmVxdWlyZSgnLi9zcmMvY29uZCcpLFxuICBjb25zdHJ1Y3Q6IHJlcXVpcmUoJy4vc3JjL2NvbnN0cnVjdCcpLFxuICBjb25zdHJ1Y3ROOiByZXF1aXJlKCcuL3NyYy9jb25zdHJ1Y3ROJyksXG4gIGNvbnRhaW5zOiByZXF1aXJlKCcuL3NyYy9jb250YWlucycpLFxuICBjb252ZXJnZTogcmVxdWlyZSgnLi9zcmMvY29udmVyZ2UnKSxcbiAgY291bnRCeTogcmVxdWlyZSgnLi9zcmMvY291bnRCeScpLFxuICBjdXJyeTogcmVxdWlyZSgnLi9zcmMvY3VycnknKSxcbiAgY3VycnlOOiByZXF1aXJlKCcuL3NyYy9jdXJyeU4nKSxcbiAgZGVjOiByZXF1aXJlKCcuL3NyYy9kZWMnKSxcbiAgZGVzY2VuZDogcmVxdWlyZSgnLi9zcmMvZGVzY2VuZCcpLFxuICBkZWZhdWx0VG86IHJlcXVpcmUoJy4vc3JjL2RlZmF1bHRUbycpLFxuICBkaWZmZXJlbmNlOiByZXF1aXJlKCcuL3NyYy9kaWZmZXJlbmNlJyksXG4gIGRpZmZlcmVuY2VXaXRoOiByZXF1aXJlKCcuL3NyYy9kaWZmZXJlbmNlV2l0aCcpLFxuICBkaXNzb2M6IHJlcXVpcmUoJy4vc3JjL2Rpc3NvYycpLFxuICBkaXNzb2NQYXRoOiByZXF1aXJlKCcuL3NyYy9kaXNzb2NQYXRoJyksXG4gIGRpdmlkZTogcmVxdWlyZSgnLi9zcmMvZGl2aWRlJyksXG4gIGRyb3A6IHJlcXVpcmUoJy4vc3JjL2Ryb3AnKSxcbiAgZHJvcExhc3Q6IHJlcXVpcmUoJy4vc3JjL2Ryb3BMYXN0JyksXG4gIGRyb3BMYXN0V2hpbGU6IHJlcXVpcmUoJy4vc3JjL2Ryb3BMYXN0V2hpbGUnKSxcbiAgZHJvcFJlcGVhdHM6IHJlcXVpcmUoJy4vc3JjL2Ryb3BSZXBlYXRzJyksXG4gIGRyb3BSZXBlYXRzV2l0aDogcmVxdWlyZSgnLi9zcmMvZHJvcFJlcGVhdHNXaXRoJyksXG4gIGRyb3BXaGlsZTogcmVxdWlyZSgnLi9zcmMvZHJvcFdoaWxlJyksXG4gIGVpdGhlcjogcmVxdWlyZSgnLi9zcmMvZWl0aGVyJyksXG4gIGVtcHR5OiByZXF1aXJlKCcuL3NyYy9lbXB0eScpLFxuICBlcUJ5OiByZXF1aXJlKCcuL3NyYy9lcUJ5JyksXG4gIGVxUHJvcHM6IHJlcXVpcmUoJy4vc3JjL2VxUHJvcHMnKSxcbiAgZXF1YWxzOiByZXF1aXJlKCcuL3NyYy9lcXVhbHMnKSxcbiAgZXZvbHZlOiByZXF1aXJlKCcuL3NyYy9ldm9sdmUnKSxcbiAgZmlsdGVyOiByZXF1aXJlKCcuL3NyYy9maWx0ZXInKSxcbiAgZmluZDogcmVxdWlyZSgnLi9zcmMvZmluZCcpLFxuICBmaW5kSW5kZXg6IHJlcXVpcmUoJy4vc3JjL2ZpbmRJbmRleCcpLFxuICBmaW5kTGFzdDogcmVxdWlyZSgnLi9zcmMvZmluZExhc3QnKSxcbiAgZmluZExhc3RJbmRleDogcmVxdWlyZSgnLi9zcmMvZmluZExhc3RJbmRleCcpLFxuICBmbGF0dGVuOiByZXF1aXJlKCcuL3NyYy9mbGF0dGVuJyksXG4gIGZsaXA6IHJlcXVpcmUoJy4vc3JjL2ZsaXAnKSxcbiAgZm9yRWFjaDogcmVxdWlyZSgnLi9zcmMvZm9yRWFjaCcpLFxuICBmb3JFYWNoT2JqSW5kZXhlZDogcmVxdWlyZSgnLi9zcmMvZm9yRWFjaE9iakluZGV4ZWQnKSxcbiAgZnJvbVBhaXJzOiByZXF1aXJlKCcuL3NyYy9mcm9tUGFpcnMnKSxcbiAgZ3JvdXBCeTogcmVxdWlyZSgnLi9zcmMvZ3JvdXBCeScpLFxuICBncm91cFdpdGg6IHJlcXVpcmUoJy4vc3JjL2dyb3VwV2l0aCcpLFxuICBndDogcmVxdWlyZSgnLi9zcmMvZ3QnKSxcbiAgZ3RlOiByZXF1aXJlKCcuL3NyYy9ndGUnKSxcbiAgaGFzOiByZXF1aXJlKCcuL3NyYy9oYXMnKSxcbiAgaGFzSW46IHJlcXVpcmUoJy4vc3JjL2hhc0luJyksXG4gIGhlYWQ6IHJlcXVpcmUoJy4vc3JjL2hlYWQnKSxcbiAgaWRlbnRpY2FsOiByZXF1aXJlKCcuL3NyYy9pZGVudGljYWwnKSxcbiAgaWRlbnRpdHk6IHJlcXVpcmUoJy4vc3JjL2lkZW50aXR5JyksXG4gIGlmRWxzZTogcmVxdWlyZSgnLi9zcmMvaWZFbHNlJyksXG4gIGluYzogcmVxdWlyZSgnLi9zcmMvaW5jJyksXG4gIGluZGV4Qnk6IHJlcXVpcmUoJy4vc3JjL2luZGV4QnknKSxcbiAgaW5kZXhPZjogcmVxdWlyZSgnLi9zcmMvaW5kZXhPZicpLFxuICBpbml0OiByZXF1aXJlKCcuL3NyYy9pbml0JyksXG4gIGluc2VydDogcmVxdWlyZSgnLi9zcmMvaW5zZXJ0JyksXG4gIGluc2VydEFsbDogcmVxdWlyZSgnLi9zcmMvaW5zZXJ0QWxsJyksXG4gIGludGVyc2VjdGlvbjogcmVxdWlyZSgnLi9zcmMvaW50ZXJzZWN0aW9uJyksXG4gIGludGVyc2VjdGlvbldpdGg6IHJlcXVpcmUoJy4vc3JjL2ludGVyc2VjdGlvbldpdGgnKSxcbiAgaW50ZXJzcGVyc2U6IHJlcXVpcmUoJy4vc3JjL2ludGVyc3BlcnNlJyksXG4gIGludG86IHJlcXVpcmUoJy4vc3JjL2ludG8nKSxcbiAgaW52ZXJ0OiByZXF1aXJlKCcuL3NyYy9pbnZlcnQnKSxcbiAgaW52ZXJ0T2JqOiByZXF1aXJlKCcuL3NyYy9pbnZlcnRPYmonKSxcbiAgaW52b2tlcjogcmVxdWlyZSgnLi9zcmMvaW52b2tlcicpLFxuICBpczogcmVxdWlyZSgnLi9zcmMvaXMnKSxcbiAgaXNBcnJheUxpa2U6IHJlcXVpcmUoJy4vc3JjL2lzQXJyYXlMaWtlJyksXG4gIGlzRW1wdHk6IHJlcXVpcmUoJy4vc3JjL2lzRW1wdHknKSxcbiAgaXNOaWw6IHJlcXVpcmUoJy4vc3JjL2lzTmlsJyksXG4gIGpvaW46IHJlcXVpcmUoJy4vc3JjL2pvaW4nKSxcbiAganV4dDogcmVxdWlyZSgnLi9zcmMvanV4dCcpLFxuICBrZXlzOiByZXF1aXJlKCcuL3NyYy9rZXlzJyksXG4gIGtleXNJbjogcmVxdWlyZSgnLi9zcmMva2V5c0luJyksXG4gIGxhc3Q6IHJlcXVpcmUoJy4vc3JjL2xhc3QnKSxcbiAgbGFzdEluZGV4T2Y6IHJlcXVpcmUoJy4vc3JjL2xhc3RJbmRleE9mJyksXG4gIGxlbmd0aDogcmVxdWlyZSgnLi9zcmMvbGVuZ3RoJyksXG4gIGxlbnM6IHJlcXVpcmUoJy4vc3JjL2xlbnMnKSxcbiAgbGVuc0luZGV4OiByZXF1aXJlKCcuL3NyYy9sZW5zSW5kZXgnKSxcbiAgbGVuc1BhdGg6IHJlcXVpcmUoJy4vc3JjL2xlbnNQYXRoJyksXG4gIGxlbnNQcm9wOiByZXF1aXJlKCcuL3NyYy9sZW5zUHJvcCcpLFxuICBsaWZ0OiByZXF1aXJlKCcuL3NyYy9saWZ0JyksXG4gIGxpZnROOiByZXF1aXJlKCcuL3NyYy9saWZ0TicpLFxuICBsdDogcmVxdWlyZSgnLi9zcmMvbHQnKSxcbiAgbHRlOiByZXF1aXJlKCcuL3NyYy9sdGUnKSxcbiAgbWFwOiByZXF1aXJlKCcuL3NyYy9tYXAnKSxcbiAgbWFwQWNjdW06IHJlcXVpcmUoJy4vc3JjL21hcEFjY3VtJyksXG4gIG1hcEFjY3VtUmlnaHQ6IHJlcXVpcmUoJy4vc3JjL21hcEFjY3VtUmlnaHQnKSxcbiAgbWFwT2JqSW5kZXhlZDogcmVxdWlyZSgnLi9zcmMvbWFwT2JqSW5kZXhlZCcpLFxuICBtYXRjaDogcmVxdWlyZSgnLi9zcmMvbWF0Y2gnKSxcbiAgbWF0aE1vZDogcmVxdWlyZSgnLi9zcmMvbWF0aE1vZCcpLFxuICBtYXg6IHJlcXVpcmUoJy4vc3JjL21heCcpLFxuICBtYXhCeTogcmVxdWlyZSgnLi9zcmMvbWF4QnknKSxcbiAgbWVhbjogcmVxdWlyZSgnLi9zcmMvbWVhbicpLFxuICBtZWRpYW46IHJlcXVpcmUoJy4vc3JjL21lZGlhbicpLFxuICBtZW1vaXplOiByZXF1aXJlKCcuL3NyYy9tZW1vaXplJyksXG4gIG1lcmdlOiByZXF1aXJlKCcuL3NyYy9tZXJnZScpLFxuICBtZXJnZUFsbDogcmVxdWlyZSgnLi9zcmMvbWVyZ2VBbGwnKSxcbiAgbWVyZ2VXaXRoOiByZXF1aXJlKCcuL3NyYy9tZXJnZVdpdGgnKSxcbiAgbWVyZ2VXaXRoS2V5OiByZXF1aXJlKCcuL3NyYy9tZXJnZVdpdGhLZXknKSxcbiAgbWluOiByZXF1aXJlKCcuL3NyYy9taW4nKSxcbiAgbWluQnk6IHJlcXVpcmUoJy4vc3JjL21pbkJ5JyksXG4gIG1vZHVsbzogcmVxdWlyZSgnLi9zcmMvbW9kdWxvJyksXG4gIG11bHRpcGx5OiByZXF1aXJlKCcuL3NyYy9tdWx0aXBseScpLFxuICBuQXJ5OiByZXF1aXJlKCcuL3NyYy9uQXJ5JyksXG4gIG5lZ2F0ZTogcmVxdWlyZSgnLi9zcmMvbmVnYXRlJyksXG4gIG5vbmU6IHJlcXVpcmUoJy4vc3JjL25vbmUnKSxcbiAgbm90OiByZXF1aXJlKCcuL3NyYy9ub3QnKSxcbiAgbnRoOiByZXF1aXJlKCcuL3NyYy9udGgnKSxcbiAgbnRoQXJnOiByZXF1aXJlKCcuL3NyYy9udGhBcmcnKSxcbiAgb2JqT2Y6IHJlcXVpcmUoJy4vc3JjL29iak9mJyksXG4gIG9mOiByZXF1aXJlKCcuL3NyYy9vZicpLFxuICBvbWl0OiByZXF1aXJlKCcuL3NyYy9vbWl0JyksXG4gIG9uY2U6IHJlcXVpcmUoJy4vc3JjL29uY2UnKSxcbiAgb3I6IHJlcXVpcmUoJy4vc3JjL29yJyksXG4gIG92ZXI6IHJlcXVpcmUoJy4vc3JjL292ZXInKSxcbiAgcGFpcjogcmVxdWlyZSgnLi9zcmMvcGFpcicpLFxuICBwYXJ0aWFsOiByZXF1aXJlKCcuL3NyYy9wYXJ0aWFsJyksXG4gIHBhcnRpYWxSaWdodDogcmVxdWlyZSgnLi9zcmMvcGFydGlhbFJpZ2h0JyksXG4gIHBhcnRpdGlvbjogcmVxdWlyZSgnLi9zcmMvcGFydGl0aW9uJyksXG4gIHBhdGg6IHJlcXVpcmUoJy4vc3JjL3BhdGgnKSxcbiAgcGF0aEVxOiByZXF1aXJlKCcuL3NyYy9wYXRoRXEnKSxcbiAgcGF0aE9yOiByZXF1aXJlKCcuL3NyYy9wYXRoT3InKSxcbiAgcGF0aFNhdGlzZmllczogcmVxdWlyZSgnLi9zcmMvcGF0aFNhdGlzZmllcycpLFxuICBwaWNrOiByZXF1aXJlKCcuL3NyYy9waWNrJyksXG4gIHBpY2tBbGw6IHJlcXVpcmUoJy4vc3JjL3BpY2tBbGwnKSxcbiAgcGlja0J5OiByZXF1aXJlKCcuL3NyYy9waWNrQnknKSxcbiAgcGlwZTogcmVxdWlyZSgnLi9zcmMvcGlwZScpLFxuICBwaXBlSzogcmVxdWlyZSgnLi9zcmMvcGlwZUsnKSxcbiAgcGlwZVA6IHJlcXVpcmUoJy4vc3JjL3BpcGVQJyksXG4gIHBsdWNrOiByZXF1aXJlKCcuL3NyYy9wbHVjaycpLFxuICBwcmVwZW5kOiByZXF1aXJlKCcuL3NyYy9wcmVwZW5kJyksXG4gIHByb2R1Y3Q6IHJlcXVpcmUoJy4vc3JjL3Byb2R1Y3QnKSxcbiAgcHJvamVjdDogcmVxdWlyZSgnLi9zcmMvcHJvamVjdCcpLFxuICBwcm9wOiByZXF1aXJlKCcuL3NyYy9wcm9wJyksXG4gIHByb3BFcTogcmVxdWlyZSgnLi9zcmMvcHJvcEVxJyksXG4gIHByb3BJczogcmVxdWlyZSgnLi9zcmMvcHJvcElzJyksXG4gIHByb3BPcjogcmVxdWlyZSgnLi9zcmMvcHJvcE9yJyksXG4gIHByb3BTYXRpc2ZpZXM6IHJlcXVpcmUoJy4vc3JjL3Byb3BTYXRpc2ZpZXMnKSxcbiAgcHJvcHM6IHJlcXVpcmUoJy4vc3JjL3Byb3BzJyksXG4gIHJhbmdlOiByZXF1aXJlKCcuL3NyYy9yYW5nZScpLFxuICByZWR1Y2U6IHJlcXVpcmUoJy4vc3JjL3JlZHVjZScpLFxuICByZWR1Y2VCeTogcmVxdWlyZSgnLi9zcmMvcmVkdWNlQnknKSxcbiAgcmVkdWNlUmlnaHQ6IHJlcXVpcmUoJy4vc3JjL3JlZHVjZVJpZ2h0JyksXG4gIHJlZHVjZVdoaWxlOiByZXF1aXJlKCcuL3NyYy9yZWR1Y2VXaGlsZScpLFxuICByZWR1Y2VkOiByZXF1aXJlKCcuL3NyYy9yZWR1Y2VkJyksXG4gIHJlamVjdDogcmVxdWlyZSgnLi9zcmMvcmVqZWN0JyksXG4gIHJlbW92ZTogcmVxdWlyZSgnLi9zcmMvcmVtb3ZlJyksXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9zcmMvcmVwZWF0JyksXG4gIHJlcGxhY2U6IHJlcXVpcmUoJy4vc3JjL3JlcGxhY2UnKSxcbiAgcmV2ZXJzZTogcmVxdWlyZSgnLi9zcmMvcmV2ZXJzZScpLFxuICBzY2FuOiByZXF1aXJlKCcuL3NyYy9zY2FuJyksXG4gIHNlcXVlbmNlOiByZXF1aXJlKCcuL3NyYy9zZXF1ZW5jZScpLFxuICBzZXQ6IHJlcXVpcmUoJy4vc3JjL3NldCcpLFxuICBzbGljZTogcmVxdWlyZSgnLi9zcmMvc2xpY2UnKSxcbiAgc29ydDogcmVxdWlyZSgnLi9zcmMvc29ydCcpLFxuICBzb3J0Qnk6IHJlcXVpcmUoJy4vc3JjL3NvcnRCeScpLFxuICBzb3J0V2l0aDogcmVxdWlyZSgnLi9zcmMvc29ydFdpdGgnKSxcbiAgc3BsaXQ6IHJlcXVpcmUoJy4vc3JjL3NwbGl0JyksXG4gIHNwbGl0QXQ6IHJlcXVpcmUoJy4vc3JjL3NwbGl0QXQnKSxcbiAgc3BsaXRFdmVyeTogcmVxdWlyZSgnLi9zcmMvc3BsaXRFdmVyeScpLFxuICBzcGxpdFdoZW46IHJlcXVpcmUoJy4vc3JjL3NwbGl0V2hlbicpLFxuICBzdWJ0cmFjdDogcmVxdWlyZSgnLi9zcmMvc3VidHJhY3QnKSxcbiAgc3VtOiByZXF1aXJlKCcuL3NyYy9zdW0nKSxcbiAgc3ltbWV0cmljRGlmZmVyZW5jZTogcmVxdWlyZSgnLi9zcmMvc3ltbWV0cmljRGlmZmVyZW5jZScpLFxuICBzeW1tZXRyaWNEaWZmZXJlbmNlV2l0aDogcmVxdWlyZSgnLi9zcmMvc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgnKSxcbiAgdGFpbDogcmVxdWlyZSgnLi9zcmMvdGFpbCcpLFxuICB0YWtlOiByZXF1aXJlKCcuL3NyYy90YWtlJyksXG4gIHRha2VMYXN0OiByZXF1aXJlKCcuL3NyYy90YWtlTGFzdCcpLFxuICB0YWtlTGFzdFdoaWxlOiByZXF1aXJlKCcuL3NyYy90YWtlTGFzdFdoaWxlJyksXG4gIHRha2VXaGlsZTogcmVxdWlyZSgnLi9zcmMvdGFrZVdoaWxlJyksXG4gIHRhcDogcmVxdWlyZSgnLi9zcmMvdGFwJyksXG4gIHRlc3Q6IHJlcXVpcmUoJy4vc3JjL3Rlc3QnKSxcbiAgdGltZXM6IHJlcXVpcmUoJy4vc3JjL3RpbWVzJyksXG4gIHRvTG93ZXI6IHJlcXVpcmUoJy4vc3JjL3RvTG93ZXInKSxcbiAgdG9QYWlyczogcmVxdWlyZSgnLi9zcmMvdG9QYWlycycpLFxuICB0b1BhaXJzSW46IHJlcXVpcmUoJy4vc3JjL3RvUGFpcnNJbicpLFxuICB0b1N0cmluZzogcmVxdWlyZSgnLi9zcmMvdG9TdHJpbmcnKSxcbiAgdG9VcHBlcjogcmVxdWlyZSgnLi9zcmMvdG9VcHBlcicpLFxuICB0cmFuc2R1Y2U6IHJlcXVpcmUoJy4vc3JjL3RyYW5zZHVjZScpLFxuICB0cmFuc3Bvc2U6IHJlcXVpcmUoJy4vc3JjL3RyYW5zcG9zZScpLFxuICB0cmF2ZXJzZTogcmVxdWlyZSgnLi9zcmMvdHJhdmVyc2UnKSxcbiAgdHJpbTogcmVxdWlyZSgnLi9zcmMvdHJpbScpLFxuICB0cnlDYXRjaDogcmVxdWlyZSgnLi9zcmMvdHJ5Q2F0Y2gnKSxcbiAgdHlwZTogcmVxdWlyZSgnLi9zcmMvdHlwZScpLFxuICB1bmFwcGx5OiByZXF1aXJlKCcuL3NyYy91bmFwcGx5JyksXG4gIHVuYXJ5OiByZXF1aXJlKCcuL3NyYy91bmFyeScpLFxuICB1bmN1cnJ5TjogcmVxdWlyZSgnLi9zcmMvdW5jdXJyeU4nKSxcbiAgdW5mb2xkOiByZXF1aXJlKCcuL3NyYy91bmZvbGQnKSxcbiAgdW5pb246IHJlcXVpcmUoJy4vc3JjL3VuaW9uJyksXG4gIHVuaW9uV2l0aDogcmVxdWlyZSgnLi9zcmMvdW5pb25XaXRoJyksXG4gIHVuaXE6IHJlcXVpcmUoJy4vc3JjL3VuaXEnKSxcbiAgdW5pcUJ5OiByZXF1aXJlKCcuL3NyYy91bmlxQnknKSxcbiAgdW5pcVdpdGg6IHJlcXVpcmUoJy4vc3JjL3VuaXFXaXRoJyksXG4gIHVubGVzczogcmVxdWlyZSgnLi9zcmMvdW5sZXNzJyksXG4gIHVubmVzdDogcmVxdWlyZSgnLi9zcmMvdW5uZXN0JyksXG4gIHVudGlsOiByZXF1aXJlKCcuL3NyYy91bnRpbCcpLFxuICB1cGRhdGU6IHJlcXVpcmUoJy4vc3JjL3VwZGF0ZScpLFxuICB1c2VXaXRoOiByZXF1aXJlKCcuL3NyYy91c2VXaXRoJyksXG4gIHZhbHVlczogcmVxdWlyZSgnLi9zcmMvdmFsdWVzJyksXG4gIHZhbHVlc0luOiByZXF1aXJlKCcuL3NyYy92YWx1ZXNJbicpLFxuICB2aWV3OiByZXF1aXJlKCcuL3NyYy92aWV3JyksXG4gIHdoZW46IHJlcXVpcmUoJy4vc3JjL3doZW4nKSxcbiAgd2hlcmU6IHJlcXVpcmUoJy4vc3JjL3doZXJlJyksXG4gIHdoZXJlRXE6IHJlcXVpcmUoJy4vc3JjL3doZXJlRXEnKSxcbiAgd2l0aG91dDogcmVxdWlyZSgnLi9zcmMvd2l0aG91dCcpLFxuICB4cHJvZDogcmVxdWlyZSgnLi9zcmMveHByb2QnKSxcbiAgemlwOiByZXF1aXJlKCcuL3NyYy96aXAnKSxcbiAgemlwT2JqOiByZXF1aXJlKCcuL3NyYy96aXBPYmonKSxcbiAgemlwV2l0aDogcmVxdWlyZSgnLi9zcmMvemlwV2l0aCcpXG59O1xuIiwidmFyIGFsd2F5cyA9IHJlcXVpcmUoJy4vYWx3YXlzJyk7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgYGZhbHNlYC4gQW55IHBhc3NlZCBpbiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5hbHdheXMsIFIuVFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuRigpOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYWx3YXlzKGZhbHNlKTtcbiIsInZhciBhbHdheXMgPSByZXF1aXJlKCcuL2Fsd2F5cycpO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGB0cnVlYC4gQW55IHBhc3NlZCBpbiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5hbHdheXMsIFIuRlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuVCgpOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhbHdheXModHJ1ZSk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSB1c2VkIHRvIHNwZWNpZnkgXCJnYXBzXCIgd2l0aGluIGN1cnJpZWQgZnVuY3Rpb25zLFxuICogYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mXG4gKiB0aGVpciBwb3NpdGlvbnMuXG4gKlxuICogSWYgYGdgIGlzIGEgY3VycmllZCB0ZXJuYXJ5IGZ1bmN0aW9uIGFuZCBgX2AgaXMgYFIuX19gLCB0aGUgZm9sbG93aW5nIGFyZVxuICogZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gKiAgIC0gYGcoXywgMiwgXykoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoMSkoMylgXG4gKiAgIC0gYGcoXywgMikoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gKlxuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdyZWV0ID0gUi5yZXBsYWNlKCd7bmFtZX0nLCBSLl9fLCAnSGVsbG8sIHtuYW1lfSEnKTtcbiAqICAgICAgZ3JlZXQoJ0FsaWNlJyk7IC8vPT4gJ0hlbGxvLCBBbGljZSEnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0geydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInOiB0cnVlfTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBBZGRzIHR3byB2YWx1ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIFIuc3VidHJhY3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFkZCgyLCAzKTsgICAgICAgLy89PiAgNVxuICogICAgICBSLmFkZCg3KSgxMCk7ICAgICAgLy89PiAxN1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIE51bWJlcihhKSArIE51bWJlcihiKTtcbn0pO1xuIiwidmFyIF9jb25jYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb25jYXQnKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBpdGVyYXRpb24gZnVuY3Rpb24gZnJvbSBhbiBleGlzdGluZyBvbmUgYnkgYWRkaW5nIHR3byBuZXdcbiAqIHBhcmFtZXRlcnMgdG8gaXRzIGNhbGxiYWNrIGZ1bmN0aW9uOiB0aGUgY3VycmVudCBpbmRleCwgYW5kIHRoZSBlbnRpcmUgbGlzdC5cbiAqXG4gKiBUaGlzIHdvdWxkIHR1cm4sIGZvciBpbnN0YW5jZSwgUmFtZGEncyBzaW1wbGUgYG1hcGAgZnVuY3Rpb24gaW50byBvbmUgdGhhdFxuICogbW9yZSBjbG9zZWx5IHJlc2VtYmxlcyBgQXJyYXkucHJvdG90eXBlLm1hcGAuIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrXG4gKiBmb3IgZnVuY3Rpb25zIGluIHdoaWNoIHRoZSBpdGVyYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGZpcnN0XG4gKiBwYXJhbWV0ZXIsIGFuZCB3aGVyZSB0aGUgbGlzdCBpcyB0aGUgbGFzdCBwYXJhbWV0ZXIuIChUaGlzIGxhdHRlciBtaWdodCBiZVxuICogdW5pbXBvcnRhbnQgaWYgdGhlIGxpc3QgcGFyYW1ldGVyIGlzIG5vdCB1c2VkLilcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSAuLi4gLT4gYikgLi4uIC0+IFthXSAtPiAqKSAtPiAoYSAuLi4sIEludCwgW2FdIC0+IGIpIC4uLiAtPiBbYV0gLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgbGlzdCBpdGVyYXRpb24gZnVuY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXNzIGluZGV4IG9yIGxpc3QgdG8gaXRzIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQW4gYWx0ZXJlZCBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiB0aGF0IHBhc3NlcyAoaXRlbSwgaW5kZXgsIGxpc3QpIHRvIGl0cyBjYWxsYmFja1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtYXBJbmRleGVkID0gUi5hZGRJbmRleChSLm1hcCk7XG4gKiAgICAgIG1hcEluZGV4ZWQoKHZhbCwgaWR4KSA9PiBpZHggKyAnLScgKyB2YWwsIFsnZicsICdvJywgJ28nLCAnYicsICdhJywgJ3InXSk7XG4gKiAgICAgIC8vPT4gWycwLWYnLCAnMS1vJywgJzItbycsICczLWInLCAnNC1hJywgJzUtciddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBhZGRJbmRleChmbikge1xuICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIG9yaWdGbiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGFyZ3NbMF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvcmlnRm4uYXBwbHkodGhpcywgX2NvbmNhdChhcmd1bWVudHMsIFtpZHgsIGxpc3RdKSk7XG4gICAgICBpZHggKz0gMTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gIH0pO1xufSk7XG4iLCJ2YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4IG9mIGFuIGFycmF5LCByZXR1cm5pbmcgYVxuICogbmV3IGNvcHkgb2YgdGhlIGFycmF5IHdpdGggdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHJlcGxhY2VkIHdpdGggdGhlXG4gKiByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IGEpIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gaWR4IFRoZSBpbmRleC5cbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBsaXN0IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHdob3NlIHZhbHVlXG4gKiAgICAgICAgYXQgdGhlIHN1cHBsaWVkIGluZGV4IHdpbGwgYmUgcmVwbGFjZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBjb3B5IG9mIHRoZSBzdXBwbGllZCBhcnJheS1saWtlIG9iamVjdCB3aXRoXG4gKiAgICAgICAgIHRoZSBlbGVtZW50IGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlXG4gKiAgICAgICAgIHJldHVybmVkIGJ5IGFwcGx5aW5nIGBmbmAgdG8gdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIFIudXBkYXRlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hZGp1c3QoUi5hZGQoMTApLCAxLCBbMSwgMiwgM10pOyAgICAgLy89PiBbMSwgMTIsIDNdXG4gKiAgICAgIFIuYWRqdXN0KFIuYWRkKDEwKSkoMSkoWzEsIDIsIDNdKTsgICAgIC8vPT4gWzEsIDEyLCAzXVxuICogQHN5bWIgUi5hZGp1c3QoZiwgLTEsIFthLCBiXSkgPSBbYSwgZihiKV1cbiAqIEBzeW1iIFIuYWRqdXN0KGYsIDAsIFthLCBiXSkgPSBbZihhKSwgYl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGFkanVzdChmbiwgaWR4LCBsaXN0KSB7XG4gIGlmIChpZHggPj0gbGlzdC5sZW5ndGggfHwgaWR4IDwgLWxpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gaWR4IDwgMCA/IGxpc3QubGVuZ3RoIDogMDtcbiAgdmFyIF9pZHggPSBzdGFydCArIGlkeDtcbiAgdmFyIF9saXN0ID0gX2NvbmNhdChsaXN0KTtcbiAgX2xpc3RbX2lkeF0gPSBmbihsaXN0W19pZHhdKTtcbiAgcmV0dXJuIF9saXN0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGFsbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hhbGwnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLCBgZmFsc2VgIGlmXG4gKiB0aGVyZSBhcmUgYW55IHRoYXQgZG9uJ3QuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFsbGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCBieSBldmVyeSBlbGVtZW50LCBgZmFsc2VgXG4gKiAgICAgICAgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbnksIFIubm9uZSwgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZXF1YWxzMyA9IFIuZXF1YWxzKDMpO1xuICogICAgICBSLmFsbChlcXVhbHMzKShbMywgMywgMywgM10pOyAvLz0+IHRydWVcbiAqICAgICAgUi5hbGwoZXF1YWxzMykoWzMsIDMsIDEsIDNdKTsgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbJ2FsbCddLCBfeGFsbCwgZnVuY3Rpb24gYWxsKGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoIWZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG52YXIgbWF4ID0gcmVxdWlyZSgnLi9tYXgnKTtcbnZhciBwbHVjayA9IHJlcXVpcmUoJy4vcGx1Y2snKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIHByZWRpY2F0ZXMgYW5kIHJldHVybnMgYSBwcmVkaWNhdGUgdGhhdCByZXR1cm5zIHRydWUgZm9yIGFcbiAqIGdpdmVuIGxpc3Qgb2YgYXJndW1lbnRzIGlmIGV2ZXJ5IG9uZSBvZiB0aGUgcHJvdmlkZWQgcHJlZGljYXRlcyBpcyBzYXRpc2ZpZWRcbiAqIGJ5IHRob3NlIGFyZ3VtZW50cy5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gcmV0dXJuZWQgaXMgYSBjdXJyaWVkIGZ1bmN0aW9uIHdob3NlIGFyaXR5IG1hdGNoZXMgdGhhdCBvZiB0aGVcbiAqIGhpZ2hlc3QtYXJpdHkgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIFsoKi4uLiAtPiBCb29sZWFuKV0gLT4gKCouLi4gLT4gQm9vbGVhbilcbiAqIEBwYXJhbSB7QXJyYXl9IHByZWRpY2F0ZXMgQW4gYXJyYXkgb2YgcHJlZGljYXRlcyB0byBjaGVja1xuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjb21iaW5lZCBwcmVkaWNhdGVcbiAqIEBzZWUgUi5hbnlQYXNzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzUXVlZW4gPSBSLnByb3BFcSgncmFuaycsICdRJyk7XG4gKiAgICAgIHZhciBpc1NwYWRlID0gUi5wcm9wRXEoJ3N1aXQnLCAn4pmg77iOJyk7XG4gKiAgICAgIHZhciBpc1F1ZWVuT2ZTcGFkZXMgPSBSLmFsbFBhc3MoW2lzUXVlZW4sIGlzU3BhZGVdKTtcbiAqXG4gKiAgICAgIGlzUXVlZW5PZlNwYWRlcyh7cmFuazogJ1EnLCBzdWl0OiAn4pmj77iOJ30pOyAvLz0+IGZhbHNlXG4gKiAgICAgIGlzUXVlZW5PZlNwYWRlcyh7cmFuazogJ1EnLCBzdWl0OiAn4pmg77iOJ30pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGFsbFBhc3MocHJlZHMpIHtcbiAgcmV0dXJuIGN1cnJ5TihyZWR1Y2UobWF4LCAwLCBwbHVjaygnbGVuZ3RoJywgcHJlZHMpKSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAoIXByZWRzW2lkeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIGdpdmVuIHZhbHVlLiBOb3RlIHRoYXQgZm9yXG4gKiBub24tcHJpbWl0aXZlcyB0aGUgdmFsdWUgcmV0dXJuZWQgaXMgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMga25vd24gYXMgYGNvbnN0YCwgYGNvbnN0YW50YCwgb3IgYEtgIChmb3IgSyBjb21iaW5hdG9yKSBpblxuICogb3RoZXIgbGFuZ3VhZ2VzIGFuZCBsaWJyYXJpZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBmdW5jdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IEEgRnVuY3Rpb24gOjogKiAtPiB2YWwuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHQgPSBSLmFsd2F5cygnVGVlJyk7XG4gKiAgICAgIHQoKTsgLy89PiAnVGVlJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gYWx3YXlzKHZhbCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgdHJ1ZWA7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHtBbnl9IGFcbiAqIEBwYXJhbSB7QW55fSBiXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCBpcyBmYWxzeSwgb3RoZXJ3aXNlIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKiBAc2VlIFIuYm90aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYW5kKHRydWUsIHRydWUpOyAvLz0+IHRydWVcbiAqICAgICAgUi5hbmQodHJ1ZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuYW5kKGZhbHNlLCB0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBSLmFuZChmYWxzZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBhbmQoYSwgYikge1xuICByZXR1cm4gYSAmJiBiO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGFueSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hhbnknKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBvZiBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLFxuICogYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFueWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCBieSBhdCBsZWFzdCBvbmUgZWxlbWVudCwgYGZhbHNlYFxuICogICAgICAgICBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYWxsLCBSLm5vbmUsIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGxlc3NUaGFuMCA9IFIuZmxpcChSLmx0KSgwKTtcbiAqICAgICAgdmFyIGxlc3NUaGFuMiA9IFIuZmxpcChSLmx0KSgyKTtcbiAqICAgICAgUi5hbnkobGVzc1RoYW4wKShbMSwgMl0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuYW55KGxlc3NUaGFuMikoWzEsIDJdKTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsnYW55J10sIF94YW55LCBmdW5jdGlvbiBhbnkoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSkpO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBjdXJyeU4gPSByZXF1aXJlKCcuL2N1cnJ5TicpO1xudmFyIG1heCA9IHJlcXVpcmUoJy4vbWF4Jyk7XG52YXIgcGx1Y2sgPSByZXF1aXJlKCcuL3BsdWNrJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvciBhXG4gKiBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXMgaXNcbiAqIHNhdGlzZmllZCBieSB0aG9zZSBhcmd1bWVudHMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gKiBoaWdoZXN0LWFyaXR5IHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBbKCouLi4gLT4gQm9vbGVhbildIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0FycmF5fSBwcmVkaWNhdGVzIEFuIGFycmF5IG9mIHByZWRpY2F0ZXMgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY29tYmluZWQgcHJlZGljYXRlXG4gKiBAc2VlIFIuYWxsUGFzc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc0NsdWIgPSBSLnByb3BFcSgnc3VpdCcsICfimaMnKTtcbiAqICAgICAgdmFyIGlzU3BhZGUgPSBSLnByb3BFcSgnc3VpdCcsICfimaAnKTtcbiAqICAgICAgdmFyIGlzQmxhY2tDYXJkID0gUi5hbnlQYXNzKFtpc0NsdWIsIGlzU3BhZGVdKTtcbiAqXG4gKiAgICAgIGlzQmxhY2tDYXJkKHtyYW5rOiAnMTAnLCBzdWl0OiAn4pmjJ30pOyAvLz0+IHRydWVcbiAqICAgICAgaXNCbGFja0NhcmQoe3Jhbms6ICdRJywgc3VpdDogJ+KZoCd9KTsgLy89PiB0cnVlXG4gKiAgICAgIGlzQmxhY2tDYXJkKHtyYW5rOiAnUScsIHN1aXQ6ICfimaYnfSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGFueVBhc3MocHJlZHMpIHtcbiAgcmV0dXJuIGN1cnJ5TihyZWR1Y2UobWF4LCAwLCBwbHVjaygnbGVuZ3RoJywgcHJlZHMpKSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAocHJlZHNbaWR4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59KTtcbiIsInZhciBfY29uY2F0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29uY2F0Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG5cbi8qKlxuICogYXAgYXBwbGllcyBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGEgbGlzdCBvZiB2YWx1ZXMuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFwYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC4gQWxzb1xuICogdHJlYXRzIGN1cnJpZWQgZnVuY3Rpb25zIGFzIGFwcGxpY2F0aXZlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBbYSAtPiBiXSAtPiBbYV0gLT4gW2JdXG4gKiBAc2lnIEFwcGx5IGYgPT4gZiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gKiBAcGFyYW0ge0FycmF5fSBmbnMgQW4gYXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fSB2cyBBbiBhcnJheSBvZiB2YWx1ZXNcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiByZXN1bHRzIG9mIGFwcGx5aW5nIGVhY2ggb2YgYGZuc2AgdG8gYWxsIG9mIGB2c2AgaW4gdHVybi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFwKFtSLm11bHRpcGx5KDIpLCBSLmFkZCgzKV0sIFsxLDIsM10pOyAvLz0+IFsyLCA0LCA2LCA0LCA1LCA2XVxuICogICAgICBSLmFwKFtSLmNvbmNhdCgndGFzdHkgJyksIFIudG9VcHBlcl0sIFsncGl6emEnLCAnc2FsYWQnXSk7IC8vPT4gW1widGFzdHkgcGl6emFcIiwgXCJ0YXN0eSBzYWxhZFwiLCBcIlBJWlpBXCIsIFwiU0FMQURcIl1cbiAqIEBzeW1iIFIuYXAoW2YsIGddLCBbYSwgYl0pID0gW2YoYSksIGYoYiksIGcoYSksIGcoYildXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBhcChhcHBsaWNhdGl2ZSwgZm4pIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgYXBwbGljYXRpdmUuYXAgPT09ICdmdW5jdGlvbicgP1xuICAgICAgYXBwbGljYXRpdmUuYXAoZm4pIDpcbiAgICB0eXBlb2YgYXBwbGljYXRpdmUgPT09ICdmdW5jdGlvbicgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gYXBwbGljYXRpdmUoeCkoZm4oeCkpOyB9IDpcbiAgICAvLyBlbHNlXG4gICAgICBfcmVkdWNlKGZ1bmN0aW9uKGFjYywgZikgeyByZXR1cm4gX2NvbmNhdChhY2MsIG1hcChmLCBmbikpOyB9LCBbXSwgYXBwbGljYXRpdmUpXG4gICk7XG59KTtcbiIsInZhciBfYXBlcnR1cmUgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcGVydHVyZScpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX3hhcGVydHVyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hhcGVydHVyZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0LCBjb21wb3NlZCBvZiBuLXR1cGxlcyBvZiBjb25zZWN1dGl2ZSBlbGVtZW50cyBJZiBgbmAgaXNcbiAqIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBsaXN0LCBhbiBlbXB0eSBsaXN0IGlzIHJldHVybmVkLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFtbYV1dXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgdHVwbGVzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzcGxpdCBpbnRvIGBuYC1sZW5ndGggdHVwbGVzXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIHJlc3VsdGluZyBsaXN0IG9mIGBuYC1sZW5ndGggdHVwbGVzXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hcGVydHVyZSgyLCBbMSwgMiwgMywgNCwgNV0pOyAvLz0+IFtbMSwgMl0sIFsyLCAzXSwgWzMsIDRdLCBbNCwgNV1dXG4gKiAgICAgIFIuYXBlcnR1cmUoMywgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbWzEsIDIsIDNdLCBbMiwgMywgNF0sIFszLCA0LCA1XV1cbiAqICAgICAgUi5hcGVydHVyZSg3LCBbMSwgMiwgMywgNCwgNV0pOyAvLz0+IFtdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFtdLCBfeGFwZXJ0dXJlLCBfYXBlcnR1cmUpKTtcbiIsInZhciBfY29uY2F0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29uY2F0Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBmb2xsb3dlZCBieVxuICogdGhlIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0gZWwgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIG5ldyBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCBvZiBlbGVtZW50cyB0byBhZGQgYSBuZXcgaXRlbSB0by5cbiAqICAgICAgICBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgZWxlbWVudHMgb2YgdGhlIG9sZCBsaXN0IGZvbGxvd2VkIGJ5IGBlbGAuXG4gKiBAc2VlIFIucHJlcGVuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXBwZW5kKCd0ZXN0cycsIFsnd3JpdGUnLCAnbW9yZSddKTsgLy89PiBbJ3dyaXRlJywgJ21vcmUnLCAndGVzdHMnXVxuICogICAgICBSLmFwcGVuZCgndGVzdHMnLCBbXSk7IC8vPT4gWyd0ZXN0cyddXG4gKiAgICAgIFIuYXBwZW5kKFsndGVzdHMnXSwgWyd3cml0ZScsICdtb3JlJ10pOyAvLz0+IFsnd3JpdGUnLCAnbW9yZScsIFsndGVzdHMnXV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGFwcGVuZChlbCwgbGlzdCkge1xuICByZXR1cm4gX2NvbmNhdChsaXN0LCBbZWxdKTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIEFwcGxpZXMgZnVuY3Rpb24gYGZuYCB0byB0aGUgYXJndW1lbnQgbGlzdCBgYXJnc2AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICogY3JlYXRpbmcgYSBmaXhlZC1hcml0eSBmdW5jdGlvbiBmcm9tIGEgdmFyaWFkaWMgZnVuY3Rpb24uIGBmbmAgc2hvdWxkIGJlIGFcbiAqIGJvdW5kIGZ1bmN0aW9uIGlmIGNvbnRleHQgaXMgc2lnbmlmaWNhbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCouLi4gLT4gYSkgLT4gWypdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBhcmdzYFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGNhbGwgYGZuYCB3aXRoXG4gKiBAcmV0dXJuIHsqfSByZXN1bHQgVGhlIHJlc3VsdCwgZXF1aXZhbGVudCB0byBgZm4oLi4uYXJncylgXG4gKiBAc2VlIFIuY2FsbCwgUi51bmFwcGx5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bXMgPSBbMSwgMiwgMywgLTk5LCA0MiwgNiwgN107XG4gKiAgICAgIFIuYXBwbHkoTWF0aC5tYXgsIG51bXMpOyAvLz0+IDQyXG4gKiBAc3ltYiBSLmFwcGx5KGYsIFthLCBiLCBjXSkgPSBmKGEsIGIsIGMpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBhcHBseShmbiwgYXJncykge1xuICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuL2FwcGx5Jyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xudmFyIG1heCA9IHJlcXVpcmUoJy4vbWF4Jyk7XG52YXIgcGx1Y2sgPSByZXF1aXJlKCcuL3BsdWNrJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciB2YWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG5cbi8qKlxuICogR2l2ZW4gYSBzcGVjIG9iamVjdCByZWN1cnNpdmVseSBtYXBwaW5nIHByb3BlcnRpZXMgdG8gZnVuY3Rpb25zLCBjcmVhdGVzIGFcbiAqIGZ1bmN0aW9uIHByb2R1Y2luZyBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc3RydWN0dXJlLCBieSBtYXBwaW5nIGVhY2ggcHJvcGVydHlcbiAqIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyBpdHMgYXNzb2NpYXRlZCBmdW5jdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIHtrOiAoKGEsIGIsIC4uLiwgbSkgLT4gdil9IC0+ICgoYSwgYiwgLi4uLCBtKSAtPiB7azogdn0pXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlYyBhbiBvYmplY3QgcmVjdXJzaXZlbHkgbWFwcGluZyBwcm9wZXJ0aWVzIHRvIGZ1bmN0aW9ucyBmb3JcbiAqICAgICAgICBwcm9kdWNpbmcgdGhlIHZhbHVlcyBmb3IgdGhlc2UgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc3RydWN0dXJlXG4gKiBhcyBgc3BlYycsIHdpdGggZWFjaCBwcm9wZXJ0eSBzZXQgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5IGNhbGxpbmcgaXRzXG4gKiBhc3NvY2lhdGVkIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAqIEBzZWUgUi5jb252ZXJnZSwgUi5qdXh0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdldE1ldHJpY3MgPSBSLmFwcGx5U3BlYyh7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtOiBSLmFkZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWQ6IHsgbXVsOiBSLm11bHRpcGx5IH1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAqICAgICAgZ2V0TWV0cmljcygyLCA0KTsgLy8gPT4geyBzdW06IDYsIG5lc3RlZDogeyBtdWw6IDggfSB9XG4gKiBAc3ltYiBSLmFwcGx5U3BlYyh7IHg6IGYsIHk6IHsgejogZyB9IH0pKGEsIGIpID0geyB4OiBmKGEsIGIpLCB5OiB7IHo6IGcoYSwgYikgfSB9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBhcHBseVNwZWMoc3BlYykge1xuICBzcGVjID0gbWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHR5cGVvZiB2ID09ICdmdW5jdGlvbicgPyB2IDogYXBwbHlTcGVjKHYpOyB9LFxuICAgICAgICAgICAgIHNwZWMpO1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCB2YWx1ZXMoc3BlYykpKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcChmdW5jdGlvbihmKSB7IHJldHVybiBhcHBseShmLCBhcmdzKTsgfSwgc3BlYyk7XG4gICAgICAgICAgICAgICAgfSk7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBNYWtlcyBhbiBhc2NlbmRpbmcgY29tcGFyYXRvciBmdW5jdGlvbiBvdXQgb2YgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZVxuICogdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBgPGAgYW5kIGA+YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IE51bWJlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiBvZiBhcml0eSBvbmUgdGhhdCByZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgY29tcGFyZWRcbiAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3QgaXRlbSB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIGl0ZW0gdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGAtMWAgaWYgZm4oYSkgPCBmbihiKSwgYDFgIGlmIGZuKGIpIDwgZm4oYSksIG90aGVyd2lzZSBgMGBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYnlBZ2UgPSBSLmFzY2VuZChSLnByb3AoJ2FnZScpKTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtcbiAqICAgICAgICAvLyAuLi5cbiAqICAgICAgXTtcbiAqICAgICAgdmFyIHBlb3BsZUJ5WW91bmdlc3RGaXJzdCA9IFIuc29ydChieUFnZSwgcGVvcGxlKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGFzY2VuZChmbiwgYSwgYikge1xuICB2YXIgYWEgPSBmbihhKTtcbiAgdmFyIGJiID0gZm4oYik7XG4gIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIHNwZWNpZmllZFxuICogcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuIE5vdGUgdGhhdCB0aGlzIGNvcGllcyBhbmQgZmxhdHRlbnMgcHJvdG90eXBlXG4gKiBwcm9wZXJ0aWVzIG9udG8gdGhlIG5ldyBvYmplY3QgYXMgd2VsbC4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllcyBhcmVcbiAqIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFN0cmluZyAtPiBhIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIHNldFxuICogQHBhcmFtIHsqfSB2YWwgVGhlIG5ldyB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCBlcXVpdmFsZW50IHRvIHRoZSBvcmlnaW5hbCBleGNlcHQgZm9yIHRoZSBjaGFuZ2VkIHByb3BlcnR5LlxuICogQHNlZSBSLmRpc3NvY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXNzb2MoJ2MnLCAzLCB7YTogMSwgYjogMn0pOyAvLz0+IHthOiAxLCBiOiAyLCBjOiAzfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gYXNzb2MocHJvcCwgdmFsLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgfVxuICByZXN1bHRbcHJvcF0gPSB2YWw7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNBcnJheScpO1xudmFyIF9pc0ludGVnZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0ludGVnZXInKTtcbnZhciBhc3NvYyA9IHJlcXVpcmUoJy4vYXNzb2MnKTtcblxuXG4vKipcbiAqIE1ha2VzIGEgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QsIHNldHRpbmcgb3Igb3ZlcnJpZGluZyB0aGUgbm9kZXMgcmVxdWlyZWRcbiAqIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gcGF0aCwgYW5kIHBsYWNpbmcgdGhlIHNwZWNpZmljIHZhbHVlIGF0IHRoZSB0YWlsIGVuZCBvZlxuICogdGhhdCBwYXRoLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9udG8gdGhlXG4gKiBuZXcgb2JqZWN0IGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IGEgLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtBcnJheX0gcGF0aCB0aGUgcGF0aCB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBuZXcgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3QgZXF1aXZhbGVudCB0byB0aGUgb3JpZ2luYWwgZXhjZXB0IGFsb25nIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAqIEBzZWUgUi5kaXNzb2NQYXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCA0Miwge2E6IHtiOiB7YzogMH19fSk7IC8vPT4ge2E6IHtiOiB7YzogNDJ9fX1cbiAqXG4gKiAgICAgIC8vIEFueSBtaXNzaW5nIG9yIG5vbi1vYmplY3Qga2V5cyBpbiBwYXRoIHdpbGwgYmUgb3ZlcnJpZGRlblxuICogICAgICBSLmFzc29jUGF0aChbJ2EnLCAnYicsICdjJ10sIDQyLCB7YTogNX0pOyAvLz0+IHthOiB7Yjoge2M6IDQyfX19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBhc3NvY1BhdGgocGF0aCwgdmFsLCBvYmopIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YXIgaWR4ID0gcGF0aFswXTtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIHZhciBuZXh0T2JqID0gX2hhcyhpZHgsIG9iaikgPyBvYmpbaWR4XSA6IF9pc0ludGVnZXIocGF0aFsxXSkgPyBbXSA6IHt9O1xuICAgIHZhbCA9IGFzc29jUGF0aChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXRoLCAxKSwgdmFsLCBuZXh0T2JqKTtcbiAgfVxuICBpZiAoX2lzSW50ZWdlcihpZHgpICYmIF9pc0FycmF5KG9iaikpIHtcbiAgICB2YXIgYXJyID0gW10uY29uY2F0KG9iaik7XG4gICAgYXJyW2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzb2MoaWR4LCB2YWwsIG9iaik7XG4gIH1cbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBuQXJ5ID0gcmVxdWlyZSgnLi9uQXJ5Jyk7XG5cblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gKiBleGFjdGx5IDIgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBjKSAtPiAoYSwgYiAtPiBjKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gKiAgICAgICAgIGFyaXR5IDIuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHRha2VzVGhyZWVBcmdzID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICogICAgICAgIHJldHVybiBbYSwgYiwgY107XG4gKiAgICAgIH07XG4gKiAgICAgIHRha2VzVGhyZWVBcmdzLmxlbmd0aDsgLy89PiAzXG4gKiAgICAgIHRha2VzVGhyZWVBcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCAzXVxuICpcbiAqICAgICAgdmFyIHRha2VzVHdvQXJncyA9IFIuYmluYXJ5KHRha2VzVGhyZWVBcmdzKTtcbiAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gKiAgICAgIC8vIE9ubHkgMiBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIHVuZGVmaW5lZF1cbiAqIEBzeW1iIFIuYmluYXJ5KGYpKGEsIGIsIGMpID0gZihhLCBiKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gYmluYXJ5KGZuKSB7XG4gIHJldHVybiBuQXJ5KDIsIGZuKTtcbn0pO1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgYm91bmQgdG8gYSBjb250ZXh0LlxuICogTm90ZTogYFIuYmluZGAgZG9lcyBub3QgcHJvdmlkZSB0aGUgYWRkaXRpb25hbCBhcmd1bWVudC1iaW5kaW5nIGNhcGFiaWxpdGllcyBvZlxuICogW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKiAtPiAqKSAtPiB7Kn0gLT4gKCogLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzT2JqIFRoZSBjb250ZXh0IHRvIGJpbmQgYGZuYCB0b1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2YgYHRoaXNPYmpgLlxuICogQHNlZSBSLnBhcnRpYWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbG9nID0gUi5iaW5kKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAqICAgICAgUi5waXBlKFIuYXNzb2MoJ2EnLCAyKSwgUi50YXAobG9nKSwgUi5hc3NvYygnYScsIDMpKSh7YTogMX0pOyAvLz0+IHthOiAzfVxuICogICAgICAvLyBsb2dzIHthOiAyfVxuICogQHN5bWIgUi5iaW5kKGYsIG8pKGEsIGIpID0gZi5jYWxsKG8sIGEsIGIpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBiaW5kKGZuLCB0aGlzT2JqKSB7XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc09iaiwgYXJndW1lbnRzKTtcbiAgfSk7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2lzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0Z1bmN0aW9uJyk7XG52YXIgYW5kID0gcmVxdWlyZSgnLi9hbmQnKTtcbnZhciBsaWZ0ID0gcmVxdWlyZSgnLi9saWZ0Jyk7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIHRoZSB0d28gcHJvdmlkZWQgZnVuY3Rpb25zIGFuZCByZXR1cm5zIHRoZSBgJiZgXG4gKiBvZiB0aGUgcmVzdWx0cy5cbiAqIEl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QgZnVuY3Rpb24gaWYgaXQgaXMgZmFsc2UteSBhbmQgdGhlIHJlc3VsdFxuICogb2YgdGhlIHNlY29uZCBmdW5jdGlvbiBvdGhlcndpc2UuIE5vdGUgdGhhdCB0aGlzIGlzIHNob3J0LWNpcmN1aXRlZCxcbiAqIG1lYW5pbmcgdGhhdCB0aGUgc2Vjb25kIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgdGhlIGZpcnN0IHJldHVybnMgYVxuICogZmFsc2UteSB2YWx1ZS5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBmdW5jdGlvbnMsIGBSLmJvdGhgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAqIGFwcGxpY2F0aXZlIGZ1bmN0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIEEgcHJlZGljYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIEFub3RoZXIgcHJlZGljYXRlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgaXRzIGFyZ3VtZW50cyB0byBgZmAgYW5kIGBnYCBhbmQgYCYmYHMgdGhlaXIgb3V0cHV0cyB0b2dldGhlci5cbiAqIEBzZWUgUi5hbmRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZ3QxMCA9IFIuZ3QoUi5fXywgMTApXG4gKiAgICAgIHZhciBsdDIwID0gUi5sdChSLl9fLCAyMClcbiAqICAgICAgdmFyIGYgPSBSLmJvdGgoZ3QxMCwgbHQyMCk7XG4gKiAgICAgIGYoMTUpOyAvLz0+IHRydWVcbiAqICAgICAgZigzMCk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGJvdGgoZiwgZykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24oZikgP1xuICAgIGZ1bmN0aW9uIF9ib3RoKCkge1xuICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSA6XG4gICAgbGlmdChhbmQpKGYsIGcpO1xufSk7XG4iLCJ2YXIgY3VycnkgPSByZXF1aXJlKCcuL2N1cnJ5Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY2FsbGluZyBpdHMgZmlyc3QgYXJndW1lbnQgd2l0aCB0aGUgcmVtYWluaW5nXG4gKiBhcmd1bWVudHMuIFRoaXMgaXMgb2NjYXNpb25hbGx5IHVzZWZ1bCBhcyBhIGNvbnZlcmdpbmcgZnVuY3Rpb24gZm9yXG4gKiBgUi5jb252ZXJnZWA6IHRoZSBsZWZ0IGJyYW5jaCBjYW4gcHJvZHVjZSBhIGZ1bmN0aW9uIHdoaWxlIHRoZSByaWdodCBicmFuY2hcbiAqIHByb2R1Y2VzIGEgdmFsdWUgdG8gYmUgcGFzc2VkIHRvIHRoYXQgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCouLi4gLT4gYSksKi4uLiAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuYXBwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNhbGwoUi5hZGQsIDEsIDIpOyAvLz0+IDNcbiAqXG4gKiAgICAgIHZhciBpbmRlbnROID0gUi5waXBlKFIudGltZXMoUi5hbHdheXMoJyAnKSksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFIuam9pbignJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucmVwbGFjZSgvXig/ISQpL2dtKSk7XG4gKlxuICogICAgICB2YXIgZm9ybWF0ID0gUi5jb252ZXJnZShSLmNhbGwsIFtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucGlwZShSLnByb3AoJ2luZGVudCcpLCBpbmRlbnROKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucHJvcCgndmFsdWUnKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAqXG4gKiAgICAgIGZvcm1hdCh7aW5kZW50OiAyLCB2YWx1ZTogJ2Zvb1xcbmJhclxcbmJhelxcbid9KTsgLy89PiAnICBmb29cXG4gIGJhclxcbiAgYmF6XFxuJ1xuICogQHN5bWIgUi5jYWxsKGYsIGEsIGIpID0gZihhLCBiKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGN1cnJ5KGZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfbWFrZUZsYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19tYWtlRmxhdCcpO1xudmFyIF94Y2hhaW4gPSByZXF1aXJlKCcuL2ludGVybmFsL194Y2hhaW4nKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG5cbi8qKlxuICogYGNoYWluYCBtYXBzIGEgZnVuY3Rpb24gb3ZlciBhIGxpc3QgYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0cy4gYGNoYWluYFxuICogaXMgYWxzbyBrbm93biBhcyBgZmxhdE1hcGAgaW4gc29tZSBsaWJyYXJpZXNcbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgY2hhaW5gIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LFxuICogYWNjb3JkaW5nIHRvIHRoZSBbRmFudGFzeUxhbmQgQ2hhaW4gc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbikuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBDaGFpbiBtID0+IChhIC0+IG0gYikgLT4gbSBhIC0+IG0gYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcCB3aXRoXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIG1hcCBvdmVyXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIHJlc3VsdCBvZiBmbGF0LW1hcHBpbmcgYGxpc3RgIHdpdGggYGZuYFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkdXBsaWNhdGUgPSBuID0+IFtuLCBuXTtcbiAqICAgICAgUi5jaGFpbihkdXBsaWNhdGUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDEsIDIsIDIsIDMsIDNdXG4gKlxuICogICAgICBSLmNoYWluKFIuYXBwZW5kLCBSLmhlYWQpKFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDMsIDFdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsnY2hhaW4nXSwgX3hjaGFpbiwgZnVuY3Rpb24gY2hhaW4oZm4sIG1vbmFkKSB7XG4gIGlmICh0eXBlb2YgbW9uYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZm4obW9uYWQoeCkpKHgpOyB9O1xuICB9XG4gIHJldHVybiBfbWFrZUZsYXQoZmFsc2UpKG1hcChmbiwgbW9uYWQpKTtcbn0pKTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cbi8qKlxuICogUmVzdHJpY3RzIGEgbnVtYmVyIHRvIGJlIHdpdGhpbiBhIHJhbmdlLlxuICpcbiAqIEFsc28gd29ya3MgZm9yIG90aGVyIG9yZGVyZWQgdHlwZXMgc3VjaCBhcyBTdHJpbmdzIGFuZCBEYXRlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbmltdW0gVGhlIGxvd2VyIGxpbWl0IG9mIHRoZSBjbGFtcCAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW0gVGhlIHVwcGVyIGxpbWl0IG9mIHRoZSBjbGFtcCAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGJlIGNsYW1wZWRcbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyBgbWluaW11bWAgd2hlbiBgdmFsIDwgbWluaW11bWAsIGBtYXhpbXVtYCB3aGVuIGB2YWwgPiBtYXhpbXVtYCwgcmV0dXJucyBgdmFsYCBvdGhlcndpc2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNsYW1wKDEsIDEwLCAtNSkgLy8gPT4gMVxuICogICAgICBSLmNsYW1wKDEsIDEwLCAxNSkgLy8gPT4gMTBcbiAqICAgICAgUi5jbGFtcCgxLCAxMCwgNCkgIC8vID0+IDRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICBpZiAobWluID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaW4gbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBpbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpJyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDpcbiAgICAgICAgIHZhbHVlID4gbWF4ID8gbWF4IDpcbiAgICAgICAgIHZhbHVlO1xufSk7XG4iLCJ2YXIgX2Nsb25lID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY2xvbmUnKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSB2YWx1ZSB3aGljaCBtYXkgY29udGFpbiAobmVzdGVkKSBgQXJyYXlgcyBhbmRcbiAqIGBPYmplY3RgcywgYE51bWJlcmBzLCBgU3RyaW5nYHMsIGBCb29sZWFuYHMgYW5kIGBEYXRlYHMuIGBGdW5jdGlvbmBzIGFyZVxuICogYXNzaWduZWQgYnkgcmVmZXJlbmNlIHJhdGhlciB0aGFuIGNvcGllZFxuICpcbiAqIERpc3BhdGNoZXMgdG8gYSBgY2xvbmVgIG1ldGhvZCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7Kn0gLT4geyp9XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gY2xvbmVcbiAqIEByZXR1cm4geyp9IEEgZGVlcGx5IGNsb25lZCBjb3B5IG9mIGB2YWxgXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG9iamVjdHMgPSBbe30sIHt9LCB7fV07XG4gKiAgICAgIHZhciBvYmplY3RzQ2xvbmUgPSBSLmNsb25lKG9iamVjdHMpO1xuICogICAgICBvYmplY3RzID09PSBvYmplY3RzQ2xvbmU7IC8vPT4gZmFsc2VcbiAqICAgICAgb2JqZWN0c1swXSA9PT0gb2JqZWN0c0Nsb25lWzBdOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuY2xvbmUgPT09ICdmdW5jdGlvbicgP1xuICAgIHZhbHVlLmNsb25lKCkgOlxuICAgIF9jbG9uZSh2YWx1ZSwgW10sIFtdLCB0cnVlKTtcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIE1ha2VzIGEgY29tcGFyYXRvciBmdW5jdGlvbiBvdXQgb2YgYSBmdW5jdGlvbiB0aGF0IHJlcG9ydHMgd2hldGhlciB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKGEsIGIgLT4gQm9vbGVhbikgLT4gKGEsIGIgLT4gTnVtYmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvbiBvZiBhcml0eSB0d28gd2hpY2ggd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudFxuICogaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBGdW5jdGlvbiA6OiBhIC0+IGIgLT4gSW50IHRoYXQgcmV0dXJucyBgLTFgIGlmIGEgPCBiLCBgMWAgaWYgYiA8IGEsIG90aGVyd2lzZSBgMGBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYnlBZ2UgPSBSLmNvbXBhcmF0b3IoKGEsIGIpID0+IGEuYWdlIDwgYi5hZ2UpO1xuICogICAgICB2YXIgcGVvcGxlID0gW1xuICogICAgICAgIC8vIC4uLlxuICogICAgICBdO1xuICogICAgICB2YXIgcGVvcGxlQnlJbmNyZWFzaW5nQWdlID0gUi5zb3J0KGJ5QWdlLCBwZW9wbGUpO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gY29tcGFyYXRvcihwcmVkKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIHByZWQoYSwgYikgPyAtMSA6IHByZWQoYiwgYSkgPyAxIDogMDtcbiAgfTtcbn0pO1xuIiwidmFyIGxpZnQgPSByZXF1aXJlKCcuL2xpZnQnKTtcbnZhciBub3QgPSByZXF1aXJlKCcuL25vdCcpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBgZmAgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2Agc3VjaCB0aGF0IGlmIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuICogd2hlbiBgZmAgcmV0dXJucyBhIFwidHJ1dGh5XCIgdmFsdWUsIGBnYCByZXR1cm5zIGBmYWxzZWAgYW5kIHdoZW4gYGZgIHJldHVybnMgYSBcImZhbHN5XCIgdmFsdWUgYGdgIHJldHVybnMgYHRydWVgLlxuICpcbiAqIGBSLmNvbXBsZW1lbnRgIG1heSBiZSBhcHBsaWVkIHRvIGFueSBmdW5jdG9yXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5ub3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNOb3ROaWwgPSBSLmNvbXBsZW1lbnQoUi5pc05pbCk7XG4gKiAgICAgIGlzTmlsKG51bGwpOyAvLz0+IHRydWVcbiAqICAgICAgaXNOb3ROaWwobnVsbCk7IC8vPT4gZmFsc2VcbiAqICAgICAgaXNOaWwoNyk7IC8vPT4gZmFsc2VcbiAqICAgICAgaXNOb3ROaWwoNyk7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGxpZnQobm90KTtcbiIsInZhciBwaXBlID0gcmVxdWlyZSgnLi9waXBlJyk7XG52YXIgcmV2ZXJzZSA9IHJlcXVpcmUoJy4vcmV2ZXJzZScpO1xuXG5cbi8qKlxuICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIHJpZ2h0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZVxuICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGZ1bmN0aW9ucyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIGNvbXBvc2UgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHkgLT4geiksICh4IC0+IHkpLCAuLi4sIChvIC0+IHApLCAoKGEsIGIsIC4uLiwgbikgLT4gbykpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gLi4uZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGlwZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBjbGFzc3lHcmVldGluZyA9IChmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PiBcIlRoZSBuYW1lJ3MgXCIgKyBsYXN0TmFtZSArIFwiLCBcIiArIGZpcnN0TmFtZSArIFwiIFwiICsgbGFzdE5hbWVcbiAqICAgICAgdmFyIHllbGxHcmVldGluZyA9IFIuY29tcG9zZShSLnRvVXBwZXIsIGNsYXNzeUdyZWV0aW5nKTtcbiAqICAgICAgeWVsbEdyZWV0aW5nKCdKYW1lcycsICdCb25kJyk7IC8vPT4gXCJUSEUgTkFNRSdTIEJPTkQsIEpBTUVTIEJPTkRcIlxuICpcbiAqICAgICAgUi5jb21wb3NlKE1hdGguYWJzLCBSLmFkZCgxKSwgUi5tdWx0aXBseSgyKSkoLTQpIC8vPT4gN1xuICpcbiAqIEBzeW1iIFIuY29tcG9zZShmLCBnLCBoKShhLCBiKSA9IGYoZyhoKGEsIGIpKSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wb3NlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gcGlwZS5hcHBseSh0aGlzLCByZXZlcnNlKGFyZ3VtZW50cykpO1xufTtcbiIsInZhciBjaGFpbiA9IHJlcXVpcmUoJy4vY2hhaW4nKTtcbnZhciBjb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJpZ2h0LXRvLWxlZnQgS2xlaXNsaSBjb21wb3NpdGlvbiBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zLFxuICogZWFjaCBvZiB3aGljaCBtdXN0IHJldHVybiBhIHZhbHVlIG9mIGEgdHlwZSBzdXBwb3J0ZWQgYnkgW2BjaGFpbmBdKCNjaGFpbikuXG4gKlxuICogYFIuY29tcG9zZUsoaCwgZywgZilgIGlzIGVxdWl2YWxlbnQgdG8gYFIuY29tcG9zZShSLmNoYWluKGgpLCBSLmNoYWluKGcpLCBSLmNoYWluKGYpKWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIENoYWluIG0gPT4gKCh5IC0+IG0geiksICh4IC0+IG0geSksIC4uLiwgKGEgLT4gbSBiKSkgLT4gKGEgLT4gbSB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gLi4uZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGlwZUtcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAgLy8gIGdldCA6OiBTdHJpbmcgLT4gT2JqZWN0IC0+IE1heWJlICpcbiAqICAgICAgIHZhciBnZXQgPSBSLmN1cnJ5KChwcm9wTmFtZSwgb2JqKSA9PiBNYXliZShvYmpbcHJvcE5hbWVdKSlcbiAqXG4gKiAgICAgICAvLyAgZ2V0U3RhdGVDb2RlIDo6IE1heWJlIFN0cmluZyAtPiBNYXliZSBTdHJpbmdcbiAqICAgICAgIHZhciBnZXRTdGF0ZUNvZGUgPSBSLmNvbXBvc2VLKFxuICogICAgICAgICBSLmNvbXBvc2UoTWF5YmUub2YsIFIudG9VcHBlciksXG4gKiAgICAgICAgIGdldCgnc3RhdGUnKSxcbiAqICAgICAgICAgZ2V0KCdhZGRyZXNzJyksXG4gKiAgICAgICAgIGdldCgndXNlcicpLFxuICogICAgICAgKTtcbiAqICAgICAgIGdldFN0YXRlQ29kZSh7XCJ1c2VyXCI6e1wiYWRkcmVzc1wiOntcInN0YXRlXCI6XCJueVwifX19KTsgLy89PiBNYXliZS5KdXN0KFwiTllcIilcbiAqICAgICAgIGdldFN0YXRlQ29kZSh7fSk7IC8vPT4gTWF5YmUuTm90aGluZygpXG4gKiBAc3ltYiBSLmNvbXBvc2VLKGYsIGcsIGgpKGEpID0gUi5jaGFpbihmLCBSLmNoYWluKGcsIGgoYSkpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbXBvc2VLKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZUsgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cbiAgdmFyIGluaXQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICB2YXIgbGFzdCA9IGluaXQucG9wKCk7XG4gIHJldHVybiBjb21wb3NlKGNvbXBvc2UuYXBwbHkodGhpcywgbWFwKGNoYWluLCBpbml0KSksIGxhc3QpO1xufTtcbiIsInZhciBwaXBlUCA9IHJlcXVpcmUoJy4vcGlwZVAnKTtcbnZhciByZXZlcnNlID0gcmVxdWlyZSgnLi9yZXZlcnNlJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbnMuIFRoZSByaWdodG1vc3QgZnVuY3Rpb24gbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nXG4gKiBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCh5IC0+IFByb21pc2UgeiksICh4IC0+IFByb21pc2UgeSksIC4uLiwgKGEgLT4gUHJvbWlzZSBiKSkgLT4gKGEgLT4gUHJvbWlzZSB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGlwZVBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZGIgPSB7XG4gKiAgICAgICAgdXNlcnM6IHtcbiAqICAgICAgICAgIEpPRToge1xuICogICAgICAgICAgICBuYW1lOiAnSm9lJyxcbiAqICAgICAgICAgICAgZm9sbG93ZXJzOiBbJ1NURVZFJywgJ1NVWlknXVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfVxuICpcbiAqICAgICAgLy8gV2UnbGwgcHJldGVuZCB0byBkbyBhIGRiIGxvb2t1cCB3aGljaCByZXR1cm5zIGEgcHJvbWlzZVxuICogICAgICB2YXIgbG9va3VwVXNlciA9ICh1c2VySWQpID0+IFByb21pc2UucmVzb2x2ZShkYi51c2Vyc1t1c2VySWRdKVxuICogICAgICB2YXIgbG9va3VwRm9sbG93ZXJzID0gKHVzZXIpID0+IFByb21pc2UucmVzb2x2ZSh1c2VyLmZvbGxvd2VycylcbiAqICAgICAgbG9va3VwVXNlcignSk9FJykudGhlbihsb29rdXBGb2xsb3dlcnMpXG4gKlxuICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcklkXVxuICogICAgICB2YXIgZm9sbG93ZXJzRm9yVXNlciA9IFIuY29tcG9zZVAobG9va3VwRm9sbG93ZXJzLCBsb29rdXBVc2VyKTtcbiAqICAgICAgZm9sbG93ZXJzRm9yVXNlcignSk9FJykudGhlbihmb2xsb3dlcnMgPT4gY29uc29sZS5sb2coJ0ZvbGxvd2VyczonLCBmb2xsb3dlcnMpKVxuICogICAgICAvLyBGb2xsb3dlcnM6IFtcIlNURVZFXCIsXCJTVVpZXCJdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcG9zZVAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb3NlUCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gcGlwZVAuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbn07XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNBcnJheScpO1xudmFyIF9pc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNGdW5jdGlvbicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxpc3RzIG9yIHN0cmluZ3MuXG4gKlxuICogTm90ZTogYFIuY29uY2F0YCBleHBlY3RzIGJvdGggYXJndW1lbnRzIHRvIGJlIG9mIHRoZSBzYW1lIHR5cGUsXG4gKiB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kLiBJdCB3aWxsIHRocm93XG4gKiBhbiBlcnJvciBpZiB5b3UgYGNvbmNhdGAgYW4gQXJyYXkgd2l0aCBhIG5vbi1BcnJheSB2YWx1ZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgY29uY2F0YCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBmaXJzdExpc3QgVGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBzZWNvbmRMaXN0IFRoZSBzZWNvbmQgbGlzdFxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfSBBIGxpc3QgY29uc2lzdGluZyBvZiB0aGUgZWxlbWVudHMgb2YgYGZpcnN0TGlzdGAgZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnRzIG9mXG4gKiBgc2Vjb25kTGlzdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuY29uY2F0KCdBQkMnLCAnREVGJyk7IC8vICdBQkNERUYnXG4gKiAgICAgIFIuY29uY2F0KFs0LCA1LCA2XSwgWzEsIDIsIDNdKTsgLy89PiBbNCwgNSwgNiwgMSwgMiwgM11cbiAqICAgICAgUi5jb25jYXQoW10sIFtdKTsgLy89PiBbXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCAhX2lzRnVuY3Rpb24oYS5jb25jYXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyhhKSArICcgZG9lcyBub3QgaGF2ZSBhIG1ldGhvZCBuYW1lZCBcImNvbmNhdFwiJyk7XG4gIH1cbiAgaWYgKF9pc0FycmF5KGEpICYmICFfaXNBcnJheShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodG9TdHJpbmcoYikgKyAnIGlzIG5vdCBhbiBhcnJheScpO1xuICB9XG4gIHJldHVybiBhLmNvbmNhdChiKTtcbn0pO1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgbWF4ID0gcmVxdWlyZSgnLi9tYXgnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCBgZm5gLCB3aGljaCBlbmNhcHN1bGF0ZXMgYGlmL2Vsc2UsIGlmL2Vsc2UsIC4uLmAgbG9naWMuXG4gKiBgUi5jb25kYCB0YWtlcyBhIGxpc3Qgb2YgW3ByZWRpY2F0ZSwgdHJhbnNmb3JtZXJdIHBhaXJzLiBBbGwgb2YgdGhlIGFyZ3VtZW50c1xuICogdG8gYGZuYCBhcmUgYXBwbGllZCB0byBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm4gdW50aWwgb25lIHJldHVybnMgYVxuICogXCJ0cnV0aHlcIiB2YWx1ZSwgYXQgd2hpY2ggcG9pbnQgYGZuYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgaXRzXG4gKiBhcmd1bWVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdHJhbnNmb3JtZXIuIElmIG5vbmUgb2YgdGhlIHByZWRpY2F0ZXNcbiAqIG1hdGNoZXMsIGBmbmAgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgW1soKi4uLiAtPiBCb29sZWFuKSwoKi4uLiAtPiAqKV1dIC0+ICgqLi4uIC0+ICopXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBIGxpc3Qgb2YgW3ByZWRpY2F0ZSwgdHJhbnNmb3JtZXJdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZm4gPSBSLmNvbmQoW1xuICogICAgICAgIFtSLmVxdWFscygwKSwgICBSLmFsd2F5cygnd2F0ZXIgZnJlZXplcyBhdCAwwrBDJyldLFxuICogICAgICAgIFtSLmVxdWFscygxMDApLCBSLmFsd2F5cygnd2F0ZXIgYm9pbHMgYXQgMTAwwrBDJyldLFxuICogICAgICAgIFtSLlQsICAgICAgICAgICB0ZW1wID0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCAnICsgdGVtcCArICfCsEMnXVxuICogICAgICBdKTtcbiAqICAgICAgZm4oMCk7IC8vPT4gJ3dhdGVyIGZyZWV6ZXMgYXQgMMKwQydcbiAqICAgICAgZm4oNTApOyAvLz0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCA1MMKwQydcbiAqICAgICAgZm4oMTAwKTsgLy89PiAnd2F0ZXIgYm9pbHMgYXQgMTAwwrBDJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gY29uZChwYWlycykge1xuICB2YXIgYXJpdHkgPSByZWR1Y2UobWF4LFxuICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgIG1hcChmdW5jdGlvbihwYWlyKSB7IHJldHVybiBwYWlyWzBdLmxlbmd0aDsgfSwgcGFpcnMpKTtcbiAgcmV0dXJuIF9hcml0eShhcml0eSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IHBhaXJzLmxlbmd0aCkge1xuICAgICAgaWYgKHBhaXJzW2lkeF1bMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gcGFpcnNbaWR4XVsxXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBjb25zdHJ1Y3ROID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3ROJyk7XG5cblxuLyoqXG4gKiBXcmFwcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGluc2lkZSBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkXG4gKiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgc2FtZSB0eXBlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSB3cmFwcGVkLCBjdXJyaWVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiAgICAgIGZ1bmN0aW9uIEFuaW1hbChraW5kKSB7XG4gKiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAqICAgICAgfTtcbiAqICAgICAgQW5pbWFsLnByb3RvdHlwZS5zaWdodGluZyA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiBcIkl0J3MgYSBcIiArIHRoaXMua2luZCArIFwiIVwiO1xuICogICAgICB9XG4gKlxuICogICAgICB2YXIgQW5pbWFsQ29uc3RydWN0b3IgPSBSLmNvbnN0cnVjdChBbmltYWwpXG4gKlxuICogICAgICAvLyBOb3RpY2Ugd2Ugbm8gbG9uZ2VyIG5lZWQgdGhlICduZXcnIGtleXdvcmQ6XG4gKiAgICAgIEFuaW1hbENvbnN0cnVjdG9yKCdQaWcnKTsgLy89PiB7XCJraW5kXCI6IFwiUGlnXCIsIFwic2lnaHRpbmdcIjogZnVuY3Rpb24gKCl7Li4ufX07XG4gKlxuICogICAgICB2YXIgYW5pbWFsVHlwZXMgPSBbXCJMaW9uXCIsIFwiVGlnZXJcIiwgXCJCZWFyXCJdO1xuICogICAgICB2YXIgYW5pbWFsU2lnaHRpbmcgPSBSLmludm9rZXIoMCwgJ3NpZ2h0aW5nJyk7XG4gKiAgICAgIHZhciBzaWdodE5ld0FuaW1hbCA9IFIuY29tcG9zZShhbmltYWxTaWdodGluZywgQW5pbWFsQ29uc3RydWN0b3IpO1xuICogICAgICBSLm1hcChzaWdodE5ld0FuaW1hbCwgYW5pbWFsVHlwZXMpOyAvLz0+IFtcIkl0J3MgYSBMaW9uIVwiLCBcIkl0J3MgYSBUaWdlciFcIiwgXCJJdCdzIGEgQmVhciFcIl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGNvbnN0cnVjdChGbikge1xuICByZXR1cm4gY29uc3RydWN0TihGbi5sZW5ndGgsIEZuKTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBjdXJyeSA9IHJlcXVpcmUoJy4vY3VycnknKTtcbnZhciBuQXJ5ID0gcmVxdWlyZSgnLi9uQXJ5Jyk7XG5cblxuLyoqXG4gKiBXcmFwcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGluc2lkZSBhIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkXG4gKiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgc2FtZSB0eXBlLiBUaGUgYXJpdHkgb2YgdGhlIGZ1bmN0aW9uXG4gKiByZXR1cm5lZCBpcyBzcGVjaWZpZWQgdG8gYWxsb3cgdXNpbmcgdmFyaWFkaWMgY29uc3RydWN0b3IgZnVuY3Rpb25zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKiAtPiB7Kn0pIC0+ICgqIC0+IHsqfSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBhcml0eSBvZiB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBGbiBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIHdyYXBwZWQsIGN1cnJpZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gVmFyaWFkaWMgQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAqICAgICAgZnVuY3Rpb24gU2FsYWQoKSB7XG4gKiAgICAgICAgdGhpcy5pbmdyZWRpZW50cyA9IGFyZ3VtZW50cztcbiAqICAgICAgfTtcbiAqICAgICAgU2FsYWQucHJvdG90eXBlLnJlY2lwZSA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHZhciBpbnN0cnVjdGlvbnMgPSBSLm1hcCgoaW5ncmVkaWVudCkgPT4gKFxuICogICAgICAgICAgJ0FkZCBhIHdob2xsb3Agb2YgJyArIGluZ3JlZGllbnQsIHRoaXMuaW5ncmVkaWVudHMpXG4gKiAgICAgICAgKVxuICogICAgICAgIHJldHVybiBSLmpvaW4oJ1xcbicsIGluc3RydWN0aW9ucylcbiAqICAgICAgfVxuICpcbiAqICAgICAgdmFyIFRocmVlTGF5ZXJTYWxhZCA9IFIuY29uc3RydWN0TigzLCBTYWxhZClcbiAqXG4gKiAgICAgIC8vIE5vdGljZSB3ZSBubyBsb25nZXIgbmVlZCB0aGUgJ25ldycga2V5d29yZCwgYW5kIHRoZSBjb25zdHJ1Y3RvciBpcyBjdXJyaWVkIGZvciAzIGFyZ3VtZW50cy5cbiAqICAgICAgdmFyIHNhbGFkID0gVGhyZWVMYXllclNhbGFkKCdNYXlvbm5haXNlJykoJ1BvdGF0byBDaGlwcycpKCdLZXRjaHVwJylcbiAqICAgICAgY29uc29sZS5sb2coc2FsYWQucmVjaXBlKCkpO1xuICogICAgICAvLyBBZGQgYSB3aG9sbG9wIG9mIE1heW9ubmFpc2VcbiAqICAgICAgLy8gQWRkIGEgd2hvbGxvcCBvZiBQb3RhdG8gQ2hpcHNcbiAqICAgICAgLy8gQWRkIGEgd2hvbGxvcCBvZiBQb3RhdG8gS2V0Y2h1cFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gY29uc3RydWN0TihuLCBGbikge1xuICBpZiAobiA+IDEwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RvciB3aXRoIGdyZWF0ZXIgdGhhbiB0ZW4gYXJndW1lbnRzJyk7XG4gIH1cbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRm4oKTsgfTtcbiAgfVxuICByZXR1cm4gY3VycnkobkFyeShuLCBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAgMTogcmV0dXJuIG5ldyBGbigkMCk7XG4gICAgICBjYXNlICAyOiByZXR1cm4gbmV3IEZuKCQwLCAkMSk7XG4gICAgICBjYXNlICAzOiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIpO1xuICAgICAgY2FzZSAgNDogcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMyk7XG4gICAgICBjYXNlICA1OiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCk7XG4gICAgICBjYXNlICA2OiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUpO1xuICAgICAgY2FzZSAgNzogcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNik7XG4gICAgICBjYXNlICA4OiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNyk7XG4gICAgICBjYXNlICA5OiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgpO1xuICAgICAgY2FzZSAxMDogcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSk7XG4gICAgfVxuICB9KSk7XG59KTtcbiIsInZhciBfY29udGFpbnMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb250YWlucycpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgZXF1YWwsIGluIGBSLmVxdWFsc2AgdGVybXMsIHRvIGF0XG4gKiBsZWFzdCBvbmUgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgaXRlbSB0byBjb21wYXJlIGFnYWluc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBhbiBlcXVpdmFsZW50IGl0ZW0gaXMgaW4gdGhlIGxpc3QsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQHNlZSBSLmFueVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuY29udGFpbnMoMywgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuY29udGFpbnMoNCwgWzEsIDIsIDNdKTsgLy89PiBmYWxzZVxuICogICAgICBSLmNvbnRhaW5zKHsgbmFtZTogJ0ZyZWQnIH0sIFt7IG5hbWU6ICdGcmVkJyB9XSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmNvbnRhaW5zKFs0Ml0sIFtbNDJdXSk7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2NvbnRhaW5zKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX21hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX21hcCcpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG52YXIgbWF4ID0gcmVxdWlyZSgnLi9tYXgnKTtcbnZhciBwbHVjayA9IHJlcXVpcmUoJy4vcGx1Y2snKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuXG5cbi8qKlxuICogQWNjZXB0cyBhIGNvbnZlcmdpbmcgZnVuY3Rpb24gYW5kIGEgbGlzdCBvZiBicmFuY2hpbmcgZnVuY3Rpb25zIGFuZCByZXR1cm5zXG4gKiBhIG5ldyBmdW5jdGlvbi4gV2hlbiBpbnZva2VkLCB0aGlzIG5ldyBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHNvbWVcbiAqIGFyZ3VtZW50cywgZWFjaCBicmFuY2hpbmcgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aG9zZSBzYW1lIGFyZ3VtZW50cy4gVGhlXG4gKiByZXN1bHRzIG9mIGVhY2ggYnJhbmNoaW5nIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIHRoZSBjb252ZXJnaW5nXG4gKiBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSByZXR1cm4gdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4yXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKHgxIC0+IHgyIC0+IC4uLiAtPiB6KSAtPiBbKGEgLT4gYiAtPiAuLi4gLT4geDEpLCAoYSAtPiBiIC0+IC4uLiAtPiB4MiksIC4uLl0gLT4gKGEgLT4gYiAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFmdGVyIEEgZnVuY3Rpb24uIGBhZnRlcmAgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIHJldHVybiB2YWx1ZXMgb2ZcbiAqICAgICAgICBgZm4xYCBhbmQgYGZuMmAgYXMgaXRzIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IGZ1bmN0aW9ucyBBIGxpc3Qgb2YgZnVuY3Rpb25zLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uLlxuICogQHNlZSBSLnVzZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYXZlcmFnZSA9IFIuY29udmVyZ2UoUi5kaXZpZGUsIFtSLnN1bSwgUi5sZW5ndGhdKVxuICogICAgICBhdmVyYWdlKFsxLCAyLCAzLCA0LCA1LCA2LCA3XSkgLy89PiA0XG4gKlxuICogICAgICB2YXIgc3RyYW5nZUNvbmNhdCA9IFIuY29udmVyZ2UoUi5jb25jYXQsIFtSLnRvVXBwZXIsIFIudG9Mb3dlcl0pXG4gKiAgICAgIHN0cmFuZ2VDb25jYXQoXCJZb2RlbFwiKSAvLz0+IFwiWU9ERUx5b2RlbFwiXG4gKlxuICogQHN5bWIgUi5jb252ZXJnZShmLCBbZywgaF0pKGEsIGIpID0gZihnKGEsIGIpLCBoKGEsIGIpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gY29udmVyZ2UoYWZ0ZXIsIGZucykge1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCBmbnMpKSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgIHJldHVybiBhZnRlci5hcHBseShjb250ZXh0LCBfbWFwKGZ1bmN0aW9uKGZuKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSwgZm5zKSk7XG4gIH0pO1xufSk7XG4iLCJ2YXIgcmVkdWNlQnkgPSByZXF1aXJlKCcuL3JlZHVjZUJ5Jyk7XG5cblxuLyoqXG4gKiBDb3VudHMgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdCBhY2NvcmRpbmcgdG8gaG93IG1hbnkgbWF0Y2ggZWFjaCB2YWx1ZSBvZiBhXG4gKiBrZXkgZ2VuZXJhdGVkIGJ5IHRoZSBzdXBwbGllZCBmdW5jdGlvbi4gUmV0dXJucyBhbiBvYmplY3QgbWFwcGluZyB0aGUga2V5c1xuICogcHJvZHVjZWQgYnkgYGZuYCB0byB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIGluIHRoZSBsaXN0LiBOb3RlIHRoYXQgYWxsXG4gKiBrZXlzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgYmVjYXVzZSBvZiBob3cgSmF2YVNjcmlwdCBvYmplY3RzIHdvcmsuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW2FdIC0+IHsqfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gbWFwIHZhbHVlcyB0byBrZXlzLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBjb3VudCBlbGVtZW50cyBmcm9tLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgbWFwcGluZyBrZXlzIHRvIG51bWJlciBvZiBvY2N1cnJlbmNlcyBpbiB0aGUgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbnVtYmVycyA9IFsxLjAsIDEuMSwgMS4yLCAyLjAsIDMuMCwgMi4yXTtcbiAqICAgICAgUi5jb3VudEJ5KE1hdGguZmxvb3IpKG51bWJlcnMpOyAgICAvLz0+IHsnMSc6IDMsICcyJzogMiwgJzMnOiAxfVxuICpcbiAqICAgICAgdmFyIGxldHRlcnMgPSBbJ2EnLCAnYicsICdBJywgJ2EnLCAnQicsICdjJ107XG4gKiAgICAgIFIuY291bnRCeShSLnRvTG93ZXIpKGxldHRlcnMpOyAgIC8vPT4geydhJzogMywgJ2InOiAyLCAnYyc6IDF9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlQnkoZnVuY3Rpb24oYWNjLCBlbGVtKSB7IHJldHVybiBhY2MgKyAxOyB9LCAwKTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGUgY3VycmllZCBmdW5jdGlvblxuICogaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0cyBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmVcbiAqIGF0IGEgdGltZS4gSWYgYGZgIGlzIGEgdGVybmFyeSBmdW5jdGlvbiBhbmQgYGdgIGlzIGBSLmN1cnJ5KGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBgUi5fX2AsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5TlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhZGRGb3VyTnVtYmVycyA9IChhLCBiLCBjLCBkKSA9PiBhICsgYiArIGMgKyBkO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnkoYWRkRm91ck51bWJlcnMpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBjdXJyeShmbikge1xuICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZm4pO1xufSk7XG4iLCJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fYXJpdHknKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9jdXJyeU4gPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeU4nKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIGFyaXR5LiBUaGUgY3VycmllZCBmdW5jdGlvbiBoYXMgdHdvIHVudXN1YWwgY2FwYWJpbGl0aWVzLiBGaXJzdCwgaXRzXG4gKiBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmUgYXQgYSB0aW1lLiBJZiBgZ2AgaXMgYFIuY3VycnlOKDMsIGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBgUi5fX2AsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC41LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IGZvciB0aGUgcmV0dXJuZWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcsIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY3VycnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgc3VtQXJncyA9ICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKTtcbiAqXG4gKiAgICAgIHZhciBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5Tig0LCBzdW1BcmdzKTtcbiAqICAgICAgdmFyIGYgPSBjdXJyaWVkQWRkRm91ck51bWJlcnMoMSwgMik7XG4gKiAgICAgIHZhciBnID0gZigzKTtcbiAqICAgICAgZyg0KTsgLy89PiAxMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gY3VycnlOKGxlbmd0aCwgZm4pIHtcbiAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBfY3VycnkxKGZuKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGxlbmd0aCwgX2N1cnJ5TihsZW5ndGgsIFtdLCBmbikpO1xufSk7XG4iLCJ2YXIgYWRkID0gcmVxdWlyZSgnLi9hZGQnKTtcblxuXG4vKipcbiAqIERlY3JlbWVudHMgaXRzIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn0gbiAtIDFcbiAqIEBzZWUgUi5pbmNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRlYyg0Mik7IC8vPT4gNDFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhZGQoLTEpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlY29uZCBhcmd1bWVudCBpZiBpdCBpcyBub3QgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYFxuICogb3RoZXJ3aXNlIHRoZSBmaXJzdCBhcmd1bWVudCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgYSAtPiBiIC0+IGEgfCBiXG4gKiBAcGFyYW0ge2F9IGRlZmF1bHQgVGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge2J9IHZhbCBgdmFsYCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYGRlZmF1bHRgIHVubGVzcyBgdmFsYCBpcyBgbnVsbGAsIGB1bmRlZmluZWRgIG9yIGBOYU5gLlxuICogQHJldHVybiB7Kn0gVGhlIHNlY29uZCB2YWx1ZSBpZiBpdCBpcyBub3QgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYCwgb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IHZhbHVlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRlZmF1bHRUbzQyID0gUi5kZWZhdWx0VG8oNDIpO1xuICpcbiAqICAgICAgZGVmYXVsdFRvNDIobnVsbCk7ICAvLz0+IDQyXG4gKiAgICAgIGRlZmF1bHRUbzQyKHVuZGVmaW5lZCk7ICAvLz0+IDQyXG4gKiAgICAgIGRlZmF1bHRUbzQyKCdSYW1kYScpOyAgLy89PiAnUmFtZGEnXG4gKiAgICAgIC8vIHBhcnNlSW50KCdzdHJpbmcnKSByZXN1bHRzIGluIE5hTlxuICogICAgICBkZWZhdWx0VG80MihwYXJzZUludCgnc3RyaW5nJykpOyAvLz0+IDQyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBkZWZhdWx0VG8oZCwgdikge1xuICByZXR1cm4gdiA9PSBudWxsIHx8IHYgIT09IHYgPyBkIDogdjtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIE1ha2VzIGEgZGVzY2VuZGluZyBjb21wYXJhdG9yIGZ1bmN0aW9uIG91dCBvZiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlXG4gKiB0aGF0IGNhbiBiZSBjb21wYXJlZCB3aXRoIGA8YCBhbmQgYD5gLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIzLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIG9mIGFyaXR5IG9uZSB0aGF0IHJldHVybnMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBjb21wYXJlZFxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBpdGVtIHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHsqfSBiIFRoZSBzZWNvbmQgaXRlbSB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge051bWJlcn0gYC0xYCBpZiBmbihhKSA+IGZuKGIpLCBgMWAgaWYgZm4oYikgPiBmbihhKSwgb3RoZXJ3aXNlIGAwYFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBieUFnZSA9IFIuZGVzY2VuZChSLnByb3AoJ2FnZScpKTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtcbiAqICAgICAgICAvLyAuLi5cbiAqICAgICAgXTtcbiAqICAgICAgdmFyIHBlb3BsZUJ5T2xkZXN0Rmlyc3QgPSBSLnNvcnQoYnlBZ2UsIHBlb3BsZSk7XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBkZXNjZW5kKGZuLCBhLCBiKSB7XG4gIHZhciBhYSA9IGZuKGEpO1xuICB2YXIgYmIgPSBmbihiKTtcbiAgcmV0dXJuIGFhID4gYmIgPyAtMSA6IGFhIDwgYmIgPyAxIDogMDtcbn0pO1xuIiwidmFyIF9jb250YWlucyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbnRhaW5zJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gKiBjb250YWluZWQgaW4gdGhlIHNlY29uZCBsaXN0LiBPYmplY3RzIGFuZCBBcnJheXMgYXJlIGNvbXBhcmVkIGFyZSBjb21wYXJlZFxuICogaW4gdGVybXMgb2YgdmFsdWUgZXF1YWxpdHksIG5vdCByZWZlcmVuY2UgZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIHRoYXQgYXJlIG5vdCBpbiBgbGlzdDJgLlxuICogQHNlZSBSLmRpZmZlcmVuY2VXaXRoLCBSLnN5bW1ldHJpY0RpZmZlcmVuY2UsIFIuc3ltbWV0cmljRGlmZmVyZW5jZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRpZmZlcmVuY2UoWzEsMiwzLDRdLCBbNyw2LDUsNCwzXSk7IC8vPT4gWzEsMl1cbiAqICAgICAgUi5kaWZmZXJlbmNlKFs3LDYsNSw0LDNdLCBbMSwyLDMsNF0pOyAvLz0+IFs3LDYsNV1cbiAqICAgICAgUi5kaWZmZXJlbmNlKFt7YTogMX0sIHtiOiAyfV0sIFt7YTogMX0sIHtjOiAzfV0pIC8vPT4gW3tiOiAyfV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGRpZmZlcmVuY2UoZmlyc3QsIHNlY29uZCkge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgZmlyc3RMZW4gPSBmaXJzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBmaXJzdExlbikge1xuICAgIGlmICghX2NvbnRhaW5zKGZpcnN0W2lkeF0sIHNlY29uZCkgJiYgIV9jb250YWlucyhmaXJzdFtpZHhdLCBvdXQpKSB7XG4gICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBmaXJzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4iLCJ2YXIgX2NvbnRhaW5zV2l0aCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbnRhaW5zV2l0aCcpO1xudmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBmaXJzdCBsaXN0IG5vdFxuICogY29udGFpbmVkIGluIHRoZSBzZWNvbmQgbGlzdC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlXG4gKiB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIHRoYXQgYXJlIG5vdCBpbiBgbGlzdDJgLlxuICogQHNlZSBSLmRpZmZlcmVuY2UsIFIuc3ltbWV0cmljRGlmZmVyZW5jZSwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBjbXAgPSAoeCwgeSkgPT4geC5hID09PSB5LmE7XG4gKiAgICAgIHZhciBsMSA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAqICAgICAgdmFyIGwyID0gW3thOiAzfSwge2E6IDR9XTtcbiAqICAgICAgUi5kaWZmZXJlbmNlV2l0aChjbXAsIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gZGlmZmVyZW5jZVdpdGgocHJlZCwgZmlyc3QsIHNlY29uZCkge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgZmlyc3RMZW4gPSBmaXJzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBmaXJzdExlbikge1xuICAgIGlmICghX2NvbnRhaW5zV2l0aChwcmVkLCBmaXJzdFtpZHhdLCBzZWNvbmQpICYmXG4gICAgICAgICFfY29udGFpbnNXaXRoKHByZWQsIGZpcnN0W2lkeF0sIG91dCkpIHtcbiAgICAgIG91dC5wdXNoKGZpcnN0W2lkeF0pO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgYHByb3BgIHByb3BlcnR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgU3RyaW5nIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBkaXNzb2NpYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGJ1dCB3aXRob3V0IHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqIEBzZWUgUi5hc3NvY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZGlzc29jKCdiJywge2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiB7YTogMSwgYzogM31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGRpc3NvYyhwcm9wLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgfVxuICBkZWxldGUgcmVzdWx0W3Byb3BdO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGFzc29jID0gcmVxdWlyZSgnLi9hc3NvYycpO1xudmFyIGRpc3NvYyA9IHJlcXVpcmUoJy4vZGlzc29jJyk7XG5cblxuLyoqXG4gKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBvbWl0dGluZyB0aGUgcHJvcGVydHkgYXQgdGhlIGdpdmVuIHBhdGguXG4gKiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9udG8gdGhlIG5ldyBvYmplY3RcbiAqIGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBbU3RyaW5nXSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB2YWx1ZSB0byBvbWl0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGhvdXQgdGhlIHByb3BlcnR5IGF0IHBhdGhcbiAqIEBzZWUgUi5hc3NvY1BhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRpc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCB7YToge2I6IHtjOiA0Mn19fSk7IC8vPT4ge2E6IHtiOiB7fX19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBkaXNzb2NQYXRoKHBhdGgsIG9iaikge1xuICBzd2l0Y2ggKHBhdGgubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIG9iajtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZGlzc29jKHBhdGhbMF0sIG9iaik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBoZWFkID0gcGF0aFswXTtcbiAgICAgIHZhciB0YWlsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocGF0aCwgMSk7XG4gICAgICByZXR1cm4gb2JqW2hlYWRdID09IG51bGwgPyBvYmogOiBhc3NvYyhoZWFkLCBkaXNzb2NQYXRoKHRhaWwsIG9ialtoZWFkXSksIG9iaik7XG4gIH1cbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIERpdmlkZXMgdHdvIG51bWJlcnMuIEVxdWl2YWxlbnQgdG8gYGEgLyBiYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhIC8gYmAuXG4gKiBAc2VlIFIubXVsdGlwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRpdmlkZSg3MSwgMTAwKTsgLy89PiAwLjcxXG4gKlxuICogICAgICB2YXIgaGFsZiA9IFIuZGl2aWRlKFIuX18sIDIpO1xuICogICAgICBoYWxmKDQyKTsgLy89PiAyMVxuICpcbiAqICAgICAgdmFyIHJlY2lwcm9jYWwgPSBSLmRpdmlkZSgxKTtcbiAqICAgICAgcmVjaXByb2NhbCg0KTsgICAvLz0+IDAuMjVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGRpdmlkZShhLCBiKSB7IHJldHVybiBhIC8gYjsgfSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGRyb3AgPSByZXF1aXJlKCcuL2ludGVybmFsL194ZHJvcCcpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhbGwgYnV0IHRoZSBmaXJzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QsIHN0cmluZywgb3JcbiAqIHRyYW5zZHVjZXIvdHJhbnNmb3JtZXIgKG9yIG9iamVjdCB3aXRoIGEgYGRyb3BgIG1ldGhvZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGRyb3BgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge1thXX0gbGlzdFxuICogQHJldHVybiB7W2FdfSBBIGNvcHkgb2YgbGlzdCB3aXRob3V0IHRoZSBmaXJzdCBgbmAgZWxlbWVudHNcbiAqIEBzZWUgUi50YWtlLCBSLnRyYW5zZHVjZSwgUi5kcm9wTGFzdCwgUi5kcm9wV2hpbGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRyb3AoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICogICAgICBSLmRyb3AoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JheiddXG4gKiAgICAgIFIuZHJvcCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gKiAgICAgIFIuZHJvcCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gKiAgICAgIFIuZHJvcCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdkYSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydkcm9wJ10sIF94ZHJvcCwgZnVuY3Rpb24gZHJvcChuLCB4cykge1xuICByZXR1cm4gc2xpY2UoTWF0aC5tYXgoMCwgbiksIEluZmluaXR5LCB4cyk7XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfZHJvcExhc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL19kcm9wTGFzdCcpO1xudmFyIF94ZHJvcExhc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL194ZHJvcExhc3QnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgYWxsIGJ1dCB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGBsaXN0YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBgbGlzdGAgdG8gc2tpcC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBjb3B5IG9mIHRoZSBsaXN0IHdpdGggb25seSB0aGUgZmlyc3QgYGxpc3QubGVuZ3RoIC0gbmAgZWxlbWVudHNcbiAqIEBzZWUgUi50YWtlTGFzdCwgUi5kcm9wLCBSLmRyb3BXaGlsZSwgUi5kcm9wTGFzdFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kcm9wTGFzdCgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKiAgICAgIFIuZHJvcExhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gKiAgICAgIFIuZHJvcExhc3QoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3BMYXN0KDQsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAqICAgICAgUi5kcm9wTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdyYSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoW10sIF94ZHJvcExhc3QsIF9kcm9wTGFzdCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX2Ryb3BMYXN0V2hpbGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kcm9wTGFzdFdoaWxlJyk7XG52YXIgX3hkcm9wTGFzdFdoaWxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGRyb3BMYXN0V2hpbGUnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBleGNsdWRpbmcgYWxsIHRoZSB0YWlsaW5nIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCB3aGljaFxuICogc2F0aXNmeSB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLiBJdCBwYXNzZXMgZWFjaCB2YWx1ZSBmcm9tIHRoZSByaWdodFxuICogdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgc2tpcHBpbmcgZWxlbWVudHMgdW50aWwgdGhlIHByZWRpY2F0ZVxuICogZnVuY3Rpb24gcmV0dXJucyBhIGBmYWxzeWAgdmFsdWUuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgYXBwbGllZCB0byBvbmUgYXJndW1lbnQ6XG4gKiAqKHZhbHVlKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZWFjaCBlbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheSB3aXRob3V0IGFueSB0cmFpbGluZyBlbGVtZW50cyB0aGF0IHJldHVybiBgZmFsc3lgIHZhbHVlcyBmcm9tIHRoZSBgcHJlZGljYXRlYC5cbiAqIEBzZWUgUi50YWtlTGFzdFdoaWxlLCBSLmFkZEluZGV4LCBSLmRyb3AsIFIuZHJvcFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGx0ZVRocmVlID0geCA9PiB4IDw9IDM7XG4gKlxuICogICAgICBSLmRyb3BMYXN0V2hpbGUobHRlVGhyZWUsIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzEsIDIsIDMsIDRdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFtdLCBfeGRyb3BMYXN0V2hpbGUsIF9kcm9wTGFzdFdoaWxlKSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGRyb3BSZXBlYXRzV2l0aCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hkcm9wUmVwZWF0c1dpdGgnKTtcbnZhciBkcm9wUmVwZWF0c1dpdGggPSByZXF1aXJlKCcuL2Ryb3BSZXBlYXRzV2l0aCcpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aG91dCBhbnkgY29uc2VjdXRpdmVseSByZXBlYXRpbmcgZWxlbWVudHMuIGBSLmVxdWFsc2BcbiAqIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBgbGlzdGAgd2l0aG91dCByZXBlYXRpbmcgZWxlbWVudHMuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBSLmRyb3BSZXBlYXRzKFsxLCAxLCAxLCAyLCAzLCA0LCA0LCAyLCAyXSk7IC8vPT4gWzEsIDIsIDMsIDQsIDJdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShfZGlzcGF0Y2hhYmxlKFtdLCBfeGRyb3BSZXBlYXRzV2l0aChlcXVhbHMpLCBkcm9wUmVwZWF0c1dpdGgoZXF1YWxzKSkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX3hkcm9wUmVwZWF0c1dpdGggPSByZXF1aXJlKCcuL2ludGVybmFsL194ZHJvcFJlcGVhdHNXaXRoJyk7XG52YXIgbGFzdCA9IHJlcXVpcmUoJy4vbGFzdCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgYW55IGNvbnNlY3V0aXZlbHkgcmVwZWF0aW5nIGVsZW1lbnRzLiBFcXVhbGl0eSBpc1xuICogZGV0ZXJtaW5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIGVhY2ggcGFpciBvZiBjb25zZWN1dGl2ZSBlbGVtZW50cy4gVGhlXG4gKiBmaXJzdCBlbGVtZW50IGluIGEgc2VyaWVzIG9mIGVxdWFsIGVsZW1lbnRzIHdpbGwgYmUgcHJlc2VydmVkLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSwgYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBgbGlzdGAgd2l0aG91dCByZXBlYXRpbmcgZWxlbWVudHMuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGwgPSBbMSwgLTEsIDEsIDMsIDQsIC00LCAtNCwgLTUsIDUsIDMsIDNdO1xuICogICAgICBSLmRyb3BSZXBlYXRzV2l0aChSLmVxQnkoTWF0aC5hYnMpLCBsKTsgLy89PiBbMSwgMywgNCwgLTUsIDNdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFtdLCBfeGRyb3BSZXBlYXRzV2l0aCwgZnVuY3Rpb24gZHJvcFJlcGVhdHNXaXRoKHByZWQsIGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaWR4ID0gMTtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuICE9PSAwKSB7XG4gICAgcmVzdWx0WzBdID0gbGlzdFswXTtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAoIXByZWQobGFzdChyZXN1bHQpLCBsaXN0W2lkeF0pKSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSkpO1xuXG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGRyb3BXaGlsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hkcm9wV2hpbGUnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBleGNsdWRpbmcgdGhlIGxlYWRpbmcgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0IHdoaWNoXG4gKiBzYXRpc2Z5IHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24uIEl0IHBhc3NlcyBlYWNoIHZhbHVlIHRvIHRoZSBzdXBwbGllZFxuICogcHJlZGljYXRlIGZ1bmN0aW9uLCBza2lwcGluZyBlbGVtZW50cyB3aGlsZSB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnNcbiAqIGB0cnVlYC4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wV2hpbGVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLnRha2VXaGlsZSwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbHRlVHdvID0geCA9PiB4IDw9IDI7XG4gKlxuICogICAgICBSLmRyb3BXaGlsZShsdGVUd28sIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzMsIDQsIDMsIDIsIDFdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsnZHJvcFdoaWxlJ10sIF94ZHJvcFdoaWxlLCBmdW5jdGlvbiBkcm9wV2hpbGUocHJlZCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuICYmIHByZWQobGlzdFtpZHhdKSkge1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgpO1xufSkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzRnVuY3Rpb24nKTtcbnZhciBsaWZ0ID0gcmVxdWlyZSgnLi9saWZ0Jyk7XG52YXIgb3IgPSByZXF1aXJlKCcuL29yJyk7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHdyYXBwaW5nIGNhbGxzIHRvIHRoZSB0d28gZnVuY3Rpb25zIGluIGFuIGB8fGAgb3BlcmF0aW9uLFxuICogcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0IGZ1bmN0aW9uIGlmIGl0IGlzIHRydXRoLXkgYW5kIHRoZSByZXN1bHRcbiAqIG9mIHRoZSBzZWNvbmQgZnVuY3Rpb24gb3RoZXJ3aXNlLiBOb3RlIHRoYXQgdGhpcyBpcyBzaG9ydC1jaXJjdWl0ZWQsXG4gKiBtZWFuaW5nIHRoYXQgdGhlIHNlY29uZCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBpbnZva2VkIGlmIHRoZSBmaXJzdCByZXR1cm5zIGFcbiAqIHRydXRoLXkgdmFsdWUuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gZnVuY3Rpb25zLCBgUi5laXRoZXJgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAqIGFwcGxpY2F0aXZlIGZ1bmN0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIGEgcHJlZGljYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIGFub3RoZXIgcHJlZGljYXRlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgaXRzIGFyZ3VtZW50cyB0byBgZmAgYW5kIGBnYCBhbmQgYHx8YHMgdGhlaXIgb3V0cHV0cyB0b2dldGhlci5cbiAqIEBzZWUgUi5vclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBndDEwID0geCA9PiB4ID4gMTA7XG4gKiAgICAgIHZhciBldmVuID0geCA9PiB4ICUgMiA9PT0gMDtcbiAqICAgICAgdmFyIGYgPSBSLmVpdGhlcihndDEwLCBldmVuKTtcbiAqICAgICAgZigxMDEpOyAvLz0+IHRydWVcbiAqICAgICAgZig4KTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBlaXRoZXIoZiwgZykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24oZikgP1xuICAgIGZ1bmN0aW9uIF9laXRoZXIoKSB7XG4gICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IDpcbiAgICBsaWZ0KG9yKShmLCBnKTtcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0FyZ3VtZW50cycpO1xudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNBcnJheScpO1xudmFyIF9pc09iamVjdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzT2JqZWN0Jyk7XG52YXIgX2lzU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNTdHJpbmcnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVtcHR5IHZhbHVlIG9mIGl0cyBhcmd1bWVudCdzIHR5cGUuIFJhbWRhIGRlZmluZXMgdGhlIGVtcHR5XG4gKiB2YWx1ZSBvZiBBcnJheSAoYFtdYCksIE9iamVjdCAoYHt9YCksIFN0cmluZyAoYCcnYCksIGFuZCBBcmd1bWVudHMuIE90aGVyXG4gKiB0eXBlcyBhcmUgc3VwcG9ydGVkIGlmIHRoZXkgZGVmaW5lIGA8VHlwZT4uZW1wdHlgIGFuZC9vclxuICogYDxUeXBlPi5wcm90b3R5cGUuZW1wdHlgLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBlbXB0eWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBhIC0+IGFcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmVtcHR5KEp1c3QoNDIpKTsgICAgICAvLz0+IE5vdGhpbmcoKVxuICogICAgICBSLmVtcHR5KFsxLCAyLCAzXSk7ICAgICAvLz0+IFtdXG4gKiAgICAgIFIuZW1wdHkoJ3VuaWNvcm5zJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi5lbXB0eSh7eDogMSwgeTogMn0pOyAgLy89PiB7fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gZW1wdHkoeCkge1xuICByZXR1cm4gKFxuICAgICh4ICE9IG51bGwgJiYgdHlwZW9mIHguZW1wdHkgPT09ICdmdW5jdGlvbicpID9cbiAgICAgIHguZW1wdHkoKSA6XG4gICAgKHggIT0gbnVsbCAmJiB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiYgdHlwZW9mIHguY29uc3RydWN0b3IuZW1wdHkgPT09ICdmdW5jdGlvbicpID9cbiAgICAgIHguY29uc3RydWN0b3IuZW1wdHkoKSA6XG4gICAgX2lzQXJyYXkoeCkgP1xuICAgICAgW10gOlxuICAgIF9pc1N0cmluZyh4KSA/XG4gICAgICAnJyA6XG4gICAgX2lzT2JqZWN0KHgpID9cbiAgICAgIHt9IDpcbiAgICBfaXNBcmd1bWVudHMoeCkgP1xuICAgICAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpIDpcbiAgICAvLyBlbHNlXG4gICAgICB2b2lkIDBcbiAgKTtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBlcXVhbHMgPSByZXF1aXJlKCcuL2VxdWFscycpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBhbmQgdHdvIHZhbHVlcyBpbiBpdHMgZG9tYWluIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVcbiAqIHZhbHVlcyBtYXAgdG8gdGhlIHNhbWUgdmFsdWUgaW4gdGhlIGNvZG9tYWluOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKGEgLT4gYikgLT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZXFCeShNYXRoLmFicywgNSwgLTUpOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGVxQnkoZiwgeCwgeSkge1xuICByZXR1cm4gZXF1YWxzKGYoeCksIGYoeSkpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG5cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgdHdvIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaW4gYFIuZXF1YWxzYCB0ZXJtcywgZm9yXG4gKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBVc2VmdWwgYXMgYSBjdXJyaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgayAtPiB7azogdn0gLT4ge2s6IHZ9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBvMSA9IHsgYTogMSwgYjogMiwgYzogMywgZDogNCB9O1xuICogICAgICB2YXIgbzIgPSB7IGE6IDEwLCBiOiAyMCwgYzogMywgZDogNDAgfTtcbiAqICAgICAgUi5lcVByb3BzKCdhJywgbzEsIG8yKTsgLy89PiBmYWxzZVxuICogICAgICBSLmVxUHJvcHMoJ2MnLCBvMSwgbzIpOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGVxUHJvcHMocHJvcCwgb2JqMSwgb2JqMikge1xuICByZXR1cm4gZXF1YWxzKG9iajFbcHJvcF0sIG9iajJbcHJvcF0pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9lcXVhbHMgPSByZXF1aXJlKCcuL2ludGVybmFsL19lcXVhbHMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIGVxdWl2YWxlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBIYW5kbGVzXG4gKiBjeWNsaWNhbCBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogRGlzcGF0Y2hlcyBzeW1tZXRyaWNhbGx5IHRvIHRoZSBgZXF1YWxzYCBtZXRob2RzIG9mIGJvdGggYXJndW1lbnRzLCBpZlxuICogcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgYSAtPiBiIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZXF1YWxzKDEsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5lcXVhbHMoMSwgJzEnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmVxdWFscyhbMSwgMiwgM10sIFsxLCAyLCAzXSk7IC8vPT4gdHJ1ZVxuICpcbiAqICAgICAgdmFyIGEgPSB7fTsgYS52ID0gYTtcbiAqICAgICAgdmFyIGIgPSB7fTsgYi52ID0gYjtcbiAqICAgICAgUi5lcXVhbHMoYSwgYik7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIF9lcXVhbHMoYSwgYiwgW10sIFtdKTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGJ5IHJlY3Vyc2l2ZWx5IGV2b2x2aW5nIGEgc2hhbGxvdyBjb3B5IG9mIGBvYmplY3RgLFxuICogYWNjb3JkaW5nIHRvIHRoZSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9ucy4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllc1xuICogYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgaXRzIGNvcnJlc3BvbmRpbmcga2V5XG4gKiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZXZvbHZlZCBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiAodiAtPiB2KX0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybWF0aW9ucyBUaGUgb2JqZWN0IHNwZWNpZnlpbmcgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGFwcGx5XG4gKiAgICAgICAgdG8gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSB0cmFuc2Zvcm1lZC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRyYW5zZm9ybWVkIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdG9tYXRvICA9IHtmaXJzdE5hbWU6ICcgIFRvbWF0byAnLCBkYXRhOiB7ZWxhcHNlZDogMTAwLCByZW1haW5pbmc6IDE0MDB9LCBpZDoxMjN9O1xuICogICAgICB2YXIgdHJhbnNmb3JtYXRpb25zID0ge1xuICogICAgICAgIGZpcnN0TmFtZTogUi50cmltLFxuICogICAgICAgIGxhc3ROYW1lOiBSLnRyaW0sIC8vIFdpbGwgbm90IGdldCBpbnZva2VkLlxuICogICAgICAgIGRhdGE6IHtlbGFwc2VkOiBSLmFkZCgxKSwgcmVtYWluaW5nOiBSLmFkZCgtMSl9XG4gKiAgICAgIH07XG4gKiAgICAgIFIuZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgdG9tYXRvKTsgLy89PiB7Zmlyc3ROYW1lOiAnVG9tYXRvJywgZGF0YToge2VsYXBzZWQ6IDEwMSwgcmVtYWluaW5nOiAxMzk5fSwgaWQ6MTIzfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgb2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIHRyYW5zZm9ybWF0aW9uLCBrZXksIHR5cGU7XG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb25zW2tleV07XG4gICAgdHlwZSA9IHR5cGVvZiB0cmFuc2Zvcm1hdGlvbjtcbiAgICByZXN1bHRba2V5XSA9IHR5cGUgPT09ICdmdW5jdGlvbicgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtYXRpb24ob2JqZWN0W2tleV0pXG4gICAgICAgICAgICAgICAgOiB0cmFuc2Zvcm1hdGlvbiAmJiB0eXBlID09PSAnb2JqZWN0JyA/IGV2b2x2ZSh0cmFuc2Zvcm1hdGlvbiwgb2JqZWN0W2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9iamVjdFtrZXldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL19maWx0ZXInKTtcbnZhciBfaXNPYmplY3QgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc09iamVjdCcpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBfeGZpbHRlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hmaWx0ZXInKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBcImZpbHRlcmFibGVcIiwgYW5kIHJldHVybnMgYSBuZXcgZmlsdGVyYWJsZSBvZiB0aGVcbiAqIHNhbWUgdHlwZSBjb250YWluaW5nIHRoZSBtZW1iZXJzIG9mIHRoZSBnaXZlbiBmaWx0ZXJhYmxlIHdoaWNoIHNhdGlzZnkgdGhlXG4gKiBnaXZlbiBwcmVkaWNhdGUuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbHRlcmAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmFibGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHNlZSBSLnJlamVjdCwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNFdmVuID0gbiA9PiBuICUgMiA9PT0gMDtcbiAqXG4gKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAqXG4gKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YjogMiwgZDogNH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydmaWx0ZXInXSwgX3hmaWx0ZXIsIGZ1bmN0aW9uKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIChcbiAgICBfaXNPYmplY3QoZmlsdGVyYWJsZSkgP1xuICAgICAgX3JlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgICBpZiAocHJlZChmaWx0ZXJhYmxlW2tleV0pKSB7XG4gICAgICAgICAgYWNjW2tleV0gPSBmaWx0ZXJhYmxlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzKGZpbHRlcmFibGUpKSA6XG4gICAgLy8gZWxzZVxuICAgICAgX2ZpbHRlcihwcmVkLCBmaWx0ZXJhYmxlKVxuICApO1xufSkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX3hmaW5kID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGZpbmQnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvclxuICogYHVuZGVmaW5lZGAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaW5kYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gYSB8IHVuZGVmaW5lZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAqICAgICAgICBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhzID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IHthOiAyfVxuICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IHVuZGVmaW5lZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbJ2ZpbmQnXSwgX3hmaW5kLCBmdW5jdGlvbiBmaW5kKGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbn0pKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94ZmluZEluZGV4ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGZpbmRJbmRleCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGVcbiAqIHByZWRpY2F0ZSwgb3IgYC0xYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAqIGRlc2lyZWQgb25lLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBmb3VuZCwgb3IgYC0xYC5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeHMgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfV07XG4gKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgMikpKHhzKTsgLy89PiAxXG4gKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbXSwgX3hmaW5kSW5kZXgsIGZ1bmN0aW9uIGZpbmRJbmRleChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiAtMTtcbn0pKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94ZmluZExhc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL194ZmluZExhc3QnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yXG4gKiBgdW5kZWZpbmVkYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IGEgfCB1bmRlZmluZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhzID0gW3thOiAxLCBiOiAwfSwge2E6MSwgYjogMX1dO1xuICogICAgICBSLmZpbmRMYXN0KFIucHJvcEVxKCdhJywgMSkpKHhzKTsgLy89PiB7YTogMSwgYjogMX1cbiAqICAgICAgUi5maW5kTGFzdChSLnByb3BFcSgnYScsIDQpKSh4cyk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFtdLCBfeGZpbmRMYXN0LCBmdW5jdGlvbiBmaW5kTGFzdChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4IC09IDE7XG4gIH1cbn0pKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94ZmluZExhc3RJbmRleCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hmaW5kTGFzdEluZGV4Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsaXN0IHdoaWNoIG1hdGNoZXMgdGhlXG4gKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZm91bmQsIG9yIGAtMWAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhzID0gW3thOiAxLCBiOiAwfSwge2E6MSwgYjogMX1dO1xuICogICAgICBSLmZpbmRMYXN0SW5kZXgoUi5wcm9wRXEoJ2EnLCAxKSkoeHMpOyAvLz0+IDFcbiAqICAgICAgUi5maW5kTGFzdEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbXSwgX3hmaW5kTGFzdEluZGV4LCBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gLTE7XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9tYWtlRmxhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX21ha2VGbGF0Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgYnkgcHVsbGluZyBldmVyeSBpdGVtIG91dCBvZiBpdCAoYW5kIGFsbCBpdHMgc3ViLWFycmF5cylcbiAqIGFuZCBwdXR0aW5nIHRoZW0gaW4gYSBuZXcgYXJyYXksIGRlcHRoLWZpcnN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFtiXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGZsYXR0ZW5lZCBsaXN0LlxuICogQHNlZSBSLnVubmVzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZmxhdHRlbihbMSwgMiwgWzMsIDRdLCA1LCBbNiwgWzcsIDgsIFs5LCBbMTAsIDExXSwgMTJdXV1dKTtcbiAqICAgICAgLy89PiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKF9tYWtlRmxhdCh0cnVlKSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGN1cnJ5ID0gcmVxdWlyZSgnLi9jdXJyeScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBtdWNoIGxpa2UgdGhlIHN1cHBsaWVkIG9uZSwgZXhjZXB0IHRoYXQgdGhlIGZpcnN0IHR3b1xuICogYXJndW1lbnRzJyBvcmRlciBpcyByZXZlcnNlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoYSAtPiBiIC0+IGMgLT4gLi4uIC0+IHopIC0+IChiIC0+IGEgLT4gYyAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMgcmV2ZXJzZWQuXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmVzdWx0IG9mIGludm9raW5nIGBmbmAgd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMnIG9yZGVyIHJldmVyc2VkLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtZXJnZVRocmVlID0gKGEsIGIsIGMpID0+IFtdLmNvbmNhdChhLCBiLCBjKTtcbiAqXG4gKiAgICAgIG1lcmdlVGhyZWUoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gKlxuICogICAgICBSLmZsaXAobWVyZ2VUaHJlZSkoMSwgMiwgMyk7IC8vPT4gWzIsIDEsIDNdXG4gKiBAc3ltYiBSLmZsaXAoZikoYSwgYiwgYykgPSBmKGIsIGEsIGMpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBmbGlwKGZuKSB7XG4gIHJldHVybiBjdXJyeShmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGFyZ3NbMF0gPSBiO1xuICAgIGFyZ3NbMV0gPSBhO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG59KTtcbiIsInZhciBfY2hlY2tGb3JNZXRob2QgPSByZXF1aXJlKCcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBpbnB1dCBgbGlzdGAsIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBgZm5gIGZvciBlYWNoXG4gKiBlbGVtZW50IGluIHRoZSBsaXN0LlxuICpcbiAqIGBmbmAgcmVjZWl2ZXMgb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gKlxuICogTm90ZTogYFIuZm9yRWFjaGAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZC4gRm9yIG1vcmVcbiAqIGRldGFpbHMgb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaCNEZXNjcmlwdGlvblxuICpcbiAqIEFsc28gbm90ZSB0aGF0LCB1bmxpa2UgYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCwgUmFtZGEncyBgZm9yRWFjaGAgcmV0dXJuc1xuICogdGhlIG9yaWdpbmFsIGFycmF5LiBJbiBzb21lIGxpYnJhcmllcyB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBlYWNoYC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZm9yRWFjaGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiAqKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLiBSZWNlaXZlcyBvbmUgYXJndW1lbnQsIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgb3JpZ2luYWwgbGlzdC5cbiAqIEBzZWUgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBwcmludFhQbHVzRml2ZSA9IHggPT4gY29uc29sZS5sb2coeCArIDUpO1xuICogICAgICBSLmZvckVhY2gocHJpbnRYUGx1c0ZpdmUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDNdXG4gKiAgICAgIC8vIGxvZ3MgNlxuICogICAgICAvLyBsb2dzIDdcbiAqICAgICAgLy8gbG9ncyA4XG4gKiBAc3ltYiBSLmZvckVhY2goZiwgW2EsIGIsIGNdKSA9IFthLCBiLCBjXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2NoZWNrRm9yTWV0aG9kKCdmb3JFYWNoJywgZnVuY3Rpb24gZm9yRWFjaChmbiwgbGlzdCkge1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgZm4obGlzdFtpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn0pKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIGlucHV0IGBvYmplY3RgLCBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gYGZuYCBmb3IgZWFjaFxuICoga2V5IGFuZCB2YWx1ZSBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIGBmbmAgcmVjZWl2ZXMgdGhyZWUgYXJndW1lbnQ6ICoodmFsdWUsIGtleSwgb2JqKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKGEsIFN0cmluZywgU3RyTWFwIGEpIC0+IEFueSkgLT4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuIFJlY2VpdmVzIHRocmVlIGFyZ3VtZW50LCBgdmFsdWVgLCBga2V5YCwgYG9iamAuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb3JpZ2luYWwgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBwcmludEtleUNvbmNhdFZhbHVlID0gKHZhbHVlLCBrZXkpID0+IGNvbnNvbGUubG9nKGtleSArICc6JyArIHZhbHVlKTtcbiAqICAgICAgUi5mb3JFYWNoT2JqSW5kZXhlZChwcmludEtleUNvbmNhdFZhbHVlLCB7eDogMSwgeTogMn0pOyAvLz0+IHt4OiAxLCB5OiAyfVxuICogICAgICAvLyBsb2dzIHg6MVxuICogICAgICAvLyBsb2dzIHk6MlxuICogQHN5bWIgUi5mb3JFYWNoT2JqSW5kZXhlZChmLCB7eDogYSwgeTogYn0pID0ge3g6IGEsIHk6IGJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBmb3JFYWNoT2JqSW5kZXhlZChmbiwgb2JqKSB7XG4gIHZhciBrZXlMaXN0ID0ga2V5cyhvYmopO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGtleUxpc3QubGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IGtleUxpc3RbaWR4XTtcbiAgICBmbihvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvYmo7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBmcm9tIGEgbGlzdCBrZXktdmFsdWUgcGFpcnMuIElmIGEga2V5IGFwcGVhcnMgaW5cbiAqIG11bHRpcGxlIHBhaXJzLCB0aGUgcmlnaHRtb3N0IHBhaXIgaXMgaW5jbHVkZWQgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFtbayx2XV0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiB0d28tZWxlbWVudCBhcnJheXMgdGhhdCB3aWxsIGJlIHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIGBrZXlzYCBhbmQgYHZhbHVlc2AuXG4gKiBAc2VlIFIudG9QYWlycywgUi5wYWlyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0W3BhaXJzW2lkeF1bMF1dID0gcGFpcnNbaWR4XVsxXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2NoZWNrRm9yTWV0aG9kID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgcmVkdWNlQnkgPSByZXF1aXJlKCcuL3JlZHVjZUJ5Jyk7XG5cbi8qKlxuICogU3BsaXRzIGEgbGlzdCBpbnRvIHN1Yi1saXN0cyBzdG9yZWQgaW4gYW4gb2JqZWN0LCBiYXNlZCBvbiB0aGUgcmVzdWx0IG9mXG4gKiBjYWxsaW5nIGEgU3RyaW5nLXJldHVybmluZyBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQsIGFuZCBncm91cGluZyB0aGVcbiAqIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHZhbHVlcyByZXR1cm5lZC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZ3JvdXBCeWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gU3RyaW5nKSAtPiBbYV0gLT4ge1N0cmluZzogW2FdfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gOjogYSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBvdXRwdXQgb2YgYGZuYCBmb3Iga2V5cywgbWFwcGVkIHRvIGFycmF5cyBvZiBlbGVtZW50c1xuICogICAgICAgICB0aGF0IHByb2R1Y2VkIHRoYXQga2V5IHdoZW4gcGFzc2VkIHRvIGBmbmAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGJ5R3JhZGUgPSBSLmdyb3VwQnkoZnVuY3Rpb24oc3R1ZGVudCkge1xuICogICAgICAgIHZhciBzY29yZSA9IHN0dWRlbnQuc2NvcmU7XG4gKiAgICAgICAgcmV0dXJuIHNjb3JlIDwgNjUgPyAnRicgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDcwID8gJ0QnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA4MCA/ICdDJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgOTAgPyAnQicgOiAnQSc7XG4gKiAgICAgIH0pO1xuICogICAgICB2YXIgc3R1ZGVudHMgPSBbe25hbWU6ICdBYmJ5Jywgc2NvcmU6IDg0fSxcbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnRWRkeScsIHNjb3JlOiA1OH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnSmFjaycsIHNjb3JlOiA2OX1dO1xuICogICAgICBieUdyYWRlKHN0dWRlbnRzKTtcbiAqICAgICAgLy8ge1xuICogICAgICAvLyAgICdBJzogW3tuYW1lOiAnRGlhbm5lJywgc2NvcmU6IDk5fV0sXG4gKiAgICAgIC8vICAgJ0InOiBbe25hbWU6ICdBYmJ5Jywgc2NvcmU6IDg0fV1cbiAqICAgICAgLy8gICAvLyAuLi4sXG4gKiAgICAgIC8vICAgJ0YnOiBbe25hbWU6ICdFZGR5Jywgc2NvcmU6IDU4fV1cbiAqICAgICAgLy8gfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2NoZWNrRm9yTWV0aG9kKCdncm91cEJ5JywgcmVkdWNlQnkoZnVuY3Rpb24oYWNjLCBpdGVtKSB7XG4gIGlmIChhY2MgPT0gbnVsbCkge1xuICAgIGFjYyA9IFtdO1xuICB9XG4gIGFjYy5wdXNoKGl0ZW0pO1xuICByZXR1cm4gYWNjO1xufSwgbnVsbCkpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IGFuZCByZXR1cm5zIGEgbGlzdCBvZiBsaXN0cyB3aGVyZSBlYWNoIHN1Ymxpc3QncyBlbGVtZW50cyBhcmVcbiAqIGFsbCBcImVxdWFsXCIgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBlcXVhbGl0eSBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGEpIOKGkiBCb29sZWFuKSDihpIgW2FdIOKGkiBbW2FdXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIGdpdmVuIChhZGphY2VudClcbiAqICAgICAgICBlbGVtZW50cyBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZ3JvdXBcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwLiBBbHNvIGFjY2VwdHMgYSBzdHJpbmcsIHdoaWNoIHdpbGwgYmVcbiAqICAgICAgICB0cmVhdGVkIGFzIGEgbGlzdCBvZiBjaGFyYWN0ZXJzLlxuICogQHJldHVybiB7TGlzdH0gQSBsaXN0IHRoYXQgY29udGFpbnMgc3VibGlzdHMgb2YgZXF1YWwgZWxlbWVudHMsXG4gKiAgICAgICAgIHdob3NlIGNvbmNhdGVuYXRpb25zIGFyZSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogUi5ncm91cFdpdGgoUi5lcXVhbHMsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzBdLCBbMSwgMV0sIFsyXSwgWzNdLCBbNV0sIFs4XSwgWzEzXSwgWzIxXV1cbiAqXG4gKiBSLmdyb3VwV2l0aCgoYSwgYikgPT4gYSAlIDIgPT09IGIgJSAyLCBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxXSlcbiAqIC8vPT4gW1swXSwgWzEsIDFdLCBbMl0sIFszLCA1XSwgWzhdLCBbMTMsIDIxXV1cbiAqXG4gKiBSLmdyb3VwV2l0aChSLmVxQnkoaXNWb3dlbCksICdhZXN0aW91JylcbiAqIC8vPT4gWydhZScsICdzdCcsICdpb3UnXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24oZm4sIGxpc3QpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFyIG5leHRpZHggPSBpZHggKyAxO1xuICAgIHdoaWxlIChuZXh0aWR4IDwgbGVuICYmIGZuKGxpc3RbaWR4XSwgbGlzdFtuZXh0aWR4XSkpIHtcbiAgICAgIG5leHRpZHggKz0gMTtcbiAgICB9XG4gICAgcmVzLnB1c2gobGlzdC5zbGljZShpZHgsIG5leHRpZHgpKTtcbiAgICBpZHggPSBuZXh0aWR4O1xuICB9XG4gIHJldHVybiByZXM7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQ7IGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIubHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmd0KDIsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ndCgyLCAyKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0KDIsIDMpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZ3QoJ2EnLCAneicpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZ3QoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGd0KGEsIGIpIHsgcmV0dXJuIGEgPiBiOyB9KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmx0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZ3RlKDIsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ndGUoMiwgMik7IC8vPT4gdHJ1ZVxuICogICAgICBSLmd0ZSgyLCAzKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0ZSgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndGUoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGd0ZShhLCBiKSB7IHJldHVybiBhID49IGI7IH0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faGFzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHMgLT4ge3M6IHh9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGhhc05hbWUgPSBSLmhhcygnbmFtZScpO1xuICogICAgICBoYXNOYW1lKHtuYW1lOiAnYWxpY2UnfSk7ICAgLy89PiB0cnVlXG4gKiAgICAgIGhhc05hbWUoe25hbWU6ICdib2InfSk7ICAgICAvLz0+IHRydWVcbiAqICAgICAgaGFzTmFtZSh7fSk7ICAgICAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAqXG4gKiAgICAgIHZhciBwb2ludCA9IHt4OiAwLCB5OiAwfTtcbiAqICAgICAgdmFyIHBvaW50SGFzID0gUi5oYXMoUi5fXywgcG9pbnQpO1xuICogICAgICBwb2ludEhhcygneCcpOyAgLy89PiB0cnVlXG4gKiAgICAgIHBvaW50SGFzKCd5Jyk7ICAvLz0+IHRydWVcbiAqICAgICAgcG9pbnRIYXMoJ3onKTsgIC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9oYXMpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4gaGFzIGEgcHJvcGVydHkgd2l0aFxuICogdGhlIHNwZWNpZmllZCBuYW1lXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHMgLT4ge3M6IHh9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgZnVuY3Rpb24gUmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQpIHtcbiAqICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gKiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gKiAgICAgIH1cbiAqICAgICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAqICAgICAgfTtcbiAqXG4gKiAgICAgIHZhciBzcXVhcmUgPSBuZXcgUmVjdGFuZ2xlKDIsIDIpO1xuICogICAgICBSLmhhc0luKCd3aWR0aCcsIHNxdWFyZSk7ICAvLz0+IHRydWVcbiAqICAgICAgUi5oYXNJbignYXJlYScsIHNxdWFyZSk7ICAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGhhc0luKHByb3AsIG9iaikge1xuICByZXR1cm4gcHJvcCBpbiBvYmo7XG59KTtcbiIsInZhciBudGggPSByZXF1aXJlKCcuL250aCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIEluIHNvbWUgbGlicmFyaWVzXG4gKiB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBmaXJzdGAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi50YWlsLCBSLmluaXQsIFIubGFzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaGVhZChbJ2ZpJywgJ2ZvJywgJ2Z1bSddKTsgLy89PiAnZmknXG4gKiAgICAgIFIuaGVhZChbXSk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLmhlYWQoJ2FiYycpOyAvLz0+ICdhJ1xuICogICAgICBSLmhlYWQoJycpOyAvLz0+ICcnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gbnRoKDApO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdHMgYXJndW1lbnRzIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZS4gVmFsdWVzIGFyZVxuICogaWRlbnRpY2FsIGlmIHRoZXkgcmVmZXJlbmNlIHRoZSBzYW1lIG1lbW9yeS4gYE5hTmAgaXMgaWRlbnRpY2FsIHRvIGBOYU5gO1xuICogYDBgIGFuZCBgLTBgIGFyZSBub3QgaWRlbnRpY2FsLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG8gPSB7fTtcbiAqICAgICAgUi5pZGVudGljYWwobywgbyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlkZW50aWNhbCgxLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pZGVudGljYWwoW10sIFtdKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbCgwLCAtMCk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pZGVudGljYWwoTmFOLCBOYU4pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGlkZW50aWNhbChhLCBiKSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKGEgPT09IGIpIHsgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xuICB9XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2lkZW50aXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faWRlbnRpdHknKTtcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJldHVybiB0aGUgcGFyYW1ldGVyIHN1cHBsaWVkIHRvIGl0LiBHb29kXG4gKiBhcyBhIGRlZmF1bHQgb3IgcGxhY2Vob2xkZXIgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBhXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIHJldHVybi5cbiAqIEByZXR1cm4geyp9IFRoZSBpbnB1dCB2YWx1ZSwgYHhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaWRlbnRpdHkoMSk7IC8vPT4gMVxuICpcbiAqICAgICAgdmFyIG9iaiA9IHt9O1xuICogICAgICBSLmlkZW50aXR5KG9iaikgPT09IG9iajsgLy89PiB0cnVlXG4gKiBAc3ltYiBSLmlkZW50aXR5KGEpID0gYVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoX2lkZW50aXR5KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAqIGZ1bmN0aW9uIGRlcGVuZGluZyB1cG9uIHRoZSByZXN1bHQgb2YgdGhlIGBjb25kaXRpb25gIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiAqKSAtPiAoKi4uLiAtPiAqKSAtPiAoKi4uLiAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblRydWUgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25GYWxzZSBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgY29uZGl0aW9uYCBldmFsdWF0ZXMgdG8gYSBmYWxzeSB2YWx1ZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyB1bmFyeSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAqICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZXBlbmRpbmcgdXBvbiB0aGUgcmVzdWx0IG9mIHRoZSBgY29uZGl0aW9uYCBwcmVkaWNhdGUuXG4gKiBAc2VlIFIudW5sZXNzLCBSLndoZW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaW5jQ291bnQgPSBSLmlmRWxzZShcbiAqICAgICAgICBSLmhhcygnY291bnQnKSxcbiAqICAgICAgICBSLm92ZXIoUi5sZW5zUHJvcCgnY291bnQnKSwgUi5pbmMpLFxuICogICAgICAgIFIuYXNzb2MoJ2NvdW50JywgMSlcbiAqICAgICAgKTtcbiAqICAgICAgaW5jQ291bnQoe30pOyAgICAgICAgICAgLy89PiB7IGNvdW50OiAxIH1cbiAqICAgICAgaW5jQ291bnQoeyBjb3VudDogMSB9KTsgLy89PiB7IGNvdW50OiAyIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGlmRWxzZShjb25kaXRpb24sIG9uVHJ1ZSwgb25GYWxzZSkge1xuICByZXR1cm4gY3VycnlOKE1hdGgubWF4KGNvbmRpdGlvbi5sZW5ndGgsIG9uVHJ1ZS5sZW5ndGgsIG9uRmFsc2UubGVuZ3RoKSxcbiAgICBmdW5jdGlvbiBfaWZFbHNlKCkge1xuICAgICAgcmV0dXJuIGNvbmRpdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gb25UcnVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvbkZhbHNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICApO1xufSk7XG4iLCJ2YXIgYWRkID0gcmVxdWlyZSgnLi9hZGQnKTtcblxuXG4vKipcbiAqIEluY3JlbWVudHMgaXRzIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn0gbiArIDFcbiAqIEBzZWUgUi5kZWNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluYyg0Mik7IC8vPT4gNDNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhZGQoMSk7XG4iLCJ2YXIgcmVkdWNlQnkgPSByZXF1aXJlKCcuL3JlZHVjZUJ5Jyk7XG5cblxuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEga2V5LCB0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBpbnRvIGFuXG4gKiBvYmplY3QgaW5kZXhpbmcgdGhlIG9iamVjdHMgYnkgdGhlIGdpdmVuIGtleS4gTm90ZSB0aGF0IGlmIG11bHRpcGxlXG4gKiBvYmplY3RzIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlIGZvciB0aGUgaW5kZXhpbmcga2V5IG9ubHkgdGhlIGxhc3QgdmFsdWVcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBvYmplY3QuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW3trOiB2fV0gLT4ge2s6IHtrOiB2fX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIDo6IGEgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2Ygb2JqZWN0cyB0byBpbmRleFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgaW5kZXhpbmcgZWFjaCBhcnJheSBlbGVtZW50IGJ5IHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbGlzdCA9IFt7aWQ6ICd4eXonLCB0aXRsZTogJ0EnfSwge2lkOiAnYWJjJywgdGl0bGU6ICdCJ31dO1xuICogICAgICBSLmluZGV4QnkoUi5wcm9wKCdpZCcpLCBsaXN0KTtcbiAqICAgICAgLy89PiB7YWJjOiB7aWQ6ICdhYmMnLCB0aXRsZTogJ0InfSwgeHl6OiB7aWQ6ICd4eXonLCB0aXRsZTogJ0EnfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2VCeShmdW5jdGlvbihhY2MsIGVsZW0pIHsgcmV0dXJuIGVsZW07IH0sIG51bGwpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfaW5kZXhPZiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2luZGV4T2YnKTtcbnZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJyYXknKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xXG4gKiBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LiBgUi5lcXVhbHNgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiBlcXVhbGl0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIGl0ZW0gdG8gZmluZC5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LCBvciAtMSBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBmb3VuZC5cbiAqIEBzZWUgUi5sYXN0SW5kZXhPZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5kZXhPZigzLCBbMSwyLDMsNF0pOyAvLz0+IDJcbiAqICAgICAgUi5pbmRleE9mKDEwLCBbMSwyLDMsNF0pOyAvLz0+IC0xXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBpbmRleE9mKHRhcmdldCwgeHMpIHtcbiAgcmV0dXJuIHR5cGVvZiB4cy5pbmRleE9mID09PSAnZnVuY3Rpb24nICYmICFfaXNBcnJheSh4cykgP1xuICAgIHhzLmluZGV4T2YodGFyZ2V0KSA6XG4gICAgX2luZGV4T2YoeHMsIHRhcmdldCwgMCk7XG59KTtcbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmxhc3QsIFIuaGVhZCwgUi50YWlsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbml0KFsxLCAyLCAzXSk7ICAvLz0+IFsxLCAyXVxuICogICAgICBSLmluaXQoWzEsIDJdKTsgICAgIC8vPT4gWzFdXG4gKiAgICAgIFIuaW5pdChbMV0pOyAgICAgICAgLy89PiBbXVxuICogICAgICBSLmluaXQoW10pOyAgICAgICAgIC8vPT4gW11cbiAqXG4gKiAgICAgIFIuaW5pdCgnYWJjJyk7ICAvLz0+ICdhYidcbiAqICAgICAgUi5pbml0KCdhYicpOyAgIC8vPT4gJ2EnXG4gKiAgICAgIFIuaW5pdCgnYScpOyAgICAvLz0+ICcnXG4gKiAgICAgIFIuaW5pdCgnJyk7ICAgICAvLz0+ICcnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gc2xpY2UoMCwgLTEpO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIEluc2VydHMgdGhlIHN1cHBsaWVkIGVsZW1lbnQgaW50byB0aGUgbGlzdCwgYXQgaW5kZXggYGluZGV4YC4gX05vdGUgdGhhdFxuICogdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjJcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0geyp9IGVsdCBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IGludG9cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBBcnJheSB3aXRoIGBlbHRgIGluc2VydGVkIGF0IGBpbmRleGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbnNlcnQoMiwgJ3gnLCBbMSwyLDMsNF0pOyAvLz0+IFsxLDIsJ3gnLDMsNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGluc2VydChpZHgsIGVsdCwgbGlzdCkge1xuICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCk7XG4gIHJlc3VsdC5zcGxpY2UoaWR4LCAwLCBlbHQpO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogSW5zZXJ0cyB0aGUgc3ViLWxpc3QgaW50byB0aGUgbGlzdCwgYXQgaW5kZXggYGluZGV4YC4gX05vdGUgdGhhdCB0aGlzIGlzIG5vdFxuICogZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHN1Yi1saXN0XG4gKiBAcGFyYW0ge0FycmF5fSBlbHRzIFRoZSBzdWItbGlzdCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IHRoZSBzdWItbGlzdCBpbnRvXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgZWx0c2AgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgYGluZGV4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluc2VydEFsbCgyLCBbJ3gnLCd5JywneiddLCBbMSwyLDMsNF0pOyAvLz0+IFsxLDIsJ3gnLCd5JywneicsMyw0XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gaW5zZXJ0QWxsKGlkeCwgZWx0cywgbGlzdCkge1xuICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICByZXR1cm4gW10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDAsIGlkeCksXG4gICAgICAgICAgICAgICAgICAgZWx0cyxcbiAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgpKTtcbn0pO1xuIiwidmFyIF9jb250YWlucyA9IHJlcXVpcmUoJy4vX2NvbnRhaW5zJyk7XG5cblxuLy8gQSBzaW1wbGUgU2V0IHR5cGUgdGhhdCBob25vdXJzIFIuZXF1YWxzIHNlbWFudGljc1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIF9TZXQoKSB7XG4gICAgLyogZ2xvYmFscyBTZXQgKi9cbiAgICB0aGlzLl9uYXRpdmVTZXQgPSB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nID8gbmV3IFNldCgpIDogbnVsbDtcbiAgICB0aGlzLl9pdGVtcyA9IHt9O1xuICB9XG5cbiAgLy8gdW50aWwgd2UgZmlndXJlIG91dCB3aHkganNkb2MgY2hva2VzIG9uIHRoaXNcbiAgLy8gQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBTZXRcbiAgLy8gQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gZGlkIG5vdCBleGlzdCBwcmlvciwgb3RoZXJ3aXNlIGZhbHNlXG4gIC8vXG4gIF9TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gIWhhc09yQWRkKGl0ZW0sIHRydWUsIHRoaXMpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGNoZWNrIGZvciBleGlzdGVuY2UgaW4gdGhlIFNldFxuICAvLyBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgaXRlbSBleGlzdHMgaW4gdGhlIFNldCwgb3RoZXJ3aXNlIGZhbHNlXG4gIC8vXG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaGFzT3JBZGQoaXRlbSwgZmFsc2UsIHRoaXMpO1xuICB9O1xuXG4gIC8vXG4gIC8vIENvbWJpbmVzIHRoZSBsb2dpYyBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBpdGVtIGlzIGEgbWVtYmVyIG9mIHRoZSBzZXQgYW5kXG4gIC8vIGZvciBhZGRpbmcgYSBuZXcgaXRlbSB0byB0aGUgc2V0LlxuICAvL1xuICAvLyBAcGFyYW0gaXRlbSAgICAgICBUaGUgaXRlbSB0byBjaGVjayBvciBhZGQgdG8gdGhlIFNldCBpbnN0YW5jZS5cbiAgLy8gQHBhcmFtIHNob3VsZEFkZCAgSWYgdHJ1ZSwgdGhlIGl0ZW0gd2lsbCBiZSBhZGRlZCB0byB0aGUgc2V0IGlmIGl0IGRvZXNuJ3RcbiAgLy8gICAgICAgICAgICAgICAgICAgYWxyZWFkeSBleGlzdC5cbiAgLy8gQHBhcmFtIHNldCAgICAgICAgVGhlIHNldCBpbnN0YW5jZSB0byBjaGVjayBvciBhZGQgdG8uXG4gIC8vIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gYWxyZWFkeSBleGlzdGVkLCBvdGhlcndpc2UgZmFsc2UuXG4gIC8vXG4gIGZ1bmN0aW9uIGhhc09yQWRkKGl0ZW0sIHNob3VsZEFkZCwgc2V0KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICB2YXIgcHJldlNpemUsIG5ld1NpemU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiArMCBhbmQgLTBcbiAgICAgICAgaWYgKGl0ZW0gPT09IDAgJiYgMSAvIGl0ZW0gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIGlmIChzZXQuX2l0ZW1zWyctMCddKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICBzZXQuX2l0ZW1zWyctMCddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgdHlwZXMgY2FuIGFsbCB1dGlsaXNlIHRoZSBuYXRpdmUgU2V0XG4gICAgICAgIGlmIChzZXQuX25hdGl2ZVNldCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHByZXZTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICAgIHNldC5fbmF0aXZlU2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NpemUgPT09IHByZXZTaXplO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0Ll9uYXRpdmVTZXQuaGFzKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtpdGVtXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluIHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1baXRlbV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgLy8gc2V0Ll9pdGVtc1snYm9vbGVhbiddIGhvbGRzIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICAgICAgLy8gcmVwcmVzZW50aW5nIFsgZmFsc2VFeGlzdHMsIHRydWVFeGlzdHMgXVxuICAgICAgICBpZiAodHlwZSBpbiBzZXQuX2l0ZW1zKSB7XG4gICAgICAgICAgdmFyIGJJZHggPSBpdGVtID8gMSA6IDA7XG4gICAgICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV1bYklkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1bYklkeF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gaXRlbSA/IFtmYWxzZSwgdHJ1ZV0gOiBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAvLyBjb21wYXJlIGZ1bmN0aW9ucyBmb3IgcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgICAgIGlmIChzZXQuX25hdGl2ZVNldCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHByZXZTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICAgIHNldC5fbmF0aXZlU2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NpemUgPT09IHByZXZTaXplO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0Ll9uYXRpdmVTZXQuaGFzKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBbaXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2NvbnRhaW5zKGl0ZW0sIHNldC5faXRlbXNbdHlwZV0pKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFzZXQuX2l0ZW1zWydudWxsJ10pIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgc2V0Ll9pdGVtc1snbnVsbCddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAgICAgLy8gZm9yIGVhY2ggdHlwZS5cbiAgICAgICAgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBbaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FuIHRocm91Z2ggYWxsIHByZXZpb3VzbHkgYXBwbGllZCBpdGVtc1xuICAgICAgICBpZiAoIV9jb250YWlucyhpdGVtLCBzZXQuX2l0ZW1zW3R5cGVdKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX1NldDtcbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9hcGVydHVyZShuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGltaXQgPSBsaXN0Lmxlbmd0aCAtIChuIC0gMSk7XG4gIHZhciBhY2MgPSBuZXcgQXJyYXkobGltaXQgPj0gMCA/IGxpbWl0IDogMCk7XG4gIHdoaWxlIChpZHggPCBsaW1pdCkge1xuICAgIGFjY1tpZHhdID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaWR4LCBpZHggKyBuKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gYWNjO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2FyaXR5KG4sIGZuKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhMCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhMCwgYTEpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMykgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA2OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDc6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDg6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA5OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDEwOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBfYXJpdHkgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG5vIGdyZWF0ZXIgdGhhbiB0ZW4nKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2FycmF5RnJvbUl0ZXJhdG9yKGl0ZXIpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgdmFyIG5leHQ7XG4gIHdoaWxlICghKG5leHQgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgIGxpc3QucHVzaChuZXh0LnZhbHVlKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn07XG4iLCJ2YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdEFzc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmFzc2lnbiA6IF9vYmplY3RBc3NpZ247XG4iLCJ2YXIgX2lzQXJyYXkgPSByZXF1aXJlKCcuL19pc0FycmF5Jyk7XG5cblxuLyoqXG4gKiBUaGlzIGNoZWNrcyB3aGV0aGVyIGEgZnVuY3Rpb24gaGFzIGEgW21ldGhvZG5hbWVdIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhblxuICogYXJyYXkgaXQgd2lsbCBleGVjdXRlIHRoYXQgZnVuY3Rpb24gb3RoZXJ3aXNlIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgcmFtZGFcbiAqIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiByYW1kYSBpbXBsZW10YXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7T2JqZWN0fSBXaGF0ZXZlciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBtZXRob2QgaXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tsZW5ndGggLSAxXTtcbiAgICByZXR1cm4gKF9pc0FycmF5KG9iaikgfHwgdHlwZW9mIG9ialttZXRob2RuYW1lXSAhPT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6XG4gICAgICBvYmpbbWV0aG9kbmFtZV0uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgfTtcbn07XG4iLCJ2YXIgX2Nsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8qKlxuICogQ29waWVzIGFuIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5fSByZWZGcm9tIEFycmF5IGNvbnRhaW5pbmcgdGhlIHNvdXJjZSByZWZlcmVuY2VzXG4gKiBAcGFyYW0ge0FycmF5fSByZWZUbyBBcnJheSBjb250YWluaW5nIHRoZSBjb3BpZWQgc291cmNlIHJlZmVyZW5jZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcCBXaGV0aGVyIG9yIG5vdCB0byBwZXJmb3JtIGRlZXAgY2xvbmluZy5cbiAqIEByZXR1cm4geyp9IFRoZSBjb3BpZWQgdmFsdWUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2Nsb25lKHZhbHVlLCByZWZGcm9tLCByZWZUbywgZGVlcCkge1xuICB2YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkoY29waWVkVmFsdWUpIHtcbiAgICB2YXIgbGVuID0gcmVmRnJvbS5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKHZhbHVlID09PSByZWZGcm9tW2lkeF0pIHtcbiAgICAgICAgcmV0dXJuIHJlZlRvW2lkeF07XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmVmRnJvbVtpZHggKyAxXSA9IHZhbHVlO1xuICAgIHJlZlRvW2lkeCArIDFdID0gY29waWVkVmFsdWU7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb3BpZWRWYWx1ZVtrZXldID0gZGVlcCA/XG4gICAgICAgIF9jbG9uZSh2YWx1ZVtrZXldLCByZWZGcm9tLCByZWZUbywgdHJ1ZSkgOiB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29waWVkVmFsdWU7XG4gIH07XG4gIHN3aXRjaCAodHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlICdPYmplY3QnOiAgcmV0dXJuIGNvcHkoe30pO1xuICAgIGNhc2UgJ0FycmF5JzogICByZXR1cm4gY29weShbXSk7XG4gICAgY2FzZSAnRGF0ZSc6ICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkpO1xuICAgIGNhc2UgJ1JlZ0V4cCc6ICByZXR1cm4gX2Nsb25lUmVnRXhwKHZhbHVlKTtcbiAgICBkZWZhdWx0OiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY2xvbmVSZWdFeHAocGF0dGVybikge1xuICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4uZ2xvYmFsICAgICA/ICdnJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYXR0ZXJuLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhdHRlcm4uc3RpY2t5ICAgICA/ICd5JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGF0dGVybi51bmljb2RlICAgID8gJ3UnIDogJycpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jb21wbGVtZW50KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIi8qKlxuICogUHJpdmF0ZSBgY29uY2F0YCBmdW5jdGlvbiB0byBtZXJnZSB0d28gYXJyYXktbGlrZSBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDE9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IFtzZXQyPVtdXSBBbiBhcnJheS1saWtlIG9iamVjdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldywgbWVyZ2VkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIF9jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jb25jYXQoc2V0MSwgc2V0Mikge1xuICBzZXQxID0gc2V0MSB8fCBbXTtcbiAgc2V0MiA9IHNldDIgfHwgW107XG4gIHZhciBpZHg7XG4gIHZhciBsZW4xID0gc2V0MS5sZW5ndGg7XG4gIHZhciBsZW4yID0gc2V0Mi5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuMSkge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHNldDFbaWR4XTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuMikge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHNldDJbaWR4XTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBfaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2luZGV4T2YnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jb250YWlucyhhLCBsaXN0KSB7XG4gIHJldHVybiBfaW5kZXhPZihsaXN0LCBhLCAwKSA+PSAwO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2NvbnRhaW5zV2l0aChwcmVkLCB4LCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChwcmVkKHgsIGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vX2FyaXR5Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKGNvbmNhdCkge1xuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbihmbiwgYXJncykge1xuICAgIHJldHVybiBfYXJpdHkoTWF0aC5tYXgoMCwgZm4ubGVuZ3RoIC0gYXJncy5sZW5ndGgpLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBjb25jYXQoYXJncywgYXJndW1lbnRzKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsInZhciBfaXNQbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuXG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCBvbmUtYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jdXJyeTEoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYxKGEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBfaXNQbGFjZWhvbGRlcihhKSkge1xuICAgICAgcmV0dXJuIGYxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG59O1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL19jdXJyeTEnKTtcbnZhciBfaXNQbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuXG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCB0d28tYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jdXJyeTIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYyKGEsIGIpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmMlxuICAgICAgICAgICAgIDogX2N1cnJ5MShmdW5jdGlvbihfYikgeyByZXR1cm4gZm4oYSwgX2IpOyB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IGYyXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2EpIHsgcmV0dXJuIGZuKF9hLCBiKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbihfYikgeyByZXR1cm4gZm4oYSwgX2IpOyB9KVxuICAgICAgICAgICAgIDogZm4oYSwgYik7XG4gICAgfVxuICB9O1xufTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9fY3VycnkxJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF9pc1BsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIHRocmVlLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnkzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMyhhLCBiLCBjKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmMztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjNcbiAgICAgICAgICAgICA6IF9jdXJyeTIoZnVuY3Rpb24oX2IsIF9jKSB7IHJldHVybiBmbihhLCBfYiwgX2MpOyB9KTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gZjNcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MihmdW5jdGlvbihfYSwgX2MpIHsgcmV0dXJuIGZuKF9hLCBiLCBfYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2IsIF9jKSB7IHJldHVybiBmbihhLCBfYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogX2N1cnJ5MShmdW5jdGlvbihfYykgeyByZXR1cm4gZm4oYSwgYiwgX2MpOyB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IGYzXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2EsIF9iKSB7IHJldHVybiBmbihfYSwgX2IsIGMpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uKF9hLCBfYykgeyByZXR1cm4gZm4oX2EsIGIsIF9jKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGIpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MihmdW5jdGlvbihfYiwgX2MpIHsgcmV0dXJuIGZuKGEsIF9iLCBfYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2EpIHsgcmV0dXJuIGZuKF9hLCBiLCBjKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbihfYikgeyByZXR1cm4gZm4oYSwgX2IsIGMpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkxKGZ1bmN0aW9uKF9jKSB7IHJldHVybiBmbihhLCBiLCBfYyk7IH0pXG4gICAgICAgICAgICAgOiBmbihhLCBiLCBjKTtcbiAgICB9XG4gIH07XG59O1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vX2FyaXR5Jyk7XG52YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBjdXJyeU4gZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgb2YgdGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSByZWNlaXZlZCBBbiBhcnJheSBvZiBhcmd1bWVudHMgcmVjZWl2ZWQgdGh1cyBmYXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5TihsZW5ndGgsIHJlY2VpdmVkLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgdmFyIGFyZ3NJZHggPSAwO1xuICAgIHZhciBsZWZ0ID0gbGVuZ3RoO1xuICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG4gICAgd2hpbGUgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoIHx8IGFyZ3NJZHggPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoICYmXG4gICAgICAgICAgKCFfaXNQbGFjZWhvbGRlcihyZWNlaXZlZFtjb21iaW5lZElkeF0pIHx8XG4gICAgICAgICAgIGFyZ3NJZHggPj0gYXJndW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZWRbY29tYmluZWRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2FyZ3NJZHhdO1xuICAgICAgICBhcmdzSWR4ICs9IDE7XG4gICAgICB9XG4gICAgICBjb21iaW5lZFtjb21iaW5lZElkeF0gPSByZXN1bHQ7XG4gICAgICBpZiAoIV9pc1BsYWNlaG9sZGVyKHJlc3VsdCkpIHtcbiAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgfVxuICAgICAgY29tYmluZWRJZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQgPD0gMCA/IGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgOiBfYXJpdHkobGVmdCwgX2N1cnJ5TihsZW5ndGgsIGNvbWJpbmVkLCBmbikpO1xuICB9O1xufTtcbiIsInZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzQXJyYXknKTtcbnZhciBfaXNUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vX2lzVHJhbnNmb3JtZXInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgd2l0aCBkaWZmZXJlbnQgc3RyYXRlZ2llcyBiYXNlZCBvbiB0aGVcbiAqIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uIChsYXN0IGFyZ3VtZW50KS4gSWYgaXQgaXMgYW4gYXJyYXksIGV4ZWN1dGVzIFtmbl0uXG4gKiBPdGhlcndpc2UsIGlmIGl0IGhhcyBhIGZ1bmN0aW9uIHdpdGggb25lIG9mIHRoZSBnaXZlbiBtZXRob2QgbmFtZXMsIGl0IHdpbGxcbiAqIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiAoZnVuY3RvciBjYXNlKS4gT3RoZXJ3aXNlLCBpZiBpdCBpcyBhIHRyYW5zZm9ybWVyLFxuICogdXNlcyB0cmFuc2R1Y2VyIFt4Zl0gdG8gcmV0dXJuIGEgbmV3IHRyYW5zZm9ybWVyICh0cmFuc2R1Y2VyIGNhc2UpLlxuICogT3RoZXJ3aXNlLCBpdCB3aWxsIGRlZmF1bHQgdG8gZXhlY3V0aW5nIFtmbl0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IG1ldGhvZE5hbWVzIHByb3BlcnRpZXMgdG8gY2hlY2sgZm9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiB0cmFuc2R1Y2VyIHRvIGluaXRpYWxpemUgaWYgb2JqZWN0IGlzIHRyYW5zZm9ybWVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBkZWZhdWx0IHJhbWRhIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgb24gb2JqZWN0IGluIGxpc3QgcG9zaXRpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfZGlzcGF0Y2hhYmxlKG1ldGhvZE5hbWVzLCB4ZiwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIHZhciBvYmogPSBhcmdzLnBvcCgpO1xuICAgIGlmICghX2lzQXJyYXkob2JqKSkge1xuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICB3aGlsZSAoaWR4IDwgbWV0aG9kTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW21ldGhvZE5hbWVzW2lkeF1dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialttZXRob2ROYW1lc1tpZHhdXS5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlkeCArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKF9pc1RyYW5zZm9ybWVyKG9iaikpIHtcbiAgICAgICAgdmFyIHRyYW5zZHVjZXIgPSB4Zi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZHVjZXIob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIHRha2UgPSByZXF1aXJlKCcuLi90YWtlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJvcExhc3QobiwgeHMpIHtcbiAgcmV0dXJuIHRha2UobiA8IHhzLmxlbmd0aCA/IHhzLmxlbmd0aCAtIG4gOiAwLCB4cyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcm9wTGFzdFdoaWxlKHByZWQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwICYmIHByZWQobGlzdFtpZHhdKSkge1xuICAgIGlkeCAtPSAxO1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwLCBpZHggKyAxKTtcbn07XG4iLCJ2YXIgX2FycmF5RnJvbUl0ZXJhdG9yID0gcmVxdWlyZSgnLi9fYXJyYXlGcm9tSXRlcmF0b3InKTtcbnZhciBfZnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnLi9fZnVuY3Rpb25OYW1lJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIGlkZW50aWNhbCA9IHJlcXVpcmUoJy4uL2lkZW50aWNhbCcpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuLi9rZXlzJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9lcXVhbHMoYSwgYiwgc3RhY2tBLCBzdGFja0IpIHtcbiAgaWYgKGlkZW50aWNhbChhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGUoYSkgIT09IHR5cGUoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJiBhLmVxdWFscyhiKSAmJlxuICAgICAgICAgICB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYi5lcXVhbHMoYSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUoYSkpIHtcbiAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgIGNhc2UgJ0FycmF5JzpcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgaWYgKHR5cGVvZiBhLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgX2Z1bmN0aW9uTmFtZShhLmNvbnN0cnVjdG9yKSA9PT0gJ1Byb21pc2UnKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgaWYgKCEodHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGlkZW50aWNhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdEYXRlJzpcbiAgICAgIGlmICghaWRlbnRpY2FsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRXJyb3InOlxuICAgICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlO1xuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICBpZiAoIShhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICAgIGEuZ2xvYmFsID09PSBiLmdsb2JhbCAmJlxuICAgICAgICAgICAgYS5pZ25vcmVDYXNlID09PSBiLmlnbm9yZUNhc2UgJiZcbiAgICAgICAgICAgIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJlxuICAgICAgICAgICAgYS5zdGlja3kgPT09IGIuc3RpY2t5ICYmXG4gICAgICAgICAgICBhLnVuaWNvZGUgPT09IGIudW5pY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTWFwJzpcbiAgICBjYXNlICdTZXQnOlxuICAgICAgaWYgKCFfZXF1YWxzKF9hcnJheUZyb21JdGVyYXRvcihhLmVudHJpZXMoKSksIF9hcnJheUZyb21JdGVyYXRvcihiLmVudHJpZXMoKSksIHN0YWNrQSwgc3RhY2tCKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdJbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzpcbiAgICBjYXNlICdJbnQxNkFycmF5JzpcbiAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgY2FzZSAnSW50MzJBcnJheSc6XG4gICAgY2FzZSAnVWludDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FycmF5QnVmZmVyJzpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBWYWx1ZXMgb2Ygb3RoZXIgdHlwZXMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0ga2V5cyhhKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaWR4ID0gc3RhY2tBLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChzdGFja0FbaWR4XSA9PT0gYSkge1xuICAgICAgcmV0dXJuIHN0YWNrQltpZHhdID09PSBiO1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxuXG4gIHN0YWNrQS5wdXNoKGEpO1xuICBzdGFja0IucHVzaChiKTtcbiAgaWR4ID0ga2V5c0EubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgdmFyIGtleSA9IGtleXNBW2lkeF07XG4gICAgaWYgKCEoX2hhcyhrZXksIGIpICYmIF9lcXVhbHMoYltrZXldLCBhW2tleV0sIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWR4IC09IDE7XG4gIH1cbiAgc3RhY2tBLnBvcCgpO1xuICBzdGFja0IucG9wKCk7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2ZpbHRlcihmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIF9mb3JjZVJlZHVjZWQgPSByZXF1aXJlKCcuL19mb3JjZVJlZHVjZWQnKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9fcmVkdWNlJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xudmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaXNBcnJheUxpa2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBwcmVzZXJ2aW5nUmVkdWNlZCA9IGZ1bmN0aW9uKHhmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICB9LFxuICAgICAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICB2YXIgcmV0ID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIHJldHVybiByZXRbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10gPyBfZm9yY2VSZWR1Y2VkKHJldCkgOiByZXQ7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gX3hjYXQoeGYpIHtcbiAgICB2YXIgcnhmID0gcHJlc2VydmluZ1JlZHVjZWQoeGYpO1xuICAgIHJldHVybiB7XG4gICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBfeGZCYXNlLmluaXQsXG4gICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgIHJldHVybiAhaXNBcnJheUxpa2UoaW5wdXQpID8gX3JlZHVjZShyeGYsIHJlc3VsdCwgW2lucHV0XSkgOiBfcmVkdWNlKHJ4ZiwgcmVzdWx0LCBpbnB1dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9mb3JjZVJlZHVjZWQoeCkge1xuICByZXR1cm4ge1xuICAgICdAQHRyYW5zZHVjZXIvdmFsdWUnOiB4LFxuICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9mdW5jdGlvbk5hbWUoZikge1xuICAvLyBTdHJpbmcoeCA9PiB4KSBldmFsdWF0ZXMgdG8gXCJ4ID0+IHhcIiwgc28gdGhlIHBhdHRlcm4gbWF5IG5vdCBtYXRjaC5cbiAgdmFyIG1hdGNoID0gU3RyaW5nKGYpLm1hdGNoKC9eZnVuY3Rpb24gKFxcdyopLyk7XG4gIHJldHVybiBtYXRjaCA9PSBudWxsID8gJycgOiBtYXRjaFsxXTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9oYXMocHJvcCwgb2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pZGVudGl0eSh4KSB7IHJldHVybiB4OyB9O1xuIiwidmFyIGVxdWFscyA9IHJlcXVpcmUoJy4uL2VxdWFscycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2luZGV4T2YobGlzdCwgYSwgaWR4KSB7XG4gIHZhciBpbmYsIGl0ZW07XG4gIC8vIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGRvZXNuJ3QgZXhpc3QgYmVsb3cgSUU5XG4gIGlmICh0eXBlb2YgbGlzdC5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAvLyBtYW51YWxseSBjcmF3bCB0aGUgbGlzdCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgICAgICAgIGluZiA9IDEgLyBhO1xuICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSAwICYmIDEgLyBpdGVtID09PSBpbmYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYSAhPT0gYSkge1xuICAgICAgICAgIC8vIE5hTlxuICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgJiYgaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub24temVybyBudW1iZXJzIGNhbiB1dGlsaXNlIFNldFxuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG5cbiAgICAgIC8vIGFsbCB0aGVzZSB0eXBlcyBjYW4gdXRpbGlzZSBTZXRcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBudWxsIGNhbiB1dGlsaXNlIFNldFxuICAgICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBhbnl0aGluZyBlbHNlIG5vdCBjb3ZlcmVkIGFib3ZlLCBkZWZlciB0byBSLmVxdWFsc1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoZXF1YWxzKGxpc3RbaWR4XSwgYSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG4iLCJ2YXIgX2hhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmd1bWVudHMpID09PSAnW29iamVjdCBBcmd1bWVudHNdJyA/XG4gICAgZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHsgcmV0dXJuIHRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nOyB9IDpcbiAgICBmdW5jdGlvbiBfaXNBcmd1bWVudHMoeCkgeyByZXR1cm4gX2hhcygnY2FsbGVlJywgeCk7IH07XG59KCkpO1xuIiwiLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsYCBpcyBhbiBhcnJheSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXkoW10pOyAvLz0+IHRydWVcbiAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXkoe30pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBfaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuICh2YWwgIT0gbnVsbCAmJlxuICAgICAgICAgIHZhbC5sZW5ndGggPj0gMCAmJlxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG4iLCIvKipcbiAqIERldGVybWluZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGludGVnZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gblxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiBfaXNJbnRlZ2VyKG4pIHtcbiAgcmV0dXJuIChuIDw8IDApID09PSBuO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lzTnVtYmVyKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNPYmplY3QoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1BsYWNlaG9sZGVyKGEpIHtcbiAgcmV0dXJuIGEgIT0gbnVsbCAmJlxuICAgICAgICAgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1JlZ0V4cCh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lzU3RyaW5nKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNUcmFuc2Zvcm1lcihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmpbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPT09ICdmdW5jdGlvbic7XG59O1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaXNBcnJheUxpa2UnKTtcblxuXG4vKipcbiAqIGBfbWFrZUZsYXRgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG9uZS1sZXZlbCBvciBmdWxseSByZWN1cnNpdmVcbiAqIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBmbGFnIHBhc3NlZCBpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9tYWtlRmxhdChyZWN1cnNpdmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZsYXR0KGxpc3QpIHtcbiAgICB2YXIgdmFsdWUsIGpsZW4sIGo7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBpbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaWR4IDwgaWxlbikge1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgdmFsdWUgPSByZWN1cnNpdmUgPyBmbGF0dChsaXN0W2lkeF0pIDogbGlzdFtpZHhdO1xuICAgICAgICBqID0gMDtcbiAgICAgICAgamxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGogPCBqbGVuKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWVbal07XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9tYXAoZm4sIGZ1bmN0b3IpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBmdW5jdG9yLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbik7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICByZXN1bHRbaWR4XSA9IGZuKGZ1bmN0b3JbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgX2hhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9vYmplY3RBc3NpZ24odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaWR4ID0gMTtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2lkeF07XG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoX2hhcyhuZXh0S2V5LCBzb3VyY2UpKSB7XG4gICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfb2YoeCkgeyByZXR1cm4gW3hdOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfcGlwZShmLCBnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZy5jYWxsKHRoaXMsIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfcGlwZVAoZiwgZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpLnRoZW4oZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGcuY2FsbChjdHgsIHgpO1xuICAgIH0pO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX3F1b3RlKHMpIHtcbiAgdmFyIGVzY2FwZWQgPSBzXG4gICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAucmVwbGFjZSgvW1xcYl0vZywgJ1xcXFxiJykgIC8vIFxcYiBtYXRjaGVzIHdvcmQgYm91bmRhcnk7IFtcXGJdIG1hdGNoZXMgYmFja3NwYWNlXG4gICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKVxuICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuICAgIC5yZXBsYWNlKC9cXHYvZywgJ1xcXFx2JylcbiAgICAucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpO1xuXG4gIHJldHVybiAnXCInICsgZXNjYXBlZC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCInO1xufTtcbiIsInZhciBfeHdyYXAgPSByZXF1aXJlKCcuL194d3JhcCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9iaW5kJyk7XG52YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pc0FycmF5TGlrZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBfYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIGxpc3RbaWR4XSk7XG4gICAgICBpZiAoYWNjICYmIGFjY1snQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlUmVkdWNlKHhmLCBhY2MsIGl0ZXIpIHtcbiAgICB2YXIgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICAgIHdoaWxlICghc3RlcC5kb25lKSB7XG4gICAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIHN0ZXAudmFsdWUpO1xuICAgICAgaWYgKGFjYyAmJiBhY2NbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGVwID0gaXRlci5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG4gIH1cblxuICBmdW5jdGlvbiBfbWV0aG9kUmVkdWNlKHhmLCBhY2MsIG9iaikge1xuICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKG9iai5yZWR1Y2UoYmluZCh4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSwgeGYpLCBhY2MpKTtcbiAgfVxuXG4gIHZhciBzeW1JdGVyYXRvciA9ICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJykgPyBTeW1ib2wuaXRlcmF0b3IgOiAnQEBpdGVyYXRvcic7XG4gIHJldHVybiBmdW5jdGlvbiBfcmVkdWNlKGZuLCBhY2MsIGxpc3QpIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbiA9IF94d3JhcChmbik7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShsaXN0KSkge1xuICAgICAgcmV0dXJuIF9hcnJheVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaXN0LnJlZHVjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgfVxuICAgIGlmIChsaXN0W3N5bUl0ZXJhdG9yXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3Rbc3ltSXRlcmF0b3JdKCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxpc3QubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlOiBsaXN0IG11c3QgYmUgYXJyYXkgb3IgaXRlcmFibGUnKTtcbiAgfTtcbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9yZWR1Y2VkKHgpIHtcbiAgcmV0dXJuIHggJiYgeFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IHggOlxuICAgIHtcbiAgICAgICdAQHRyYW5zZHVjZXIvdmFsdWUnOiB4LFxuICAgICAgJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJzogdHJ1ZVxuICAgIH07XG59O1xuIiwidmFyIF9hc3NpZ24gPSByZXF1aXJlKCcuL19hc3NpZ24nKTtcbnZhciBfaWRlbnRpdHkgPSByZXF1aXJlKCcuL19pZGVudGl0eScpO1xudmFyIF9pc1RyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi9faXNUcmFuc2Zvcm1lcicpO1xudmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaXNBcnJheUxpa2UnKTtcbnZhciBvYmpPZiA9IHJlcXVpcmUoJy4uL29iak9mJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBfc3RlcENhdEFycmF5ID0ge1xuICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IEFycmF5LFxuICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uKHhzLCB4KSB7XG4gICAgICB4cy5wdXNoKHgpO1xuICAgICAgcmV0dXJuIHhzO1xuICAgIH0sXG4gICAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBfaWRlbnRpdHlcbiAgfTtcbiAgdmFyIF9zdGVwQ2F0U3RyaW5nID0ge1xuICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IFN0cmluZyxcbiAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICsgYjsgfSxcbiAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IF9pZGVudGl0eVxuICB9O1xuICB2YXIgX3N0ZXBDYXRPYmplY3QgPSB7XG4gICAgJ0BAdHJhbnNkdWNlci9pbml0JzogT2JqZWN0LFxuICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgIHJldHVybiBfYXNzaWduKFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIGlzQXJyYXlMaWtlKGlucHV0KSA/IG9iak9mKGlucHV0WzBdLCBpbnB1dFsxXSkgOiBpbnB1dFxuICAgICAgKTtcbiAgICB9LFxuICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9zdGVwQ2F0KG9iaikge1xuICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgcmV0dXJuIF9zdGVwQ2F0QXJyYXk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIF9zdGVwQ2F0U3RyaW5nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBfc3RlcENhdE9iamVjdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHRyYW5zZm9ybWVyIGZvciAnICsgb2JqKTtcbiAgfTtcbn0oKSk7XG4iLCIvKipcbiAqIFBvbHlmaWxsIGZyb20gPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmc+LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHBhZCA9IGZ1bmN0aW9uIHBhZChuKSB7IHJldHVybiAobiA8IDEwID8gJzAnIDogJycpICsgbjsgfTtcblxuICByZXR1cm4gdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nID9cbiAgICBmdW5jdGlvbiBfdG9JU09TdHJpbmcoZCkge1xuICAgICAgcmV0dXJuIGQudG9JU09TdHJpbmcoKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbiBfdG9JU09TdHJpbmcoZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZC5nZXRVVENGdWxsWWVhcigpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDRGF0ZSgpKSArICdUJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0hvdXJzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTWludXRlcygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgK1xuICAgICAgICAoZC5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDEwMDApLnRvRml4ZWQoMykuc2xpY2UoMiwgNSkgKyAnWidcbiAgICAgICk7XG4gICAgfTtcbn0oKSk7XG4iLCJ2YXIgX2NvbnRhaW5zID0gcmVxdWlyZSgnLi9fY29udGFpbnMnKTtcbnZhciBfbWFwID0gcmVxdWlyZSgnLi9fbWFwJyk7XG52YXIgX3F1b3RlID0gcmVxdWlyZSgnLi9fcXVvdGUnKTtcbnZhciBfdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL190b0lTT1N0cmluZycpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuLi9rZXlzJyk7XG52YXIgcmVqZWN0ID0gcmVxdWlyZSgnLi4vcmVqZWN0Jyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfdG9TdHJpbmcoeCwgc2Vlbikge1xuICB2YXIgcmVjdXIgPSBmdW5jdGlvbiByZWN1cih5KSB7XG4gICAgdmFyIHhzID0gc2Vlbi5jb25jYXQoW3hdKTtcbiAgICByZXR1cm4gX2NvbnRhaW5zKHksIHhzKSA/ICc8Q2lyY3VsYXI+JyA6IF90b1N0cmluZyh5LCB4cyk7XG4gIH07XG5cbiAgLy8gIG1hcFBhaXJzIDo6IChPYmplY3QsIFtTdHJpbmddKSAtPiBbU3RyaW5nXVxuICB2YXIgbWFwUGFpcnMgPSBmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICByZXR1cm4gX21hcChmdW5jdGlvbihrKSB7IHJldHVybiBfcXVvdGUoaykgKyAnOiAnICsgcmVjdXIob2JqW2tdKTsgfSwga2V5cy5zbGljZSgpLnNvcnQoKSk7XG4gIH07XG5cbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOlxuICAgICAgcmV0dXJuICcoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oJyArIF9tYXAocmVjdXIsIHgpLmpvaW4oJywgJykgKyAnKSknO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgIHJldHVybiAnWycgKyBfbWFwKHJlY3VyLCB4KS5jb25jYXQobWFwUGFpcnMoeCwgcmVqZWN0KGZ1bmN0aW9uKGspIHsgcmV0dXJuIC9eXFxkKyQvLnRlc3Qoayk7IH0sIGtleXMoeCkpKSkuam9pbignLCAnKSArICddJztcbiAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IEJvb2xlYW4oJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IHgudG9TdHJpbmcoKTtcbiAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIHJldHVybiAnbmV3IERhdGUoJyArIChpc05hTih4LnZhbHVlT2YoKSkgPyByZWN1cihOYU4pIDogX3F1b3RlKF90b0lTT1N0cmluZyh4KSkpICsgJyknO1xuICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOlxuICAgICAgcmV0dXJuICdudWxsJztcbiAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgTnVtYmVyKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiAxIC8geCA9PT0gLUluZmluaXR5ID8gJy0wJyA6IHgudG9TdHJpbmcoMTApO1xuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID8gJ25ldyBTdHJpbmcoJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IF9xdW90ZSh4KTtcbiAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOlxuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHgudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcHIgPSB4LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXByICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgIHJldHVybiByZXByO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3snICsgbWFwUGFpcnMoeCwga2V5cyh4KSkuam9pbignLCAnKSArICd9JztcbiAgfVxufTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL19yZWR1Y2VkJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYQWxsKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy5hbGwgPSB0cnVlO1xuICB9XG4gIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYQWxsLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgaWYgKHRoaXMuYWxsKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWEFsbC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmFsbCA9IGZhbHNlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGZhbHNlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hhbGwoZiwgeGYpIHsgcmV0dXJuIG5ldyBYQWxsKGYsIHhmKTsgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfcmVkdWNlZCA9IHJlcXVpcmUoJy4vX3JlZHVjZWQnKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhBbnkoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLmFueSA9IGZhbHNlO1xuICB9XG4gIFhBbnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLmFueSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgdGhpcy5hbnkgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGFueShmLCB4ZikgeyByZXR1cm4gbmV3IFhBbnkoZiwgeGYpOyB9KTtcbn0oKSk7XG4iLCJ2YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vX2NvbmNhdCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhBcGVydHVyZShuLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5mdWxsID0gZmFsc2U7XG4gICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gIH1cbiAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdGhpcy5hY2MgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLnN0b3JlKGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy5mdWxsID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuZ2V0Q29weSgpKSA6IHJlc3VsdDtcbiAgfTtcbiAgWEFwZXJ0dXJlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdGhpcy5hY2NbdGhpcy5wb3NdID0gaW5wdXQ7XG4gICAgdGhpcy5wb3MgKz0gMTtcbiAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuYWNjLmxlbmd0aCkge1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgdGhpcy5mdWxsID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIFhBcGVydHVyZS5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuYWNjLCB0aGlzLnBvcyksXG4gICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5hY2MsIDAsIHRoaXMucG9zKSk7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hhcGVydHVyZShuLCB4ZikgeyByZXR1cm4gbmV3IFhBcGVydHVyZShuLCB4Zik7IH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX2ZsYXRDYXQgPSByZXF1aXJlKCcuL19mbGF0Q2F0Jyk7XG52YXIgbWFwID0gcmVxdWlyZSgnLi4vbWFwJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIF94Y2hhaW4oZiwgeGYpIHtcbiAgcmV0dXJuIG1hcChmLCBfZmxhdENhdCh4ZikpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWERyb3AobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5uID0gbjtcbiAgfVxuICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5uID4gMCkge1xuICAgICAgdGhpcy5uIC09IDE7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3AobiwgeGYpIHsgcmV0dXJuIG5ldyBYRHJvcChuLCB4Zik7IH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRHJvcExhc3QobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgIHRoaXMuYWNjID0gbmV3IEFycmF5KG4pO1xuICB9XG4gIFhEcm9wTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9ICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB0aGlzLmFjYyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmZ1bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmFjY1t0aGlzLnBvc10pO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBYRHJvcExhc3QucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB0aGlzLmFjY1t0aGlzLnBvc10gPSBpbnB1dDtcbiAgICB0aGlzLnBvcyArPSAxO1xuICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5hY2MubGVuZ3RoKSB7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB0aGlzLmZ1bGwgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3BMYXN0KG4sIHhmKSB7IHJldHVybiBuZXcgWERyb3BMYXN0KG4sIHhmKTsgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9fcmVkdWNlJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWERyb3BMYXN0V2hpbGUoZm4sIHhmKSB7XG4gICAgdGhpcy5mID0gZm47XG4gICAgdGhpcy5yZXRhaW5lZCA9IFtdO1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgfVxuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdGhpcy5yZXRhaW5lZCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZihpbnB1dCkgPyB0aGlzLnJldGFpbihyZXN1bHQsIGlucHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5mbHVzaChyZXN1bHQsIGlucHV0KTtcbiAgfTtcbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHJlc3VsdCA9IF9yZWR1Y2UoXG4gICAgICB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddLFxuICAgICAgcmVzdWx0LFxuICAgICAgdGhpcy5yZXRhaW5lZFxuICAgICk7XG4gICAgdGhpcy5yZXRhaW5lZCA9IFtdO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMucmV0YWluZWQucHVzaChpbnB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3BMYXN0V2hpbGUoZm4sIHhmKSB7IHJldHVybiBuZXcgWERyb3BMYXN0V2hpbGUoZm4sIHhmKTsgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5wcmVkID0gcHJlZDtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gZmFsc2U7XG4gIH1cblxuICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWERyb3BSZXBlYXRzV2l0aC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB2YXIgc2FtZUFzTGFzdCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5zZWVuRmlyc3RWYWx1ZSkge1xuICAgICAgdGhpcy5zZWVuRmlyc3RWYWx1ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWQodGhpcy5sYXN0VmFsdWUsIGlucHV0KSkge1xuICAgICAgc2FtZUFzTGFzdCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMubGFzdFZhbHVlID0gaW5wdXQ7XG4gICAgcmV0dXJuIHNhbWVBc0xhc3QgPyByZXN1bHQgOiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKSB7IHJldHVybiBuZXcgWERyb3BSZXBlYXRzV2l0aChwcmVkLCB4Zik7IH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRHJvcFdoaWxlKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZikge1xuICAgICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZiA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFdoaWxlKGYsIHhmKSB7IHJldHVybiBuZXcgWERyb3BXaGlsZShmLCB4Zik7IH0pO1xufSgpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfVxufTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRmlsdGVyKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaWx0ZXIucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZihpbnB1dCkgPyB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpIDogcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmlsdGVyKGYsIHhmKSB7IHJldHVybiBuZXcgWEZpbHRlcihmLCB4Zik7IH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL19yZWR1Y2VkJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRmluZChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgfVxuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kKGYsIHhmKSB7IHJldHVybiBuZXcgWEZpbmQoZiwgeGYpOyB9KTtcbn0oKSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF9yZWR1Y2VkID0gcmVxdWlyZSgnLi9fcmVkdWNlZCcpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWEZpbmRJbmRleChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuaWR4ID0gLTE7XG4gICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICB9XG4gIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuaWR4ICs9IDE7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuaWR4KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kSW5kZXgoZiwgeGYpIHsgcmV0dXJuIG5ldyBYRmluZEluZGV4KGYsIHhmKTsgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhGaW5kTGFzdChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMubGFzdCkpO1xuICB9O1xuICBYRmluZExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRMYXN0KGYsIHhmKSB7IHJldHVybiBuZXcgWEZpbmRMYXN0KGYsIHhmKTsgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhGaW5kTGFzdEluZGV4KGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy5pZHggPSAtMTtcbiAgICB0aGlzLmxhc3RJZHggPSAtMTtcbiAgfVxuICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kTGFzdEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5sYXN0SWR4KSk7XG4gIH07XG4gIFhGaW5kTGFzdEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmlkeCArPSAxO1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxhc3RJZHggPSB0aGlzLmlkeDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRMYXN0SW5kZXgoZiwgeGYpIHsgcmV0dXJuIG5ldyBYRmluZExhc3RJbmRleChmLCB4Zik7IH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYTWFwKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmYoaW5wdXQpKTtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeG1hcChmLCB4ZikgeyByZXR1cm4gbmV3IFhNYXAoZiwgeGYpOyB9KTtcbn0oKSk7XG4iLCJ2YXIgX2N1cnJ5TiA9IHJlcXVpcmUoJy4vX2N1cnJ5TicpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhSZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKSB7XG4gICAgdGhpcy52YWx1ZUZuID0gdmFsdWVGbjtcbiAgICB0aGlzLnZhbHVlQWNjID0gdmFsdWVBY2M7XG4gICAgdGhpcy5rZXlGbiA9IGtleUZuO1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmlucHV0cyA9IHt9O1xuICB9XG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5pbnB1dHMpIHtcbiAgICAgIGlmIChfaGFzKGtleSwgdGhpcy5pbnB1dHMpKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlucHV0c1trZXldKTtcbiAgICAgICAgaWYgKHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnB1dHMgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWFJlZHVjZUJ5LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXlGbihpbnB1dCk7XG4gICAgdGhpcy5pbnB1dHNba2V5XSA9IHRoaXMuaW5wdXRzW2tleV0gfHwgW2tleSwgdGhpcy52YWx1ZUFjY107XG4gICAgdGhpcy5pbnB1dHNba2V5XVsxXSA9IHRoaXMudmFsdWVGbih0aGlzLmlucHV0c1trZXldWzFdLCBpbnB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5Tig0LCBbXSxcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX3hyZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYUmVkdWNlQnkodmFsdWVGbiwgdmFsdWVBY2MsIGtleUZuLCB4Zik7XG4gICAgICAgICAgICAgICAgIH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL19yZWR1Y2VkJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWFRha2UobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLmkgPSAwO1xuICB9XG4gIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuaSArPSAxO1xuICAgIHZhciByZXQgPSB0aGlzLm4gPT09IDAgPyByZXN1bHQgOiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLmkgPj0gdGhpcy5uID8gX3JlZHVjZWQocmV0KSA6IHJldDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeHRha2UobiwgeGYpIHsgcmV0dXJuIG5ldyBYVGFrZShuLCB4Zik7IH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL19yZWR1Y2VkJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYVGFrZVdoaWxlKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWFRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWFRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZihpbnB1dCkgPyB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpIDogX3JlZHVjZWQocmVzdWx0KTtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeHRha2VXaGlsZShmLCB4ZikgeyByZXR1cm4gbmV3IFhUYWtlV2hpbGUoZiwgeGYpOyB9KTtcbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWFdyYXAoZm4pIHtcbiAgICB0aGlzLmYgPSBmbjtcbiAgfVxuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbm90IGltcGxlbWVudGVkIG9uIFhXcmFwJyk7XG4gIH07XG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24oYWNjKSB7IHJldHVybiBhY2M7IH07XG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKGFjYywgeCkge1xuICAgIHJldHVybiB0aGlzLmYoYWNjLCB4KTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gX3h3cmFwKGZuKSB7IHJldHVybiBuZXcgWFdyYXAoZm4pOyB9O1xufSgpKTtcbiIsInZhciBfY29udGFpbnMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb250YWlucycpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZmlsdGVyJyk7XG52YXIgZmxpcCA9IHJlcXVpcmUoJy4vZmxpcCcpO1xudmFyIHVuaXEgPSByZXF1aXJlKCcuL3VuaXEnKTtcblxuXG4vKipcbiAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRob3NlXG4gKiBlbGVtZW50cyBjb21tb24gdG8gYm90aCBsaXN0cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgZWxlbWVudHMgZm91bmQgaW4gYm90aCBgbGlzdDFgIGFuZCBgbGlzdDJgLlxuICogQHNlZSBSLmludGVyc2VjdGlvbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmludGVyc2VjdGlvbihbMSwyLDMsNF0sIFs3LDYsNSw0LDNdKTsgLy89PiBbNCwgM11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGludGVyc2VjdGlvbihsaXN0MSwgbGlzdDIpIHtcbiAgdmFyIGxvb2t1cExpc3QsIGZpbHRlcmVkTGlzdDtcbiAgaWYgKGxpc3QxLmxlbmd0aCA+IGxpc3QyLmxlbmd0aCkge1xuICAgIGxvb2t1cExpc3QgPSBsaXN0MTtcbiAgICBmaWx0ZXJlZExpc3QgPSBsaXN0MjtcbiAgfSBlbHNlIHtcbiAgICBsb29rdXBMaXN0ID0gbGlzdDI7XG4gICAgZmlsdGVyZWRMaXN0ID0gbGlzdDE7XG4gIH1cbiAgcmV0dXJuIHVuaXEoX2ZpbHRlcihmbGlwKF9jb250YWlucykobG9va3VwTGlzdCksIGZpbHRlcmVkTGlzdCkpO1xufSk7XG4iLCJ2YXIgX2NvbnRhaW5zV2l0aCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbnRhaW5zV2l0aCcpO1xudmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciB1bmlxV2l0aCA9IHJlcXVpcmUoJy4vdW5pcVdpdGgnKTtcblxuXG4vKipcbiAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRob3NlXG4gKiBlbGVtZW50cyBjb21tb24gdG8gYm90aCBsaXN0cy4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlXG4gKiB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAqICAgICAgICB0aGUgdHdvIHN1cHBsaWVkIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIE9uZSBsaXN0IG9mIGl0ZW1zIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIEEgc2Vjb25kIGxpc3Qgb2YgaXRlbXMgdG8gY29tcGFyZVxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3QgY29udGFpbmluZyB0aG9zZSBlbGVtZW50cyBjb21tb24gdG8gYm90aCBsaXN0cy5cbiAqIEBzZWUgUi5pbnRlcnNlY3Rpb25cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYnVmZmFsb1NwcmluZ2ZpZWxkID0gW1xuICogICAgICAgIHtpZDogODI0LCBuYW1lOiAnUmljaGllIEZ1cmF5J30sXG4gKiAgICAgICAge2lkOiA5NTYsIG5hbWU6ICdEZXdleSBNYXJ0aW4nfSxcbiAqICAgICAgICB7aWQ6IDMxMywgbmFtZTogJ0JydWNlIFBhbG1lcid9LFxuICogICAgICAgIHtpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSxcbiAqICAgICAgICB7aWQ6IDE3NywgbmFtZTogJ05laWwgWW91bmcnfVxuICogICAgICBdO1xuICogICAgICB2YXIgY3NueSA9IFtcbiAqICAgICAgICB7aWQ6IDIwNCwgbmFtZTogJ0RhdmlkIENyb3NieSd9LFxuICogICAgICAgIHtpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSxcbiAqICAgICAgICB7aWQ6IDUzOSwgbmFtZTogJ0dyYWhhbSBOYXNoJ30sXG4gKiAgICAgICAge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31cbiAqICAgICAgXTtcbiAqXG4gKiAgICAgIFIuaW50ZXJzZWN0aW9uV2l0aChSLmVxQnkoUi5wcm9wKCdpZCcpKSwgYnVmZmFsb1NwcmluZ2ZpZWxkLCBjc255KTtcbiAqICAgICAgLy89PiBbe2lkOiA0NTYsIG5hbWU6ICdTdGVwaGVuIFN0aWxscyd9LCB7aWQ6IDE3NywgbmFtZTogJ05laWwgWW91bmcnfV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGludGVyc2VjdGlvbldpdGgocHJlZCwgbGlzdDEsIGxpc3QyKSB7XG4gIHZhciBsb29rdXBMaXN0LCBmaWx0ZXJlZExpc3Q7XG4gIGlmIChsaXN0MS5sZW5ndGggPiBsaXN0Mi5sZW5ndGgpIHtcbiAgICBsb29rdXBMaXN0ID0gbGlzdDE7XG4gICAgZmlsdGVyZWRMaXN0ID0gbGlzdDI7XG4gIH0gZWxzZSB7XG4gICAgbG9va3VwTGlzdCA9IGxpc3QyO1xuICAgIGZpbHRlcmVkTGlzdCA9IGxpc3QxO1xuICB9XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgZmlsdGVyZWRMaXN0Lmxlbmd0aCkge1xuICAgIGlmIChfY29udGFpbnNXaXRoKHByZWQsIGZpbHRlcmVkTGlzdFtpZHhdLCBsb29rdXBMaXN0KSkge1xuICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBmaWx0ZXJlZExpc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHVuaXFXaXRoKHByZWQsIHJlc3VsdHMpO1xufSk7XG4iLCJ2YXIgX2NoZWNrRm9yTWV0aG9kID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgd2l0aCB0aGUgc2VwYXJhdG9yIGludGVycG9zZWQgYmV0d2VlbiBlbGVtZW50cy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgaW50ZXJzcGVyc2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHsqfSBzZXBhcmF0b3IgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBiZSBpbnRlcnBvc2VkLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmludGVyc3BlcnNlKCduJywgWydiYScsICdhJywgJ2EnXSk7IC8vPT4gWydiYScsICduJywgJ2EnLCAnbicsICdhJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9jaGVja0Zvck1ldGhvZCgnaW50ZXJzcGVyc2UnLCBmdW5jdGlvbiBpbnRlcnNwZXJzZShzZXBhcmF0b3IsIGxpc3QpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGlkeCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgb3V0LnB1c2gobGlzdFtpZHhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0LnB1c2gobGlzdFtpZHhdLCBzZXBhcmF0b3IpO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSkpO1xuIiwidmFyIF9jbG9uZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Nsb25lJyk7XG52YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIF9pc1RyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNUcmFuc2Zvcm1lcicpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBfc3RlcENhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3N0ZXBDYXQnKTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGl0ZW1zIG9mIHRoZSBsaXN0IHdpdGggdGhlIHRyYW5zZHVjZXIgYW5kIGFwcGVuZHMgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyB0byB0aGUgYWNjdW11bGF0b3IgdXNpbmcgYW4gYXBwcm9wcmlhdGUgaXRlcmF0b3IgZnVuY3Rpb25cbiAqIGJhc2VkIG9uIHRoZSBhY2N1bXVsYXRvciB0eXBlLlxuICpcbiAqIFRoZSBhY2N1bXVsYXRvciBjYW4gYmUgYW4gYXJyYXksIHN0cmluZywgb2JqZWN0IG9yIGEgdHJhbnNmb3JtZXIuIEl0ZXJhdGVkXG4gKiBpdGVtcyB3aWxsIGJlIGFwcGVuZGVkIHRvIGFycmF5cyBhbmQgY29uY2F0ZW5hdGVkIHRvIHN0cmluZ3MuIE9iamVjdHMgd2lsbFxuICogYmUgbWVyZ2VkIGRpcmVjdGx5IG9yIDItaXRlbSBhcnJheXMgd2lsbCBiZSBtZXJnZWQgYXMga2V5LCB2YWx1ZSBwYWlycy5cbiAqXG4gKiBUaGUgYWNjdW11bGF0b3IgY2FuIGFsc28gYmUgYSB0cmFuc2Zvcm1lciBvYmplY3QgdGhhdCBwcm92aWRlcyBhIDItYXJpdHlcbiAqIHJlZHVjaW5nIGl0ZXJhdG9yIGZ1bmN0aW9uLCBzdGVwLCAwLWFyaXR5IGluaXRpYWwgdmFsdWUgZnVuY3Rpb24sIGluaXQsIGFuZFxuICogMS1hcml0eSByZXN1bHQgZXh0cmFjdGlvbiBmdW5jdGlvbiByZXN1bHQuIFRoZSBzdGVwIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlXG4gKiBpdGVyYXRvciBmdW5jdGlvbiBpbiByZWR1Y2UuIFRoZSByZXN1bHQgZnVuY3Rpb24gaXMgdXNlZCB0byBjb252ZXJ0IHRoZVxuICogZmluYWwgYWNjdW11bGF0b3IgaW50byB0aGUgcmV0dXJuIHR5cGUgYW5kIGluIG1vc3QgY2FzZXMgaXMgUi5pZGVudGl0eS4gVGhlXG4gKiBpbml0IGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJvdmlkZSB0aGUgaW5pdGlhbCBhY2N1bXVsYXRvci5cbiAqXG4gKiBUaGUgaXRlcmF0aW9uIGlzIHBlcmZvcm1lZCB3aXRoIFIucmVkdWNlIGFmdGVyIGluaXRpYWxpemluZyB0aGUgdHJhbnNkdWNlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IChiIC0+IGIpIC0+IFtjXSAtPiBhXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIFRoZSB0cmFuc2R1Y2VyIGZ1bmN0aW9uLiBSZWNlaXZlcyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGEgdHJhbnNmb3JtZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gKiAgICAgIHZhciB0cmFuc2R1Y2VyID0gUi5jb21wb3NlKFIubWFwKFIuYWRkKDEpKSwgUi50YWtlKDIpKTtcbiAqXG4gKiAgICAgIFIuaW50byhbXSwgdHJhbnNkdWNlciwgbnVtYmVycyk7IC8vPT4gWzIsIDNdXG4gKlxuICogICAgICB2YXIgaW50b0FycmF5ID0gUi5pbnRvKFtdKTtcbiAqICAgICAgaW50b0FycmF5KHRyYW5zZHVjZXIsIG51bWJlcnMpOyAvLz0+IFsyLCAzXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gaW50byhhY2MsIHhmLCBsaXN0KSB7XG4gIHJldHVybiBfaXNUcmFuc2Zvcm1lcihhY2MpID9cbiAgICBfcmVkdWNlKHhmKGFjYyksIGFjY1snQEB0cmFuc2R1Y2VyL2luaXQnXSgpLCBsaXN0KSA6XG4gICAgX3JlZHVjZSh4Zihfc3RlcENhdChhY2MpKSwgX2Nsb25lKGFjYywgW10sIFtdLCBmYWxzZSksIGxpc3QpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuLyoqXG4gKiBTYW1lIGFzIFIuaW52ZXJ0T2JqLCBob3dldmVyIHRoaXMgYWNjb3VudHMgZm9yIG9iamVjdHMgd2l0aCBkdXBsaWNhdGUgdmFsdWVzXG4gKiBieSBwdXR0aW5nIHRoZSB2YWx1ZXMgaW50byBhbiBhcnJheS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge3M6IHh9IC0+IHt4OiBbIHMsIC4uLiBdfVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGludmVydFxuICogQHJldHVybiB7T2JqZWN0fSBvdXQgQSBuZXcgb2JqZWN0IHdpdGgga2V5c1xuICogaW4gYW4gYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHJhY2VSZXN1bHRzQnlGaXJzdE5hbWUgPSB7XG4gKiAgICAgICAgZmlyc3Q6ICdhbGljZScsXG4gKiAgICAgICAgc2Vjb25kOiAnamFrZScsXG4gKiAgICAgICAgdGhpcmQ6ICdhbGljZScsXG4gKiAgICAgIH07XG4gKiAgICAgIFIuaW52ZXJ0KHJhY2VSZXN1bHRzQnlGaXJzdE5hbWUpO1xuICogICAgICAvLz0+IHsgJ2FsaWNlJzogWydmaXJzdCcsICd0aGlyZCddLCAnamFrZSc6WydzZWNvbmQnXSB9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBpbnZlcnQob2JqKSB7XG4gIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBvdXQgPSB7fTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2lkeF07XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgIHZhciBsaXN0ID0gX2hhcyh2YWwsIG91dCkgPyBvdXRbdmFsXSA6IChvdXRbdmFsXSA9IFtdKTtcbiAgICBsaXN0W2xpc3QubGVuZ3RoXSA9IGtleTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdCBhcyB2YWx1ZXMsIGFuZCB0aGVcbiAqIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCB3aGljaCBhcmUgY29lcmNlZCB0byBzdHJpbmdzLCBhcyBrZXlzLiBOb3RlXG4gKiB0aGF0IHRoZSBsYXN0IGtleSBmb3VuZCBpcyBwcmVmZXJyZWQgd2hlbiBoYW5kbGluZyB0aGUgc2FtZSB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge3M6IHh9IC0+IHt4OiBzfVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGludmVydFxuICogQHJldHVybiB7T2JqZWN0fSBvdXQgQSBuZXcgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHJhY2VSZXN1bHRzID0ge1xuICogICAgICAgIGZpcnN0OiAnYWxpY2UnLFxuICogICAgICAgIHNlY29uZDogJ2pha2UnXG4gKiAgICAgIH07XG4gKiAgICAgIFIuaW52ZXJ0T2JqKHJhY2VSZXN1bHRzKTtcbiAqICAgICAgLy89PiB7ICdhbGljZSc6ICdmaXJzdCcsICdqYWtlJzonc2Vjb25kJyB9XG4gKlxuICogICAgICAvLyBBbHRlcm5hdGl2ZWx5OlxuICogICAgICB2YXIgcmFjZVJlc3VsdHMgPSBbJ2FsaWNlJywgJ2pha2UnXTtcbiAqICAgICAgUi5pbnZlcnRPYmoocmFjZVJlc3VsdHMpO1xuICogICAgICAvLz0+IHsgJ2FsaWNlJzogJzAnLCAnamFrZSc6JzEnIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGludmVydE9iaihvYmopIHtcbiAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIG91dCA9IHt9O1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaWR4XTtcbiAgICBvdXRbb2JqW2tleV1dID0ga2V5O1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2lzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0Z1bmN0aW9uJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuXG4vKipcbiAqIFR1cm5zIGEgbmFtZWQgbWV0aG9kIHdpdGggYSBzcGVjaWZpZWQgYXJpdHkgaW50byBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiBjYWxsZWQgZGlyZWN0bHkgc3VwcGxpZWQgd2l0aCBhcmd1bWVudHMgYW5kIGEgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gaXMgY3VycmllZCBhbmQgYWNjZXB0cyBgYXJpdHkgKyAxYCBwYXJhbWV0ZXJzIHdoZXJlXG4gKiB0aGUgZmluYWwgcGFyYW1ldGVyIGlzIHRoZSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gKGEgLT4gYiAtPiAuLi4gLT4gbiAtPiBPYmplY3QgLT4gKilcbiAqIEBwYXJhbSB7TnVtYmVyfSBhcml0eSBOdW1iZXIgb2YgYXJndW1lbnRzIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBzaG91bGQgdGFrZVxuICogICAgICAgIGJlZm9yZSB0aGUgdGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTmFtZSBvZiB0aGUgbWV0aG9kIHRvIGNhbGwuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgc2xpY2VGcm9tID0gUi5pbnZva2VyKDEsICdzbGljZScpO1xuICogICAgICBzbGljZUZyb20oNiwgJ2FiY2RlZmdoaWprbG0nKTsgLy89PiAnZ2hpamtsbSdcbiAqICAgICAgdmFyIHNsaWNlRnJvbTYgPSBSLmludm9rZXIoMiwgJ3NsaWNlJykoNik7XG4gKiAgICAgIHNsaWNlRnJvbTYoOCwgJ2FiY2RlZmdoaWprbG0nKTsgLy89PiAnZ2gnXG4gKiBAc3ltYiBSLmludm9rZXIoMCwgJ21ldGhvZCcpKG8pID0gb1snbWV0aG9kJ10oKVxuICogQHN5bWIgUi5pbnZva2VyKDEsICdtZXRob2QnKShhLCBvKSA9IG9bJ21ldGhvZCddKGEpXG4gKiBAc3ltYiBSLmludm9rZXIoMiwgJ21ldGhvZCcpKGEsIGIsIG8pID0gb1snbWV0aG9kJ10oYSwgYilcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGludm9rZXIoYXJpdHksIG1ldGhvZCkge1xuICByZXR1cm4gY3VycnlOKGFyaXR5ICsgMSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1thcml0eV07XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIF9pc0Z1bmN0aW9uKHRhcmdldFttZXRob2RdKSkge1xuICAgICAgcmV0dXJuIHRhcmdldFttZXRob2RdLmFwcGx5KHRhcmdldCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBhcml0eSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKHRhcmdldCkgKyAnIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gIH0pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogU2VlIGlmIGFuIG9iamVjdCAoYHZhbGApIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBzdXBwbGllZCBjb25zdHJ1Y3Rvci4gVGhpc1xuICogZnVuY3Rpb24gd2lsbCBjaGVjayB1cCB0aGUgaW5oZXJpdGFuY2UgY2hhaW4sIGlmIGFueS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICgqIC0+IHsqfSkgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH0gY3RvciBBIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmlzKE9iamVjdCwge30pOyAvLz0+IHRydWVcbiAqICAgICAgUi5pcyhOdW1iZXIsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pcyhPYmplY3QsIDEpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXMoU3RyaW5nLCAncycpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pcyhTdHJpbmcsIG5ldyBTdHJpbmcoJycpKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoT2JqZWN0LCBuZXcgU3RyaW5nKCcnKSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKE9iamVjdCwgJ3MnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzKE51bWJlciwge30pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBpcyhDdG9yLCB2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQ3RvciB8fCB2YWwgaW5zdGFuY2VvZiBDdG9yO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNBcnJheScpO1xudmFyIF9pc1N0cmluZyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgc2ltaWxhciB0byBhbiBhcnJheS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC41LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGhhcyBhIG51bWVyaWMgbGVuZ3RoIHByb3BlcnR5IGFuZCBleHRyZW1lIGluZGljZXMgZGVmaW5lZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2MC4yMy4wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pc0FycmF5TGlrZShbXSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzQXJyYXlMaWtlKHRydWUpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNBcnJheUxpa2Uoe2xlbmd0aDogMTB9KTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzQXJyYXlMaWtlKHswOiAnemVybycsIDk6ICduaW5lJywgbGVuZ3RoOiAxMH0pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHgpIHtcbiAgaWYgKF9pc0FycmF5KHgpKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmICgheCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKF9pc1N0cmluZyh4KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHgubm9kZVR5cGUgPT09IDEpIHsgcmV0dXJuICEheC5sZW5ndGg7IH1cbiAgaWYgKHgubGVuZ3RoID09PSAwKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4geC5oYXNPd25Qcm9wZXJ0eSgwKSAmJiB4Lmhhc093blByb3BlcnR5KHgubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGVtcHR5ID0gcmVxdWlyZSgnLi9lbXB0eScpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgaXRzIHR5cGUncyBlbXB0eSB2YWx1ZTsgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmVtcHR5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pc0VtcHR5KFsxLCAyLCAzXSk7ICAgLy89PiBmYWxzZVxuICogICAgICBSLmlzRW1wdHkoW10pOyAgICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgUi5pc0VtcHR5KCcnKTsgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNFbXB0eShudWxsKTsgICAgICAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc0VtcHR5KHt9KTsgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNFbXB0eSh7bGVuZ3RoOiAwfSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGlzRW1wdHkoeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIGVxdWFscyh4LCBlbXB0eSh4KSk7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKDApOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNOaWwoW10pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBpc05pbCh4KSB7IHJldHVybiB4ID09IG51bGw7IH0pO1xuIiwidmFyIGludm9rZXIgPSByZXF1aXJlKCcuL2ludm9rZXInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgbWFkZSBieSBpbnNlcnRpbmcgdGhlIGBzZXBhcmF0b3JgIGJldHdlZW4gZWFjaCBlbGVtZW50IGFuZFxuICogY29uY2F0ZW5hdGluZyBhbGwgdGhlIGVsZW1lbnRzIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgU3RyaW5nIC0+IFthXSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gc2VwYXJhdG9yIFRoZSBzdHJpbmcgdXNlZCB0byBzZXBhcmF0ZSB0aGUgZWxlbWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgZWxlbWVudHMgdG8gam9pbiBpbnRvIGEgc3RyaW5nLlxuICogQHJldHVybiB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyBtYWRlIGJ5IGNvbmNhdGVuYXRpbmcgYHhzYCB3aXRoIGBzZXBhcmF0b3JgLlxuICogQHNlZSBSLnNwbGl0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHNwYWNlciA9IFIuam9pbignICcpO1xuICogICAgICBzcGFjZXIoWydhJywgMiwgMy40XSk7ICAgLy89PiAnYSAyIDMuNCdcbiAqICAgICAgUi5qb2luKCd8JywgWzEsIDIsIDNdKTsgICAgLy89PiAnMXwyfDMnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gaW52b2tlcigxLCAnam9pbicpO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBjb252ZXJnZSA9IHJlcXVpcmUoJy4vY29udmVyZ2UnKTtcblxuXG4vKipcbiAqIGp1eHQgYXBwbGllcyBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGEgbGlzdCBvZiB2YWx1ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIFsoYSwgYiwgLi4uLCBtKSAtPiBuXSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4gW25dKVxuICogQHBhcmFtIHtBcnJheX0gZm5zIEFuIGFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiB2YWx1ZXMgYWZ0ZXIgYXBwbHlpbmcgZWFjaCBvZiB0aGUgb3JpZ2luYWwgYGZuc2AgdG8gaXRzIHBhcmFtZXRlcnMuXG4gKiBAc2VlIFIuYXBwbHlTcGVjXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdldFJhbmdlID0gUi5qdXh0KFtNYXRoLm1pbiwgTWF0aC5tYXhdKTtcbiAqICAgICAgZ2V0UmFuZ2UoMywgNCwgOSwgLTMpOyAvLz0+IFstMywgOV1cbiAqIEBzeW1iIFIuanV4dChbZiwgZywgaF0pKGEsIGIpID0gW2YoYSwgYiksIGcoYSwgYiksIGgoYSwgYildXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBqdXh0KGZucykge1xuICByZXR1cm4gY29udmVyZ2UoZnVuY3Rpb24oKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApOyB9LCBmbnMpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcbnZhciBfaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0FyZ3VtZW50cycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIG9mXG4gKiB0aGUgc3VwcGxpZWQgb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4gW2tdXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5rZXlzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWydhJywgJ2InLCAnYyddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvLyBjb3ZlciBJRSA8IDkga2V5cyBpc3N1ZXNcbiAgdmFyIGhhc0VudW1CdWcgPSAhKHt0b1N0cmluZzogbnVsbH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWydjb25zdHJ1Y3RvcicsICd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuICAvLyBTYWZhcmkgYnVnXG4gIHZhciBoYXNBcmdzRW51bUJ1ZyA9IChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5wcm9wZXJ0eUlzRW51bWVyYWJsZSgnbGVuZ3RoJyk7XG4gIH0oKSk7XG5cbiAgdmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobGlzdCwgaXRlbSkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgaWYgKGxpc3RbaWR4XSA9PT0gaXRlbSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhaGFzQXJnc0VudW1CdWcgP1xuICAgIF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3Qob2JqKSAhPT0gb2JqID8gW10gOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIH0pIDpcbiAgICBfY3VycnkxKGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gICAgICBpZiAoT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcHJvcCwgbklkeDtcbiAgICAgIHZhciBrcyA9IFtdO1xuICAgICAgdmFyIGNoZWNrQXJnc0xlbmd0aCA9IGhhc0FyZ3NFbnVtQnVnICYmIF9pc0FyZ3VtZW50cyhvYmopO1xuICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoX2hhcyhwcm9wLCBvYmopICYmICghY2hlY2tBcmdzTGVuZ3RoIHx8IHByb3AgIT09ICdsZW5ndGgnKSkge1xuICAgICAgICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzRW51bUJ1Zykge1xuICAgICAgICBuSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChuSWR4ID49IDApIHtcbiAgICAgICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25JZHhdO1xuICAgICAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgIWNvbnRhaW5zKGtzLCBwcm9wKSkge1xuICAgICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5JZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtzO1xuICAgIH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHN1cHBsaWVkXG4gKiBvYmplY3QsIGluY2x1ZGluZyBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICogICAgICB2YXIgZiA9IG5ldyBGKCk7XG4gKiAgICAgIFIua2V5c0luKGYpOyAvLz0+IFsneCcsICd5J11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGtleXNJbihvYmopIHtcbiAgdmFyIHByb3A7XG4gIHZhciBrcyA9IFtdO1xuICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gIH1cbiAgcmV0dXJuIGtzO1xufSk7XG4iLCJ2YXIgbnRoID0gcmVxdWlyZSgnLi9udGgnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS40XG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuaW5pdCwgUi5oZWFkLCBSLnRhaWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmxhc3QoWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gJ2Z1bSdcbiAqICAgICAgUi5sYXN0KFtdKTsgLy89PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgIFIubGFzdCgnYWJjJyk7IC8vPT4gJ2MnXG4gKiAgICAgIFIubGFzdCgnJyk7IC8vPT4gJydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBudGgoLTEpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJyYXknKTtcbnZhciBlcXVhbHMgPSByZXF1aXJlKCcuL2VxdWFscycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZlxuICogdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gYFIuZXF1YWxzYCBpcyB1c2VkIHRvIGRldGVybWluZVxuICogZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCwgb3IgLTEgaWYgdGhlIHRhcmdldCBpcyBub3QgZm91bmQuXG4gKiBAc2VlIFIuaW5kZXhPZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubGFzdEluZGV4T2YoMywgWy0xLDMsMywwLDEsMiwzLDRdKTsgLy89PiA2XG4gKiAgICAgIFIubGFzdEluZGV4T2YoMTAsIFsxLDIsMyw0XSk7IC8vPT4gLTFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGxhc3RJbmRleE9mKHRhcmdldCwgeHMpIHtcbiAgaWYgKHR5cGVvZiB4cy5sYXN0SW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpKSB7XG4gICAgcmV0dXJuIHhzLmxhc3RJbmRleE9mKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkeCA9IHhzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICBpZiAoZXF1YWxzKHhzW2lkeF0sIHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIGlkeCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfaXNOdW1iZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc051bWJlcicpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSBieSByZXR1cm5pbmcgYGxpc3QubGVuZ3RoYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubGVuZ3RoKFtdKTsgLy89PiAwXG4gKiAgICAgIFIubGVuZ3RoKFsxLCAyLCAzXSk7IC8vPT4gM1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbGVuZ3RoKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QgIT0gbnVsbCAmJiBfaXNOdW1iZXIobGlzdC5sZW5ndGgpID8gbGlzdC5sZW5ndGggOiBOYU47XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsZW5zIGZvciB0aGUgZ2l2ZW4gZ2V0dGVyIGFuZCBzZXR0ZXIgZnVuY3Rpb25zLiBUaGUgZ2V0dGVyIFwiZ2V0c1wiXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzOyB0aGUgc2V0dGVyIFwic2V0c1wiIHRoZSB2YWx1ZSBvZiB0aGUgZm9jdXMuIFRoZSBzZXR0ZXJcbiAqIHNob3VsZCBub3QgbXV0YXRlIHRoZSBkYXRhIHN0cnVjdHVyZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIChzIC0+IGEpIC0+ICgoYSwgcykgLT4gcykgLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyXG4gKiBAcmV0dXJuIHtMZW5zfVxuICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXIsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zKFIucHJvcCgneCcpLCBSLmFzc29jKCd4JykpO1xuICpcbiAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgICAgICAgICAgIC8vPT4gMVxuICogICAgICBSLnNldCh4TGVucywgNCwge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgLy89PiB7eDogNCwgeTogMn1cbiAqICAgICAgUi5vdmVyKHhMZW5zLCBSLm5lZ2F0ZSwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IC0xLCB5OiAyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbGVucyhnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4gZnVuY3Rpb24odG9GdW5jdG9yRm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICByZXR1cm4gbWFwKFxuICAgICAgICBmdW5jdGlvbihmb2N1cykge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIoZm9jdXMsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvRnVuY3RvckZuKGdldHRlcih0YXJnZXQpKVxuICAgICAgKTtcbiAgICB9O1xuICB9O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGxlbnMgPSByZXF1aXJlKCcuL2xlbnMnKTtcbnZhciBudGggPSByZXF1aXJlKCcuL250aCcpO1xudmFyIHVwZGF0ZSA9IHJlcXVpcmUoJy4vdXBkYXRlJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIE51bWJlciAtPiBMZW5zIHMgYVxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0xlbnN9XG4gKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBoZWFkTGVucyA9IFIubGVuc0luZGV4KDApO1xuICpcbiAqICAgICAgUi52aWV3KGhlYWRMZW5zLCBbJ2EnLCAnYicsICdjJ10pOyAgICAgICAgICAgIC8vPT4gJ2EnXG4gKiAgICAgIFIuc2V0KGhlYWRMZW5zLCAneCcsIFsnYScsICdiJywgJ2MnXSk7ICAgICAgICAvLz0+IFsneCcsICdiJywgJ2MnXVxuICogICAgICBSLm92ZXIoaGVhZExlbnMsIFIudG9VcHBlciwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbJ0EnLCAnYicsICdjJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGxlbnNJbmRleChuKSB7XG4gIHJldHVybiBsZW5zKG50aChuKSwgdXBkYXRlKG4pKTtcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBhc3NvY1BhdGggPSByZXF1aXJlKCcuL2Fzc29jUGF0aCcpO1xudmFyIGxlbnMgPSByZXF1aXJlKCcuL2xlbnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgW0lkeF0gLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gdXNlLlxuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhIZWFkWUxlbnMgPSBSLmxlbnNQYXRoKFsneCcsIDAsICd5J10pO1xuICpcbiAqICAgICAgUi52aWV3KHhIZWFkWUxlbnMsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4gMlxuICogICAgICBSLnNldCh4SGVhZFlMZW5zLCAxLCB7eDogW3t5OiAyLCB6OiAzfSwge3k6IDQsIHo6IDV9XX0pO1xuICogICAgICAvLz0+IHt4OiBbe3k6IDEsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICogICAgICBSLm92ZXIoeEhlYWRZTGVucywgUi5uZWdhdGUsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4ge3g6IFt7eTogLTIsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbGVuc1BhdGgocCkge1xuICByZXR1cm4gbGVucyhwYXRoKHApLCBhc3NvY1BhdGgocCkpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGFzc29jID0gcmVxdWlyZSgnLi9hc3NvYycpO1xudmFyIGxlbnMgPSByZXF1aXJlKCcuL2xlbnMnKTtcbnZhciBwcm9wID0gcmVxdWlyZSgnLi9wcm9wJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIFN0cmluZyAtPiBMZW5zIHMgYVxuICogQHBhcmFtIHtTdHJpbmd9IGtcbiAqIEByZXR1cm4ge0xlbnN9XG4gKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4TGVucyA9IFIubGVuc1Byb3AoJ3gnKTtcbiAqXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgICAvLz0+IDFcbiAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIub3Zlcih4TGVucywgUi5uZWdhdGUsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt4OiAtMSwgeTogMn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGxlbnNQcm9wKGspIHtcbiAgcmV0dXJuIGxlbnMocHJvcChrKSwgYXNzb2MoaykpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGxpZnROID0gcmVxdWlyZSgnLi9saWZ0TicpO1xuXG5cbi8qKlxuICogXCJsaWZ0c1wiIGEgZnVuY3Rpb24gb2YgYXJpdHkgPiAxIHNvIHRoYXQgaXQgbWF5IFwibWFwIG92ZXJcIiBhIGxpc3QsIEZ1bmN0aW9uIG9yIG90aGVyXG4gKiBvYmplY3QgdGhhdCBzYXRpc2ZpZXMgdGhlIFtGYW50YXN5TGFuZCBBcHBseSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5KS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBsaWZ0IGludG8gaGlnaGVyIGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbGlmdGVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmxpZnROXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG1hZGQzID0gUi5saWZ0KChhLCBiLCBjKSA9PiBhICsgYiArIGMpO1xuICpcbiAqICAgICAgbWFkZDMoWzEsMiwzXSwgWzEsMiwzXSwgWzFdKTsgLy89PiBbMywgNCwgNSwgNCwgNSwgNiwgNSwgNiwgN11cbiAqXG4gKiAgICAgIHZhciBtYWRkNSA9IFIubGlmdCgoYSwgYiwgYywgZCwgZSkgPT4gYSArIGIgKyBjICsgZCArIGUpO1xuICpcbiAqICAgICAgbWFkZDUoWzEsMl0sIFszXSwgWzQsIDVdLCBbNl0sIFs3LCA4XSk7IC8vPT4gWzIxLCAyMiwgMjIsIDIzLCAyMiwgMjMsIDIzLCAyNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGxpZnQoZm4pIHtcbiAgcmV0dXJuIGxpZnROKGZuLmxlbmd0aCwgZm4pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBhcCA9IHJlcXVpcmUoJy4vYXAnKTtcbnZhciBjdXJyeU4gPSByZXF1aXJlKCcuL2N1cnJ5TicpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cblxuLyoqXG4gKiBcImxpZnRzXCIgYSBmdW5jdGlvbiB0byBiZSB0aGUgc3BlY2lmaWVkIGFyaXR5LCBzbyB0aGF0IGl0IG1heSBcIm1hcCBvdmVyXCIgdGhhdFxuICogbWFueSBsaXN0cywgRnVuY3Rpb25zIG9yIG90aGVyIG9iamVjdHMgdGhhdCBzYXRpc2Z5IHRoZSBbRmFudGFzeUxhbmQgQXBwbHkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBseSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqLi4uIC0+ICopIC0+IChbKl0uLi4gLT4gWypdKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGxpZnQgaW50byBoaWdoZXIgY29udGV4dFxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBsaWZ0ZWQgZnVuY3Rpb24uXG4gKiBAc2VlIFIubGlmdCwgUi5hcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtYWRkMyA9IFIubGlmdE4oMywgKC4uLmFyZ3MpID0+IFIuc3VtKGFyZ3MpKTtcbiAqICAgICAgbWFkZDMoWzEsMiwzXSwgWzEsMiwzXSwgWzFdKTsgLy89PiBbMywgNCwgNSwgNCwgNSwgNiwgNSwgNiwgN11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGxpZnROKGFyaXR5LCBmbikge1xuICB2YXIgbGlmdGVkID0gY3VycnlOKGFyaXR5LCBmbik7XG4gIHJldHVybiBjdXJyeU4oYXJpdHksIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfcmVkdWNlKGFwLCBtYXAobGlmdGVkLCBhcmd1bWVudHNbMF0pLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfSk7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQ7IGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZ3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmx0KDIsIDEpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIubHQoMiwgMik7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5sdCgyLCAzKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHQoJ2EnLCAneicpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdCgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGx0KGEsIGIpIHsgcmV0dXJuIGEgPCBiOyB9KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmd0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubHRlKDIsIDEpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIubHRlKDIsIDIpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoMiwgMyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0ZSgnYScsICd6Jyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0ZSgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGx0ZShhLCBiKSB7IHJldHVybiBhIDw9IGI7IH0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX21hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX21hcCcpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBfeG1hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3htYXAnKTtcbnZhciBjdXJyeU4gPSByZXF1aXJlKCcuL2N1cnJ5TicpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kXG4gKiBhIFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpLFxuICogYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gZWFjaCBvZiB0aGUgZnVuY3RvcidzIHZhbHVlcywgYW5kIHJldHVybnNcbiAqIGEgZnVuY3RvciBvZiB0aGUgc2FtZSBzaGFwZS5cbiAqXG4gKiBSYW1kYSBwcm92aWRlcyBzdWl0YWJsZSBgbWFwYCBpbXBsZW1lbnRhdGlvbnMgZm9yIGBBcnJheWAgYW5kIGBPYmplY3RgLFxuICogc28gdGhpcyBmdW5jdGlvbiBtYXkgYmUgYXBwbGllZCB0byBgWzEsIDIsIDNdYCBvciBge3g6IDEsIHk6IDIsIHo6IDN9YC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgbWFwYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQWxzbyB0cmVhdHMgZnVuY3Rpb25zIGFzIGZ1bmN0b3JzIGFuZCB3aWxsIGNvbXBvc2UgdGhlbSB0b2dldGhlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gYmUgaXRlcmF0ZWQgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGxpc3QuXG4gKiBAc2VlIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRvdWJsZSA9IHggPT4geCAqIDI7XG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIFsxLCAyLCAzXSk7IC8vPT4gWzIsIDQsIDZdXG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIHt4OiAxLCB5OiAyLCB6OiAzfSk7IC8vPT4ge3g6IDIsIHk6IDQsIHo6IDZ9XG4gKiBAc3ltYiBSLm1hcChmLCBbYSwgYl0pID0gW2YoYSksIGYoYildXG4gKiBAc3ltYiBSLm1hcChmLCB7IHg6IGEsIHk6IGIgfSkgPSB7IHg6IGYoYSksIHk6IGYoYikgfVxuICogQHN5bWIgUi5tYXAoZiwgZnVuY3Rvcl9vKSA9IGZ1bmN0b3Jfby5tYXAoZilcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydtYXAnXSwgX3htYXAsIGZ1bmN0aW9uIG1hcChmbiwgZnVuY3Rvcikge1xuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmdW5jdG9yKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzpcbiAgICAgIHJldHVybiBjdXJyeU4oZnVuY3Rvci5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBmdW5jdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSk7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzpcbiAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gZm4oZnVuY3RvcltrZXldKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzKGZ1bmN0b3IpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF9tYXAoZm4sIGZ1bmN0b3IpO1xuICB9XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogVGhlIG1hcEFjY3VtIGZ1bmN0aW9uIGJlaGF2ZXMgbGlrZSBhIGNvbWJpbmF0aW9uIG9mIG1hcCBhbmQgcmVkdWNlOyBpdFxuICogYXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBvZiBhIGxpc3QsIHBhc3NpbmcgYW4gYWNjdW11bGF0aW5nXG4gKiBwYXJhbWV0ZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBhbmQgcmV0dXJuaW5nIGEgZmluYWwgdmFsdWUgb2YgdGhpc1xuICogYWNjdW11bGF0b3IgdG9nZXRoZXIgd2l0aCB0aGUgbmV3IGxpc3QuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBhcmd1bWVudHMsICphY2MqIGFuZCAqdmFsdWUqLCBhbmQgc2hvdWxkXG4gKiByZXR1cm4gYSB0dXBsZSAqW2FjYywgdmFsdWVdKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYWNjIC0+IHggLT4gKGFjYywgeSkpIC0+IGFjYyAtPiBbeF0gLT4gKGFjYywgW3ldKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIuYWRkSW5kZXgsIFIubWFwQWNjdW1SaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkaWdpdHMgPSBbJzEnLCAnMicsICczJywgJzQnXTtcbiAqICAgICAgdmFyIGFwcGVuZGVyID0gKGEsIGIpID0+IFthICsgYiwgYSArIGJdO1xuICpcbiAqICAgICAgUi5tYXBBY2N1bShhcHBlbmRlciwgMCwgZGlnaXRzKTsgLy89PiBbJzAxMjM0JywgWycwMScsICcwMTInLCAnMDEyMycsICcwMTIzNCddXVxuICogQHN5bWIgUi5tYXBBY2N1bShmLCBhLCBbYiwgYywgZF0pID0gW1xuICogICBmKGYoZihhLCBiKVswXSwgYylbMF0sIGQpWzBdLFxuICogICBbXG4gKiAgICAgZihhLCBiKVsxXSxcbiAqICAgICBmKGYoYSwgYilbMF0sIGMpWzFdLFxuICogICAgIGYoZihmKGEsIGIpWzBdLCBjKVswXSwgZClbMV1cbiAqICAgXVxuICogXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gbWFwQWNjdW0oZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB0dXBsZSA9IFthY2NdO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdHVwbGUgPSBmbih0dXBsZVswXSwgbGlzdFtpZHhdKTtcbiAgICByZXN1bHRbaWR4XSA9IHR1cGxlWzFdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBbdHVwbGVbMF0sIHJlc3VsdF07XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUaGUgbWFwQWNjdW1SaWdodCBmdW5jdGlvbiBiZWhhdmVzIGxpa2UgYSBjb21iaW5hdGlvbiBvZiBtYXAgYW5kIHJlZHVjZTsgaXRcbiAqIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBwYXNzaW5nIGFuIGFjY3VtdWxhdGluZ1xuICogcGFyYW1ldGVyIGZyb20gcmlnaHQgdG8gbGVmdCwgYW5kIHJldHVybmluZyBhIGZpbmFsIHZhbHVlIG9mIHRoaXNcbiAqIGFjY3VtdWxhdG9yIHRvZ2V0aGVyIHdpdGggdGhlIG5ldyBsaXN0LlxuICpcbiAqIFNpbWlsYXIgdG8gYG1hcEFjY3VtYCwgZXhjZXB0IG1vdmVzIHRocm91Z2ggdGhlIGlucHV0IGxpc3QgZnJvbSB0aGUgcmlnaHQgdG9cbiAqIHRoZSBsZWZ0LlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gYXJndW1lbnRzLCAqdmFsdWUqIGFuZCAqYWNjKiwgYW5kIHNob3VsZFxuICogcmV0dXJuIGEgdHVwbGUgKlt2YWx1ZSwgYWNjXSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKHgtPiBhY2MgLT4gKHksIGFjYykpIC0+IGFjYyAtPiBbeF0gLT4gKFt5XSwgYWNjKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIuYWRkSW5kZXgsIFIubWFwQWNjdW1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZGlnaXRzID0gWycxJywgJzInLCAnMycsICc0J107XG4gKiAgICAgIHZhciBhcHBlbmQgPSAoYSwgYikgPT4gW2EgKyBiLCBhICsgYl07XG4gKlxuICogICAgICBSLm1hcEFjY3VtUmlnaHQoYXBwZW5kLCA1LCBkaWdpdHMpOyAvLz0+IFtbJzEyMzQ1JywgJzIzNDUnLCAnMzQ1JywgJzQ1J10sICcxMjM0NSddXG4gKiBAc3ltYiBSLm1hcEFjY3VtUmlnaHQoZiwgYSwgW2IsIGMsIGRdKSA9IFtcbiAqICAgW1xuICogICAgIGYoYiwgZihjLCBmKGQsIGEpWzBdKVswXSlbMV0sXG4gKiAgICAgZihjLCBmKGQsIGEpWzBdKVsxXSxcbiAqICAgICBmKGQsIGEpWzFdLFxuICogICBdXG4gKiAgIGYoYiwgZihjLCBmKGQsIGEpWzBdKVswXSlbMF0sXG4gKiBdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXBBY2N1bVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdHVwbGUgPSBbYWNjXTtcbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgdHVwbGUgPSBmbihsaXN0W2lkeF0sIHR1cGxlWzBdKTtcbiAgICByZXN1bHRbaWR4XSA9IHR1cGxlWzFdO1xuICAgIGlkeCAtPSAxO1xuICB9XG4gIHJldHVybiBbcmVzdWx0LCB0dXBsZVswXV07XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG4vKipcbiAqIEFuIE9iamVjdC1zcGVjaWZpYyB2ZXJzaW9uIG9mIGBtYXBgLiBUaGUgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aHJlZVxuICogYXJndW1lbnRzOiAqKHZhbHVlLCBrZXksIG9iaikqLiBJZiBvbmx5IHRoZSB2YWx1ZSBpcyBzaWduaWZpY2FudCwgdXNlXG4gKiBgbWFwYCBpbnN0ZWFkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKCosIFN0cmluZywgT2JqZWN0KSAtPiAqKSAtPiBPYmplY3QgLT4gT2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1hcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB2YWx1ZXMgPSB7IHg6IDEsIHk6IDIsIHo6IDMgfTtcbiAqICAgICAgdmFyIHByZXBlbmRLZXlBbmREb3VibGUgPSAobnVtLCBrZXksIG9iaikgPT4ga2V5ICsgKG51bSAqIDIpO1xuICpcbiAqICAgICAgUi5tYXBPYmpJbmRleGVkKHByZXBlbmRLZXlBbmREb3VibGUsIHZhbHVlcyk7IC8vPT4geyB4OiAneDInLCB5OiAneTQnLCB6OiAnejYnIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG1hcE9iakluZGV4ZWQoZm4sIG9iaikge1xuICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgIGFjY1trZXldID0gZm4ob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSwga2V5cyhvYmopKTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFRlc3RzIGEgcmVndWxhciBleHByZXNzaW9uIGFnYWluc3QgYSBTdHJpbmcuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHJldHVybiBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLiBUaGlzIGRpZmZlcnMgZnJvbVxuICogW2BTdHJpbmcucHJvdG90eXBlLm1hdGNoYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL21hdGNoKVxuICogd2hpY2ggcmV0dXJucyBgbnVsbGAgd2hlbiB0aGVyZSBhcmUgbm8gbWF0Y2hlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBbU3RyaW5nIHwgVW5kZWZpbmVkXVxuICogQHBhcmFtIHtSZWdFeHB9IHJ4IEEgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBtYXRjaGVzIG9yIGVtcHR5IGFycmF5LlxuICogQHNlZSBSLnRlc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1hdGNoKC8oW2Etel1hKS9nLCAnYmFuYW5hcycpOyAvLz0+IFsnYmEnLCAnbmEnLCAnbmEnXVxuICogICAgICBSLm1hdGNoKC9hLywgJ2InKTsgLy89PiBbXVxuICogICAgICBSLm1hdGNoKC9hLywgbnVsbCk7IC8vPT4gVHlwZUVycm9yOiBudWxsIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCJtYXRjaFwiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBtYXRjaChyeCwgc3RyKSB7XG4gIHJldHVybiBzdHIubWF0Y2gocngpIHx8IFtdO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc0ludGVnZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0ludGVnZXInKTtcblxuXG4vKipcbiAqIG1hdGhNb2QgYmVoYXZlcyBsaWtlIHRoZSBtb2R1bG8gb3BlcmF0b3Igc2hvdWxkIG1hdGhlbWF0aWNhbGx5LCB1bmxpa2UgdGhlXG4gKiBgJWAgb3BlcmF0b3IgKGFuZCBieSBleHRlbnNpb24sIFIubW9kdWxvKS4gU28gd2hpbGUgXCItMTcgJSA1XCIgaXMgLTIsXG4gKiBtYXRoTW9kKC0xNywgNSkgaXMgMy4gbWF0aE1vZCByZXF1aXJlcyBJbnRlZ2VyIGFyZ3VtZW50cywgYW5kIHJldHVybnMgTmFOXG4gKiB3aGVuIHRoZSBtb2R1bHVzIGlzIHplcm8gb3IgbmVnYXRpdmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG0gVGhlIGRpdmlkZW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHAgdGhlIG1vZHVsdXMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGIgbW9kIGFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWF0aE1vZCgtMTcsIDUpOyAgLy89PiAzXG4gKiAgICAgIFIubWF0aE1vZCgxNywgNSk7ICAgLy89PiAyXG4gKiAgICAgIFIubWF0aE1vZCgxNywgLTUpOyAgLy89PiBOYU5cbiAqICAgICAgUi5tYXRoTW9kKDE3LCAwKTsgICAvLz0+IE5hTlxuICogICAgICBSLm1hdGhNb2QoMTcuMiwgNSk7IC8vPT4gTmFOXG4gKiAgICAgIFIubWF0aE1vZCgxNywgNS4zKTsgLy89PiBOYU5cbiAqXG4gKiAgICAgIHZhciBjbG9jayA9IFIubWF0aE1vZChSLl9fLCAxMik7XG4gKiAgICAgIGNsb2NrKDE1KTsgLy89PiAzXG4gKiAgICAgIGNsb2NrKDI0KTsgLy89PiAwXG4gKlxuICogICAgICB2YXIgc2V2ZW50ZWVuTW9kID0gUi5tYXRoTW9kKDE3KTtcbiAqICAgICAgc2V2ZW50ZWVuTW9kKDMpOyAgLy89PiAyXG4gKiAgICAgIHNldmVudGVlbk1vZCg0KTsgIC8vPT4gMVxuICogICAgICBzZXZlbnRlZW5Nb2QoMTApOyAvLz0+IDdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG1hdGhNb2QobSwgcCkge1xuICBpZiAoIV9pc0ludGVnZXIobSkpIHsgcmV0dXJuIE5hTjsgfVxuICBpZiAoIV9pc0ludGVnZXIocCkgfHwgcCA8IDEpIHsgcmV0dXJuIE5hTjsgfVxuICByZXR1cm4gKChtICUgcCkgKyBwKSAlIHA7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXJnZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLm1heEJ5LCBSLm1pblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWF4KDc4OSwgMTIzKTsgLy89PiA3ODlcbiAqICAgICAgUi5tYXgoJ2EnLCAnYicpOyAvLz0+ICdiJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbWF4KGEsIGIpIHsgcmV0dXJuIGIgPiBhID8gYiA6IGE7IH0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAqIGxhcmdlciByZXN1bHQgd2hlbiBwYXNzZWQgdG8gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5tYXgsIFIubWluQnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyAgc3F1YXJlIDo6IE51bWJlciAtPiBOdW1iZXJcbiAqICAgICAgdmFyIHNxdWFyZSA9IG4gPT4gbiAqIG47XG4gKlxuICogICAgICBSLm1heEJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IC0zXG4gKlxuICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFszLCAtNSwgNCwgMSwgLTJdKTsgLy89PiAtNVxuICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFtdKTsgLy89PiAwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXhCeShmLCBhLCBiKSB7XG4gIHJldHVybiBmKGIpID4gZihhKSA/IGIgOiBhO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIHN1bSA9IHJlcXVpcmUoJy4vc3VtJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtZWFuIG9mIHRoZSBnaXZlbiBsaXN0IG9mIG51bWJlcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZWFuKFsyLCA3LCA5XSk7IC8vPT4gNlxuICogICAgICBSLm1lYW4oW10pOyAvLz0+IE5hTlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbWVhbihsaXN0KSB7XG4gIHJldHVybiBzdW0obGlzdCkgLyBsaXN0Lmxlbmd0aDtcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBtZWFuID0gcmVxdWlyZSgnLi9tZWFuJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtZWRpYW4gb2YgdGhlIGdpdmVuIGxpc3Qgb2YgbnVtYmVycy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBbTnVtYmVyXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lZGlhbihbMiwgOSwgN10pOyAvLz0+IDdcbiAqICAgICAgUi5tZWRpYW4oWzcsIDIsIDEwLCA5XSk7IC8vPT4gOFxuICogICAgICBSLm1lZGlhbihbXSk7IC8vPT4gTmFOXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBtZWRpYW4obGlzdCkge1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciB3aWR0aCA9IDIgLSBsZW4gJSAyO1xuICB2YXIgaWR4ID0gKGxlbiAtIHdpZHRoKSAvIDI7XG4gIHJldHVybiBtZWFuKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgfSkuc2xpY2UoaWR4LCBpZHggKyB3aWR0aCkpO1xufSk7XG4iLCJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fYXJpdHknKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmdW5jdGlvbiB0aGF0LCB3aGVuIGludm9rZWQsIGNhY2hlcyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZuYFxuICogZm9yIGEgZ2l2ZW4gYXJndW1lbnQgc2V0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlXG4gKiBtZW1vaXplZCBgZm5gIHdpdGggdGhlIHNhbWUgYXJndW1lbnQgc2V0IHdpbGwgbm90IHJlc3VsdCBpbiBhbiBhZGRpdGlvbmFsXG4gKiBjYWxsIHRvIGBmbmA7IGluc3RlYWQsIHRoZSBjYWNoZWQgcmVzdWx0IGZvciB0aGF0IHNldCBvZiBhcmd1bWVudHMgd2lsbCBiZVxuICogcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCouLi4gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplLlxuICogQHJldHVybiB7RnVuY3Rpb259IE1lbW9pemVkIHZlcnNpb24gb2YgYGZuYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgY291bnQgPSAwO1xuICogICAgICB2YXIgZmFjdG9yaWFsID0gUi5tZW1vaXplKG4gPT4ge1xuICogICAgICAgIGNvdW50ICs9IDE7XG4gKiAgICAgICAgcmV0dXJuIFIucHJvZHVjdChSLnJhbmdlKDEsIG4gKyAxKSk7XG4gKiAgICAgIH0pO1xuICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gKiAgICAgIGZhY3RvcmlhbCg1KTsgLy89PiAxMjBcbiAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICogICAgICBjb3VudDsgLy89PiAxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleSA9IHRvU3RyaW5nKGFyZ3VtZW50cyk7XG4gICAgaWYgKCFfaGFzKGtleSwgY2FjaGUpKSB7XG4gICAgICBjYWNoZVtrZXldID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG4gIH0pO1xufSk7XG4iLCJ2YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Fzc2lnbicpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCBtZXJnZWQgd2l0aFxuICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLFxuICogdGhlIHZhbHVlIGZyb20gdGhlIHNlY29uZCBvYmplY3Qgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2VXaXRoLCBSLm1lcmdlV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2UoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDEwIH0sIHsgJ2FnZSc6IDQwIH0pO1xuICogICAgICAvLz0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gKlxuICogICAgICB2YXIgcmVzZXRUb0RlZmF1bHQgPSBSLm1lcmdlKFIuX18sIHt4OiAwfSk7XG4gKiAgICAgIHJlc2V0VG9EZWZhdWx0KHt4OiA1LCB5OiAyfSk7IC8vPT4ge3g6IDAsIHk6IDJ9XG4gKiBAc3ltYiBSLm1lcmdlKHsgeDogMSwgeTogMiB9LCB7IHk6IDUsIHo6IDMgfSkgPSB7IHg6IDEsIHk6IDUsIHo6IDMgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbWVyZ2UobCwgcikge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgbCwgcik7XG59KTtcbiIsInZhciBfYXNzaWduID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fYXNzaWduJyk7XG52YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogTWVyZ2VzIGEgbGlzdCBvZiBvYmplY3RzIHRvZ2V0aGVyIGludG8gb25lIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbe2s6IHZ9XSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2Ygb2JqZWN0c1xuICogQHJldHVybiB7T2JqZWN0fSBBIG1lcmdlZCBvYmplY3QuXG4gKiBAc2VlIFIucmVkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZUFsbChbe2ZvbzoxfSx7YmFyOjJ9LHtiYXo6M31dKTsgLy89PiB7Zm9vOjEsYmFyOjIsYmF6OjN9XG4gKiAgICAgIFIubWVyZ2VBbGwoW3tmb286MX0se2ZvbzoyfSx7YmFyOjJ9XSk7IC8vPT4ge2ZvbzoyLGJhcjoyfVxuICogQHN5bWIgUi5tZXJnZUFsbChbeyB4OiAxIH0sIHsgeTogMiB9LCB7IHo6IDMgfV0pID0geyB4OiAxLCB5OiAyLCB6OiAzIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIG1lcmdlQWxsKGxpc3QpIHtcbiAgcmV0dXJuIF9hc3NpZ24uYXBwbHkobnVsbCwgW3t9XS5jb25jYXQobGlzdCkpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIG1lcmdlV2l0aEtleSA9IHJlcXVpcmUoJy4vbWVyZ2VXaXRoS2V5Jyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuIElmXG4gKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUgdmFsdWVzXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiBlYWNoIG9iamVjdCwgd2l0aCB0aGUgcmVzdWx0IGJlaW5nIHVzZWQgYXMgdGhlXG4gKiB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LiBUaGUga2V5IHdpbGwgYmVcbiAqIGV4Y2x1ZGVkIGZyb20gdGhlIHJldHVybmVkIG9iamVjdCBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKGEgLT4gYSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsXG4gKiBAcGFyYW0ge09iamVjdH0gclxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlLCBSLm1lcmdlV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2VXaXRoKFIuY29uY2F0LFxuICogICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHZhbHVlczogWzEwLCAyMF0gfSxcbiAqICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCB2YWx1ZXM6IFsxNSwgMzVdIH0pO1xuICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgdmFsdWVzOiBbMTAsIDIwLCAxNSwgMzVdIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aChmbiwgbCwgcikge1xuICByZXR1cm4gbWVyZ2VXaXRoS2V5KGZ1bmN0aW9uKF8sIF9sLCBfcikge1xuICAgIHJldHVybiBmbihfbCwgX3IpO1xuICB9LCBsLCByKTtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faGFzJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuIElmXG4gKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUga2V5XG4gKiBhbmQgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiBlYWNoIG9iamVjdCwgd2l0aCB0aGUgcmVzdWx0IGJlaW5nXG4gKiB1c2VkIGFzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LiBUaGUga2V5XG4gKiB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJldHVybmVkIG9iamVjdCBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIChTdHJpbmcgLT4gYSAtPiBhIC0+IGEpIC0+IHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2UsIFIubWVyZ2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgbGV0IGNvbmNhdFZhbHVlcyA9IChrLCBsLCByKSA9PiBrID09ICd2YWx1ZXMnID8gUi5jb25jYXQobCwgcikgOiByXG4gKiAgICAgIFIubWVyZ2VXaXRoS2V5KGNvbmNhdFZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgICAgeyBhOiB0cnVlLCB0aGluZzogJ2ZvbycsIHZhbHVlczogWzEwLCAyMF0gfSxcbiAqICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCB0aGluZzogJ2JhcicsIHZhbHVlczogWzE1LCAzNV0gfSk7XG4gKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCB0aGluZzogJ2JhcicsIHZhbHVlczogWzEwLCAyMCwgMTUsIDM1XSB9XG4gKiBAc3ltYiBSLm1lcmdlV2l0aEtleShmLCB7IHg6IDEsIHk6IDIgfSwgeyB5OiA1LCB6OiAzIH0pID0geyB4OiAxLCB5OiBmKCd5JywgMiwgNSksIHo6IDMgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gbWVyZ2VXaXRoS2V5KGZuLCBsLCByKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGs7XG5cbiAgZm9yIChrIGluIGwpIHtcbiAgICBpZiAoX2hhcyhrLCBsKSkge1xuICAgICAgcmVzdWx0W2tdID0gX2hhcyhrLCByKSA/IGZuKGssIGxba10sIHJba10pIDogbFtrXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGsgaW4gcikge1xuICAgIGlmIChfaGFzKGssIHIpICYmICEoX2hhcyhrLCByZXN1bHQpKSkge1xuICAgICAgcmVzdWx0W2tdID0gcltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc21hbGxlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubWluQnksIFIubWF4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5taW4oNzg5LCAxMjMpOyAvLz0+IDEyM1xuICogICAgICBSLm1pbignYScsICdiJyk7IC8vPT4gJ2EnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBtaW4oYSwgYikgeyByZXR1cm4gYiA8IGEgPyBiIDogYTsgfSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBhbmQgdHdvIHZhbHVlcywgYW5kIHJldHVybnMgd2hpY2hldmVyIHZhbHVlIHByb2R1Y2VzIHRoZVxuICogc21hbGxlciByZXN1bHQgd2hlbiBwYXNzZWQgdG8gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5taW4sIFIubWF4QnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyAgc3F1YXJlIDo6IE51bWJlciAtPiBOdW1iZXJcbiAqICAgICAgdmFyIHNxdWFyZSA9IG4gPT4gbiAqIG47XG4gKlxuICogICAgICBSLm1pbkJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IDJcbiAqXG4gKiAgICAgIFIucmVkdWNlKFIubWluQnkoc3F1YXJlKSwgSW5maW5pdHksIFszLCAtNSwgNCwgMSwgLTJdKTsgLy89PiAxXG4gKiAgICAgIFIucmVkdWNlKFIubWluQnkoc3F1YXJlKSwgSW5maW5pdHksIFtdKTsgLy89PiBJbmZpbml0eVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gbWluQnkoZiwgYSwgYikge1xuICByZXR1cm4gZihiKSA8IGYoYSkgPyBiIDogYTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIERpdmlkZXMgdGhlIGZpcnN0IHBhcmFtZXRlciBieSB0aGUgc2Vjb25kIGFuZCByZXR1cm5zIHRoZSByZW1haW5kZXIuIE5vdGVcbiAqIHRoYXQgdGhpcyBmdW5jdGlvbiBwcmVzZXJ2ZXMgdGhlIEphdmFTY3JpcHQtc3R5bGUgYmVoYXZpb3IgZm9yIG1vZHVsby4gRm9yXG4gKiBtYXRoZW1hdGljYWwgbW9kdWxvIHNlZSBgbWF0aE1vZGAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIHZhbHVlIHRvIHRoZSBkaXZpZGUuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgcHNldWRvLW1vZHVsdXNcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYiAlIGFgLlxuICogQHNlZSBSLm1hdGhNb2RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1vZHVsbygxNywgMyk7IC8vPT4gMlxuICogICAgICAvLyBKUyBiZWhhdmlvcjpcbiAqICAgICAgUi5tb2R1bG8oLTE3LCAzKTsgLy89PiAtMlxuICogICAgICBSLm1vZHVsbygxNywgLTMpOyAvLz0+IDJcbiAqXG4gKiAgICAgIHZhciBpc09kZCA9IFIubW9kdWxvKFIuX18sIDIpO1xuICogICAgICBpc09kZCg0Mik7IC8vPT4gMFxuICogICAgICBpc09kZCgyMSk7IC8vPT4gMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbW9kdWxvKGEsIGIpIHsgcmV0dXJuIGEgJSBiOyB9KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBudW1iZXJzLiBFcXVpdmFsZW50IHRvIGBhICogYmAgYnV0IGN1cnJpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYSAqIGJgLlxuICogQHNlZSBSLmRpdmlkZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkb3VibGUgPSBSLm11bHRpcGx5KDIpO1xuICogICAgICB2YXIgdHJpcGxlID0gUi5tdWx0aXBseSgzKTtcbiAqICAgICAgZG91YmxlKDMpOyAgICAgICAvLz0+ICA2XG4gKiAgICAgIHRyaXBsZSg0KTsgICAgICAgLy89PiAxMlxuICogICAgICBSLm11bHRpcGx5KDIsIDUpOyAgLy89PiAxMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikgeyByZXR1cm4gYSAqIGI7IH0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gb2YgYW55IGFyaXR5IChpbmNsdWRpbmcgbnVsbGFyeSkgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHNcbiAqIGV4YWN0bHkgYG5gIHBhcmFtZXRlcnMuIEFueSBleHRyYW5lb3VzIHBhcmFtZXRlcnMgd2lsbCBub3QgYmUgcGFzc2VkIHRvIHRoZVxuICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgZGVzaXJlZCBhcml0eSBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gKiAgICAgICAgIGFyaXR5IGBuYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdGFrZXNUd29BcmdzID0gKGEsIGIpID0+IFthLCBiXTtcbiAqXG4gKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMik7IC8vPT4gWzEsIDJdXG4gKlxuICogICAgICB2YXIgdGFrZXNPbmVBcmcgPSBSLm5BcnkoMSwgdGFrZXNUd29BcmdzKTtcbiAqICAgICAgdGFrZXNPbmVBcmcubGVuZ3RoOyAvLz0+IDFcbiAqICAgICAgLy8gT25seSBgbmAgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNPbmVBcmcoMSwgMik7IC8vPT4gWzEsIHVuZGVmaW5lZF1cbiAqIEBzeW1iIFIubkFyeSgwLCBmKShhLCBiKSA9IGYoKVxuICogQHN5bWIgUi5uQXJ5KDEsIGYpKGEsIGIpID0gZihhKVxuICogQHN5bWIgUi5uQXJ5KDIsIGYpKGEsIGIpID0gZihhLCBiKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbkFyeShuLCBmbikge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gZm4uY2FsbCh0aGlzKTt9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEwKSB7cmV0dXJuIGZuLmNhbGwodGhpcywgYTApO307XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExKSB7cmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExKTt9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyKTt9O1xuICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzKSB7cmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMpO307XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0KSB7cmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0KTt9O1xuICAgIGNhc2UgNjogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1KTt9O1xuICAgIGNhc2UgNzogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7cmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpO307XG4gICAgY2FzZSA4OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7cmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTt9O1xuICAgIGNhc2UgOTogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KTt9O1xuICAgIGNhc2UgMTA6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkge3JldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KTt9O1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gbkFyeSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICB9XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBOZWdhdGVzIGl0cyBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5uZWdhdGUoNDIpOyAvLz0+IC00MlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbmVnYXRlKG4pIHsgcmV0dXJuIC1uOyB9KTtcbiIsInZhciBfY29tcGxlbWVudCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbXBsZW1lbnQnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94YW55ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGFueScpO1xudmFyIGFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBubyBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLCBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFueWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIG5vdCBzYXRpc2ZpZWQgYnkgZXZlcnkgZWxlbWVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYWxsLCBSLmFueVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICpcbiAqICAgICAgUi5ub25lKGlzRXZlbiwgWzEsIDMsIDUsIDcsIDksIDExXSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm5vbmUoaXNFdmVuLCBbMSwgMywgNSwgNywgOCwgMTFdKTsgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2NvbXBsZW1lbnQoX2Rpc3BhdGNoYWJsZShbJ2FueSddLCBfeGFueSwgYW55KSkpO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBgIWAgb2YgaXRzIGFyZ3VtZW50LiBJdCB3aWxsIHJldHVybiBgdHJ1ZWAgd2hlblxuICogcGFzc2VkIGZhbHNlLXkgdmFsdWUsIGFuZCBgZmFsc2VgIHdoZW4gcGFzc2VkIGEgdHJ1dGgteSBvbmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGEgYW55IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0aGUgbG9naWNhbCBpbnZlcnNlIG9mIHBhc3NlZCBhcmd1bWVudC5cbiAqIEBzZWUgUi5jb21wbGVtZW50XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5ub3QodHJ1ZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ub3QoZmFsc2UpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ub3QoMCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm5vdCgxKTsgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbm90KGEpIHtcbiAgcmV0dXJuICFhO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc1N0cmluZyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIElmIG4gaXMgbmVnYXRpdmUgdGhlXG4gKiBlbGVtZW50IGF0IGluZGV4IGxlbmd0aCArIG4gaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbGlzdCA9IFsnZm9vJywgJ2JhcicsICdiYXonLCAncXV1eCddO1xuICogICAgICBSLm50aCgxLCBsaXN0KTsgLy89PiAnYmFyJ1xuICogICAgICBSLm50aCgtMSwgbGlzdCk7IC8vPT4gJ3F1dXgnXG4gKiAgICAgIFIubnRoKC05OSwgbGlzdCk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLm50aCgyLCAnYWJjJyk7IC8vPT4gJ2MnXG4gKiAgICAgIFIubnRoKDMsICdhYmMnKTsgLy89PiAnJ1xuICogQHN5bWIgUi5udGgoLTEsIFthLCBiLCBjXSkgPSBjXG4gKiBAc3ltYiBSLm50aCgwLCBbYSwgYiwgY10pID0gYVxuICogQHN5bWIgUi5udGgoMSwgW2EsIGIsIGNdKSA9IGJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG50aChvZmZzZXQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IG9mZnNldCA8IDAgPyBsaXN0Lmxlbmd0aCArIG9mZnNldCA6IG9mZnNldDtcbiAgcmV0dXJuIF9pc1N0cmluZyhsaXN0KSA/IGxpc3QuY2hhckF0KGlkeCkgOiBsaXN0W2lkeF07XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcbnZhciBudGggPSByZXF1aXJlKCcuL250aCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgaXRzIG50aCBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKi4uLiAtPiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5udGhBcmcoMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2InXG4gKiAgICAgIFIubnRoQXJnKC0xKSgnYScsICdiJywgJ2MnKTsgLy89PiAnYydcbiAqIEBzeW1iIFIubnRoQXJnKC0xKShhLCBiLCBjKSA9IGNcbiAqIEBzeW1iIFIubnRoQXJnKDApKGEsIGIsIGMpID0gYVxuICogQHN5bWIgUi5udGhBcmcoMSkoYSwgYiwgYykgPSBiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBudGhBcmcobikge1xuICB2YXIgYXJpdHkgPSBuIDwgMCA/IDEgOiBuICsgMTtcbiAgcmV0dXJuIGN1cnJ5Tihhcml0eSwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG50aChuLCBhcmd1bWVudHMpO1xuICB9KTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzaW5nbGUga2V5OnZhbHVlIHBhaXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7U3RyaW5nOmF9XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLnBhaXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbWF0Y2hQaHJhc2VzID0gUi5jb21wb3NlKFxuICogICAgICAgIFIub2JqT2YoJ211c3QnKSxcbiAqICAgICAgICBSLm1hcChSLm9iak9mKCdtYXRjaF9waHJhc2UnKSlcbiAqICAgICAgKTtcbiAqICAgICAgbWF0Y2hQaHJhc2VzKFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4ge211c3Q6IFt7bWF0Y2hfcGhyYXNlOiAnZm9vJ30sIHttYXRjaF9waHJhc2U6ICdiYXInfSwge21hdGNoX3BocmFzZTogJ2Jheid9XX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG9iak9mKGtleSwgdmFsKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgb2JqW2tleV0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX29mID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fb2YnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGV0b24gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUgcHJvdmlkZWQuXG4gKlxuICogTm90ZSB0aGlzIGBvZmAgaXMgZGlmZmVyZW50IGZyb20gdGhlIEVTNiBgb2ZgOyBTZWVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29mXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0geCBhbnkgdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSB3cmFwcGluZyBgeGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5vZihudWxsKTsgLy89PiBbbnVsbF1cbiAqICAgICAgUi5vZihbNDJdKTsgLy89PiBbWzQyXV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKF9vZik7XG4iLCJ2YXIgX2NvbnRhaW5zID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29udGFpbnMnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBvbWl0dGluZyB0aGUga2V5cyBzcGVjaWZpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtTdHJpbmddIC0+IHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9XG4gKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gb21pdCBmcm9tIHRoZSBuZXcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG5vdCBvbiBpdC5cbiAqIEBzZWUgUi5waWNrXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5vbWl0KFsnYScsICdkJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGM6IDN9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBvbWl0KG5hbWVzLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmICghX2NvbnRhaW5zKHByb3AsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fYXJpdHknKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ3VhcmRzIGludm9jYXRpb24gb2ZcbiAqIGBmbmAgc3VjaCB0aGF0IGBmbmAgY2FuIG9ubHkgZXZlciBiZSBjYWxsZWQgb25jZSwgbm8gbWF0dGVyIGhvdyBtYW55IHRpbWVzXG4gKiB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gaXMgaW52b2tlZC4gVGhlIGZpcnN0IHZhbHVlIGNhbGN1bGF0ZWQgaXMgcmV0dXJuZWQgaW5cbiAqIHN1YnNlcXVlbnQgaW52b2NhdGlvbnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKGEuLi4gLT4gYikgLT4gKGEuLi4gLT4gYilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwIGluIGEgY2FsbC1vbmx5LW9uY2Ugd3JhcHBlci5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWRkT25lT25jZSA9IFIub25jZSh4ID0+IHggKyAxKTtcbiAqICAgICAgYWRkT25lT25jZSgxMCk7IC8vPT4gMTFcbiAqICAgICAgYWRkT25lT25jZShhZGRPbmVPbmNlKDUwKSk7IC8vPT4gMTFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgcmVzdWx0O1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIGJvdGggb2YgaXRzIGFyZ3VtZW50cyBhcmUgYHRydWVgLiBSZXR1cm5zIGBmYWxzZWBcbiAqIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgZmFsc2VgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHtBbnl9IGFcbiAqIEBwYXJhbSB7QW55fSBiXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSBmaXJzdCBhcmd1bWVudCBpZiB0cnV0aHksIG90aGVyd2lzZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHNlZSBSLmVpdGhlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIub3IodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm9yKHRydWUsIGZhbHNlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIub3IoZmFsc2UsIHRydWUpOyAvLz0+IHRydWVcbiAqICAgICAgUi5vcihmYWxzZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBvcihhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgXCJzZXR0aW5nXCIgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlXG4gKiBmb2N1c2VkIGJ5IHRoZSBnaXZlbiBsZW5zIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvXG4gKiB0aGUgZm9jdXNlZCB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBMZW5zIHMgYSAtPiAoYSAtPiBhKSAtPiBzIC0+IHNcbiAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICogQHBhcmFtIHsqfSB2XG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaGVhZExlbnMgPSBSLmxlbnNJbmRleCgwKTtcbiAqXG4gKiAgICAgIFIub3ZlcihoZWFkTGVucywgUi50b1VwcGVyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnRk9PJywgJ2JhcicsICdiYXonXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgLy8gYElkZW50aXR5YCBpcyBhIGZ1bmN0b3IgdGhhdCBob2xkcyBhIHNpbmdsZSB2YWx1ZSwgd2hlcmUgYG1hcGAgc2ltcGx5XG4gIC8vIHRyYW5zZm9ybXMgdGhlIGhlbGQgdmFsdWUgd2l0aCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gIHZhciBJZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4ge3ZhbHVlOiB4LCBtYXA6IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIElkZW50aXR5KGYoeCkpOyB9fTtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MyhmdW5jdGlvbiBvdmVyKGxlbnMsIGYsIHgpIHtcbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiBpcyBmaXJzdCB0cmFuc2Zvcm1lZCB3aXRoIGBmYCxcbiAgICAvLyB0aGVuIHNldCBhcyB0aGUgdmFsdWUgb2YgYW4gYElkZW50aXR5YC4gVGhpcyBpcyB0aGVuIG1hcHBlZCBvdmVyIHdpdGggdGhlXG4gICAgLy8gc2V0dGVyIGZ1bmN0aW9uIG9mIHRoZSBsZW5zLlxuICAgIHJldHVybiBsZW5zKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIElkZW50aXR5KGYoeSkpOyB9KSh4KS52YWx1ZTtcbiAgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFRha2VzIHR3byBhcmd1bWVudHMsIGBmc3RgIGFuZCBgc25kYCwgYW5kIHJldHVybnMgYFtmc3QsIHNuZF1gLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gYiAtPiAoYSxiKVxuICogQHBhcmFtIHsqfSBmc3RcbiAqIEBwYXJhbSB7Kn0gc25kXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5vYmpPZiwgUi5vZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGFpcignZm9vJywgJ2JhcicpOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBwYWlyKGZzdCwgc25kKSB7IHJldHVybiBbZnN0LCBzbmRdOyB9KTtcbiIsInZhciBfY29uY2F0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29uY2F0Jyk7XG52YXIgX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3InKTtcblxuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYC5cbiAqIFdoZW4gYXBwbGllZCwgYGdgIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlIGFyZ3VtZW50c1xuICogcHJvdmlkZWQgaW5pdGlhbGx5IGZvbGxvd2VkIGJ5IHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgdG8gYGdgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEsIGIsIGMsIC4uLiwgbikgLT4geCkgLT4gW2EsIGIsIGMsIC4uLl0gLT4gKChkLCBlLCBmLCAuLi4sIG4pIC0+IHgpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5wYXJ0aWFsUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbXVsdGlwbHkyID0gKGEsIGIpID0+IGEgKiBiO1xuICogICAgICB2YXIgZG91YmxlID0gUi5wYXJ0aWFsKG11bHRpcGx5MiwgWzJdKTtcbiAqICAgICAgZG91YmxlKDIpOyAvLz0+IDRcbiAqXG4gKiAgICAgIHZhciBncmVldCA9IChzYWx1dGF0aW9uLCB0aXRsZSwgZmlyc3ROYW1lLCBsYXN0TmFtZSkgPT5cbiAqICAgICAgICBzYWx1dGF0aW9uICsgJywgJyArIHRpdGxlICsgJyAnICsgZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWUgKyAnISc7XG4gKlxuICogICAgICB2YXIgc2F5SGVsbG8gPSBSLnBhcnRpYWwoZ3JlZXQsIFsnSGVsbG8nXSk7XG4gKiAgICAgIHZhciBzYXlIZWxsb1RvTXMgPSBSLnBhcnRpYWwoc2F5SGVsbG8sIFsnTXMuJ10pO1xuICogICAgICBzYXlIZWxsb1RvTXMoJ0phbmUnLCAnSm9uZXMnKTsgLy89PiAnSGVsbG8sIE1zLiBKYW5lIEpvbmVzISdcbiAqIEBzeW1iIFIucGFydGlhbChmLCBbYSwgYl0pKGMsIGQpID0gZihhLCBiLCBjLCBkKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcihfY29uY2F0KTtcbiIsInZhciBfY29uY2F0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29uY2F0Jyk7XG52YXIgX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3InKTtcbnZhciBmbGlwID0gcmVxdWlyZSgnLi9mbGlwJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2AuXG4gKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAqIHByb3ZpZGVkIHRvIGBnYCBmb2xsb3dlZCBieSB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIGluaXRpYWxseS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCBjLCAuLi4sIG4pIC0+IHgpIC0+IFtkLCBlLCBmLCAuLi4sIG5dIC0+ICgoYSwgYiwgYywgLi4uKSAtPiB4KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGFydGlhbFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBncmVldCA9IChzYWx1dGF0aW9uLCB0aXRsZSwgZmlyc3ROYW1lLCBsYXN0TmFtZSkgPT5cbiAqICAgICAgICBzYWx1dGF0aW9uICsgJywgJyArIHRpdGxlICsgJyAnICsgZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWUgKyAnISc7XG4gKlxuICogICAgICB2YXIgZ3JlZXRNc0phbmVKb25lcyA9IFIucGFydGlhbFJpZ2h0KGdyZWV0LCBbJ01zLicsICdKYW5lJywgJ0pvbmVzJ10pO1xuICpcbiAqICAgICAgZ3JlZXRNc0phbmVKb25lcygnSGVsbG8nKTsgLy89PiAnSGVsbG8sIE1zLiBKYW5lIEpvbmVzISdcbiAqIEBzeW1iIFIucGFydGlhbFJpZ2h0KGYsIFthLCBiXSkoYywgZCkgPSBmKGMsIGQsIGEsIGIpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKGZsaXAoX2NvbmNhdCkpO1xuIiwidmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIganV4dCA9IHJlcXVpcmUoJy4vanV4dCcpO1xudmFyIHJlamVjdCA9IHJlcXVpcmUoJy4vcmVqZWN0Jyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBsaXN0IG9yIG90aGVyIFwiZmlsdGVyYWJsZVwiIG9iamVjdCBhbmQgcmV0dXJucyB0aGVcbiAqIHBhaXIgb2YgZmlsdGVyYWJsZSBvYmplY3RzIG9mIHRoZSBzYW1lIHR5cGUgb2YgZWxlbWVudHMgd2hpY2ggZG8gYW5kIGRvIG5vdFxuICogc2F0aXNmeSwgdGhlIHByZWRpY2F0ZSwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBbZiBhLCBmIGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGljaCBzaWRlIHRoZSBlbGVtZW50IGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlIHRoZSBsaXN0IChvciBvdGhlciBmaWx0ZXJhYmxlKSB0byBwYXJ0aXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXksIGNvbnRhaW5pbmcgZmlyc3QgdGhlIHN1YnNldCBvZiBlbGVtZW50cyB0aGF0IHNhdGlzZnkgdGhlXG4gKiAgICAgICAgIHByZWRpY2F0ZSwgYW5kIHNlY29uZCB0aGUgc3Vic2V0IG9mIGVsZW1lbnRzIHRoYXQgZG8gbm90IHNhdGlzZnkuXG4gKiBAc2VlIFIuZmlsdGVyLCBSLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGFydGl0aW9uKFIuY29udGFpbnMoJ3MnKSwgWydzc3MnLCAndHR0JywgJ2ZvbycsICdiYXJzJ10pO1xuICogICAgICAvLyA9PiBbIFsgJ3NzcycsICdiYXJzJyBdLCAgWyAndHR0JywgJ2ZvbycgXSBdXG4gKlxuICogICAgICBSLnBhcnRpdGlvbihSLmNvbnRhaW5zKCdzJyksIHsgYTogJ3NzcycsIGI6ICd0dHQnLCBmb286ICdiYXJzJyB9KTtcbiAqICAgICAgLy8gPT4gWyB7IGE6ICdzc3MnLCBmb286ICdiYXJzJyB9LCB7IGI6ICd0dHQnIH0gIF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBqdXh0KFtmaWx0ZXIsIHJlamVjdF0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IHthfSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIHByb3BlcnR5IGZyb20uXG4gKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAuXG4gKiBAc2VlIFIucHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGF0aChbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7IC8vPT4gMlxuICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IHVuZGVmaW5lZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcGF0aChwYXRocywgb2JqKSB7XG4gIHZhciB2YWwgPSBvYmo7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgcGF0aHMubGVuZ3RoKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhbCA9IHZhbFtwYXRoc1tpZHhdXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgbmVzdGVkIHBhdGggb24gYW4gb2JqZWN0IGhhcyBhIHNwZWNpZmljIHZhbHVlLCBpblxuICogYFIuZXF1YWxzYCB0ZXJtcy4gTW9zdCBsaWtlbHkgdXNlZCB0byBmaWx0ZXIgYSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IGEgLT4ge2F9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIG5lc3RlZCBwcm9wZXJ0eSB0byB1c2VcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byBjb21wYXJlIHRoZSBuZXN0ZWQgcHJvcGVydHkgd2l0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrIHRoZSBuZXN0ZWQgcHJvcGVydHkgaW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgZXF1YWxzIHRoZSBuZXN0ZWQgb2JqZWN0IHByb3BlcnR5LFxuICogICAgICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdXNlcjEgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogOTAyMTAgfSB9O1xuICogICAgICB2YXIgdXNlcjIgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogNTU1NTUgfSB9O1xuICogICAgICB2YXIgdXNlcjMgPSB7IG5hbWU6ICdCb2InIH07XG4gKiAgICAgIHZhciB1c2VycyA9IFsgdXNlcjEsIHVzZXIyLCB1c2VyMyBdO1xuICogICAgICB2YXIgaXNGYW1vdXMgPSBSLnBhdGhFcShbJ2FkZHJlc3MnLCAnemlwQ29kZSddLCA5MDIxMCk7XG4gKiAgICAgIFIuZmlsdGVyKGlzRmFtb3VzLCB1c2Vycyk7IC8vPT4gWyB1c2VyMSBdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBwYXRoRXEoX3BhdGgsIHZhbCwgb2JqKSB7XG4gIHJldHVybiBlcXVhbHMocGF0aChfcGF0aCwgb2JqKSwgdmFsKTtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBkZWZhdWx0VG8gPSByZXF1aXJlKCcuL2RlZmF1bHRUbycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuXG4vKipcbiAqIElmIHRoZSBnaXZlbiwgbm9uLW51bGwgb2JqZWN0IGhhcyBhIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoLCByZXR1cm5zIHRoZVxuICogdmFsdWUgYXQgdGhhdCBwYXRoLiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcHJvdmlkZWQgZGVmYXVsdCB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIGEgLT4gW0lkeF0gLT4ge2F9IC0+IGFcbiAqIEBwYXJhbSB7Kn0gZCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IHAgVGhlIHBhdGggdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydHkgZnJvbS5cbiAqIEByZXR1cm4geyp9IFRoZSBkYXRhIGF0IGBwYXRoYCBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGF0aE9yKCdOL0EnLCBbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7IC8vPT4gMlxuICogICAgICBSLnBhdGhPcignTi9BJywgWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IFwiTi9BXCJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhPcihkLCBwLCBvYmopIHtcbiAgcmV0dXJuIGRlZmF1bHRUbyhkLCBwYXRoKHAsIG9iaikpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGF0IGdpdmVuIHBhdGggc2F0aXNmaWVzIHRoZVxuICogZ2l2ZW4gcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW0lkeF0gLT4ge2F9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BQYXRoXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wU2F0aXNmaWVzLCBSLnBhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGhTYXRpc2ZpZXMoeSA9PiB5ID4gMCwgWyd4JywgJ3knXSwge3g6IHt5OiAyfX0pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhTYXRpc2ZpZXMocHJlZCwgcHJvcFBhdGgsIG9iaikge1xuICByZXR1cm4gcHJvcFBhdGgubGVuZ3RoID4gMCAmJiBwcmVkKHBhdGgocHJvcFBhdGgsIG9iaikpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBrZXlzIHNwZWNpZmllZC4gSWZcbiAqIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QsIHRoZSBwcm9wZXJ0eSBpcyBpZ25vcmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtBcnJheX0gbmFtZXMgYW4gYXJyYXkgb2YgU3RyaW5nIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkgb250byBhIG5ldyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBvbiBpdC5cbiAqIEBzZWUgUi5vbWl0LCBSLnByb3BzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5waWNrKFsnYScsICdkJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2E6IDEsIGQ6IDR9XG4gKiAgICAgIFIucGljayhbJ2EnLCAnZScsICdmJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2E6IDF9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBwaWNrKG5hbWVzLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IG5hbWVzLmxlbmd0aCkge1xuICAgIGlmIChuYW1lc1tpZHhdIGluIG9iaikge1xuICAgICAgcmVzdWx0W25hbWVzW2lkeF1dID0gb2JqW25hbWVzW2lkeF1dO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogU2ltaWxhciB0byBgcGlja2AgZXhjZXB0IHRoYXQgdGhpcyBvbmUgaW5jbHVkZXMgYSBga2V5OiB1bmRlZmluZWRgIHBhaXIgZm9yXG4gKiBwcm9wZXJ0aWVzIHRoYXQgZG9uJ3QgZXhpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtrXSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gY29weSBvbnRvIGEgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG9uIGl0LlxuICogQHNlZSBSLnBpY2tcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBpY2tBbGwoWydhJywgJ2QnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZDogNH1cbiAqICAgICAgUi5waWNrQWxsKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZTogdW5kZWZpbmVkLCBmOiB1bmRlZmluZWR9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBwaWNrQWxsKG5hbWVzLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhciBuYW1lID0gbmFtZXNbaWR4XTtcbiAgICByZXN1bHRbbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUga2V5cyB0aGF0IHNhdGlzZnlcbiAqIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICh2LCBrIC0+IEJvb2xlYW4pIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEga2V5XG4gKiAgICAgICAgc2hvdWxkIGJlIGluY2x1ZGVkIG9uIHRoZSBvdXRwdXQgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHByb3BlcnRpZXMgdGhhdCBzYXRpc2Z5IGBwcmVkYFxuICogICAgICAgICBvbiBpdC5cbiAqIEBzZWUgUi5waWNrLCBSLmZpbHRlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc1VwcGVyQ2FzZSA9ICh2YWwsIGtleSkgPT4ga2V5LnRvVXBwZXJDYXNlKCkgPT09IGtleTtcbiAqICAgICAgUi5waWNrQnkoaXNVcHBlckNhc2UsIHthOiAxLCBiOiAyLCBBOiAzLCBCOiA0fSk7IC8vPT4ge0E6IDMsIEI6IDR9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBwaWNrQnkodGVzdCwgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAodGVzdChvYmpbcHJvcF0sIHByb3AsIG9iaikpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX3BpcGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19waXBlJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciB0YWlsID0gcmVxdWlyZSgnLi90YWlsJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBUaGUgbGVmdG1vc3QgZnVuY3Rpb24gbWF5IGhhdmVcbiAqIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAqXG4gKiBJbiBzb21lIGxpYnJhcmllcyB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBzZXF1ZW5jZWAuXG4gKlxuICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgcGlwZSBpcyBub3QgYXV0b21hdGljYWxseSBjdXJyaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoKGEsIGIsIC4uLiwgbikgLT4gbyksIChvIC0+IHApLCAuLi4sICh4IC0+IHkpLCAoeSAtPiB6KSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZiA9IFIucGlwZShNYXRoLnBvdywgUi5uZWdhdGUsIFIuaW5jKTtcbiAqXG4gKiAgICAgIGYoMywgNCk7IC8vIC0oM140KSArIDFcbiAqIEBzeW1iIFIucGlwZShmLCBnLCBoKShhLCBiKSA9IGgoZyhmKGEsIGIpKSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaXBlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVkdWNlKF9waXBlLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xufTtcbiIsInZhciBjb21wb3NlSyA9IHJlcXVpcmUoJy4vY29tcG9zZUsnKTtcbnZhciByZXZlcnNlID0gcmVxdWlyZSgnLi9yZXZlcnNlJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGVmdC10by1yaWdodCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAqXG4gKiBgUi5waXBlSyhmLCBnLCBoKWAgaXMgZXF1aXZhbGVudCB0byBgUi5waXBlKFIuY2hhaW4oZiksIFIuY2hhaW4oZyksIFIuY2hhaW4oaCkpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgQ2hhaW4gbSA9PiAoKGEgLT4gbSBiKSwgKGIgLT4gbSBjKSwgLi4uLCAoeSAtPiBtIHopKSAtPiAoYSAtPiBtIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZUtcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyAgcGFyc2VKc29uIDo6IFN0cmluZyAtPiBNYXliZSAqXG4gKiAgICAgIC8vICBnZXQgOjogU3RyaW5nIC0+IE9iamVjdCAtPiBNYXliZSAqXG4gKlxuICogICAgICAvLyAgZ2V0U3RhdGVDb2RlIDo6IE1heWJlIFN0cmluZyAtPiBNYXliZSBTdHJpbmdcbiAqICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIucGlwZUsoXG4gKiAgICAgICAgcGFyc2VKc29uLFxuICogICAgICAgIGdldCgndXNlcicpLFxuICogICAgICAgIGdldCgnYWRkcmVzcycpLFxuICogICAgICAgIGdldCgnc3RhdGUnKSxcbiAqICAgICAgICBSLmNvbXBvc2UoTWF5YmUub2YsIFIudG9VcHBlcilcbiAqICAgICAgKTtcbiAqXG4gKiAgICAgIGdldFN0YXRlQ29kZSgne1widXNlclwiOntcImFkZHJlc3NcIjp7XCJzdGF0ZVwiOlwibnlcIn19fScpO1xuICogICAgICAvLz0+IEp1c3QoJ05ZJylcbiAqICAgICAgZ2V0U3RhdGVDb2RlKCdbSW52YWxpZCBKU09OXScpO1xuICogICAgICAvLz0+IE5vdGhpbmcoKVxuICogQHN5bWIgUi5waXBlSyhmLCBnLCBoKShhKSA9IFIuY2hhaW4oaCwgUi5jaGFpbihnLCBmKGEpKSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaXBlSygpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVLIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBjb21wb3NlSy5hcHBseSh0aGlzLCByZXZlcnNlKGFyZ3VtZW50cykpO1xufTtcbiIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9waXBlUCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3BpcGVQJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciB0YWlsID0gcmVxdWlyZSgnLi90YWlsJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbnMuIFRoZSBsZWZ0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZSBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zXG4gKiBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEgLT4gUHJvbWlzZSBiKSwgKGIgLT4gUHJvbWlzZSBjKSwgLi4uLCAoeSAtPiBQcm9taXNlIHopKSAtPiAoYSAtPiBQcm9taXNlIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VQXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIGZvbGxvd2Vyc0ZvclVzZXIgOjogU3RyaW5nIC0+IFByb21pc2UgW1VzZXJdXG4gKiAgICAgIHZhciBmb2xsb3dlcnNGb3JVc2VyID0gUi5waXBlUChkYi5nZXRVc2VyQnlJZCwgZGIuZ2V0Rm9sbG93ZXJzKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaXBlUCgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVQIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZWR1Y2UoX3BpcGVQLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xufTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcbnZhciBwcm9wID0gcmVxdWlyZSgnLi9wcm9wJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgYnkgcGx1Y2tpbmcgdGhlIHNhbWUgbmFtZWQgcHJvcGVydHkgb2ZmIGFsbCBvYmplY3RzIGluXG4gKiB0aGUgbGlzdCBzdXBwbGllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGsgLT4gW3trOiB2fV0gLT4gW3ZdXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleSBUaGUga2V5IG5hbWUgdG8gcGx1Y2sgb2ZmIG9mIGVhY2ggb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICogQHNlZSBSLnByb3BzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wbHVjaygnYScpKFt7YTogMX0sIHthOiAyfV0pOyAvLz0+IFsxLCAyXVxuICogICAgICBSLnBsdWNrKDApKFtbMSwgMl0sIFszLCA0XV0pOyAgIC8vPT4gWzEsIDNdXG4gKiBAc3ltYiBSLnBsdWNrKCd4JywgW3t4OiAxLCB5OiAyfSwge3g6IDMsIHk6IDR9LCB7eDogNSwgeTogNn1dKSA9IFsxLCAzLCA1XVxuICogQHN5bWIgUi5wbHVjaygwLCBbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV0pID0gWzEsIDMsIDVdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBwbHVjayhwLCBsaXN0KSB7XG4gIHJldHVybiBtYXAocHJvcChwKSwgbGlzdCk7XG59KTtcbiIsInZhciBfY29uY2F0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29uY2F0Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGggdGhlIGdpdmVuIGVsZW1lbnQgYXQgdGhlIGZyb250LCBmb2xsb3dlZCBieSB0aGVcbiAqIGNvbnRlbnRzIG9mIHRoZSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0geyp9IGVsIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgaGVhZCBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBhZGQgdG8gdGhlIHRhaWwgb2YgdGhlIG91dHB1dCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLmFwcGVuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJlcGVuZCgnZmVlJywgWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gWydmZWUnLCAnZmknLCAnZm8nLCAnZnVtJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHByZXBlbmQoZWwsIGxpc3QpIHtcbiAgcmV0dXJuIF9jb25jYXQoW2VsXSwgbGlzdCk7XG59KTtcbiIsInZhciBtdWx0aXBseSA9IHJlcXVpcmUoJy4vbXVsdGlwbHknKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuXG5cbi8qKlxuICogTXVsdGlwbGllcyB0b2dldGhlciBhbGwgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBwcm9kdWN0IG9mIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgbGlzdC5cbiAqIEBzZWUgUi5yZWR1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb2R1Y3QoWzIsNCw2LDgsMTAwLDFdKTsgLy89PiAzODQwMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZShtdWx0aXBseSwgMSk7XG4iLCJ2YXIgX21hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX21hcCcpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xudmFyIHBpY2tBbGwgPSByZXF1aXJlKCcuL3BpY2tBbGwnKTtcbnZhciB1c2VXaXRoID0gcmVxdWlyZSgnLi91c2VXaXRoJyk7XG5cblxuLyoqXG4gKiBSZWFzb25hYmxlIGFuYWxvZyB0byBTUUwgYHNlbGVjdGAgc3RhdGVtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFtrXSAtPiBbe2s6IHZ9XSAtPiBbe2s6IHZ9XVxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHByb2plY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG9ianMgVGhlIG9iamVjdHMgdG8gcXVlcnlcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGgganVzdCB0aGUgYHByb3BzYCBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhYmJ5ID0ge25hbWU6ICdBYmJ5JywgYWdlOiA3LCBoYWlyOiAnYmxvbmQnLCBncmFkZTogMn07XG4gKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJywgZ3JhZGU6IDd9O1xuICogICAgICB2YXIga2lkcyA9IFthYmJ5LCBmcmVkXTtcbiAqICAgICAgUi5wcm9qZWN0KFsnbmFtZScsICdncmFkZSddLCBraWRzKTsgLy89PiBbe25hbWU6ICdBYmJ5JywgZ3JhZGU6IDJ9LCB7bmFtZTogJ0ZyZWQnLCBncmFkZTogN31dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gdXNlV2l0aChfbWFwLCBbcGlja0FsbCwgaWRlbnRpdHldKTsgLy8gcGFzc2luZyBgaWRlbnRpdHlgIGdpdmVzIGNvcnJlY3QgYXJpdHlcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIHN1cHBsaWVkIGFuIG9iamVjdCByZXR1cm5zIHRoZSBpbmRpY2F0ZWRcbiAqIHByb3BlcnR5IG9mIHRoYXQgb2JqZWN0LCBpZiBpdCBleGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHMgLT4ge3M6IGF9IC0+IGEgfCBVbmRlZmluZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwIFRoZSBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBhdCBgb2JqLnBgLlxuICogQHNlZSBSLnBhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3AoJ3gnLCB7eDogMTAwfSk7IC8vPT4gMTAwXG4gKiAgICAgIFIucHJvcCgneCcsIHt9KTsgLy89PiB1bmRlZmluZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3AocCwgb2JqKSB7IHJldHVybiBvYmpbcF07IH0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBlcXVhbHMgPSByZXF1aXJlKCcuL2VxdWFscycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgZXF1YWwsIGluIGBSLmVxdWFsc2BcbiAqIHRlcm1zLCB0byB0aGUgZ2l2ZW4gdmFsdWU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFN0cmluZyAtPiBhIC0+IE9iamVjdCAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmVxdWFscywgUi5wcm9wU2F0aXNmaWVzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFiYnkgPSB7bmFtZTogJ0FiYnknLCBhZ2U6IDcsIGhhaXI6ICdibG9uZCd9O1xuICogICAgICB2YXIgZnJlZCA9IHtuYW1lOiAnRnJlZCcsIGFnZTogMTIsIGhhaXI6ICdicm93bid9O1xuICogICAgICB2YXIgcnVzdHkgPSB7bmFtZTogJ1J1c3R5JywgYWdlOiAxMCwgaGFpcjogJ2Jyb3duJ307XG4gKiAgICAgIHZhciBhbG9pcyA9IHtuYW1lOiAnQWxvaXMnLCBhZ2U6IDE1LCBkaXNwb3NpdGlvbjogJ3N1cmx5J307XG4gKiAgICAgIHZhciBraWRzID0gW2FiYnksIGZyZWQsIHJ1c3R5LCBhbG9pc107XG4gKiAgICAgIHZhciBoYXNCcm93bkhhaXIgPSBSLnByb3BFcSgnaGFpcicsICdicm93bicpO1xuICogICAgICBSLmZpbHRlcihoYXNCcm93bkhhaXIsIGtpZHMpOyAvLz0+IFtmcmVkLCBydXN0eV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHByb3BFcShuYW1lLCB2YWwsIG9iaikge1xuICByZXR1cm4gZXF1YWxzKHZhbCwgb2JqW25hbWVdKTtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGlzIG9mIHRoZSBnaXZlbiB0eXBlO1xuICogYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBzaWcgVHlwZSAtPiBTdHJpbmcgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5pcywgUi5wcm9wU2F0aXNmaWVzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHRydWVcbiAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt4OiAnZm9vJ30pOyAgICAvLz0+IGZhbHNlXG4gKiAgICAgIFIucHJvcElzKE51bWJlciwgJ3gnLCB7fSk7ICAgICAgICAgICAgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcElzKHR5cGUsIG5hbWUsIG9iaikge1xuICByZXR1cm4gaXModHlwZSwgb2JqW25hbWVdKTtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faGFzJyk7XG5cblxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLFxuICogcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eS4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHByb3ZpZGVkIGRlZmF1bHRcbiAqIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBhIC0+IFN0cmluZyAtPiBPYmplY3QgLT4gYVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFsaWNlID0ge1xuICogICAgICAgIG5hbWU6ICdBTElDRScsXG4gKiAgICAgICAgYWdlOiAxMDFcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIGZhdm9yaXRlID0gUi5wcm9wKCdmYXZvcml0ZUxpYnJhcnknKTtcbiAqICAgICAgdmFyIGZhdm9yaXRlV2l0aERlZmF1bHQgPSBSLnByb3BPcignUmFtZGEnLCAnZmF2b3JpdGVMaWJyYXJ5Jyk7XG4gKlxuICogICAgICBmYXZvcml0ZShhbGljZSk7ICAvLz0+IHVuZGVmaW5lZFxuICogICAgICBmYXZvcml0ZVdpdGhEZWZhdWx0KGFsaWNlKTsgIC8vPT4gJ1JhbWRhJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcE9yKHZhbCwgcCwgb2JqKSB7XG4gIHJldHVybiAob2JqICE9IG51bGwgJiYgX2hhcyhwLCBvYmopKSA/IG9ialtwXSA6IHZhbDtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IHNhdGlzZmllcyB0aGUgZ2l2ZW5cbiAqIHByZWRpY2F0ZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiB7U3RyaW5nOiBhfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIucHJvcEVxLCBSLnByb3BJc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcFNhdGlzZmllcyh4ID0+IHggPiAwLCAneCcsIHt4OiAxLCB5OiAyfSk7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcFNhdGlzZmllcyhwcmVkLCBuYW1lLCBvYmopIHtcbiAgcmV0dXJuIHByZWQob2JqW25hbWVdKTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIEFjdHMgYXMgbXVsdGlwbGUgYHByb3BgOiBhcnJheSBvZiBrZXlzIGluLCBhcnJheSBvZiB2YWx1ZXMgb3V0LiBQcmVzZXJ2ZXNcbiAqIG9yZGVyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IFt2XVxuICogQHBhcmFtIHtBcnJheX0gcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZldGNoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgb3IgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9wcyhbJ3gnLCAneSddLCB7eDogMSwgeTogMn0pOyAvLz0+IFsxLCAyXVxuICogICAgICBSLnByb3BzKFsnYycsICdhJywgJ2InXSwge2I6IDIsIGE6IDF9KTsgLy89PiBbdW5kZWZpbmVkLCAxLCAyXVxuICpcbiAqICAgICAgdmFyIGZ1bGxOYW1lID0gUi5jb21wb3NlKFIuam9pbignICcpLCBSLnByb3BzKFsnZmlyc3QnLCAnbGFzdCddKSk7XG4gKiAgICAgIGZ1bGxOYW1lKHtsYXN0OiAnQnVsbGV0LVRvb3RoJywgYWdlOiAzMywgZmlyc3Q6ICdUb255J30pOyAvLz0+ICdUb255IEJ1bGxldC1Ub290aCdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3BzKHBzLCBvYmopIHtcbiAgdmFyIGxlbiA9IHBzLmxlbmd0aDtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgb3V0W2lkeF0gPSBvYmpbcHNbaWR4XV07XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc051bWJlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzTnVtYmVyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBudW1iZXJzIGZyb20gYGZyb21gIChpbmNsdXNpdmUpIHRvIGB0b2AgKGV4Y2x1c2l2ZSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFtOdW1iZXJdXG4gKiBAcGFyYW0ge051bWJlcn0gZnJvbSBUaGUgZmlyc3QgbnVtYmVyIGluIHRoZSBsaXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHRvIE9uZSBtb3JlIHRoYW4gdGhlIGxhc3QgbnVtYmVyIGluIHRoZSBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIG51bWJlcnMgaW4gdHRoZSBzZXQgYFthLCBiKWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yYW5nZSgxLCA1KTsgICAgLy89PiBbMSwgMiwgMywgNF1cbiAqICAgICAgUi5yYW5nZSg1MCwgNTMpOyAgLy89PiBbNTAsIDUxLCA1Ml1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHJhbmdlKGZyb20sIHRvKSB7XG4gIGlmICghKF9pc051bWJlcihmcm9tKSAmJiBfaXNOdW1iZXIodG8pKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggYXJndW1lbnRzIHRvIHJhbmdlIG11c3QgYmUgbnVtYmVycycpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIG4gPSBmcm9tO1xuICB3aGlsZSAobiA8IHRvKSB7XG4gICAgcmVzdWx0LnB1c2gobik7XG4gICAgbiArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICogdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIGFuZCBwYXNzaW5nIGl0IGFuIGFjY3VtdWxhdG9yIHZhbHVlIGFuZCB0aGUgY3VycmVudFxuICogdmFsdWUgZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgbmV4dCBjYWxsLlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKGFjYywgdmFsdWUpKi4gSXQgbWF5IHVzZVxuICogYFIucmVkdWNlZGAgdG8gc2hvcnRjdXQgdGhlIGl0ZXJhdGlvbi5cbiAqXG4gKiBUaGUgYXJndW1lbnRzJyBvcmRlciBvZiBgcmVkdWNlUmlnaHRgJ3MgaXRlcmF0b3IgZnVuY3Rpb24gaXMgKih2YWx1ZSwgYWNjKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAqIGFycmF5cyksIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHNcbiAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSNEZXNjcmlwdGlvblxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGByZWR1Y2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlZCwgUi5hZGRJbmRleCwgUi5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVkdWNlKFIuc3VidHJhY3QsIDAsIFsxLCAyLCAzLCA0XSkgLy8gPT4gKCgoKDAgLSAxKSAtIDIpIC0gMykgLSA0KSA9IC0xMFxuICogICAgICAgICAgICAgICAgLSAgICAgICAgICAgICAgIC0xMFxuICogICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgICAgICAgICAgLSAgIDQgICAgICAgICAgIC02ICAgNFxuICogICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgICAtICAgMyAgID09PiAgICAgLTMgICAzXG4gKiAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgLSAgIDIgICAgICAgICAgIC0xICAgMlxuICogICAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgICAgMCAgIDEgICAgICAgICAgICAwICAgMVxuICpcbiAqIEBzeW1iIFIucmVkdWNlKGYsIGEsIFtiLCBjLCBkXSkgPSBmKGYoZihhLCBiKSwgYyksIGQpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhfcmVkdWNlKTtcbiIsInZhciBfY3VycnlOID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnlOJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIgX3hyZWR1Y2VCeSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hyZWR1Y2VCeScpO1xuXG5cbi8qKlxuICogR3JvdXBzIHRoZSBlbGVtZW50cyBvZiB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gKiB0aGUgU3RyaW5nLXJldHVybmluZyBmdW5jdGlvbiBga2V5Rm5gIG9uIGVhY2ggZWxlbWVudCBhbmQgcmVkdWNlcyB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggZ3JvdXAgdG8gYSBzaW5nbGUgdmFsdWUgdmlhIHRoZSByZWR1Y2VyIGZ1bmN0aW9uIGB2YWx1ZUZuYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2ljYWxseSBhIG1vcmUgZ2VuZXJhbCBgZ3JvdXBCeWAgZnVuY3Rpb24uXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiAoYiAtPiBTdHJpbmcpIC0+IFtiXSAtPiB7U3RyaW5nOiBhfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsdWVGbiBUaGUgZnVuY3Rpb24gdGhhdCByZWR1Y2VzIHRoZSBlbGVtZW50cyBvZiBlYWNoIGdyb3VwIHRvIGEgc2luZ2xlXG4gKiAgICAgICAgdmFsdWUuIFJlY2VpdmVzIHR3byB2YWx1ZXMsIGFjY3VtdWxhdG9yIGZvciBhIHBhcnRpY3VsYXIgZ3JvdXAgYW5kIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgKGluaXRpYWwpIGFjY3VtdWxhdG9yIHZhbHVlIGZvciBlYWNoIGdyb3VwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5Rm4gVGhlIGZ1bmN0aW9uIHRoYXQgbWFwcyB0aGUgbGlzdCdzIGVsZW1lbnQgaW50byBhIGtleS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBrZXlGbmAgZm9yIGtleXMsIG1hcHBlZCB0byB0aGUgb3V0cHV0IG9mXG4gKiAgICAgICAgIGB2YWx1ZUZuYCBmb3IgZWxlbWVudHMgd2hpY2ggcHJvZHVjZWQgdGhhdCBrZXkgd2hlbiBwYXNzZWQgdG8gYGtleUZuYC5cbiAqIEBzZWUgUi5ncm91cEJ5LCBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciByZWR1Y2VUb05hbWVzQnkgPSBSLnJlZHVjZUJ5KChhY2MsIHN0dWRlbnQpID0+IGFjYy5jb25jYXQoc3R1ZGVudC5uYW1lKSwgW10pO1xuICogICAgICB2YXIgbmFtZXNCeUdyYWRlID0gcmVkdWNlVG9OYW1lc0J5KGZ1bmN0aW9uKHN0dWRlbnQpIHtcbiAqICAgICAgICB2YXIgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICogICAgICAgIHJldHVybiBzY29yZSA8IDY1ID8gJ0YnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnO1xuICogICAgICB9KTtcbiAqICAgICAgdmFyIHN0dWRlbnRzID0gW3tuYW1lOiAnTHVjeScsIHNjb3JlOiA5Mn0sXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0RyZXcnLCBzY29yZTogODV9LFxuICogICAgICAgICAgICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0JhcnQnLCBzY29yZTogNjJ9XTtcbiAqICAgICAgbmFtZXNCeUdyYWRlKHN0dWRlbnRzKTtcbiAqICAgICAgLy8ge1xuICogICAgICAvLyAgICdBJzogWydMdWN5J10sXG4gKiAgICAgIC8vICAgJ0InOiBbJ0RyZXcnXVxuICogICAgICAvLyAgIC8vIC4uLixcbiAqICAgICAgLy8gICAnRic6IFsnQmFydCddXG4gKiAgICAgIC8vIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnlOKDQsIFtdLCBfZGlzcGF0Y2hhYmxlKFtdLCBfeHJlZHVjZUJ5LFxuICBmdW5jdGlvbiByZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIGxpc3QpIHtcbiAgICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbihhY2MsIGVsdCkge1xuICAgICAgdmFyIGtleSA9IGtleUZuKGVsdCk7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlRm4oX2hhcyhrZXksIGFjYykgPyBhY2Nba2V5XSA6IHZhbHVlQWNjLCBlbHQpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSwgbGlzdCk7XG4gIH0pKTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nXG4gKiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogU2ltaWxhciB0byBgcmVkdWNlYCwgZXhjZXB0IG1vdmVzIHRocm91Z2ggdGhlIGlucHV0IGxpc3QgZnJvbSB0aGUgcmlnaHQgdG9cbiAqIHRoZSBsZWZ0LlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKHZhbHVlLCBhY2MpKiwgd2hpbGUgdGhlIGFyZ3VtZW50cydcbiAqIG9yZGVyIG9mIGByZWR1Y2VgJ3MgaXRlcmF0b3IgZnVuY3Rpb24gaXMgKihhY2MsIHZhbHVlKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlUmlnaHRgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZVxuICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZC4gRm9yIG1vcmUgZGV0YWlsc1xuICogb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHQjRGVzY3JpcHRpb25cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhLCBiIC0+IGIpIC0+IGIgLT4gW2FdIC0+IGJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICogICAgICAgIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZWR1Y2VSaWdodChSLnN1YnRyYWN0LCAwLCBbMSwgMiwgMywgNF0pIC8vID0+ICgxIC0gKDIgLSAoMyAtICg0IC0gMCkpKSkgPSAtMlxuICogICAgICAgICAgLSAgICAgICAgICAgICAgIC0yXG4gKiAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgICAxICAgLSAgICAgICAgICAgIDEgICAzXG4gKiAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgMiAgIC0gICAgID09PiAgICAyICAtMVxuICogICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgICAzICAgLSAgICAgICAgICAgIDMgICA0XG4gKiAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgICAgICAgICA0ICAgMCAgICAgICAgICAgIDQgICAwXG4gKlxuICogQHN5bWIgUi5yZWR1Y2VSaWdodChmLCBhLCBbYiwgYywgZF0pID0gZihiLCBmKGMsIGYoZCwgYSkpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gcmVkdWNlUmlnaHQoZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBhY2MgPSBmbihsaXN0W2lkeF0sIGFjYyk7XG4gICAgaWR4IC09IDE7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn0pO1xuIiwidmFyIF9jdXJyeU4gPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeU4nKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2VkJyk7XG5cblxuLyoqXG4gKiBMaWtlIGByZWR1Y2VgLCBgcmVkdWNlV2hpbGVgIHJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaFxuICogdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nIHRoZSBpdGVyYXRvciBmdW5jdGlvbi4gYHJlZHVjZVdoaWxlYCBhbHNvXG4gKiB0YWtlcyBhIHByZWRpY2F0ZSB0aGF0IGlzIGV2YWx1YXRlZCBiZWZvcmUgZWFjaCBzdGVwLiBJZiB0aGUgcHJlZGljYXRlIHJldHVybnNcbiAqIGBmYWxzZWAsIGl0IFwic2hvcnQtY2lyY3VpdHNcIiB0aGUgaXRlcmF0aW9uIGFuZCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlXG4gKiBvZiB0aGUgYWNjdW11bGF0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBCb29sZWFuKSAtPiAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgVGhlIHByZWRpY2F0ZS4gSXQgaXMgcGFzc2VkIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGVcbiAqICAgICAgICBhY2N1bXVsYXRvciBhbmQgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gYSBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLnJlZHVjZWRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNPZGQgPSAoYWNjLCB4KSA9PiB4ICUgMiA9PT0gMTtcbiAqICAgICAgdmFyIHhzID0gWzEsIDMsIDUsIDYwLCA3NzcsIDgwMF07XG4gKiAgICAgIFIucmVkdWNlV2hpbGUoaXNPZGQsIFIuYWRkLCAwLCB4cyk7IC8vPT4gOVxuICpcbiAqICAgICAgdmFyIHlzID0gWzIsIDQsIDZdXG4gKiAgICAgIFIucmVkdWNlV2hpbGUoaXNPZGQsIFIuYWRkLCAxMTEsIHlzKTsgLy89PiAxMTFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnlOKDQsIFtdLCBmdW5jdGlvbiBfcmVkdWNlV2hpbGUocHJlZCwgZm4sIGEsIGxpc3QpIHtcbiAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24oYWNjLCB4KSB7XG4gICAgcmV0dXJuIHByZWQoYWNjLCB4KSA/IGZuKGFjYywgeCkgOiBfcmVkdWNlZChhY2MpO1xuICB9LCBhLCBsaXN0KTtcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfcmVkdWNlZCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZWQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgd3JhcHBlZCB0byBpbmRpY2F0ZSB0aGF0IGl0IGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgcmVkdWNlXG4gKiBhbmQgdHJhbnNkdWNlIGZ1bmN0aW9ucy4gVGhlIHJldHVybmVkIHZhbHVlIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgYmxhY2tcbiAqIGJveDogdGhlIGludGVybmFsIHN0cnVjdHVyZSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzdGFibGUuXG4gKlxuICogTm90ZTogdGhpcyBvcHRpbWl6YXRpb24gaXMgdW5hdmFpbGFibGUgdG8gZnVuY3Rpb25zIG5vdCBleHBsaWNpdGx5IGxpc3RlZFxuICogYWJvdmUuIEZvciBpbnN0YW5jZSwgaXQgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgcmVkdWNlUmlnaHQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiAqXG4gKiBAcGFyYW0geyp9IHggVGhlIGZpbmFsIHZhbHVlIG9mIHRoZSByZWR1Y2UuXG4gKiBAcmV0dXJuIHsqfSBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2UsIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZWR1Y2UoXG4gKiAgICAgICAgUi5waXBlKFIuYWRkLCBSLndoZW4oUi5ndGUoUi5fXywgMTApLCBSLnJlZHVjZWQpKSxcbiAqICAgICAgICAwLFxuICogICAgICAgIFsxLCAyLCAzLCA0LCA1XSkgLy8gMTBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoX3JlZHVjZWQpO1xuIiwidmFyIF9jb21wbGVtZW50ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29tcGxlbWVudCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG5cbi8qKlxuICogVGhlIGNvbXBsZW1lbnQgb2YgYGZpbHRlcmAuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmFibGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHNlZSBSLmZpbHRlciwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNPZGQgPSAobikgPT4gbiAlIDIgPT09IDE7XG4gKlxuICogICAgICBSLnJlamVjdChpc09kZCwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAqXG4gKiAgICAgIFIucmVqZWN0KGlzT2RkLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBkOiA0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcmVqZWN0KHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIGZpbHRlcihfY29tcGxlbWVudChwcmVkKSwgZmlsdGVyYWJsZSk7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBzdWItbGlzdCBvZiBgbGlzdGAgc3RhcnRpbmcgYXQgaW5kZXggYHN0YXJ0YCBhbmQgY29udGFpbmluZ1xuICogYGNvdW50YCBlbGVtZW50cy4gX05vdGUgdGhhdCB0aGlzIGlzIG5vdCBkZXN0cnVjdGl2ZV86IGl0IHJldHVybnMgYSBjb3B5IG9mXG4gKiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjJcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFRoZSBwb3NpdGlvbiB0byBzdGFydCByZW1vdmluZyBlbGVtZW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHJlbW92ZSBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgY291bnRgIGVsZW1lbnRzIGZyb20gYHN0YXJ0YCByZW1vdmVkLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVtb3ZlKDIsIDMsIFsxLDIsMyw0LDUsNiw3LDhdKTsgLy89PiBbMSwyLDYsNyw4XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBjb3VudCwgbGlzdCkge1xuICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCk7XG4gIHJlc3VsdC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBhbHdheXMgPSByZXF1aXJlKCcuL2Fsd2F5cycpO1xudmFyIHRpbWVzID0gcmVxdWlyZSgnLi90aW1lcycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZpeGVkIGxpc3Qgb2Ygc2l6ZSBgbmAgY29udGFpbmluZyBhIHNwZWNpZmllZCBpZGVudGljYWwgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IG4gLT4gW2FdXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXBlYXQuXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBvdXRwdXQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheSBjb250YWluaW5nIGBuYCBgdmFsdWVgcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlcGVhdCgnaGknLCA1KTsgLy89PiBbJ2hpJywgJ2hpJywgJ2hpJywgJ2hpJywgJ2hpJ11cbiAqXG4gKiAgICAgIHZhciBvYmogPSB7fTtcbiAqICAgICAgdmFyIHJlcGVhdGVkT2JqcyA9IFIucmVwZWF0KG9iaiwgNSk7IC8vPT4gW3t9LCB7fSwge30sIHt9LCB7fV1cbiAqICAgICAgcmVwZWF0ZWRPYmpzWzBdID09PSByZXBlYXRlZE9ianNbMV07IC8vPT4gdHJ1ZVxuICogQHN5bWIgUi5yZXBlYXQoYSwgMCkgPSBbXVxuICogQHN5bWIgUi5yZXBlYXQoYSwgMSkgPSBbYV1cbiAqIEBzeW1iIFIucmVwZWF0KGEsIDIpID0gW2EsIGFdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiByZXBlYXQodmFsdWUsIG4pIHtcbiAgcmV0dXJuIHRpbWVzKGFsd2F5cyh2YWx1ZSksIG4pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogUmVwbGFjZSBhIHN1YnN0cmluZyBvciByZWdleCBtYXRjaCBpbiBhIHN0cmluZyB3aXRoIGEgcmVwbGFjZW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFJlZ0V4cHxTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcGF0dGVybiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBhIHN1YnN0cmluZyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIHJlcGxhY2UgdGhlIG1hdGNoZXMgd2l0aC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byBkbyB0aGUgc2VhcmNoIGFuZCByZXBsYWNlbWVudCBpbi5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlcGxhY2UoJ2ZvbycsICdiYXInLCAnZm9vIGZvbyBmb28nKTsgLy89PiAnYmFyIGZvbyBmb28nXG4gKiAgICAgIFIucmVwbGFjZSgvZm9vLywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgZm9vIGZvbydcbiAqXG4gKiAgICAgIC8vIFVzZSB0aGUgXCJnXCIgKGdsb2JhbCkgZmxhZyB0byByZXBsYWNlIGFsbCBvY2N1cnJlbmNlczpcbiAqICAgICAgUi5yZXBsYWNlKC9mb28vZywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgYmFyIGJhcidcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIHJlcGxhY2VtZW50LCBzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4LCByZXBsYWNlbWVudCk7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2lzU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNTdHJpbmcnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBvciBzdHJpbmcgd2l0aCB0aGUgZWxlbWVudHMgb3IgY2hhcmFjdGVycyBpbiByZXZlcnNlXG4gKiBvcmRlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGxpc3RcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ31cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJldmVyc2UoWzEsIDIsIDNdKTsgIC8vPT4gWzMsIDIsIDFdXG4gKiAgICAgIFIucmV2ZXJzZShbMSwgMl0pOyAgICAgLy89PiBbMiwgMV1cbiAqICAgICAgUi5yZXZlcnNlKFsxXSk7ICAgICAgICAvLz0+IFsxXVxuICogICAgICBSLnJldmVyc2UoW10pOyAgICAgICAgIC8vPT4gW11cbiAqXG4gKiAgICAgIFIucmV2ZXJzZSgnYWJjJyk7ICAgICAgLy89PiAnY2JhJ1xuICogICAgICBSLnJldmVyc2UoJ2FiJyk7ICAgICAgIC8vPT4gJ2JhJ1xuICogICAgICBSLnJldmVyc2UoJ2EnKTsgICAgICAgIC8vPT4gJ2EnXG4gKiAgICAgIFIucmV2ZXJzZSgnJyk7ICAgICAgICAgLy89PiAnJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gcmV2ZXJzZShsaXN0KSB7XG4gIHJldHVybiBfaXNTdHJpbmcobGlzdCkgPyBsaXN0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkucmV2ZXJzZSgpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogU2NhbiBpcyBzaW1pbGFyIHRvIHJlZHVjZSwgYnV0IHJldHVybnMgYSBsaXN0IG9mIHN1Y2Nlc3NpdmVseSByZWR1Y2VkIHZhbHVlc1xuICogZnJvbSB0aGUgbGVmdFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhLGIgLT4gYSkgLT4gYSAtPiBbYl0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgYWxsIGludGVybWVkaWF0ZWx5IHJlZHVjZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBudW1iZXJzID0gWzEsIDIsIDMsIDRdO1xuICogICAgICB2YXIgZmFjdG9yaWFscyA9IFIuc2NhbihSLm11bHRpcGx5LCAxLCBudW1iZXJzKTsgLy89PiBbMSwgMSwgMiwgNiwgMjRdXG4gKiBAc3ltYiBSLnNjYW4oZiwgYSwgW2IsIGNdKSA9IFthLCBmKGEsIGIpLCBmKGYoYSwgYiksIGMpXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gc2NhbihmbiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbYWNjXTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGFjYyA9IGZuKGFjYywgbGlzdFtpZHhdKTtcbiAgICByZXN1bHRbaWR4ICsgMV0gPSBhY2M7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBhcCA9IHJlcXVpcmUoJy4vYXAnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xudmFyIHByZXBlbmQgPSByZXF1aXJlKCcuL3ByZXBlbmQnKTtcbnZhciByZWR1Y2VSaWdodCA9IHJlcXVpcmUoJy4vcmVkdWNlUmlnaHQnKTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBbVHJhdmVyc2FibGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2FibGUpXG4gKiBvZiBbQXBwbGljYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbGljYXRpdmUpIGludG8gYW5cbiAqIEFwcGxpY2F0aXZlIG9mIFRyYXZlcnNhYmxlLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBzZXF1ZW5jZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChhIC0+IGYgYSkgLT4gdCAoZiBhKSAtPiBmICh0IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvZlxuICogQHBhcmFtIHsqfSB0cmF2ZXJzYWJsZVxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi50cmF2ZXJzZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc2VxdWVuY2UoTWF5YmUub2YsIFtKdXN0KDEpLCBKdXN0KDIpLCBKdXN0KDMpXSk7ICAgLy89PiBKdXN0KFsxLCAyLCAzXSlcbiAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIE5vdGhpbmcoKV0pOyAvLz0+IE5vdGhpbmcoKVxuICpcbiAqICAgICAgUi5zZXF1ZW5jZShSLm9mLCBKdXN0KFsxLCAyLCAzXSkpOyAvLz0+IFtKdXN0KDEpLCBKdXN0KDIpLCBKdXN0KDMpXVxuICogICAgICBSLnNlcXVlbmNlKFIub2YsIE5vdGhpbmcoKSk7ICAgICAgIC8vPT4gW05vdGhpbmcoKV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHNlcXVlbmNlKG9mLCB0cmF2ZXJzYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHRyYXZlcnNhYmxlLnNlcXVlbmNlID09PSAnZnVuY3Rpb24nID9cbiAgICB0cmF2ZXJzYWJsZS5zZXF1ZW5jZShvZikgOlxuICAgIHJlZHVjZVJpZ2h0KGZ1bmN0aW9uKHgsIGFjYykgeyByZXR1cm4gYXAobWFwKHByZXBlbmQsIHgpLCBhY2MpOyB9LFxuICAgICAgICAgICAgICAgIG9mKFtdKSxcbiAgICAgICAgICAgICAgICB0cmF2ZXJzYWJsZSk7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgYWx3YXlzID0gcmVxdWlyZSgnLi9hbHdheXMnKTtcbnZhciBvdmVyID0gcmVxdWlyZSgnLi9vdmVyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgXCJzZXR0aW5nXCIgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlXG4gKiBmb2N1c2VkIGJ5IHRoZSBnaXZlbiBsZW5zIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBMZW5zIHMgYSAtPiBhIC0+IHMgLT4gc1xuICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gKiBAcGFyYW0geyp9IHZcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5wcm9wLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4TGVucyA9IFIubGVuc1Byb3AoJ3gnKTtcbiAqXG4gKiAgICAgIFIuc2V0KHhMZW5zLCA0LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogNCwgeTogMn1cbiAqICAgICAgUi5zZXQoeExlbnMsIDgsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt4OiA4LCB5OiAyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gc2V0KGxlbnMsIHYsIHgpIHtcbiAgcmV0dXJuIG92ZXIobGVucywgYWx3YXlzKHYpLCB4KTtcbn0pO1xuIiwidmFyIF9jaGVja0Zvck1ldGhvZCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJyk7XG52YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3Qgd2l0aCBhIGBzbGljZWBcbiAqIG1ldGhvZCkgZnJvbSBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byBgdG9JbmRleGAgKGV4Y2x1c2l2ZSkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBUaGUgc3RhcnQgaW5kZXggKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4IChleGNsdXNpdmUpLlxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc2xpY2UoMSwgMywgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAgLy89PiBbJ2InLCAnYyddXG4gKiAgICAgIFIuc2xpY2UoMSwgSW5maW5pdHksIFsnYScsICdiJywgJ2MnLCAnZCddKTsgLy89PiBbJ2InLCAnYycsICdkJ11cbiAqICAgICAgUi5zbGljZSgwLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKC0zLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgIC8vPT4gWydiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKDAsIDMsICdyYW1kYScpOyAgICAgICAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKF9jaGVja0Zvck1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShmcm9tSW5kZXgsIHRvSW5kZXgsIGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGZyb21JbmRleCwgdG9JbmRleCk7XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3QsIHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24sXG4gKiB3aGljaCBzaG91bGQgYWNjZXB0IHR3byB2YWx1ZXMgYXQgYSB0aW1lIGFuZCByZXR1cm4gYSBuZWdhdGl2ZSBudW1iZXIgaWYgdGhlXG4gKiBmaXJzdCB2YWx1ZSBpcyBzbWFsbGVyLCBhIHBvc2l0aXZlIG51bWJlciBpZiBpdCdzIGxhcmdlciwgYW5kIHplcm8gaWYgdGhleVxuICogYXJlIGVxdWFsLiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgaXMgYSAqKmNvcHkqKiBvZiB0aGUgbGlzdC4gSXQgZG9lcyBub3RcbiAqIG1vZGlmeSB0aGUgb3JpZ2luYWwuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSxhIC0+IE51bWJlcikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBBIHNvcnRpbmcgZnVuY3Rpb24gOjogYSAtPiBiIC0+IEludFxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0XG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgd2l0aCBpdHMgZWxlbWVudHMgc29ydGVkIGJ5IHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkaWZmID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG4gKiAgICAgIFIuc29ydChkaWZmLCBbNCwyLDcsNV0pOyAvLz0+IFsyLCA0LCA1LCA3XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gc29ydChjb21wYXJhdG9yLCBsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwKS5zb3J0KGNvbXBhcmF0b3IpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogU29ydHMgdGhlIGxpc3QgYWNjb3JkaW5nIHRvIHRoZSBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3Qgc29ydGVkIGJ5IHRoZSBrZXlzIGdlbmVyYXRlZCBieSBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzb3J0QnlGaXJzdEl0ZW0gPSBSLnNvcnRCeShSLnByb3AoMCkpO1xuICogICAgICB2YXIgc29ydEJ5TmFtZUNhc2VJbnNlbnNpdGl2ZSA9IFIuc29ydEJ5KFIuY29tcG9zZShSLnRvTG93ZXIsIFIucHJvcCgnbmFtZScpKSk7XG4gKiAgICAgIHZhciBwYWlycyA9IFtbLTEsIDFdLCBbLTIsIDJdLCBbLTMsIDNdXTtcbiAqICAgICAgc29ydEJ5Rmlyc3RJdGVtKHBhaXJzKTsgLy89PiBbWy0zLCAzXSwgWy0yLCAyXSwgWy0xLCAxXV1cbiAqICAgICAgdmFyIGFsaWNlID0ge1xuICogICAgICAgIG5hbWU6ICdBTElDRScsXG4gKiAgICAgICAgYWdlOiAxMDFcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIGJvYiA9IHtcbiAqICAgICAgICBuYW1lOiAnQm9iJyxcbiAqICAgICAgICBhZ2U6IC0xMFxuICogICAgICB9O1xuICogICAgICB2YXIgY2xhcmEgPSB7XG4gKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAqICAgICAgICBhZ2U6IDMxNC4xNTlcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtjbGFyYSwgYm9iLCBhbGljZV07XG4gKiAgICAgIHNvcnRCeU5hbWVDYXNlSW5zZW5zaXRpdmUocGVvcGxlKTsgLy89PiBbYWxpY2UsIGJvYiwgY2xhcmFdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBzb3J0QnkoZm4sIGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBhYSA9IGZuKGEpO1xuICAgIHZhciBiYiA9IGZuKGIpO1xuICAgIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG4gIH0pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogU29ydHMgYSBsaXN0IGFjY29yZGluZyB0byBhIGxpc3Qgb2YgY29tcGFyYXRvcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFthIC0+IGEgLT4gTnVtYmVyXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBmdW5jdGlvbnMgQSBsaXN0IG9mIGNvbXBhcmF0b3IgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3Qgc29ydGVkIGFjY29yZGluZyB0byB0aGUgY29tYXJhdG9yIGZ1bmN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWxpY2UgPSB7XG4gKiAgICAgICAgbmFtZTogJ2FsaWNlJyxcbiAqICAgICAgICBhZ2U6IDQwXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBib2IgPSB7XG4gKiAgICAgICAgbmFtZTogJ2JvYicsXG4gKiAgICAgICAgYWdlOiAzMFxuICogICAgICB9O1xuICogICAgICB2YXIgY2xhcmEgPSB7XG4gKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAqICAgICAgICBhZ2U6IDQwXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBwZW9wbGUgPSBbY2xhcmEsIGJvYiwgYWxpY2VdO1xuICogICAgICB2YXIgYWdlTmFtZVNvcnQgPSBSLnNvcnRXaXRoKFtcbiAqICAgICAgICBSLmRlc2NlbmQoUi5wcm9wKCdhZ2UnKSksXG4gKiAgICAgICAgUi5hc2NlbmQoUi5wcm9wKCduYW1lJykpXG4gKiAgICAgIF0pO1xuICogICAgICBhZ2VOYW1lU29ydChwZW9wbGUpOyAvLz0+IFthbGljZSwgY2xhcmEsIGJvYl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHNvcnRXaXRoKGZucywgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChyZXN1bHQgPT09IDAgJiYgaSA8IGZucy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGZuc1tpXShhLCBiKTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59KTtcbiIsInZhciBpbnZva2VyID0gcmVxdWlyZSgnLi9pbnZva2VyJyk7XG5cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBnaXZlblxuICogc2VwYXJhdG9yLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHNpZyAoU3RyaW5nIHwgUmVnRXhwKSAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gc2VwIFRoZSBwYXR0ZXJuLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHNlcGFyYXRlIGludG8gYW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHN0cmluZ3MgZnJvbSBgc3RyYCBzZXBhcmF0ZWQgYnkgYHN0cmAuXG4gKiBAc2VlIFIuam9pblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBwYXRoQ29tcG9uZW50cyA9IFIuc3BsaXQoJy8nKTtcbiAqICAgICAgUi50YWlsKHBhdGhDb21wb25lbnRzKCcvdXNyL2xvY2FsL2Jpbi9ub2RlJykpOyAvLz0+IFsndXNyJywgJ2xvY2FsJywgJ2JpbicsICdub2RlJ11cbiAqXG4gKiAgICAgIFIuc3BsaXQoJy4nLCAnYS5iLmMueHl6LmQnKTsgLy89PiBbJ2EnLCAnYicsICdjJywgJ3h5eicsICdkJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBpbnZva2VyKDEsICdzcGxpdCcpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBsZW5ndGggPSByZXF1aXJlKCcuL2xlbmd0aCcpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbi8qKlxuICogU3BsaXRzIGEgZ2l2ZW4gbGlzdCBvciBzdHJpbmcgYXQgYSBnaXZlbiBpbmRleC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFtbYV0sIFthXV1cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBbU3RyaW5nLCBTdHJpbmddXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBhcnJheS9zdHJpbmcgaXMgc3BsaXQuXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYXJyYXkgVGhlIGFycmF5L3N0cmluZyB0byBiZSBzcGxpdC5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3BsaXRBdCgxLCBbMSwgMiwgM10pOyAgICAgICAgICAvLz0+IFtbMV0sIFsyLCAzXV1cbiAqICAgICAgUi5zcGxpdEF0KDUsICdoZWxsbyB3b3JsZCcpOyAgICAgIC8vPT4gWydoZWxsbycsICcgd29ybGQnXVxuICogICAgICBSLnNwbGl0QXQoLTEsICdmb29iYXInKTsgICAgICAgICAgLy89PiBbJ2Zvb2JhJywgJ3InXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gc3BsaXRBdChpbmRleCwgYXJyYXkpIHtcbiAgcmV0dXJuIFtzbGljZSgwLCBpbmRleCwgYXJyYXkpLCBzbGljZShpbmRleCwgbGVuZ3RoKGFycmF5KSwgYXJyYXkpXTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuXG4vKipcbiAqIFNwbGl0cyBhIGNvbGxlY3Rpb24gaW50byBzbGljZXMgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFtTdHJpbmddXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zcGxpdEV2ZXJ5KDMsIFsxLCAyLCAzLCA0LCA1LCA2LCA3XSk7IC8vPT4gW1sxLCAyLCAzXSwgWzQsIDUsIDZdLCBbN11dXG4gKiAgICAgIFIuc3BsaXRFdmVyeSgzLCAnZm9vYmFyYmF6Jyk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBzcGxpdEV2ZXJ5KG4sIGxpc3QpIHtcbiAgaWYgKG4gPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gc3BsaXRFdmVyeSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKHNsaWNlKGlkeCwgaWR4ICs9IG4sIGxpc3QpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IGFuZCBhIHByZWRpY2F0ZSBhbmQgcmV0dXJucyBhIHBhaXIgb2YgbGlzdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogIC0gdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIHRoZSB0d28gb3V0cHV0IGxpc3RzIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IGxpc3Q7XG4gKiAgLSBub25lIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZmlyc3Qgb3V0cHV0IGxpc3Qgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IGFuZFxuICogIC0gaWYgdGhlIHNlY29uZCBvdXRwdXQgbGlzdCBpcyBub24tZW1wdHksIGl0cyBmaXJzdCBlbGVtZW50IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIFRoZSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzIHdoZXJlIHRoZSBhcnJheSBpcyBzcGxpdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGJlIHNwbGl0LlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zcGxpdFdoZW4oUi5lcXVhbHMoMiksIFsxLCAyLCAzLCAxLCAyLCAzXSk7ICAgLy89PiBbWzFdLCBbMiwgMywgMSwgMiwgM11dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBzcGxpdFdoZW4ocHJlZCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcHJlZml4ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbiAmJiAhcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgcHJlZml4LnB1c2gobGlzdFtpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBbcHJlZml4LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgpXTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFN1YnRyYWN0cyBpdHMgc2Vjb25kIGFyZ3VtZW50IGZyb20gaXRzIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgLSBiYC5cbiAqIEBzZWUgUi5hZGRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnN1YnRyYWN0KDEwLCA4KTsgLy89PiAyXG4gKlxuICogICAgICB2YXIgbWludXM1ID0gUi5zdWJ0cmFjdChSLl9fLCA1KTtcbiAqICAgICAgbWludXM1KDE3KTsgLy89PiAxMlxuICpcbiAqICAgICAgdmFyIGNvbXBsZW1lbnRhcnlBbmdsZSA9IFIuc3VidHJhY3QoOTApO1xuICogICAgICBjb21wbGVtZW50YXJ5QW5nbGUoMzApOyAvLz0+IDYwXG4gKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSg3Mik7IC8vPT4gMThcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHtcbiAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbn0pO1xuIiwidmFyIGFkZCA9IHJlcXVpcmUoJy4vYWRkJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcblxuXG4vKipcbiAqIEFkZHMgdG9nZXRoZXIgYWxsIHRoZSBlbGVtZW50cyBvZiBhIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBbTnVtYmVyXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3VtIG9mIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgbGlzdC5cbiAqIEBzZWUgUi5yZWR1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnN1bShbMiw0LDYsOCwxMDAsMV0pOyAvLz0+IDEyMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZShhZGQsIDApO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBjb25jYXQgPSByZXF1aXJlKCcuL2NvbmNhdCcpO1xudmFyIGRpZmZlcmVuY2UgPSByZXF1aXJlKCcuL2RpZmZlcmVuY2UnKTtcblxuXG4vKipcbiAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3Qgb3JcbiAqIHNlY29uZCBsaXN0LCBidXQgbm90IGJvdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFsqXSAtPiBbKl0gLT4gWypdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZWxlbWVudHMgaW4gYGxpc3QxYCBvciBgbGlzdDJgLCBidXQgbm90IGJvdGguXG4gKiBAc2VlIFIuc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgsIFIuZGlmZmVyZW5jZSwgUi5kaWZmZXJlbmNlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3ltbWV0cmljRGlmZmVyZW5jZShbMSwyLDMsNF0sIFs3LDYsNSw0LDNdKTsgLy89PiBbMSwyLDcsNiw1XVxuICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2UoWzcsNiw1LDQsM10sIFsxLDIsMyw0XSk7IC8vPT4gWzcsNiw1LDEsMl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2UobGlzdDEsIGxpc3QyKSB7XG4gIHJldHVybiBjb25jYXQoZGlmZmVyZW5jZShsaXN0MSwgbGlzdDIpLCBkaWZmZXJlbmNlKGxpc3QyLCBsaXN0MSkpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGNvbmNhdCA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XG52YXIgZGlmZmVyZW5jZVdpdGggPSByZXF1aXJlKCcuL2RpZmZlcmVuY2VXaXRoJyk7XG5cblxuLyoqXG4gKiBGaW5kcyB0aGUgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIGZpcnN0IG9yXG4gKiBzZWNvbmQgbGlzdCwgYnV0IG5vdCBib3RoLiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGUgdmFsdWVcbiAqIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIG9yIGBsaXN0MmAsIGJ1dCBub3QgYm90aC5cbiAqIEBzZWUgUi5zeW1tZXRyaWNEaWZmZXJlbmNlLCBSLmRpZmZlcmVuY2UsIFIuZGlmZmVyZW5jZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZXFBID0gUi5lcUJ5KFIucHJvcCgnYScpKTtcbiAqICAgICAgdmFyIGwxID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV07XG4gKiAgICAgIHZhciBsMiA9IFt7YTogM30sIHthOiA0fSwge2E6IDV9LCB7YTogNn1dO1xuICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoKGVxQSwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn0sIHthOiA1fSwge2E6IDZ9XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDEsIGxpc3QyKSB7XG4gIHJldHVybiBjb25jYXQoZGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDEsIGxpc3QyKSwgZGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDIsIGxpc3QxKSk7XG59KTtcbiIsInZhciBfY2hlY2tGb3JNZXRob2QgPSByZXF1aXJlKCcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCcpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcgKG9yIG9iamVjdFxuICogd2l0aCBhIGB0YWlsYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmhlYWQsIFIuaW5pdCwgUi5sYXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50YWlsKFsxLCAyLCAzXSk7ICAvLz0+IFsyLCAzXVxuICogICAgICBSLnRhaWwoWzEsIDJdKTsgICAgIC8vPT4gWzJdXG4gKiAgICAgIFIudGFpbChbMV0pOyAgICAgICAgLy89PiBbXVxuICogICAgICBSLnRhaWwoW10pOyAgICAgICAgIC8vPT4gW11cbiAqXG4gKiAgICAgIFIudGFpbCgnYWJjJyk7ICAvLz0+ICdiYydcbiAqICAgICAgUi50YWlsKCdhYicpOyAgIC8vPT4gJ2InXG4gKiAgICAgIFIudGFpbCgnYScpOyAgICAvLz0+ICcnXG4gKiAgICAgIFIudGFpbCgnJyk7ICAgICAvLz0+ICcnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShfY2hlY2tGb3JNZXRob2QoJ3RhaWwnLCBzbGljZSgxLCBJbmZpbml0eSkpKTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94dGFrZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3h0YWtlJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuL3NsaWNlJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QsIHN0cmluZywgb3JcbiAqIHRyYW5zZHVjZXIvdHJhbnNmb3JtZXIgKG9yIG9iamVjdCB3aXRoIGEgYHRha2VgIG1ldGhvZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHRha2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuZHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGFrZSgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJ11cbiAqICAgICAgUi50YWtlKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAqICAgICAgUi50YWtlKDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZSg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2UoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAncmFtJ1xuICpcbiAqICAgICAgdmFyIHBlcnNvbm5lbCA9IFtcbiAqICAgICAgICAnRGF2ZSBCcnViZWNrJyxcbiAqICAgICAgICAnUGF1bCBEZXNtb25kJyxcbiAqICAgICAgICAnRXVnZW5lIFdyaWdodCcsXG4gKiAgICAgICAgJ0pvZSBNb3JlbGxvJyxcbiAqICAgICAgICAnR2VycnkgTXVsbGlnYW4nLFxuICogICAgICAgICdCb2IgQmF0ZXMnLFxuICogICAgICAgICdKb2UgRG9kZ2UnLFxuICogICAgICAgICdSb24gQ3JvdHR5J1xuICogICAgICBdO1xuICpcbiAqICAgICAgdmFyIHRha2VGaXZlID0gUi50YWtlKDUpO1xuICogICAgICB0YWtlRml2ZShwZXJzb25uZWwpO1xuICogICAgICAvLz0+IFsnRGF2ZSBCcnViZWNrJywgJ1BhdWwgRGVzbW9uZCcsICdFdWdlbmUgV3JpZ2h0JywgJ0pvZSBNb3JlbGxvJywgJ0dlcnJ5IE11bGxpZ2FuJ11cbiAqIEBzeW1iIFIudGFrZSgtMSwgW2EsIGJdKSA9IFthLCBiXVxuICogQHN5bWIgUi50YWtlKDAsIFthLCBiXSkgPSBbXVxuICogQHN5bWIgUi50YWtlKDEsIFthLCBiXSkgPSBbYV1cbiAqIEBzeW1iIFIudGFrZSgyLCBbYSwgYl0pID0gW2EsIGJdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsndGFrZSddLCBfeHRha2UsIGZ1bmN0aW9uIHRha2UobiwgeHMpIHtcbiAgcmV0dXJuIHNsaWNlKDAsIG4gPCAwID8gSW5maW5pdHkgOiBuLCB4cyk7XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGRyb3AgPSByZXF1aXJlKCcuL2Ryb3AnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBsYXN0IGBuYCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdC5cbiAqIElmIGBuID4gbGlzdC5sZW5ndGhgLCByZXR1cm5zIGEgbGlzdCBvZiBgbGlzdC5sZW5ndGhgIGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAc2VlIFIuZHJvcExhc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRha2VMYXN0KDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICogICAgICBSLnRha2VMYXN0KDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlTGFzdCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2VMYXN0KDQsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZUxhc3QoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnbWRhJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gdGFrZUxhc3QobiwgeHMpIHtcbiAgcmV0dXJuIGRyb3AobiA+PSAwID8geHMubGVuZ3RoIC0gbiA6IDAsIHhzKTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBsYXN0IGBuYCBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3QsIHBhc3NpbmdcbiAqIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW4gdGhlXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLiBFeGNsdWRlcyB0aGUgZWxlbWVudCB0aGF0IGNhdXNlZCB0aGVcbiAqIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBmYWlsLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6XG4gKiAqKHZhbHVlKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIuZHJvcExhc3RXaGlsZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc05vdE9uZSA9IHggPT4geCAhPT0gMTtcbiAqXG4gKiAgICAgIFIudGFrZUxhc3RXaGlsZShpc05vdE9uZSwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgMywgNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHRha2VMYXN0V2hpbGUoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwICYmIGZuKGxpc3RbaWR4XSkpIHtcbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaWR4ICsgMSk7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94dGFrZVdoaWxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feHRha2VXaGlsZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3QsXG4gKiBwYXNzaW5nIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW5cbiAqIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLiBFeGNsdWRlcyB0aGUgZWxlbWVudCB0aGF0IGNhdXNlZCB0aGVcbiAqIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBmYWlsLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6XG4gKiAqKHZhbHVlKSouXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHRha2VXaGlsZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIuZHJvcFdoaWxlLCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc05vdEZvdXIgPSB4ID0+IHggIT09IDQ7XG4gKlxuICogICAgICBSLnRha2VXaGlsZShpc05vdEZvdXIsIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzEsIDIsIDNdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsndGFrZVdoaWxlJ10sIF94dGFrZVdoaWxlLCBmdW5jdGlvbiB0YWtlV2hpbGUoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbiAmJiBmbihsaXN0W2lkeF0pKSB7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDAsIGlkeCk7XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoYSAtPiAqKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdpdGggYHhgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIGBmbmAgd2lsbCBiZSB0aHJvd24gYXdheS5cbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn0gYHhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzYXlYID0geCA9PiBjb25zb2xlLmxvZygneCBpcyAnICsgeCk7XG4gKiAgICAgIFIudGFwKHNheVgsIDEwMCk7IC8vPT4gMTAwXG4gKiAgICAgIC8vIGxvZ3MgJ3ggaXMgMTAwJ1xuICogQHN5bWIgUi50YXAoZiwgYSkgPSBhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB0YXAoZm4sIHgpIHtcbiAgZm4oeCk7XG4gIHJldHVybiB4O1xufSk7XG4iLCJ2YXIgX2Nsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY2xvbmVSZWdFeHAnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2lzUmVnRXhwID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNSZWdFeHAnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIHN0cmluZyBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5tYXRjaFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGVzdCgvXngvLCAneHl6Jyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLnRlc3QoL155LywgJ3h5eicpOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB0ZXN0KHBhdHRlcm4sIHN0cikge1xuICBpZiAoIV9pc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ+KAmHRlc3TigJkgcmVxdWlyZXMgYSB2YWx1ZSBvZiB0eXBlIFJlZ0V4cCBhcyBpdHMgZmlyc3QgYXJndW1lbnQ7IHJlY2VpdmVkICcgKyB0b1N0cmluZyhwYXR0ZXJuKSk7XG4gIH1cbiAgcmV0dXJuIF9jbG9uZVJlZ0V4cChwYXR0ZXJuKS50ZXN0KHN0cik7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBDYWxscyBhbiBpbnB1dCBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZXN1bHRzXG4gKiBvZiB0aG9zZSBmdW5jdGlvbiBjYWxscy5cbiAqXG4gKiBgZm5gIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6IFRoZSBjdXJyZW50IHZhbHVlIG9mIGBuYCwgd2hpY2ggYmVnaW5zIGF0IGAwYFxuICogYW5kIGlzIGdyYWR1YWxseSBpbmNyZW1lbnRlZCB0byBgbiAtIDFgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuM1xuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKE51bWJlciAtPiBhKSAtPiBOdW1iZXIgLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLiBQYXNzZWQgb25lIGFyZ3VtZW50LCB0aGUgY3VycmVudCB2YWx1ZSBvZiBgbmAuXG4gKiBAcGFyYW0ge051bWJlcn0gbiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgbiAtIDFgLiBJbmNyZW1lbnRzIGFmdGVyIGVhY2ggZnVuY3Rpb24gY2FsbC5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCBjYWxscyB0byBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGltZXMoUi5pZGVudGl0eSwgNSk7IC8vPT4gWzAsIDEsIDIsIDMsIDRdXG4gKiBAc3ltYiBSLnRpbWVzKGYsIDApID0gW11cbiAqIEBzeW1iIFIudGltZXMoZiwgMSkgPSBbZigwKV1cbiAqIEBzeW1iIFIudGltZXMoZiwgMikgPSBbZigwKSwgZigxKV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHRpbWVzKGZuLCBuKSB7XG4gIHZhciBsZW4gPSBOdW1iZXIobik7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGlzdDtcblxuICBpZiAobGVuIDwgMCB8fCBpc05hTihsZW4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgfVxuICBsaXN0ID0gbmV3IEFycmF5KGxlbik7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBsaXN0W2lkeF0gPSBmbihpZHgpO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBsaXN0O1xufSk7XG4iLCJ2YXIgaW52b2tlciA9IHJlcXVpcmUoJy4vaW52b2tlcicpO1xuXG5cbi8qKlxuICogVGhlIGxvd2VyIGNhc2UgdmVyc2lvbiBvZiBhIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYHN0cmAuXG4gKiBAc2VlIFIudG9VcHBlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudG9Mb3dlcignWFlaJyk7IC8vPT4gJ3h5eidcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBpbnZva2VyKDAsICd0b0xvd2VyQ2FzZScpO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faGFzJyk7XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gT25seSB0aGUgb2JqZWN0J3NcbiAqIG93biBwcm9wZXJ0aWVzIGFyZSB1c2VkLlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAqIEBzZWUgUi5mcm9tUGFpcnNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvUGFpcnMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIHRvUGFpcnMob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmIChfaGFzKHByb3AsIG9iaikpIHtcbiAgICAgIHBhaXJzW3BhaXJzLmxlbmd0aF0gPSBbcHJvcCwgb2JqW3Byb3BdXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhaXJzO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMuIFRoZSBvYmplY3QncyBvd25cbiAqIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFyZSB1c2VkLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZVxuICogb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnQgYWNyb3NzIGRpZmZlcmVudCBKU1xuICogcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd25cbiAqICAgICAgICAgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLnRvUGFpcnNJbihmKTsgLy89PiBbWyd4JywnWCddLCBbJ3knLCdZJ11dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0b1BhaXJzSW4ob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIHBhaXJzW3BhaXJzLmxlbmd0aF0gPSBbcHJvcCwgb2JqW3Byb3BdXTtcbiAgfVxuICByZXR1cm4gcGFpcnM7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX3RvU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fdG9TdHJpbmcnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuIGBldmFsYCdpbmcgdGhlIG91dHB1dFxuICogc2hvdWxkIHJlc3VsdCBpbiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHZhbHVlLiBNYW55IG9mIHRoZSBidWlsdC1pblxuICogYHRvU3RyaW5nYCBtZXRob2RzIGRvIG5vdCBzYXRpc2Z5IHRoaXMgcmVxdWlyZW1lbnQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGBbb2JqZWN0IE9iamVjdF1gIHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBvdGhlclxuICogdGhhbiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AsIHRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2l0aCBubyBhcmd1bWVudHNcbiAqIHRvIHByb2R1Y2UgdGhlIHJldHVybiB2YWx1ZS4gVGhpcyBtZWFucyB1c2VyLWRlZmluZWQgY29uc3RydWN0b3IgZnVuY3Rpb25zXG4gKiBjYW4gcHJvdmlkZSBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICogICAgICAgdGhpcy54ID0geDtcbiAqICAgICAgIHRoaXMueSA9IHk7XG4gKiAgICAgfVxuICpcbiAqICAgICBQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAnbmV3IFBvaW50KCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJyknO1xuICogICAgIH07XG4gKlxuICogICAgIFIudG9TdHJpbmcobmV3IFBvaW50KDEsIDIpKTsgLy89PiAnbmV3IFBvaW50KDEsIDIpJ1xuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgKiAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50b1N0cmluZyg0Mik7IC8vPT4gJzQyJ1xuICogICAgICBSLnRvU3RyaW5nKCdhYmMnKTsgLy89PiAnXCJhYmNcIidcbiAqICAgICAgUi50b1N0cmluZyhbMSwgMiwgM10pOyAvLz0+ICdbMSwgMiwgM10nXG4gKiAgICAgIFIudG9TdHJpbmcoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9KTsgLy89PiAne1wiYmFyXCI6IDIsIFwiYmF6XCI6IDMsIFwiZm9vXCI6IDF9J1xuICogICAgICBSLnRvU3RyaW5nKG5ldyBEYXRlKCcyMDAxLTAyLTAzVDA0OjA1OjA2WicpKTsgLy89PiAnbmV3IERhdGUoXCIyMDAxLTAyLTAzVDA0OjA1OjA2LjAwMFpcIiknXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0b1N0cmluZyh2YWwpIHsgcmV0dXJuIF90b1N0cmluZyh2YWwsIFtdKTsgfSk7XG4iLCJ2YXIgaW52b2tlciA9IHJlcXVpcmUoJy4vaW52b2tlcicpO1xuXG5cbi8qKlxuICogVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBhIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVwcGVyIGNhc2UuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB1cHBlciBjYXNlIHZlcnNpb24gb2YgYHN0cmAuXG4gKiBAc2VlIFIudG9Mb3dlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudG9VcHBlcignYWJjJyk7IC8vPT4gJ0FCQydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBpbnZva2VyKDAsICd0b1VwcGVyQ2FzZScpO1xuIiwidmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBfeHdyYXAgPSByZXF1aXJlKCcuL2ludGVybmFsL194d3JhcCcpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIHRyYW5zZHVjZXIgdXNpbmcgc3VwcGxpZWQgaXRlcmF0b3IgZnVuY3Rpb24uIFJldHVybnMgYSBzaW5nbGVcbiAqIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nIHRoZSB0cmFuc2Zvcm1lZFxuICogaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlXG4gKiBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqLiBJdCB3aWxsIGJlXG4gKiB3cmFwcGVkIGFzIGEgdHJhbnNmb3JtZXIgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNkdWNlci4gQSB0cmFuc2Zvcm1lciBjYW4gYmVcbiAqIHBhc3NlZCBkaXJlY3RseSBpbiBwbGFjZSBvZiBhbiBpdGVyYXRvciBmdW5jdGlvbi4gSW4gYm90aCBjYXNlcywgaXRlcmF0aW9uXG4gKiBtYXkgYmUgc3RvcHBlZCBlYXJseSB3aXRoIHRoZSBgUi5yZWR1Y2VkYCBmdW5jdGlvbi5cbiAqXG4gKiBBIHRyYW5zZHVjZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhXG4gKiB0cmFuc2Zvcm1lciBhbmQgY2FuIGJlIGNvbXBvc2VkIGRpcmVjdGx5LlxuICpcbiAqIEEgdHJhbnNmb3JtZXIgaXMgYW4gYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYSAyLWFyaXR5IHJlZHVjaW5nIGl0ZXJhdG9yXG4gKiBmdW5jdGlvbiwgc3RlcCwgMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmQgMS1hcml0eSByZXN1bHRcbiAqIGV4dHJhY3Rpb24gZnVuY3Rpb24sIHJlc3VsdC4gVGhlIHN0ZXAgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgaXRlcmF0b3JcbiAqIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlIGZpbmFsXG4gKiBhY2N1bXVsYXRvciBpbnRvIHRoZSByZXR1cm4gdHlwZSBhbmQgaW4gbW9zdCBjYXNlcyBpcyBSLmlkZW50aXR5LiBUaGUgaW5pdFxuICogZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGFjY3VtdWxhdG9yLCBidXQgaXMgaWdub3JlZCBieVxuICogdHJhbnNkdWNlLlxuICpcbiAqIFRoZSBpdGVyYXRpb24gaXMgcGVyZm9ybWVkIHdpdGggUi5yZWR1Y2UgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSB0cmFuc2R1Y2VyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChjIC0+IGMpIC0+IChhLGIgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgVGhlIHRyYW5zZHVjZXIgZnVuY3Rpb24uIFJlY2VpdmVzIGEgdHJhbnNmb3JtZXIgYW5kIHJldHVybnMgYSB0cmFuc2Zvcm1lci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuIFdyYXBwZWQgYXMgdHJhbnNmb3JtZXIsIGlmIG5lY2Vzc2FyeSwgYW5kIHVzZWQgdG9cbiAqICAgICAgICBpbml0aWFsaXplIHRoZSB0cmFuc2R1Y2VyXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2UsIFIucmVkdWNlZCwgUi5pbnRvXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gKiAgICAgIHZhciB0cmFuc2R1Y2VyID0gUi5jb21wb3NlKFIubWFwKFIuYWRkKDEpKSwgUi50YWtlKDIpKTtcbiAqXG4gKiAgICAgIFIudHJhbnNkdWNlKHRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjdXJyeU4oNCwgZnVuY3Rpb24gdHJhbnNkdWNlKHhmLCBmbiwgYWNjLCBsaXN0KSB7XG4gIHJldHVybiBfcmVkdWNlKHhmKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IF94d3JhcChmbikgOiBmbiksIGFjYywgbGlzdCk7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIGEgMkQgbGlzdC5cbiAqIFdoZW4gcGFzc2VkIGEgbGlzdCBvZiBgbmAgbGlzdHMgb2YgbGVuZ3RoIGB4YCxcbiAqIHJldHVybnMgYSBsaXN0IG9mIGB4YCBsaXN0cyBvZiBsZW5ndGggYG5gLlxuICpcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbW2FdXSAtPiBbW2FdXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBIDJEIGxpc3RcbiAqIEByZXR1cm4ge0FycmF5fSBBIDJEIGxpc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyYW5zcG9zZShbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV0pIC8vPT4gW1sxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddXVxuICogICAgICBSLnRyYW5zcG9zZShbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dKSAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICpcbiAqIElmIHNvbWUgb2YgdGhlIHJvd3MgYXJlIHNob3J0ZXIgdGhhbiB0aGUgZm9sbG93aW5nIHJvd3MsIHRoZWlyIGVsZW1lbnRzIGFyZSBza2lwcGVkOlxuICpcbiAqICAgICAgUi50cmFuc3Bvc2UoW1sxMCwgMTFdLCBbMjBdLCBbXSwgWzMwLCAzMSwgMzJdXSkgLy89PiBbWzEwLCAyMCwgMzBdLCBbMTEsIDMxXSwgWzMyXV1cbiAqIEBzeW1iIFIudHJhbnNwb3NlKFtbYV0sIFtiXSwgW2NdXSkgPSBbYSwgYiwgY11cbiAqIEBzeW1iIFIudHJhbnNwb3NlKFtbYSwgYl0sIFtjLCBkXV0pID0gW1thLCBjXSwgW2IsIGRdXVxuICogQHN5bWIgUi50cmFuc3Bvc2UoW1thLCBiXSwgW2NdXSkgPSBbW2EsIGNdLCBbYl1dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0ZXJsaXN0KSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAoaSA8IG91dGVybGlzdC5sZW5ndGgpIHtcbiAgICB2YXIgaW5uZXJsaXN0ID0gb3V0ZXJsaXN0W2ldO1xuICAgIHZhciBqID0gMDtcbiAgICB3aGlsZSAoaiA8IGlubmVybGlzdC5sZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2pdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXN1bHRbal0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFtqXS5wdXNoKGlubmVybGlzdFtqXSk7XG4gICAgICBqICs9IDE7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgc2VxdWVuY2UgPSByZXF1aXJlKCcuL3NlcXVlbmNlJyk7XG5cblxuLyoqXG4gKiBNYXBzIGFuIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSktcmV0dXJuaW5nXG4gKiBmdW5jdGlvbiBvdmVyIGEgW1RyYXZlcnNhYmxlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlKSxcbiAqIHRoZW4gdXNlcyBbYHNlcXVlbmNlYF0oI3NlcXVlbmNlKSB0byB0cmFuc2Zvcm0gdGhlIHJlc3VsdGluZyBUcmF2ZXJzYWJsZSBvZiBBcHBsaWNhdGl2ZVxuICogaW50byBhbiBBcHBsaWNhdGl2ZSBvZiBUcmF2ZXJzYWJsZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2VxdWVuY2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChhIC0+IGYgYSkgLT4gKGEgLT4gZiBiKSAtPiB0IGEgLT4gZiAodCBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2ZcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0gdHJhdmVyc2FibGVcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuc2VxdWVuY2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBSZXR1cm5zIGBOb3RoaW5nYCBpZiB0aGUgZ2l2ZW4gZGl2aXNvciBpcyBgMGBcbiAqICAgICAgc2FmZURpdiA9IG4gPT4gZCA9PiBkID09PSAwID8gTm90aGluZygpIDogSnVzdChuIC8gZClcbiAqXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgNCwgNV0pOyAvLz0+IEp1c3QoWzUsIDIuNSwgMl0pXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgMCwgNV0pOyAvLz0+IE5vdGhpbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHRyYXZlcnNlKG9mLCBmLCB0cmF2ZXJzYWJsZSkge1xuICByZXR1cm4gc2VxdWVuY2Uob2YsIG1hcChmLCB0cmF2ZXJzYWJsZSkpO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogUmVtb3ZlcyAoc3RyaXBzKSB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybiB7U3RyaW5nfSBUcmltbWVkIHZlcnNpb24gb2YgYHN0cmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50cmltKCcgICB4eXogICcpOyAvLz0+ICd4eXonXG4gKiAgICAgIFIubWFwKFIudHJpbSwgUi5zcGxpdCgnLCcsICd4LCB5LCB6JykpOyAvLz0+IFsneCcsICd5JywgJ3onXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHdzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICAgICAgICAgICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCcgK1xuICAgICAgICAgICAnXFx1MjAyOVxcdUZFRkYnO1xuICB2YXIgemVyb1dpZHRoID0gJ1xcdTIwMGInO1xuICB2YXIgaGFzUHJvdG9UcmltID0gKHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gPT09ICdmdW5jdGlvbicpO1xuICBpZiAoIWhhc1Byb3RvVHJpbSB8fCAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKSkge1xuICAgIHJldHVybiBfY3VycnkxKGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICB2YXIgYmVnaW5SeCA9IG5ldyBSZWdFeHAoJ15bJyArIHdzICsgJ11bJyArIHdzICsgJ10qJyk7XG4gICAgICB2YXIgZW5kUnggPSBuZXcgUmVnRXhwKCdbJyArIHdzICsgJ11bJyArIHdzICsgJ10qJCcpO1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGJlZ2luUngsICcnKS5yZXBsYWNlKGVuZFJ4LCAnJyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH0pO1xuICB9XG59KCkpO1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIGB0cnlDYXRjaGAgdGFrZXMgdHdvIGZ1bmN0aW9ucywgYSBgdHJ5ZXJgIGFuZCBhIGBjYXRjaGVyYC4gVGhlIHJldHVybmVkXG4gKiBmdW5jdGlvbiBldmFsdWF0ZXMgdGhlIGB0cnllcmA7IGlmIGl0IGRvZXMgbm90IHRocm93LCBpdCBzaW1wbHkgcmV0dXJucyB0aGVcbiAqIHJlc3VsdC4gSWYgdGhlIGB0cnllcmAgKmRvZXMqIHRocm93LCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRoZVxuICogYGNhdGNoZXJgIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGl0cyByZXN1bHQuIE5vdGUgdGhhdCBmb3IgZWZmZWN0aXZlXG4gKiBjb21wb3NpdGlvbiB3aXRoIHRoaXMgZnVuY3Rpb24sIGJvdGggdGhlIGB0cnllcmAgYW5kIGBjYXRjaGVyYCBmdW5jdGlvbnNcbiAqIG11c3QgcmV0dXJuIHRoZSBzYW1lIHR5cGUgb2YgcmVzdWx0cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKC4uLnggLT4gYSkgLT4gKChlLCAuLi54KSAtPiBhKSAtPiAoLi4ueCAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJ5ZXIgVGhlIGZ1bmN0aW9uIHRoYXQgbWF5IHRocm93LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2F0Y2hlciBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCBpZiBgdHJ5ZXJgIHRocm93cy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgY2F0Y2ggZXhjZXB0aW9ucyBhbmQgc2VuZCB0aGVuIHRvIHRoZSBjYXRjaGVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudHJ5Q2F0Y2goUi5wcm9wKCd4JyksIFIuRikoe3g6IHRydWV9KTsgLy89PiB0cnVlXG4gKiAgICAgIFIudHJ5Q2F0Y2goUi5wcm9wKCd4JyksIFIuRikobnVsbCk7ICAgICAgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gX3RyeUNhdGNoKHRyeWVyLCBjYXRjaGVyKSB7XG4gIHJldHVybiBfYXJpdHkodHJ5ZXIubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRyeWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhdGNoZXIuYXBwbHkodGhpcywgX2NvbmNhdChbZV0sIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBHaXZlcyBhIHNpbmdsZS13b3JkIHN0cmluZyBkZXNjcmlwdGlvbiBvZiB0aGUgKG5hdGl2ZSkgdHlwZSBvZiBhIHZhbHVlLFxuICogcmV0dXJuaW5nIHN1Y2ggYW5zd2VycyBhcyAnT2JqZWN0JywgJ051bWJlcicsICdBcnJheScsIG9yICdOdWxsJy4gRG9lcyBub3RcbiAqIGF0dGVtcHQgdG8gZGlzdGluZ3Vpc2ggdXNlciBPYmplY3QgdHlwZXMgYW55IGZ1cnRoZXIsIHJlcG9ydGluZyB0aGVtIGFsbCBhc1xuICogJ09iamVjdCcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyAoKiAtPiB7Kn0pIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnR5cGUoe30pOyAvLz0+IFwiT2JqZWN0XCJcbiAqICAgICAgUi50eXBlKDEpOyAvLz0+IFwiTnVtYmVyXCJcbiAqICAgICAgUi50eXBlKGZhbHNlKTsgLy89PiBcIkJvb2xlYW5cIlxuICogICAgICBSLnR5cGUoJ3MnKTsgLy89PiBcIlN0cmluZ1wiXG4gKiAgICAgIFIudHlwZShudWxsKTsgLy89PiBcIk51bGxcIlxuICogICAgICBSLnR5cGUoW10pOyAvLz0+IFwiQXJyYXlcIlxuICogICAgICBSLnR5cGUoL1tBLXpdLyk7IC8vPT4gXCJSZWdFeHBcIlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gdHlwZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCAgICAgID8gJ051bGwnICAgICAgOlxuICAgICAgICAgdmFsID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6XG4gICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmbmAsIHdoaWNoIHRha2VzIGEgc2luZ2xlIGFycmF5IGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhXG4gKiBmdW5jdGlvbiB3aGljaDpcbiAqXG4gKiAgIC0gdGFrZXMgYW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cztcbiAqICAgLSBwYXNzZXMgdGhlc2UgYXJndW1lbnRzIHRvIGBmbmAgYXMgYW4gYXJyYXk7IGFuZFxuICogICAtIHJldHVybnMgdGhlIHJlc3VsdC5cbiAqXG4gKiBJbiBvdGhlciB3b3JkcywgUi51bmFwcGx5IGRlcml2ZXMgYSB2YXJpYWRpYyBmdW5jdGlvbiBmcm9tIGEgZnVuY3Rpb24gd2hpY2hcbiAqIHRha2VzIGFuIGFycmF5LiBSLnVuYXBwbHkgaXMgdGhlIGludmVyc2Ugb2YgUi5hcHBseS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoWyouLi5dIC0+IGEpIC0+ICgqLi4uIC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuYXBwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVuYXBwbHkoSlNPTi5zdHJpbmdpZnkpKDEsIDIsIDMpOyAvLz0+ICdbMSwyLDNdJ1xuICogQHN5bWIgUi51bmFwcGx5KGYpKGEsIGIpID0gZihbYSwgYl0pXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB1bmFwcGx5KGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZm4oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gIH07XG59KTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgbkFyeSA9IHJlcXVpcmUoJy4vbkFyeScpO1xuXG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0c1xuICogZXhhY3RseSAxIHBhcmFtZXRlci4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBiKSAtPiAoYSAtPiBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gKiAgICAgICAgIGFyaXR5IDEuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHRha2VzVHdvQXJncyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAqICAgICAgICByZXR1cm4gW2EsIGJdO1xuICogICAgICB9O1xuICogICAgICB0YWtlc1R3b0FyZ3MubGVuZ3RoOyAvLz0+IDJcbiAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIpOyAvLz0+IFsxLCAyXVxuICpcbiAqICAgICAgdmFyIHRha2VzT25lQXJnID0gUi51bmFyeSh0YWtlc1R3b0FyZ3MpO1xuICogICAgICB0YWtlc09uZUFyZy5sZW5ndGg7IC8vPT4gMVxuICogICAgICAvLyBPbmx5IDEgYXJndW1lbnQgaXMgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gKiAgICAgIHRha2VzT25lQXJnKDEsIDIpOyAvLz0+IFsxLCB1bmRlZmluZWRdXG4gKiBAc3ltYiBSLnVuYXJ5KGYpKGEsIGIsIGMpID0gZihhKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gdW5hcnkoZm4pIHtcbiAgcmV0dXJuIG5BcnkoMSwgZm4pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gb2YgYXJpdHkgYG5gIGZyb20gYSAobWFudWFsbHkpIGN1cnJpZWQgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoYSAtPiBiKSAtPiAoYSAtPiBjKVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgZm9yIHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB1bmN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFkZEZvdXIgPSBhID0+IGIgPT4gYyA9PiBkID0+IGEgKyBiICsgYyArIGQ7XG4gKlxuICogICAgICB2YXIgdW5jdXJyaWVkQWRkRm91ciA9IFIudW5jdXJyeU4oNCwgYWRkRm91cik7XG4gKiAgICAgIHVuY3VycmllZEFkZEZvdXIoMSwgMiwgMywgNCk7IC8vPT4gMTBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHVuY3VycnlOKGRlcHRoLCBmbikge1xuICByZXR1cm4gY3VycnlOKGRlcHRoLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudERlcHRoID0gMTtcbiAgICB2YXIgdmFsdWUgPSBmbjtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgZW5kSWR4O1xuICAgIHdoaWxlIChjdXJyZW50RGVwdGggPD0gZGVwdGggJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlbmRJZHggPSBjdXJyZW50RGVwdGggPT09IGRlcHRoID8gYXJndW1lbnRzLmxlbmd0aCA6IGlkeCArIHZhbHVlLmxlbmd0aDtcbiAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBpZHgsIGVuZElkeCkpO1xuICAgICAgY3VycmVudERlcHRoICs9IDE7XG4gICAgICBpZHggPSBlbmRJZHg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBCdWlsZHMgYSBsaXN0IGZyb20gYSBzZWVkIHZhbHVlLiBBY2NlcHRzIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zXG4gKiBlaXRoZXIgZmFsc2UgdG8gc3RvcCBpdGVyYXRpb24gb3IgYW4gYXJyYXkgb2YgbGVuZ3RoIDIgY29udGFpbmluZyB0aGUgdmFsdWVcbiAqIHRvIGFkZCB0byB0aGUgcmVzdWx0aW5nIGxpc3QgYW5kIHRoZSBzZWVkIHRvIGJlIHVzZWQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGVcbiAqIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyBvbmUgYXJndW1lbnQ6ICooc2VlZCkqLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFtiXSkgLT4gKiAtPiBbYl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gcmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBgc2VlZGAsIGFuZCByZXR1cm5zXG4gKiAgICAgICAgZWl0aGVyIGZhbHNlIHRvIHF1aXQgaXRlcmF0aW9uIG9yIGFuIGFycmF5IG9mIGxlbmd0aCB0d28gdG8gcHJvY2VlZC4gVGhlIGVsZW1lbnRcbiAqICAgICAgICBhdCBpbmRleCAwIG9mIHRoaXMgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIGFycmF5LCBhbmQgdGhlIGVsZW1lbnRcbiAqICAgICAgICBhdCBpbmRleCAxIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBuZXh0IGNhbGwgdG8gYGZuYC5cbiAqIEBwYXJhbSB7Kn0gc2VlZCBUaGUgc2VlZCB2YWx1ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmluYWwgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZiA9IG4gPT4gbiA+IDUwID8gZmFsc2UgOiBbLW4sIG4gKyAxMF07XG4gKiAgICAgIFIudW5mb2xkKGYsIDEwKTsgLy89PiBbLTEwLCAtMjAsIC0zMCwgLTQwLCAtNTBdXG4gKiBAc3ltYiBSLnVuZm9sZChmLCB4KSA9IFtmKHgpWzBdLCBmKGYoeClbMV0pWzBdLCBmKGYoZih4KVsxXSlbMV0pWzBdLCAuLi5dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB1bmZvbGQoZm4sIHNlZWQpIHtcbiAgdmFyIHBhaXIgPSBmbihzZWVkKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAocGFpciAmJiBwYWlyLmxlbmd0aCkge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHBhaXJbMF07XG4gICAgcGFpciA9IGZuKHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbiIsInZhciBfY29uY2F0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29uY2F0Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGNvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcbnZhciB1bmlxID0gcmVxdWlyZSgnLi91bmlxJyk7XG5cblxuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggbGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICogQHBhcmFtIHtBcnJheX0gYXMgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBicyBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGZpcnN0IGFuZCBzZWNvbmQgbGlzdHMgY29uY2F0ZW5hdGVkLCB3aXRoXG4gKiAgICAgICAgIGR1cGxpY2F0ZXMgcmVtb3ZlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVuaW9uKFsxLCAyLCAzXSwgWzIsIDMsIDRdKTsgLy89PiBbMSwgMiwgMywgNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGNvbXBvc2UodW5pcSwgX2NvbmNhdCkpO1xuIiwidmFyIF9jb25jYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb25jYXQnKTtcbnZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgdW5pcVdpdGggPSByZXF1aXJlKCcuL3VuaXFXaXRoJyk7XG5cblxuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggbGlzdC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5XG4gKiBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIChhIC0+IGEgLT4gQm9vbGVhbikgLT4gWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICogICAgICAgICBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gKiBAc2VlIFIudW5pb25cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn1dO1xuICogICAgICB2YXIgbDIgPSBbe2E6IDF9LCB7YTogNH1dO1xuICogICAgICBSLnVuaW9uV2l0aChSLmVxQnkoUi5wcm9wKCdhJykpLCBsMSwgbDIpOyAvLz0+IFt7YTogMX0sIHthOiAyfSwge2E6IDR9XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gdW5pb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICByZXR1cm4gdW5pcVdpdGgocHJlZCwgX2NvbmNhdChsaXN0MSwgbGlzdDIpKTtcbn0pO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xudmFyIHVuaXFCeSA9IHJlcXVpcmUoJy4vdW5pcUJ5Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAqIGxpc3QuIGBSLmVxdWFsc2AgaXMgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bmlxKFsxLCAxLCAyLCAxXSk7IC8vPT4gWzEsIDJdXG4gKiAgICAgIFIudW5pcShbMSwgJzEnXSk7ICAgICAvLz0+IFsxLCAnMSddXG4gKiAgICAgIFIudW5pcShbWzQyXSwgWzQyXV0pOyAvLz0+IFtbNDJdXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXFCeShpZGVudGl0eSk7XG4iLCJ2YXIgX1NldCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX1NldCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIG9ubHkgb25lIGNvcHkgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICogbGlzdCwgYmFzZWQgdXBvbiB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIHRvXG4gKiBlYWNoIGxpc3QgZWxlbWVudC4gUHJlZmVycyB0aGUgZmlyc3QgaXRlbSBpZiB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcHJvZHVjZXNcbiAqIHRoZSBzYW1lIHZhbHVlIG9uIHR3byBpdGVtcy4gYFIuZXF1YWxzYCBpcyB1c2VkIGZvciBjb21wYXJpc29uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IGIpIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdXNlZCB0byBwcm9kdWNlIGEgdmFsdWUgdG8gdXNlIGR1cmluZyBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHVuaXF1ZSBpdGVtcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVuaXFCeShNYXRoLmFicywgWy0xLCAtNSwgMiwgMTAsIDEsIDJdKTsgLy89PiBbLTEsIC01LCAyLCAxMF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHVuaXFCeShmbiwgbGlzdCkge1xuICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGFwcGxpZWRJdGVtLCBpdGVtO1xuXG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGl0ZW0gPSBsaXN0W2lkeF07XG4gICAgYXBwbGllZEl0ZW0gPSBmbihpdGVtKTtcbiAgICBpZiAoc2V0LmFkZChhcHBsaWVkSXRlbSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJ2YXIgX2NvbnRhaW5zV2l0aCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbnRhaW5zV2l0aCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIG9ubHkgb25lIGNvcHkgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICogbGlzdCwgYmFzZWQgdXBvbiB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0b1xuICogdHdvIGxpc3QgZWxlbWVudHMuIFByZWZlcnMgdGhlIGZpcnN0IGl0ZW0gaWYgdHdvIGl0ZW1zIGNvbXBhcmUgZXF1YWwgYmFzZWRcbiAqIG9uIHRoZSBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSwgYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHN0ckVxID0gUi5lcUJ5KFN0cmluZyk7XG4gKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsxLCAnMScsIDIsIDFdKTsgLy89PiBbMSwgMl1cbiAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoW3t9LCB7fV0pOyAgICAgICAvLz0+IFt7fV1cbiAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoWzEsICcxJywgMV0pOyAgICAvLz0+IFsxXVxuICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbJzEnLCAxLCAxXSk7ICAgIC8vPT4gWycxJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHVuaXFXaXRoKHByZWQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaXRlbTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGl0ZW0gPSBsaXN0W2lkeF07XG4gICAgaWYgKCFfY29udGFpbnNXaXRoKHByZWQsIGl0ZW0sIHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGl0ZW07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUZXN0cyB0aGUgZmluYWwgYXJndW1lbnQgYnkgcGFzc2luZyBpdCB0byB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLiBJZlxuICogdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICogY2FsbGluZyB0aGUgYHdoZW5GYWxzZUZuYCBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50LiBJZiB0aGUgcHJlZGljYXRlXG4gKiBpcyBzYXRpc2ZpZWQsIHRoZSBhcmd1bWVudCBpcyByZXR1cm5lZCBhcyBpcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkICAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gd2hlbkZhbHNlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYHByZWRgIGV2YWx1YXRlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBmYWxzeSB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gICAgICAgIHggICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5GYWxzZUZuYCBpZiBuZWNlc3NhcnkuXG4gKiBAcmV0dXJuIHsqfSBFaXRoZXIgYHhgIG9yIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYHhgIHRvIGB3aGVuRmFsc2VGbmAuXG4gKiBAc2VlIFIuaWZFbHNlLCBSLndoZW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBjb2VyY2VBcnJheSA6OiAoYXxbYV0pIC0+IFthXVxuICogICAgICB2YXIgY29lcmNlQXJyYXkgPSBSLnVubGVzcyhSLmlzQXJyYXlMaWtlLCBSLm9mKTtcbiAqICAgICAgY29lcmNlQXJyYXkoWzEsIDIsIDNdKTsgLy89PiBbMSwgMiwgM11cbiAqICAgICAgY29lcmNlQXJyYXkoMSk7ICAgICAgICAgLy89PiBbMV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHVubGVzcyhwcmVkLCB3aGVuRmFsc2VGbiwgeCkge1xuICByZXR1cm4gcHJlZCh4KSA/IHggOiB3aGVuRmFsc2VGbih4KTtcbn0pO1xuIiwidmFyIF9pZGVudGl0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lkZW50aXR5Jyk7XG52YXIgY2hhaW4gPSByZXF1aXJlKCcuL2NoYWluJyk7XG5cblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGBSLmNoYWluKFIuaWRlbnRpdHkpYCwgd2hpY2ggcmVtb3ZlcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyBmcm9tXG4gKiBhbnkgW0NoYWluXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIENoYWluIGMgPT4gYyAoYyBhKSAtPiBjIGFcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5mbGF0dGVuLCBSLmNoYWluXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bm5lc3QoWzEsIFsyXSwgW1szXV1dKTsgLy89PiBbMSwgMiwgWzNdXVxuICogICAgICBSLnVubmVzdChbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV0pOyAvLz0+IFsxLCAyLCAzLCA0LCA1LCA2XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNoYWluKF9pZGVudGl0eSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBwcmVkaWNhdGUsIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24sIGFuZCBhbiBpbml0aWFsIHZhbHVlLFxuICogYW5kIHJldHVybnMgYSB2YWx1ZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogSXQgZG9lcyBzbyBieSBhcHBseWluZyB0aGUgdHJhbnNmb3JtYXRpb24gdW50aWwgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsXG4gKiBhdCB3aGljaCBwb2ludCBpdCByZXR1cm5zIHRoZSBzYXRpc2ZhY3RvcnkgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IGluaXQgSW5pdGlhbCB2YWx1ZVxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWUgdGhhdCBzYXRpc2ZpZXMgcHJlZGljYXRlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bnRpbChSLmd0KFIuX18sIDEwMCksIFIubXVsdGlwbHkoMikpKDEpIC8vID0+IDEyOFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gdW50aWwocHJlZCwgZm4sIGluaXQpIHtcbiAgdmFyIHZhbCA9IGluaXQ7XG4gIHdoaWxlICghcHJlZCh2YWwpKSB7XG4gICAgdmFsID0gZm4odmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGFkanVzdCA9IHJlcXVpcmUoJy4vYWRqdXN0Jyk7XG52YXIgYWx3YXlzID0gcmVxdWlyZSgnLi9hbHdheXMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXhcbiAqIHJlcGxhY2VkIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4IHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gZXhpc3QgYXQgdGhlIGdpdmVuIGluZGV4IG9mIHRoZSByZXR1cm5lZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBsaXN0IFRoZSBzb3VyY2UgYXJyYXktbGlrZSBvYmplY3QgdG8gYmUgdXBkYXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgYGxpc3RgIHdpdGggdGhlIHZhbHVlIGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggYHhgLlxuICogQHNlZSBSLmFkanVzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudXBkYXRlKDEsIDExLCBbMCwgMSwgMl0pOyAgICAgLy89PiBbMCwgMTEsIDJdXG4gKiAgICAgIFIudXBkYXRlKDEpKDExKShbMCwgMSwgMl0pOyAgICAgLy89PiBbMCwgMTEsIDJdXG4gKiBAc3ltYiBSLnVwZGF0ZSgtMSwgYSwgW2IsIGNdKSA9IFtiLCBhXVxuICogQHN5bWIgUi51cGRhdGUoMCwgYSwgW2IsIGNdKSA9IFthLCBjXVxuICogQHN5bWIgUi51cGRhdGUoMSwgYSwgW2IsIGNdKSA9IFtiLCBhXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gdXBkYXRlKGlkeCwgeCwgbGlzdCkge1xuICByZXR1cm4gYWRqdXN0KGFsd2F5cyh4KSwgaWR4LCBsaXN0KTtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBjdXJyeU4gPSByZXF1aXJlKCcuL2N1cnJ5TicpO1xuXG5cbi8qKlxuICogQWNjZXB0cyBhIGZ1bmN0aW9uIGBmbmAgYW5kIGEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnMgYW5kIHJldHVybnMgYVxuICogbmV3IGN1cnJpZWQgZnVuY3Rpb24uIFdoZW4gdGhlIG5ldyBmdW5jdGlvbiBpcyBpbnZva2VkLCBpdCBjYWxscyB0aGVcbiAqIGZ1bmN0aW9uIGBmbmAgd2l0aCBwYXJhbWV0ZXJzIGNvbnNpc3Rpbmcgb2YgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGVhY2hcbiAqIHN1cHBsaWVkIGhhbmRsZXIgb24gc3VjY2Vzc2l2ZSBhcmd1bWVudHMgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAqXG4gKiBJZiBtb3JlIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB0aGFuIHRyYW5zZm9ybWVyXG4gKiBmdW5jdGlvbnMsIHRob3NlIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGRpcmVjdGx5IHRvIGBmbmAgYXMgYWRkaXRpb25hbFxuICogcGFyYW1ldGVycy4gSWYgeW91IGV4cGVjdCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGRvbid0IG5lZWQgdG8gYmVcbiAqIHRyYW5zZm9ybWVkLCBhbHRob3VnaCB5b3UgY2FuIGlnbm9yZSB0aGVtLCBpdCdzIGJlc3QgdG8gcGFzcyBhbiBpZGVudGl0eVxuICogZnVuY3Rpb24gc28gdGhhdCB0aGUgbmV3IGZ1bmN0aW9uIHJlcG9ydHMgdGhlIGNvcnJlY3QgYXJpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKHgxIC0+IHgyIC0+IC4uLiAtPiB6KSAtPiBbKGEgLT4geDEpLCAoYiAtPiB4MiksIC4uLl0gLT4gKGEgLT4gYiAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtZXJzIEEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jb252ZXJnZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuaWRlbnRpdHksIFIuaWRlbnRpdHldKSgzLCA0KTsgLy89PiA4MVxuICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmlkZW50aXR5LCBSLmlkZW50aXR5XSkoMykoNCk7IC8vPT4gODFcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMywgNCk7IC8vPT4gMzJcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMykoNCk7IC8vPT4gMzJcbiAqIEBzeW1iIFIudXNlV2l0aChmLCBbZywgaF0pKGEsIGIpID0gZihnKGEpLCBoKGIpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gdXNlV2l0aChmbiwgdHJhbnNmb3JtZXJzKSB7XG4gIHJldHVybiBjdXJyeU4odHJhbnNmb3JtZXJzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB3aGlsZSAoaWR4IDwgdHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgYXJncy5wdXNoKHRyYW5zZm9ybWVyc1tpZHhdLmNhbGwodGhpcywgYXJndW1lbnRzW2lkeF0pKTtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCB0cmFuc2Zvcm1lcnMubGVuZ3RoKSkpO1xuICB9KTtcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZGlmZmVyZW50XG4gKiBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBbdl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi52YWx1ZXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbMSwgMiwgM11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICB2YXIgdmFscyA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhbHNbaWR4XSA9IG9ialtwcm9wc1tpZHhdXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gdmFscztcbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgcHJvcGVydGllcywgaW5jbHVkaW5nIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBvZiB0aGVcbiAqIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFt2XVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgdmFsdWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QncyBvd24gYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLnZhbHVlc0luKGYpOyAvLz0+IFsnWCcsICdZJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIHZhbHVlc0luKG9iaikge1xuICB2YXIgcHJvcDtcbiAgdmFyIHZzID0gW107XG4gIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICB2c1t2cy5sZW5ndGhdID0gb2JqW3Byb3BdO1xuICB9XG4gIHJldHVybiB2cztcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBcInZpZXdcIiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmUsIGRldGVybWluZWQgYnkgdGhlIGdpdmVuIGxlbnMuXG4gKiBUaGUgbGVucydzIGZvY3VzIGRldGVybWluZXMgd2hpY2ggcG9ydGlvbiBvZiB0aGUgZGF0YSBzdHJ1Y3R1cmUgaXMgdmlzaWJsZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBMZW5zIHMgYSAtPiBzIC0+IGFcbiAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICpcbiAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgLy89PiAxXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDQsIHk6IDJ9KTsgIC8vPT4gNFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgLy8gYENvbnN0YCBpcyBhIGZ1bmN0b3IgdGhhdCBlZmZlY3RpdmVseSBpZ25vcmVzIHRoZSBmdW5jdGlvbiBnaXZlbiB0byBgbWFwYC5cbiAgdmFyIENvbnN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB7dmFsdWU6IHgsIG1hcDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9fTtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiB2aWV3KGxlbnMsIHgpIHtcbiAgICAvLyBVc2luZyBgQ29uc3RgIGVmZmVjdGl2ZWx5IGlnbm9yZXMgdGhlIHNldHRlciBmdW5jdGlvbiBvZiB0aGUgYGxlbnNgLFxuICAgIC8vIGxlYXZpbmcgdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBnZXR0ZXIgZnVuY3Rpb24gdW5tb2RpZmllZC5cbiAgICByZXR1cm4gbGVucyhDb25zdCkoeCkudmFsdWU7XG4gIH0pO1xufSgpKTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUZXN0cyB0aGUgZmluYWwgYXJndW1lbnQgYnkgcGFzc2luZyBpdCB0byB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLiBJZlxuICogdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAqIHRoZSBgd2hlblRydWVGbmAgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBhcmd1bWVudC4gSWYgdGhlIHByZWRpY2F0ZSBpcyBub3RcbiAqIHNhdGlzZmllZCwgdGhlIGFyZ3VtZW50IGlzIHJldHVybmVkIGFzIGlzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHdoZW5UcnVlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLlxuICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICBBbiBvYmplY3QgdG8gdGVzdCB3aXRoIHRoZSBgcHJlZGAgZnVuY3Rpb24gYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5UcnVlRm5gIGlmIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm4geyp9IEVpdGhlciBgeGAgb3IgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgeGAgdG8gYHdoZW5UcnVlRm5gLlxuICogQHNlZSBSLmlmRWxzZSwgUi51bmxlc3NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyB0cnVuY2F0ZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gKiAgICAgIHZhciB0cnVuY2F0ZSA9IFIud2hlbihcbiAqICAgICAgICBSLnByb3BTYXRpc2ZpZXMoUi5ndChSLl9fLCAxMCksICdsZW5ndGgnKSxcbiAqICAgICAgICBSLnBpcGUoUi50YWtlKDEwKSwgUi5hcHBlbmQoJ+KApicpLCBSLmpvaW4oJycpKVxuICogICAgICApO1xuICogICAgICB0cnVuY2F0ZSgnMTIzNDUnKTsgICAgICAgICAvLz0+ICcxMjM0NSdcbiAqICAgICAgdHJ1bmNhdGUoJzAxMjM0NTY3ODlBQkMnKTsgLy89PiAnMDEyMzQ1Njc4OeKApidcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHdoZW4ocHJlZCwgd2hlblRydWVGbiwgeCkge1xuICByZXR1cm4gcHJlZCh4KSA/IHdoZW5UcnVlRm4oeCkgOiB4O1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgc3BlYyBvYmplY3QgYW5kIGEgdGVzdCBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiB0aGUgdGVzdCBzYXRpc2ZpZXNcbiAqIHRoZSBzcGVjLiBFYWNoIG9mIHRoZSBzcGVjJ3Mgb3duIHByb3BlcnRpZXMgbXVzdCBiZSBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEVhY2ggcHJlZGljYXRlIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG9mIHRoZVxuICogdGVzdCBvYmplY3QuIGB3aGVyZWAgcmV0dXJucyB0cnVlIGlmIGFsbCB0aGUgcHJlZGljYXRlcyByZXR1cm4gdHJ1ZSwgZmFsc2VcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBgd2hlcmVgIGlzIHdlbGwgc3VpdGVkIHRvIGRlY2xhcmF0aXZlbHkgZXhwcmVzc2luZyBjb25zdHJhaW50cyBmb3Igb3RoZXJcbiAqIGZ1bmN0aW9ucyBzdWNoIGFzIGBmaWx0ZXJgIGFuZCBgZmluZGAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICgqIC0+IEJvb2xlYW4pfSAtPiB7U3RyaW5nOiAqfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICogQHBhcmFtIHtPYmplY3R9IHRlc3RPYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gcHJlZCA6OiBPYmplY3QgLT4gQm9vbGVhblxuICogICAgICB2YXIgcHJlZCA9IFIud2hlcmUoe1xuICogICAgICAgIGE6IFIuZXF1YWxzKCdmb28nKSxcbiAqICAgICAgICBiOiBSLmNvbXBsZW1lbnQoUi5lcXVhbHMoJ2JhcicpKSxcbiAqICAgICAgICB4OiBSLmd0KF9fLCAxMCksXG4gKiAgICAgICAgeTogUi5sdChfXywgMjApXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICd4eHgnLCB4OiAxMSwgeTogMTl9KTsgLy89PiB0cnVlXG4gKiAgICAgIHByZWQoe2E6ICd4eHgnLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICdiYXInLCB4OiAxMSwgeTogMTl9KTsgLy89PiBmYWxzZVxuICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDEwLCB5OiAxOX0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDIwfSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHdoZXJlKHNwZWMsIHRlc3RPYmopIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSB7XG4gICAgaWYgKF9oYXMocHJvcCwgc3BlYykgJiYgIXNwZWNbcHJvcF0odGVzdE9ialtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgZXF1YWxzID0gcmVxdWlyZSgnLi9lcXVhbHMnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xudmFyIHdoZXJlID0gcmVxdWlyZSgnLi93aGVyZScpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBzcGVjIG9iamVjdCBhbmQgYSB0ZXN0IG9iamVjdDsgcmV0dXJucyB0cnVlIGlmIHRoZSB0ZXN0IHNhdGlzZmllc1xuICogdGhlIHNwZWMsIGZhbHNlIG90aGVyd2lzZS4gQW4gb2JqZWN0IHNhdGlzZmllcyB0aGUgc3BlYyBpZiwgZm9yIGVhY2ggb2YgdGhlXG4gKiBzcGVjJ3Mgb3duIHByb3BlcnRpZXMsIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZSBvYmplY3QgZ2l2ZXMgdGhlIHNhbWVcbiAqIHZhbHVlIChpbiBgUi5lcXVhbHNgIHRlcm1zKSBhcyBhY2Nlc3NpbmcgdGhhdCBwcm9wZXJ0eSBvZiB0aGUgc3BlYy5cbiAqXG4gKiBgd2hlcmVFcWAgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBbYHdoZXJlYF0oI3doZXJlKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdE9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi53aGVyZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIHByZWQgOjogT2JqZWN0IC0+IEJvb2xlYW5cbiAqICAgICAgdmFyIHByZWQgPSBSLndoZXJlRXEoe2E6IDEsIGI6IDJ9KTtcbiAqXG4gKiAgICAgIHByZWQoe2E6IDF9KTsgICAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAqICAgICAgcHJlZCh7YTogMSwgYjogMn0pOyAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIHByZWQoe2E6IDEsIGI6IDIsIGM6IDN9KTsgIC8vPT4gdHJ1ZVxuICogICAgICBwcmVkKHthOiAxLCBiOiAxfSk7ICAgICAgICAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB3aGVyZUVxKHNwZWMsIHRlc3RPYmopIHtcbiAgcmV0dXJuIHdoZXJlKG1hcChlcXVhbHMsIHNwZWMpLCB0ZXN0T2JqKTtcbn0pO1xuIiwidmFyIF9jb250YWlucyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbnRhaW5zJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGZsaXAgPSByZXF1aXJlKCcuL2ZsaXAnKTtcbnZhciByZWplY3QgPSByZXF1aXJlKCcuL3JlamVjdCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgdmFsdWVzIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIGBSLmVxdWFsc2AgaXMgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgdmFsdWVzIHRvIGJlIHJlbW92ZWQgZnJvbSBgbGlzdDJgLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIGFycmF5IHRvIHJlbW92ZSB2YWx1ZXMgZnJvbS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGFycmF5IHdpdGhvdXQgdmFsdWVzIGluIGBsaXN0MWAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi53aXRob3V0KFsxLCAyXSwgWzEsIDIsIDEsIDMsIDRdKTsgLy89PiBbMywgNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uKHhzLCBsaXN0KSB7XG4gIHJldHVybiByZWplY3QoZmxpcChfY29udGFpbnMpKHhzKSwgbGlzdCk7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgY3JlYXRpbmcgZWFjaCBwb3NzaWJsZSBwYWlyXG4gKiBmcm9tIHRoZSBsaXN0cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYl0gLT4gW1thLGJdXVxuICogQHBhcmFtIHtBcnJheX0gYXMgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBicyBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgZWFjaCBwb3NzaWJsZSBwYWlyIGZyb21cbiAqICAgICAgICAgYGFzYCBhbmQgYGJzYCBpbnRvIHBhaXJzIChgW2EsIGJdYCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi54cHJvZChbMSwgMl0sIFsnYScsICdiJ10pOyAvLz0+IFtbMSwgJ2EnXSwgWzEsICdiJ10sIFsyLCAnYSddLCBbMiwgJ2InXV1cbiAqIEBzeW1iIFIueHByb2QoW2EsIGJdLCBbYywgZF0pID0gW1thLCBjXSwgW2EsIGRdLCBbYiwgY10sIFtiLCBkXV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHhwcm9kKGEsIGIpIHsgLy8gPSB4cHJvZFdpdGgocHJlcGVuZCk7ICh0YWtlcyBhYm91dCAzIHRpbWVzIGFzIGxvbmcuLi4pXG4gIHZhciBpZHggPSAwO1xuICB2YXIgaWxlbiA9IGEubGVuZ3RoO1xuICB2YXIgajtcbiAgdmFyIGpsZW4gPSBiLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAoaWR4IDwgaWxlbikge1xuICAgIGogPSAwO1xuICAgIHdoaWxlIChqIDwgamxlbikge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gW2FbaWR4XSwgYltqXV07XG4gICAgICBqICs9IDE7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgcGFpcmluZyB1cCBlcXVhbGx5LXBvc2l0aW9uZWRcbiAqIGl0ZW1zIGZyb20gYm90aCBsaXN0cy4gVGhlIHJldHVybmVkIGxpc3QgaXMgdHJ1bmNhdGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBzaG9ydGVyIG9mIHRoZSB0d28gaW5wdXQgbGlzdHMuXG4gKiBOb3RlOiBgemlwYCBpcyBlcXVpdmFsZW50IHRvIGB6aXBXaXRoKGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIFthLCBiXSB9KWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBhcnJheSB0byBjb25zaWRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuemlwKFsxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV1cbiAqIEBzeW1iIFIuemlwKFthLCBiLCBjXSwgW2QsIGUsIGZdKSA9IFtbYSwgZF0sIFtiLCBlXSwgW2MsIGZdXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgdmFyIHJ2ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJ2W2lkeF0gPSBbYVtpZHhdLCBiW2lkeF1dO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBydjtcbn0pO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IG91dCBvZiBhIGxpc3Qgb2Yga2V5cyBhbmQgYSBsaXN0IG9mIHZhbHVlcy5cbiAqIEtleS92YWx1ZSBwYWlyaW5nIGlzIHRydW5jYXRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBzaG9ydGVyIG9mIHRoZSB0d28gbGlzdHMuXG4gKiBOb3RlOiBgemlwT2JqYCBpcyBlcXVpdmFsZW50IHRvIGBwaXBlKHppcFdpdGgocGFpciksIGZyb21QYWlycylgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW1N0cmluZ10gLT4gWypdIC0+IHtTdHJpbmc6ICp9XG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSB0aGF0IHdpbGwgYmUgcHJvcGVydGllcyBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgbGlzdCBvZiB2YWx1ZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuemlwT2JqKFsnYScsICdiJywgJ2MnXSwgWzEsIDIsIDNdKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHppcE9iaihrZXlzLCB2YWx1ZXMpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihrZXlzLmxlbmd0aCwgdmFsdWVzLmxlbmd0aCk7XG4gIHZhciBvdXQgPSB7fTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIG91dFtrZXlzW2lkeF1dID0gdmFsdWVzW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG8gZWFjaFxuICogZXF1YWxseS1wb3NpdGlvbmVkIHBhaXIgaW4gdGhlIGxpc3RzLiBUaGUgcmV0dXJuZWQgbGlzdCBpcyB0cnVuY2F0ZWQgdG8gdGhlXG4gKiBsZW5ndGggb2YgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBpbnB1dCBsaXN0cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSxiIC0+IGMpIC0+IFthXSAtPiBbYl0gLT4gW2NdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21iaW5lIHRoZSB0d28gZWxlbWVudHMgaW50byBvbmUgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgY29tYmluaW5nIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgXG4gKiAgICAgICAgIHVzaW5nIGBmbmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGYgPSAoeCwgeSkgPT4ge1xuICogICAgICAgIC8vIC4uLlxuICogICAgICB9O1xuICogICAgICBSLnppcFdpdGgoZiwgWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10pO1xuICogICAgICAvLz0+IFtmKDEsICdhJyksIGYoMiwgJ2InKSwgZigzLCAnYycpXVxuICogQHN5bWIgUi56aXBXaXRoKGZuLCBbYSwgYiwgY10sIFtkLCBlLCBmXSkgPSBbZm4oYSwgZCksIGZuKGIsIGUpLCBmbihjLCBmKV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHppcFdpdGgoZm4sIGEsIGIpIHtcbiAgdmFyIHJ2ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJ2W2lkeF0gPSBmbihhW2lkeF0sIGJbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJ2O1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwidmVyc2lvblwiOiBcIjEuMC4wXCIsXG4gIFwic3ltYm9saXplcnNcIjoge1xuICAgIFwicG9seWdvblwiOiB7XG4gICAgICBcImZpbGxcIjoge1xuICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tZmlsbFwiLFxuICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJyZ2JhKDEyOCwxMjgsMTI4LDEpXCIsXG4gICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ3JheSBhbmQgZnVsbHkgb3BhcXVlIChhbHBoYSA9IDEpLCBzYW1lIGFzIHJnYigxMjgsMTI4LDEyOClcIixcbiAgICAgICAgXCJkb2NcIjogXCJGaWxsIGNvbG9yIHRvIGFzc2lnbiB0byBhIHBvbHlnb25cIlxuICAgICAgfSxcbiAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLW9wYWNpdHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBvZiB0aGUgcG9seWdvblwiLFxuICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIlxuICAgICAgfSxcbiAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1jb21wLW9wXCIsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiQWRkIHRoZSBjdXJyZW50IHN5bWJvbGl6ZXIgb24gdG9wIG9mIG90aGVyIHN5bWJvbGl6ZXIuXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICBcImFkZFwiLFxuICAgICAgICAgIFwib3ZlcmxheVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcInBvbHlnb24tcGF0dGVyblwiOiB7XG4gICAgICBcImZpbGVcIjoge1xuICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1maWxlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInVyaVwiLFxuICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZG9jXCI6IFwiSW1hZ2UgdG8gdXNlIGFzIGEgcmVwZWF0ZWQgcGF0dGVybiBmaWxsIHdpdGhpbiBhIHBvbHlnb24uIEFjY2VwdGVkIGZvcm1hdHM6IHN2ZywganBnLCBwbmcsIHRpZmYsIGFuZCB3ZWJwLlwiLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmVcIjoge1xuICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICBcImNzc1wiOiBcImxpbmUtY29sb3JcIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgwLDAsMCwxKVwiLFxuICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImJsYWNrIGFuZCBmdWxseSBvcGFxdWUgKGFscGhhID0gMSksIHNhbWUgYXMgcmdiKDAsMCwwKVwiLFxuICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiBhIGRyYXduIGxpbmVcIlxuICAgICAgfSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHtcbiAgICAgICAgXCJjc3NcIjogXCJsaW5lLXdpZHRoXCIsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICBcImRvY1wiOiBcIlRoZSB3aWR0aCBvZiBhIGxpbmUgaW4gcGl4ZWxzXCJcbiAgICAgIH0sXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgXCJjc3NcIjogXCJsaW5lLW9wYWNpdHlcIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwib3BhcXVlXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgYSBsaW5lXCJcbiAgICAgIH0sXG4gICAgICBcInN0cm9rZS1saW5lam9pblwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwibGluZS1qb2luXCIsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm1pdGVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgXCJtaXRlclwiLFxuICAgICAgICAgIFwibWl0ZXItcmV2ZXJ0XCIsXG4gICAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICAgIFwiYmV2ZWxcIlxuICAgICAgICBdLFxuICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgXCJkb2NcIjogXCJUaGUgYmVoYXZpb3Igb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBsaW5lIGpvaW5zIHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgYSBtaXRlciBsb29rLlwiXG4gICAgICB9LFxuICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwibGluZS1jYXBcIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYnV0dFwiLFxuICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgIFwiYnV0dFwiLFxuICAgICAgICAgIFwicm91bmRcIixcbiAgICAgICAgICBcInNxdWFyZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5ncy5cIixcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgbGluZSBlbmRpbmdzIHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgYSBidXR0IGxvb2suXCJcbiAgICAgIH0sXG4gICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICBcImNzc1wiOiBcImxpbmUtY29tcC1vcFwiLFxuICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJvdmVybGF5XCIsXG4gICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiQWRkIHRoZSBjdXJyZW50IHN5bWJvbGl6ZXIgb24gdG9wIG9mIG90aGVyIHN5bWJvbGl6ZXIuXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICBcImFkZFwiLFxuICAgICAgICAgIFwib3ZlcmxheVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlXG4gICAgICB9LFxuICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IHtcbiAgICAgICAgXCJjc3NcIjogXCJsaW5lLWRhc2hhcnJheVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJzXCIsXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICBcImRvY1wiOiBcIkEgcGFpciBvZiBsZW5ndGggdmFsdWVzIFthLGJdLCB3aGVyZSAoYSkgaXMgdGhlIGRhc2ggbGVuZ3RoIGFuZCAoYikgaXMgdGhlIGdhcCBsZW5ndGggcmVzcGVjdGl2ZWx5LiBNb3JlIHRoYW4gdHdvIHZhbHVlcyBhcmUgc3VwcG9ydGVkIGZvciBtb3JlIGNvbXBsZXggcGF0dGVybnMuXCIsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgbGluZSB3aWxsIGJlIGRyYXduIHdpdGhvdXQgZGFzaGVzLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIm1hcmtlcnNcIjoge1xuICAgICAgXCJmaWxlXCI6IHtcbiAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsZVwiLFxuICAgICAgICBcImRvY1wiOiBcIkEgZmlsZSB0aGF0IHRoaXMgbWFya2VyIHNob3dzIGF0IGVhY2ggcGxhY2VtZW50LiBJZiBubyBmaWxlIGlzIGdpdmVuLCB0aGUgbWFya2VyIHdpbGwgc2hvdyBhbiBlbGxpcHNlLiBBY2NlcHRlZCBmb3JtYXRzOiBzdmcsIGpwZywgcG5nLCB0aWZmLCBhbmQgd2VicC5cIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkFuIGVsbGlwc2Ugb3IgY2lyY2xlLCBpZiB3aWR0aCBlcXVhbHMgaGVpZ2h0LlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1cmlcIixcbiAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1vcGFjaXR5XCIsXG4gICAgICAgIFwiZG9jXCI6IFwiVGhlIG92ZXJhbGwgb3BhY2l0eSBvZiB0aGUgbWFya2VyLCBpZiBzZXQsIG92ZXJyaWRlcyBib3RoIHRoZSBvcGFjaXR5IG9mIGJvdGggdGhlIGZpbGwgYW5kIHN0cm9rZVwiLFxuICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgc3Ryb2tlLW9wYWNpdHkgYW5kIGZpbGwtb3BhY2l0eSB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgfSxcbiAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWZpbGxcIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYmx1ZVwiLFxuICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgYXJlYSBvZiB0aGUgbWFya2VyLlwiLFxuICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFwiYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWFsbG93LW92ZXJsYXBcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciBvdmVybGFwcGluZyBtYXJrZXJzIGFyZSBzaG93biBvciBoaWRkZW4uXCIsXG4gICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRG8gbm90IGFsbG93IG1hcmtlcnMgdG8gb3ZlcmxhcCB3aXRoIGVhY2ggb3RoZXIgLSBvdmVybGFwcGluZyBtYXJrZXJzIHdpbGwgbm90IGJlIHNob3duLlwiXG4gICAgICB9LFxuICAgICAgXCJ3aWR0aFwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwibWFya2VyLXdpZHRoXCIsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxMC4wLFxuICAgICAgICBcImRvY1wiOiBcIlRoZSB3aWR0aCBvZiB0aGUgbWFya2VyLCBpZiB1c2luZyBvbmUgb2YgdGhlIGRlZmF1bHQgdHlwZXMuXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoZSBtYXJrZXIgd2lkdGggaXMgMTAgcGl4ZWxzLlwiXG4gICAgICB9LFxuICAgICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1maWxsLW9wYWNpdHlcIixcbiAgICAgICAgXCJkb2NcIjogXCJUaGUgZmlsbCBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXCIsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLjAsXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkNvbG9yIGlzIGZ1bGx5IG9wYXF1ZS5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgfSxcbiAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWNvbXAtb3BcIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJBZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplci5cIixcbiAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgIFwiYWRkXCIsXG4gICAgICAgICAgXCJvdmVybGF5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWxpbmUtY29sb3JcIixcbiAgICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHN0cm9rZSBhcm91bmQgdGhlIG1hcmtlci5cIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYmxhY2tcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIG1hcmtlciB3aWxsIGJlIGRyYXduIHdpdGggYSBibGFjayBvdXRsaW5lLlwiXG4gICAgICB9LFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjoge1xuICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLXdpZHRoXCIsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLjUsXG4gICAgICAgIFwiZG9jXCI6IFwiVGhlIHdpZHRoIG9mIHRoZSBzdHJva2UgYXJvdW5kIHRoZSBtYXJrZXIsIGluIHBpeGVscy4gVGhpcyBpcyBwb3NpdGlvbmVkIG9uIHRoZSBib3VuZGFyeSwgc28gaGlnaCB2YWx1ZXMgY2FuIGNvdmVyIHRoZSBhcmVhIGl0c2VsZi5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIG1hcmtlciB3aWxsIGJlIGRyYXduIHdpdGggYW4gb3V0bGluZSBvZiAuNSBwaXhlbHMgd2lkZS5cIlxuICAgICAgfSxcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLW9wYWNpdHlcIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEuMCxcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJDb2xvciBpcyBmdWxseSBvcGFxdWUuXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgYSBsaW5lLlwiLFxuICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFwicGxhY2VtZW50XCI6IHtcbiAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItcGxhY2VtZW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgXCJwb2ludFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb2ludFwiLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlBsYWNlIG1hcmtlcnMgYXQgdGhlIGNlbnRlciBwb2ludCAoY2VudHJvaWQpIG9mIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgXCJkb2NcIjogXCJBdHRlbXB0IHRvIHBsYWNlIG1hcmtlcnMgb24gYSBwb2ludCwgaW4gdGhlIGNlbnRlciBvZiBhIHBvbHlnb24sIG9yIGlmIG1hcmtlcnMtcGxhY2VtZW50OmxpbmUsIHRoZW4gbXVsdGlwbGUgdGltZXMgYWxvbmcgYSBsaW5lLiAnaW50ZXJpb3InIHBsYWNlbWVudCBjYW4gYmUgdXNlZCB0byBlbnN1cmUgdGhhdCBwb2ludHMgcGxhY2VkIG9uIHBvbHlnb25zIGFyZSBmb3JjZWQgdG8gYmUgaW5zaWRlIHRoZSBwb2x5Z29uIGludGVyaW9yLiBUaGUgJ3ZlcnRleC1maXJzdCcgYW5kICd2ZXJ0ZXgtbGFzdCcgb3B0aW9ucyBjYW4gYmUgdXNlZCB0byBwbGFjZSBtYXJrZXJzIGF0IHRoZSBmaXJzdCBvciBsYXN0IHZlcnRleCBvZiBsaW5lcyBvciBwb2x5Z29ucy5cIlxuICAgICAgfSxcbiAgICAgIFwibWFya2VyLXR5cGVcIjoge1xuICAgICAgICBcImNzc1wiOiBcIm1hcmtlci10eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgXCJlbGxpcHNlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImVsbGlwc2VcIixcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgbWFya2VyIHNoYXBlIGlzIGFuIGVsbGlwc2UuXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiVGhlIGRlZmF1bHQgbWFya2VyLXR5cGUuIElmIGEgU1ZHIGZpbGUgaXMgbm90IGdpdmVuIGFzIHRoZSBtYXJrZXItZmlsZSBwYXJhbWV0ZXIsIHRoZSByZW5kZXJlciBwcm92aWRlcyBlaXRoZXIgYW4gYXJyb3cgb3IgYW4gZWxsaXBzZSAoYSBjaXJjbGUgaWYgaGVpZ2h0IGlzIGVxdWFsIHRvIHdpZHRoKS5cIixcbiAgICAgICAgXCJzdGF0dXNcIjogXCJkZXByZWNhdGVkXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dFwiOiB7XG4gICAgICBcIm5hbWVcIjoge1xuICAgICAgICBcImNzc1wiOiBcInRleHQtbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICBcInNlcmlhbGl6YXRpb25cIjogXCJjb250ZW50XCIsXG4gICAgICAgIFwiZG9jXCI6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIERhdGEgY29sdW1ucyBhcmUgc3BlY2lmaWVkIHVzaW5nIGJyYWNrZXRzIGxpa2UgW2NvbHVtbl9uYW1lXS5cIixcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJcIlxuICAgICAgfSxcbiAgICAgIFwic2l6ZVwiOiB7XG4gICAgICAgIFwiY3NzXCI6IFwidGV4dC1zaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMTAuMCxcbiAgICAgICAgXCJkb2NcIjogXCJUZXh0IHNpemUgaW4gcGl4ZWxzLlwiLFxuICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkZvbnQgc2l6ZSBvZiAxMCB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIHRleHQuXCJcbiAgICAgIH0sXG4gICAgICBcImZpbGxcIjoge1xuICAgICAgICBcImNzc1wiOiBcInRleHQtZmlsbFwiLFxuICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGNvbG9yIGZvciB0aGUgdGV4dC5cIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYmxhY2tcIixcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgdGV4dCB3aWxsIGJlIHJlbmRlcmVkIGJsYWNrLlwiXG4gICAgICB9LFxuICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LW9wYWNpdHlcIixcbiAgICAgICAgXCJkb2NcIjogXCJBIG51bWJlciBmcm9tIDAgdG8gMSBzcGVjaWZ5aW5nIHRoZSBvcGFjaXR5IGZvciB0aGUgdGV4dC5cIixcbiAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEuMCxcbiAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJGdWxseSBvcGFxdWVcIixcbiAgICAgICAgXCJleHByZXNzaW9uXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiY29sb3JzXCI6IHtcbiAgICBcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxuICAgIFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgXCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgXCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgXCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxuICAgIFwiYmxhY2tcIjogWzAsIDAsIDBdLFxuICAgIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxuICAgIFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcbiAgICBcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXG4gICAgXCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxuICAgIFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcbiAgICBcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcbiAgICBcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxuICAgIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxuICAgIFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxuICAgIFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXG4gICAgXCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxuICAgIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcbiAgICBcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcbiAgICBcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXG4gICAgXCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxuICAgIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcbiAgICBcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcbiAgICBcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXG4gICAgXCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxuICAgIFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxuICAgIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxuICAgIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXG4gICAgXCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXG4gICAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXG4gICAgXCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcbiAgICBcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXG4gICAgXCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxuICAgIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcbiAgICBcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxuICAgIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxuICAgIFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcbiAgICBcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcbiAgICBcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXG4gICAgXCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcbiAgICBcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcbiAgICBcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcbiAgICBcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxuICAgIFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgXCJncmVlblwiOiBbMCwgMTI4LCAwXSxcbiAgICBcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxuICAgIFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxuICAgIFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXG4gICAgXCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcbiAgICBcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXG4gICAgXCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXG4gICAgXCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgXCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXG4gICAgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgICBcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxuICAgIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcbiAgICBcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXG4gICAgXCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcbiAgICBcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXG4gICAgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXG4gICAgXCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxuICAgIFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgXCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxuICAgIFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcbiAgICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcbiAgICBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXG4gICAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxuICAgIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxuICAgIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxuICAgIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxuICAgIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxuICAgIFwibGltZVwiOiBbMCwgMjU1LCAwXSxcbiAgICBcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxuICAgIFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxuICAgIFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxuICAgIFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxuICAgIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXG4gICAgXCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxuICAgIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxuICAgIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcbiAgICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxuICAgIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcbiAgICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXG4gICAgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXG4gICAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXG4gICAgXCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcbiAgICBcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgXCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxuICAgIFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxuICAgIFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxuICAgIFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcbiAgICBcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxuICAgIFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcbiAgICBcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcbiAgICBcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxuICAgIFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcbiAgICBcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXG4gICAgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcbiAgICBcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcbiAgICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxuICAgIFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXG4gICAgXCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxuICAgIFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcbiAgICBcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxuICAgIFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXG4gICAgXCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcbiAgICBcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxuICAgIFwicmVkXCI6IFsyNTUsIDAsIDBdLFxuICAgIFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcbiAgICBcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcbiAgICBcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXG4gICAgXCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxuICAgIFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICBcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXG4gICAgXCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgXCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcbiAgICBcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgXCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICBcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcbiAgICBcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgXCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxuICAgIFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXG4gICAgXCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxuICAgIFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxuICAgIFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcbiAgICBcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcbiAgICBcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxuICAgIFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXG4gICAgXCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXG4gICAgXCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxuICAgIFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxuICAgIFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxuICAgIFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgXCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcbiAgICBcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdLFxuICAgIFwidHJhbnNwYXJlbnRcIjogWzAsIDAsIDAsIDBdXG4gIH1cbn1cbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICBleGlzdHNTeW5jID0gcmVxdWlyZSgnZnMnKS5leGlzdHNTeW5jIHx8IHJlcXVpcmUoJ3BhdGgnKS5leGlzdHNTeW5jO1xuXG52YXIgdmVyc2lvbnMgPSBbXG4gICAgJzEuMC4wJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMudmVyc2lvbnMgPSB2ZXJzaW9ucztcblxubW9kdWxlLmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgICBpZiAodmVyc2lvbnMuaW5kZXhPZih2ZXJzaW9uKSA8PSAtMSkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1hcG5pay1yZWZlcmVuY2UgdmVyc2lvbjogJ1wiICsgdmVyc2lvbiArIFwiJ1wiKTtcbiAgICB9XG4gICAgdmFyIHJlZiA9IHJlcXVpcmUoJy4vMS4wLjAvcmVmZXJlbmNlLmpzb24nKTtcbiAvLyAgICB2YXIgZHNfcGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsIHZlcnNpb24sICdkYXRhc291cmNlcy5qc29uJyk7XG4gLy8gICAgaWYgKGV4aXN0c1N5bmMoZHNfcGF0aCkpIHtcblx0Ly8gcmVmLmRhdGFzb3VyY2VzID0gcmVxdWlyZShkc19wYXRoKS5kYXRhc291cmNlcztcbiAvLyAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLypcblx0IF9fXyAgICAgICBfX18gIF9fX19fX19fICAgX19fX19fXyAgIF9fX19fX19fXG5cdHxcXCAgXFwgICAgIHxcXCAgXFx8XFwgICBfX18gIFxcfFxcICBfX18gXFwgfFxcICAgX19fX1xcXG5cdFxcIFxcICBcXCAgICBcXCBcXCAgXFwgXFwgIFxcXFwgXFwgIFxcIFxcICAgX18vfFxcIFxcICBcXF9fX3xfXG5cdCBcXCBcXCAgXFwgICAgXFwgXFwgIFxcIFxcICBcXFxcIFxcICBcXCBcXCAgXFxffC9fXFwgXFxfX19fXyAgXFxcblx0ICBcXCBcXCAgXFxfX19fXFwgXFwgIFxcIFxcICBcXFxcIFxcICBcXCBcXCAgXFxffFxcIFxcfF9fX198XFwgIFxcXG5cdCAgIFxcIFxcX19fX19fX1xcIFxcX19cXCBcXF9fXFxcXCBcXF9fXFwgXFxfX19fX19fXFxfX19fXFxfXFwgIFxcXG5cdCAgICBcXHxfX19fX19ffFxcfF9ffFxcfF9ffCBcXHxfX3xcXHxfX19fX19ffFxcX19fX19fX19fXFxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFx8X19fX19fX19ffFxuXG4gKi9cblxuLypcblx0RVhURVJOQUwgREVQRU5ERU5DSUVTXG4gKi9cblxuaW1wb3J0IHtjdXJyeSwgY29tcG9zZSwgbm90LCBlcXVhbHMsIGlkZW50aXR5LCBjb25kfSBmcm9tICdyYW1kYSc7XG5cbi8qXG5cdElOVEVSTkFMIERFUEVOREVOQ0lFU1xuICovXG5cbmltcG9ydCB7IGdldEV4ZWN1dGVkRm4sIGdldFByb3BlcnR5T3JEZWZGbiwgZ2V0QmxlbmRGbiwgZ2V0Q29sb3JGbiB9IGZyb20gJy4uL3V0aWxzL3JlZmVyZW5jZS1oZWxwZXJzJztcbmltcG9ydCBUYW5ncmFtUmVmZXJlbmNlIGZyb20gJy4uL3V0aWxzL3JlZmVyZW5jZSc7XG5pbXBvcnQgR2VvbSBmcm9tICcuLi91dGlscy9nZW9tJztcblxuY29uc3Qgbm90RXEgPSBjdXJyeShjb21wb3NlKG5vdCwgZXF1YWxzKSk7XG5cbmNvbnN0IExSID0gVGFuZ3JhbVJlZmVyZW5jZS5nZXRMaW5lKG51bGwpOyAvLyBMaW5lIHJlZmVyZW5jZVxuLypcblx0SU5URVJOQUwgTElORSBGVU5DVElPTlNcbiAqL1xuXG5jb25zdCBjaGVja0xpbmVTeW0gPSBUYW5ncmFtUmVmZXJlbmNlLmNoZWNrU3ltYm9saXplcignbGluZScpO1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBnZXR0aW5nIHRoZSBjb2xvciBpbiByZ2JhXG4gKlxuICogQHBhcmFtICAge29iamVjdH0gYzNzcyBjb21waWxlZCBjYXJ0byBjc3NcbiAqIEByZXR1cm5zIHtvYmplY3R9IHdpdGggYSBmdW5jdGlvbiB0aGF0IGNvbnRhaW4gdGhlIGNvbmRpdGlvbnMgdG8gcmV0dXJuIGEgY29sb3Igd2l0aCBhbHBoYSBjaGFubmVsXG4gKi9cblxuY29uc3QgZ2V0Q29sb3IgPSBnZXRDb2xvckZuKFxuICBnZXRQcm9wZXJ0eU9yRGVmRm4oJ3N0cm9rZScsIExSKSxcbiAgZ2V0UHJvcGVydHlPckRlZkZuKCdzdHJva2Utb3BhY2l0eScsIExSKVxuKTtcblxuLyoqXG4gKiBGdW5jdGlvbiBmb3IgZ2V0dGluZyB0aGUgd2lkdGggaW4gbWV0ZXJzIGR5bmFtaWNhbGx5IGJ5IHpvb21cbiAqXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBjM3NzIGNvbXBpbGVkIGNhcnRvIGNzc1xuICogQHJldHVybnMge29iamVjdH0gd2l0aGEgYSBmdW5jdGlvbiB3aXRoIHRoZSBjb25kaXRpb25zIHRvIHJldHVybiB3aWR0aCB2YWx1ZVxuICovXG5cbmNvbnN0IGdldFdpZHRoID0gY29tcG9zZShcbiAgR2VvbS5weDJNZXRlcnMsXG4gIGdldFByb3BlcnR5T3JEZWZGbignc3Ryb2tlLXdpZHRoJywgTFIpXG4pO1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBnZXR0aW5nIHRoZSBjYXAgc3RhdGljYWxseVxuICpcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGMzc3MgY29tcGlsZWQgY2FydG8gY3NzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB3aXRoIGNhcCB2YWx1ZSBFeDogcm91bmRcbiAqL1xuY29uc3QgZ2V0Q2FwID0gZ2V0RXhlY3V0ZWRGbignc3Ryb2tlLWxpbmVjYXAnLCBMUik7XG5cbi8qKlxuICogRnVuY3Rpb24gZm9yIGdldHRpbmcgdGhlIGpvaW4gc3RhdGljYWxseVxuICpcbiAqIEBwYXJhbSAgIHtvYmplY3R9IGMzc3MgY29tcGlsZWQgY2FydG8gY3NzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB3aXRoIGpvaW4gdmFsdWUgRXg6IHJvdW5kXG4gKi9cbmNvbnN0IGdldEpvaW4gPSBnZXRFeGVjdXRlZEZuKCdzdHJva2UtbGluZWpvaW4nLCBMUik7XG5cbi8qKlxuICogRnVuY3Rpb24gZm9yIGdldHRpbmcgdGhlIGJsZW5kIHN0YXRpY2FsbHlcbiAqXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBjM3NzIGNvbXBpbGVkIGNhcnRvIGNzc1xuICogQHJldHVybnMge3N0cmluZ30gd2l0aCBibGVuZGluZyB2YWx1ZSBFeDogXCJtdWx0aXBseVwiXG4gKi9cbmNvbnN0IGdldEJsZW5kaW5nID0gZ2V0QmxlbmRGbihMUik7XG5cbi8qKlxuICogRnVuY3Rpb24gZm9yIGdldHRpbmcgZGFzaCB2YWx1ZSBzdGF0aWNhbGx5XG4gKlxuICogQHBhcmFtICAge29iamVjdH0gYzNzcyBjb21waWxlZCBjYXJ0byBjc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHdpdGggZGFzaCB2YWx1ZSBFeDogWzIsIDFdXG4gKi9cblxuY29uc3QgZ2V0RGFzaGVkID0gY29tcG9zZShcbiAgY29uZChbXG4gICAgW25vdEVxKCdub25lJyksIGlkZW50aXR5XVxuICBdKSxcbiAgZ2V0RXhlY3V0ZWRGbignc3Ryb2tlLWRhc2hhcnJheScsIExSKVxuKTtcblxuLyoqXG4gKiBCYXNpYyBMaW5lXG4gKi9cblxudmFyIExpbmUgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgTGluZTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBnZXQgdGhlIGRyYXcgb2JqZWN0IG9mIGEgbGluZS5cbiAqXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBjM3NzIGNvbXBpbGVkIGNhcnRvIGNzc1xuICogQHJldHVybnMge2Z1bmN0aW9ufSBmdW5jdGlvbiB3aXRoIHRoZSBjb25kaXRpb25zIHRvIHJldHVybiBhbHBoYSB2YWx1ZVxuICovXG5cbkxpbmUuZ2V0RHJhdyA9IChjM3NzLCBpZCkgPT4ge1xuICBsZXQgZHJhdyA9IHt9O1xuICBpZiAoY2hlY2tMaW5lU3ltKGMzc3MpKSB7XG4gICAgZHJhd1snbGluZXNfJyArIGlkXSA9IHtcbiAgICAgIGNvbG9yOiBnZXRDb2xvcihjM3NzKSxcbiAgICAgIHdpZHRoOiBnZXRXaWR0aChjM3NzKSxcbiAgICAgIGNhcDogZ2V0Q2FwKGMzc3MpLFxuICAgICAgam9pbjogZ2V0Sm9pbihjM3NzKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZHJhdztcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzdHlsZSBjb25maWd1cmF0aW9uIG9mIGEgbGluZS5cbiAqXG4gKiBAcmV0dXJucyBkZWZhdWx0IHN0eWxlIGNvbmZpZ3VyYXRpb24gZm9yIGxpbmVzXG4gKi9cbkxpbmUuZ2V0U3R5bGUgPSBmdW5jdGlvbihjM3NzLCBpZCwgb3JkKSB7XG4gIGxldCBzdHlsZSA9IHt9O1xuXG4gIHN0eWxlWydsaW5lc18nICsgaWRdID0ge1xuICAgIGJhc2U6ICdsaW5lcycsXG4gICAgYmxlbmQ6IGdldEJsZW5kaW5nKGMzc3MpLFxuICAgIGRhc2g6IGdldERhc2hlZChjM3NzKSxcbiAgICBibGVuZF9vcmRlcjogdHlwZW9mIG9yZCA9PT0gJ251bWJlcicgPyBvcmQgKyAxIDogMVxuICB9O1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG4iLCIvKlxuXHQgX19fX19fX18gIF9fX19fX19fICBfX18gIF9fX19fX19fICAgX19fX19fX19fXG5cdHxcXCAgIF9fICBcXHxcXCAgIF9fICBcXHxcXCAgXFx8XFwgICBfX18gIFxcfFxcX19fICAgX19fXFxcblx0XFwgXFwgIFxcfFxcICBcXCBcXCAgXFx8XFwgIFxcIFxcICBcXCBcXCAgXFxcXCBcXCAgXFx8X19fIFxcICBcXF98XG5cdCBcXCBcXCAgIF9fX19cXCBcXCAgXFxcXFxcICBcXCBcXCAgXFwgXFwgIFxcXFwgXFwgIFxcICAgXFwgXFwgIFxcXG5cdCAgXFwgXFwgIFxcX19ffFxcIFxcICBcXFxcXFwgIFxcIFxcICBcXCBcXCAgXFxcXCBcXCAgXFwgICBcXCBcXCAgXFxcblx0ICAgXFwgXFxfX1xcICAgIFxcIFxcX19fX19fX1xcIFxcX19cXCBcXF9fXFxcXCBcXF9fXFwgICBcXCBcXF9fXFxcblx0ICAgIFxcfF9ffCAgICAgXFx8X19fX19fX3xcXHxfX3xcXHxfX3wgXFx8X198ICAgIFxcfF9ffFxuXG4gKi9cblxuLypcblx0RVhURVJOQUwgREVQRU5ERU5DSUVTXG4gKi9cbmltcG9ydCBNRDUgZnJvbSAnbWQ1JztcbmltcG9ydCB7Y29tcG9zZSwgcGlja0J5LCBub3QsIGlzTmlsLCBhcHBseVNwZWMsIG1lcmdlLCBtZXJnZVdpdGh9IGZyb20gJ3JhbWRhJztcblxuLypcblx0SU5URVJOQUwgREVQRU5ERU5DSUVTXG4gKi9cblxuaW1wb3J0IHsgZ2V0RXhlY3V0ZWRGbiwgZ2V0UHJvcGVydHlPckRlZkZuLCBnZXRCbGVuZEZuLCBnZXRQcm9wZXJ0eUZuU2FmZSwgZ2V0RWl0aGVyUHJvcCwgZ2V0Q29sb3JGbiB9IGZyb20gJy4uL3V0aWxzL3JlZmVyZW5jZS1oZWxwZXJzJztcbmltcG9ydCBUYW5ncmFtUmVmZXJlbmNlIGZyb20gJy4uL3V0aWxzL3JlZmVyZW5jZSc7XG5cbmNvbnN0IFBSID0gVGFuZ3JhbVJlZmVyZW5jZS5nZXRQb2ludChudWxsKTsgLy8gUG9pbnQgcmVmZXJlbmNlXG5cbi8qXG5cdElOVEVSTkFMIE1BUktFUiBGVU5DVElPTlNcbiAqL1xuXG5jb25zdCBjaGVja01hcmtlclN5bSA9IFRhbmdyYW1SZWZlcmVuY2UuY2hlY2tTeW1ib2xpemVyKCdtYXJrZXJzJyk7XG5cbi8qKlxuICogZ2V0IGNvbG9ycyBmcm9tIGNhcnRvY3NzIHdpdGggdGhlIGFscGhhIGNoYW5uZWwgYXBwbGllZFxuICogQHBhcmFtICB7b2JqZWN0fSBjM3NzIGNvbXBpbGVkIGNhcnRvIGNzc1xuICogQHJldHVybiB7b2JqZWN0fSAgICAgIGRyYXcgb2JqZWN0IHdpdGggY29sb3IgYW5kIGJvcmRlcl9jb2xvclxuICovXG5cbmNvbnN0IGdldENvbG9yID0gZ2V0Q29sb3JGbihcbiAgZ2V0UHJvcGVydHlPckRlZkZuKCdmaWxsJywgUFIpLFxuICBnZXRFaXRoZXJQcm9wKCdmaWxsLW9wYWNpdHknLCAnb3BhY2l0eScsIFBSKVxuKTtcblxuY29uc3QgZ2V0T3V0bGluZUNvbG9yID0gZ2V0Q29sb3JGbihcbiAgZ2V0UHJvcGVydHlGblNhZmUoJ3N0cm9rZScsIFBSKSxcbiAgZ2V0RWl0aGVyUHJvcCgnc3Ryb2tlLW9wYWNpdHknLCAnb3BhY2l0eScsIFBSKVxuKTtcblxuY29uc3QgZ2V0Q29sb3JzID0gY29tcG9zZShcbiAgcGlja0J5KGNvbXBvc2Uobm90LGlzTmlsKSksXG4gIGFwcGx5U3BlYyh7XG4gICAgY29sb3I6IGdldENvbG9yLFxuICAgIG91dGxpbmU6IHtcbiAgICAgIGNvbG9yOiBnZXRPdXRsaW5lQ29sb3JcbiAgICB9XG4gIH0pXG4pO1xuXG4vKipcbiAqIGdldFdpZHRoIGZvciB0aGUgbWFya2VyIGFuZCBoaXMgYm9yZGVyXG4gKiBAcGFyYW0gIHtvYmplY3R9IGMzc3MgY29tcGlsZWQgY2FydG8gY3NzXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgc2l6ZSBhbmQgYm9yZGVyX3dpZHRoXG4gKi9cblxuY29uc3QgZ2V0TWFya2VyV2lkdGggPSBnZXRQcm9wZXJ0eUZuU2FmZSgnd2lkdGgnLCBQUik7XG5cbmNvbnN0IGdldE91dGxpbmVXaWR0aCA9IGdldFByb3BlcnR5Rm5TYWZlKCdzdHJva2Utd2lkdGgnLCBQUik7XG5cbmNvbnN0IGdldFdpZHRocyA9IGNvbXBvc2UoXG4gIHBpY2tCeShjb21wb3NlKG5vdCwgaXNOaWwpKSxcbiAgYXBwbHlTcGVjKHtcbiAgICBzaXplOiBnZXRNYXJrZXJXaWR0aCxcbiAgICBvdXRsaW5lOiB7XG4gICAgICB3aWR0aDogZ2V0T3V0bGluZVdpZHRoXG4gICAgfVxuICB9KVxuKTtcblxuLyoqXG4gKiBHZXQgY29sbGlkZSBmcm9tIGFsbG93LW92ZXJsYXAgaW4gY2FydG9jc3MgW05PTi1EWU5BTUlDXVxuICogQHBhcmFtICB7b2JqZWN0fSBjM3NzIGNvbXBpbGVkIGNhcnRvIGNzc1xuICogQHJldHVybiB7b2JqZWN0fSAgICAgIHJldHVybiBkcmF3IG9iamVjdCB3aXRoIGEgbm9uLWR5bmFtaWMgY29sbGlkZSBvcHRpb25cbiAqL1xuXG5jb25zdCBnZXRDb2xsaWRlID0gZ2V0RXhlY3V0ZWRGbignYWxsb3ctb3ZlcmxhcCcsIFBSKTtcblxuY29uc3QgZ2V0VGV4dHVyZUZpbGUgPSBnZXRFeGVjdXRlZEZuKCdmaWxlJywgUFIpO1xuXG4vKipcbiAqIEdldCB0ZXh0dXJlIGZyb20gbWFya2VyLWZpbGUgaW4gY2FydG9jc3MgW05PTi1EWU5BTUlDXVxuICogQHBhcmFtICB7b2JqZWN0fSBjM3NzIGNvbXBpbGVkIGNhcnRvIGNzc1xuICogQHJldHVybiB7b2JqZWN0fSAgICAgIHJldHVybiBkcmF3IG9iamVjdCB3aXRoIGEgbm9uLWR5bmFtaWMgdGV4dHVyZS5cbiAqL1xuY29uc3QgZ2V0VGV4dHVyZSA9IGNvbXBvc2UoXG4gIE1ENSxcbiAgZ2V0VGV4dHVyZUZpbGVcbik7XG5cbmNvbnN0IGdldEJsZW5kaW5nID0gZ2V0QmxlbmRGbihQUik7XG5cbi8qKlxuICogQmFzaWMgcG9pbnRcbiAqL1xuXG52YXIgUG9pbnQgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRyYXcgKGZvciB0YW5ncmFtKSBvYmplY3Qgb2YgYSBwb2ludCBmcm9tIGNvbXBpbGVkIGNhcnRvIGNzc1xuICogQHBhcmFtICB7b2JqZWN0fSBjM3NzIGNvbXBpbGVkIGNhcnRvIEBjbGFzc1xuICogQHJldHVybiB7b2JqZWN0fSAgICAgIG9iamVjdCB3aXRoIHRoZSBkcmF3IHR5cGVzIGFuZCB0aGVpciBwcm9wZXJ0aWVzXG4gKi9cblBvaW50LmdldERyYXcgPSBmdW5jdGlvbihjM3NzLCBpZCkge1xuXHR2YXIgcG9pbnQgPSB7fSxcbiAgICAgIGRyYXcgPSB7fTtcblxuXHRpZiAoY2hlY2tNYXJrZXJTeW0oYzNzcykpIHtcblxuXHRcdHBvaW50ID0gbWVyZ2VXaXRoKFxuICAgICAgICBtZXJnZSxcblx0XHRcdFx0Z2V0V2lkdGhzKGMzc3MpLFxuXHRcdFx0XHRnZXRDb2xvcnMoYzNzcylcblx0XHRcdCk7XG5cbiAgICBwb2ludC5jb2xsaWRlID0gIWdldENvbGxpZGUoYzNzcyk7XG5cdH1cblxuICBkcmF3Wydwb2ludHNfJyArIGlkXSA9IHBvaW50O1xuXG4gIHJldHVybiBkcmF3O1xufTtcblxuLy8gVE9ET1xuLyoqXG4gKiBbZ2V0U3R5bGUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtbdHlwZV19IGMzc3MgIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5Qb2ludC5nZXRTdHlsZSA9IGZ1bmN0aW9uKGMzc3MsIGlkLCBvcmQpIHtcbiAgbGV0IHN0eWxlID0ge307XG4gIHN0eWxlWydwb2ludHNfJyArIGlkXSA9IHtcbiAgICBiYXNlOiAncG9pbnRzJyxcbiAgICBibGVuZDogJ292ZXJsYXknLFxuICAgIGJsZW5kX29yZGVyOiBvcmQgfHwgMVxuICB9O1xuXG5cdGlmIChjaGVja01hcmtlclN5bShjM3NzKSkge1xuICAgIGxldCBwID0gc3R5bGVbJ3BvaW50c18nICsgaWRdO1xuICAgIHAudGV4dHVyZSA9IGdldFRleHR1cmVGaWxlKGMzc3MpICE9PSAnbm9uZScgPyBnZXRUZXh0dXJlKGMzc3MpIDogdm9pZCAwO1xuICAgIHAuYmxlbmQgPSBnZXRCbGVuZGluZyhjM3NzKTtcblx0fVxuXG5cdHJldHVybiBzdHlsZTtcbn07XG5cblBvaW50LmdldFRleHR1cmVzID0gZnVuY3Rpb24oYzNzcykge1xuICBsZXQgdGV4ID0ge307XG5cdGlmIChjaGVja01hcmtlclN5bShjM3NzKSkge1xuXHRcdGxldCB0ZXh0dXJlID0gZ2V0VGV4dHVyZUZpbGUoYzNzcyk7XG5cblx0XHRpZiAodGV4dHVyZSAhPT0gJ25vbmUnKSB7XG5cdFx0XHR0ZXhbTUQ1KHRleHR1cmUpXSA9IHt1cmw6IHRleHR1cmV9O1xuXHRcdH1cblxuXHRcdHJldHVybiB0ZXg7XG5cdH1cbn07XG4iLCIvKlxuIF9fX19fX19fICBfX19fX19fXyAgX19fICAgICAgICAgICBfX18gICAgX19fIF9fX19fX19fICBfX19fX19fXyAgX19fX19fX18gICBfX19fX19fX1xufFxcICAgX18gIFxcfFxcICAgX18gIFxcfFxcICBcXCAgICAgICAgIHxcXCAgXFwgIC8gIC98XFwgICBfX19fXFx8XFwgICBfXyAgXFx8XFwgICBfX18gIFxcfFxcICAgX19fX1xcXG5cXCBcXCAgXFx8XFwgIFxcIFxcICBcXHxcXCAgXFwgXFwgIFxcICAgICAgICBcXCBcXCAgXFwvICAvIHwgXFwgIFxcX19ffFxcIFxcICBcXHxcXCAgXFwgXFwgIFxcXFwgXFwgIFxcIFxcICBcXF9fX3xfXG4gXFwgXFwgICBfX19fXFwgXFwgIFxcXFxcXCAgXFwgXFwgIFxcICAgICAgICBcXCBcXCAgICAvIC8gXFwgXFwgIFxcICBfX1xcIFxcICBcXFxcXFwgIFxcIFxcICBcXFxcIFxcICBcXCBcXF9fX19fICBcXFxuICBcXCBcXCAgXFxfX198XFwgXFwgIFxcXFxcXCAgXFwgXFwgIFxcX19fXyAgICBcXC8gIC8gIC8gICBcXCBcXCAgXFx8XFwgIFxcIFxcICBcXFxcXFwgIFxcIFxcICBcXFxcIFxcICBcXHxfX19ffFxcICBcXFxuICAgXFwgXFxfX1xcICAgIFxcIFxcX19fX19fX1xcIFxcX19fX19fX1xcX18vICAvIC8gICAgICBcXCBcXF9fX19fX19cXCBcXF9fX19fX19cXCBcXF9fXFxcXCBcXF9fXFxfX19fXFxfXFwgIFxcXG4gICAgXFx8X198ICAgICBcXHxfX19fX19ffFxcfF9fX19fX198XFxfX18vIC8gICAgICAgIFxcfF9fX19fX198XFx8X19fX19fX3xcXHxfX3wgXFx8X198XFxfX19fX19fX19cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFx8X19ffC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXHxfX19fX19fX198XG5cbiAqL1xuXG4vKlxuXHRFWFRFUk5BTCBERVBFTkRFTkNJRVNcbiAqL1xuaW1wb3J0IE1ENSBmcm9tICdtZDUnO1xuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gJ3JhbWRhJztcblxuLypcblx0SU5URVJOQUwgREVQRU5ERU5DSUVTXG4gKi9cblxuaW1wb3J0IHsgZ2V0RXhlY3V0ZWRGbiwgZ2V0UHJvcGVydHlPckRlZkZuLCBnZXRCbGVuZEZuLCBnZXRDb2xvckZuIH0gZnJvbSAnLi4vdXRpbHMvcmVmZXJlbmNlLWhlbHBlcnMnO1xuaW1wb3J0IFRhbmdyYW1SZWZlcmVuY2UgZnJvbSAnLi4vdXRpbHMvcmVmZXJlbmNlJztcblxuY29uc3QgUFIgPSBUYW5ncmFtUmVmZXJlbmNlLmdldFBvbHlnb24obnVsbCk7IC8vIFBvbHlnb24gcmVmZXJlbmNlXG5jb25zdCBQUFIgPSBUYW5ncmFtUmVmZXJlbmNlLmdldFBvbHlnb25QYXR0ZXJuKG51bGwpO1xuXG4vKlxuXHRJTlRFUk5BTCBQT0xZR09OUyBGVU5DVElPTlNcbiAqL1xuXG5jb25zdCBjaGVja1BvbHlnb25TeW0gPSBUYW5ncmFtUmVmZXJlbmNlLmNoZWNrU3ltYm9saXplcigncG9seWdvbicpO1xuY29uc3QgY2hlY2tQb2xQYXR0ZXJuU3ltID0gVGFuZ3JhbVJlZmVyZW5jZS5jaGVja1N5bWJvbGl6ZXIoJ3BvbHlnb24tcGF0dGVybicpO1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBnZXR0aW5nIHRoZSBjb2xvciBpbiByZ2JhXG4gKlxuICogQHBhcmFtICAge29iamVjdH0gYzNzcyBjb21waWxlZCBjYXJ0byBjc3NcbiAqIEByZXR1cm5zIHtvYmplY3R9IHdpdGggYSBmdW5jdGlvbiB0aGF0IGNvbnRhaW4gdGhlIGNvbmRpdGlvbnMgdG8gcmV0dXJuIGEgY29sb3Igd2l0aCBhbHBoYSBjaGFubmVsXG4gKi9cbmNvbnN0IGdldENvbG9yID0gZ2V0Q29sb3JGbihcbiAgZ2V0UHJvcGVydHlPckRlZkZuKCdmaWxsJywgUFIpLFxuICBnZXRQcm9wZXJ0eU9yRGVmRm4oJ2ZpbGwtb3BhY2l0eScsIFBSKVxuKTtcblxuY29uc3QgZ2V0VGV4dHVyZUZpbGUgPSBnZXRFeGVjdXRlZEZuKCdmaWxlJywgUFBSKTtcblxuY29uc3QgZ2V0VGV4dHVyZSA9IGNvbXBvc2UoXG4gIE1ENSxcbiAgZ2V0VGV4dHVyZUZpbGVcbik7XG5cbmNvbnN0IGdldEJsZW5kaW5nID0gZ2V0QmxlbmRGbihQUik7XG5cbi8qKlxuICogQmFzaWMgUG9seWdvblxuICovXG5cbnZhciBQb2x5Z29uID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IFBvbHlnb247XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBkcmF3IG9iamVjdCBvZiBhIHBvbHlnb24uXG4gKlxuICogQHBhcmFtICAge29iamVjdH0gYzNzcyBjb21waWxlZCBjYXJ0byBjc3NcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZnVuY3Rpb24gd2l0aCB0aGUgY29uZGl0aW9ucyB0byByZXR1cm4gYWxwaGEgdmFsdWVcbiAqL1xuUG9seWdvbi5nZXREcmF3ID0gKGMzc3MsIGlkKSA9PiB7XG4gIGxldCBkcmF3ID0ge307XG5cbiAgaWYgKGNoZWNrUG9seWdvblN5bShjM3NzKSkge1xuICAgIGRyYXdbJ3BvbHlnb25zXycgKyBpZF0gPSB7XG4gICAgICBjb2xvcjogZ2V0Q29sb3IoYzNzcylcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGRyYXc7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGdldCB0aGUgc3R5bGUgY29uZmlndXJhdGlvbiBvZiBhIHBvbHlnb24uXG4gKlxuICogQHJldHVybnMgZGVmYXVsdCBzdHlsZSBjb25maWd1cmF0aW9uIGZvciBwb2x5Z29uXG4gKi9cblBvbHlnb24uZ2V0U3R5bGUgPSBmdW5jdGlvbihjM3NzLCBpZCwgb3JkKSB7XG4gIGxldCBzdHlsZSA9IHt9O1xuXG4gIHN0eWxlWydwb2x5Z29uc18nICsgaWRdID0ge1xuICAgIGJhc2U6ICdwb2x5Z29ucycsXG4gICAgYmxlbmQ6IGdldEJsZW5kaW5nKGMzc3MpLFxuICAgIGJsZW5kX29yZGVyOiBvcmQgfHwgMVxuICB9O1xuXG4gIGlmIChjaGVja1BvbFBhdHRlcm5TeW0oYzNzcykpIHtcbiAgICBzdHlsZVsncG9seWdvbnNfJyArIGlkXS5tYXRlcmlhbCA9IHtcbiAgICAgIGRpZmZ1c2U6IHtcbiAgICAgICAgdGV4dHVyZTogZ2V0VGV4dHVyZShjM3NzKSxcbiAgICAgICAgbWFwcGluZzogJ3V2J1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuXHRyZXR1cm4gc3R5bGU7XG59O1xuXG5Qb2x5Z29uLmdldFRleHR1cmVzID0gYzNzcyA9PiB7XG4gIGxldCB0ZXggPSB7fTtcbiAgaWYgKGNoZWNrUG9sUGF0dGVyblN5bShjM3NzKSkge1xuICAgIGxldCB0ZXh0dXJlID0gZ2V0VGV4dHVyZUZpbGUoYzNzcyk7XG5cbiAgICBpZiAodGV4dHVyZSkge1xuICAgICAgdGV4W01ENSh0ZXh0dXJlKV0gPSB7dXJsOiB0ZXh0dXJlfTtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4gdGV4O1xufTtcbiIsIi8qKlxuICAgX19fX19fX19fICBfX19fX19fICAgICAgX19fICAgIF9fXyBfX19fX19fX19cbiAgfFxcX19fICAgX19fXFxcXCAgX19fIFxcICAgIHxcXCAgXFwgIC8gIC98XFxfX18gICBfX19cXFxuICBcXHxfX18gXFwgIFxcX1xcIFxcICAgX18vfCAgIFxcIFxcICBcXC8gIC8gfHxfX18gXFwgIFxcX3xcbiAgICAgIFxcIFxcICBcXCBcXCBcXCAgXFxffC9fXyAgXFwgXFwgICAgLyAvICAgICBcXCBcXCAgXFxcbiAgICAgICAgXFwgXFwgIFxcIFxcIFxcICBcXF98XFwgXFwgIC8gICAgIFxcLyAgICAgICBcXCBcXCAgXFxcbiAgICAgICAgXFwgXFxfX1xcIFxcIFxcX19fX19fX1xcLyAgL1xcICAgXFwgICAgICAgICBcXCBcXF9fXFxcbiAgICAgICAgICBcXHxfX3wgIFxcfF9fX19fX18vX18vIC9cXCBfX1xcICAgICAgICBcXHxfX3xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfF9ffC8gXFx8X198XG5cbiAqL1xuXG4vKlxuICBFWFRFUk5BTCBERVBFTkRFTkNJRVNcbiovXG5cbi8qXG4gIElOVEVSTkFMIERFUEVOREVOQ0lFU1xuKi9cblxuaW1wb3J0IHsgZ2V0UHJvcGVydHlGblNhZmUsIGdldFByb3BlcnR5T3JEZWZGbiwgZ2V0Q29sb3JGbiB9IGZyb20gJy4uL3V0aWxzL3JlZmVyZW5jZS1oZWxwZXJzJztcbmltcG9ydCBUYW5ncmFtUmVmZXJlbmNlIGZyb20gJy4uL3V0aWxzL3JlZmVyZW5jZSc7XG5cbmNvbnN0IFRSID0gVGFuZ3JhbVJlZmVyZW5jZS5nZXRUZXh0KG51bGwpO1xuXG4vKlxuICBJTlRFUk5BTCBQT0xZR09OUyBGVU5DVElPTlNcbiovXG5cbmNvbnN0IGNoZWNrVGV4dFN5bSA9IFRhbmdyYW1SZWZlcmVuY2UuY2hlY2tTeW1ib2xpemVyKCd0ZXh0Jyk7XG5cbmNvbnN0IGdldFRleHROYW1lID0gZ2V0UHJvcGVydHlGblNhZmUoJ25hbWUnLCBUUik7XG5cbmNvbnN0IGdldFNpemUgPSBnZXRQcm9wZXJ0eUZuU2FmZSgnc2l6ZScsIFRSKTtcblxuY29uc3QgZ2V0Q29sb3IgPSBnZXRDb2xvckZuKFxuICBnZXRQcm9wZXJ0eUZuU2FmZSgnZmlsbCcsIFRSKSxcbiAgZ2V0UHJvcGVydHlPckRlZkZuKCdvcGFjaXR5JywgVFIpXG4pO1xuXG52YXIgVGV4dFBvaW50ID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRQb2ludDtcblxuVGV4dFBvaW50LmdldERyYXcgPSAoYzNzcywgaWQpID0+IHtcbiAgbGV0IGRyYXcgPSB7fTtcblxuICBpZiAoY2hlY2tUZXh0U3ltKGMzc3MpKSB7XG4gICAgZHJhd1sndGV4dF8nICsgaWRdID0ge1xuICAgICAgY29sbGlkZTogZmFsc2UsXG4gICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgdGV4dF9zb3VyY2U6IGdldFRleHROYW1lKGMzc3MpLFxuICAgICAgICBmb250OiB7XG4gICAgICAgICAgc2l6ZTogZ2V0U2l6ZShjM3NzKSxcbiAgICAgICAgICBmaWxsOiBnZXRDb2xvcihjM3NzKVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGRyYXc7XG59O1xuXG5cblRleHRQb2ludC5nZXRTdHlsZSA9IChjM3NzLCBpZCwgb3JkKSA9PiB7XG4gIGxldCBzdHlsZSA9IHt9O1xuXG4gIHN0eWxlWyd0ZXh0XycgKyBpZF0gPSB7XG4gICAgYmFzZTogJ3BvaW50cycsXG4gICAgYmxlbmQ6ICdvdmVybGF5JyxcbiAgICBibGVuZF9vcmRlcjogb3JkIHx8IDFcbiAgfTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuIiwiaW1wb3J0IENhcnRvIGZyb20gJ2NhcnRvJztcbmltcG9ydCBQb2ludHMgZnJvbSAnLi9iYXNpYy9wb2ludHMnO1xuaW1wb3J0IFBvbHlnb25zIGZyb20gJy4vYmFzaWMvcG9seWdvbnMnO1xuaW1wb3J0IExpbmVzIGZyb20gJy4vYmFzaWMvbGluZXMnO1xuaW1wb3J0IFRleHRQb2ludHMgZnJvbSAnLi9iYXNpYy90ZXh0JztcbmltcG9ydCBNRDUgZnJvbSAnbWQ1JztcblxuY29uc3QgQ2FydG9DU1NSZW5kZXJlciA9IG5ldyBDYXJ0by5SZW5kZXJlckpTKCk7XG5cbmNvbnN0IGV4dHJhY3RGZWF0dXJlcyA9IGZ1bmN0aW9uIChjY3NzLCBpbmRleCkge1xuICBsZXQgbGF5ZXJzID0gQ2FydG9DU1NSZW5kZXJlci5yZW5kZXIoY2NzcykuZ2V0TGF5ZXJzKCksXG4gICAgICBpZCA9IE1ENShjY3NzKSxcbiAgICAgIGRyYXcgPSB7fSxcbiAgICAgIHN0eWxlcyA9IHt9LFxuICAgICAgdGV4dHVyZXMgPSB7fTtcblxuICAvLyBOT1RFOiB0aGlzIGlzIHdyb25nLCB3ZSBoYXZlIHRvIHNlcGFyYXRlIHRoZSBsYXllcnMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IGx5ID0gbGF5ZXJzW2ldLnNoYWRlcjtcblxuICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIGRyYXcsXG4gICAgICAgIFBvaW50cy5nZXREcmF3KGx5LCBpZCksXG4gICAgICAgIFBvbHlnb25zLmdldERyYXcobHksIGlkKSxcbiAgICAgICAgTGluZXMuZ2V0RHJhdyhseSwgaWQpLFxuICAgICAgICBUZXh0UG9pbnRzLmdldERyYXcobHksIGlkKVxuICAgICAgKTtcblxuICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHRleHR1cmVzLFxuICAgICAgICBQb2ludHMuZ2V0VGV4dHVyZXMobHkpLFxuICAgICAgICBQb2x5Z29ucy5nZXRUZXh0dXJlcyhseSlcbiAgICAgICk7XG5cbiAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIFBvaW50cy5nZXRTdHlsZShseSwgaWQsIGluZGV4KSxcbiAgICAgICAgUG9seWdvbnMuZ2V0U3R5bGUobHksIGlkLCBpbmRleCksXG4gICAgICAgIExpbmVzLmdldFN0eWxlKGx5LCBpZCwgaW5kZXgpLFxuICAgICAgICBUZXh0UG9pbnRzLmdldFN0eWxlKGx5LCBpZCwgaW5kZXgpXG4gICAgICApO1xuICB9XG5cbiAgcmV0dXJuIHt0ZXh0dXJlcywgZHJhdywgc3R5bGVzfTtcbn07XG5cbnZhciBDMlQ7XG5cbmV4cG9ydCBkZWZhdWx0IEMyVCA9IHtcbiAgZXh0cmFjdEZlYXR1cmVzXG59O1xuIiwiaW1wb3J0IENDU1MgZnJvbSAnLi9jYXJ0byc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYXJ0bzJEcmF3OiBDQ1NTLmV4dHJhY3RGZWF0dXJlcyxcblx0fTtcbiIsImltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG52YXIgQ29sb3JzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IENvbG9ycztcblxubGV0IEMgPSBDb2xvcnM7XG5cbkNvbG9ycy5faXNIZXggPSBVdGlscy5mdW5jdGlvblN0cmluZyhcbiAgYGZ1bmN0aW9uIGlzSGV4IChjKSB7XG5cdFx0cmV0dXJuIGMuaW5kZXhPZignIycpID49IDA7XG5cdH1gXG4pO1xuXG5Db2xvcnMuX2lzUkdCID0gVXRpbHMuZnVuY3Rpb25TdHJpbmcoXG4gIGBmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiBjLmluZGV4T2YoJ3JnYicpID49IDA7XG5cdH1gXG4pO1xuXG5Db2xvcnMuX2lzUkdCQSA9IFV0aWxzLmZ1bmN0aW9uU3RyaW5nKFxuICBgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gYy5pbmRleE9mKCdyZ2JhJykgPj0gMDtcblx0fWBcbik7XG5cbkNvbG9ycy50b1NpeEhleCA9IFV0aWxzLmZ1bmN0aW9uU3RyaW5nKFxuICBgZnVuY3Rpb24gKGMpIHtcblx0XHRcdGlmIChjLmxlbmd0aCA9PT0gNykge1xuXHRcdFx0XHRyZXR1cm4gYztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgciA9IGNbMV0sXG5cdFx0XHRcdFx0ZyA9IGNbMl0sXG5cdFx0XHRcdFx0YiA9IGNbM107XG5cblx0XHRcdFx0cmV0dXJuICcjJyArIHIgKyByICsgZyArIGcgKyBiICsgYjtcblx0XHRcdH1cblx0XHR9YFxuKTtcblxuQ29sb3JzLmhleFRvSW50ID0gVXRpbHMuZnVuY3Rpb25TdHJpbmcoXG4gIGBmdW5jdGlvbiAoaGV4KSB7XG5cdFx0cmV0dXJuIHBhcnNlSW50KCcweCcgKyBoZXgpO1xuXHR9YFxuKTtcblxuQ29sb3JzLnRvUkdCID0gVXRpbHMuZnVuY3Rpb25TdHJpbmcoXG4gIGBmdW5jdGlvbiAoYykge1xuXHRcdHZhciByID0gJHtDLmhleFRvSW50fShjLnN1YnN0cigxLCAyKSkgKyAnLCAnLFxuXHRcdFx0ZyA9ICR7Qy5oZXhUb0ludH0oYy5zdWJzdHIoMywgMikpICsgJywgJyxcblx0XHRcdGIgPSAke0MuaGV4VG9JbnR9KGMuc3Vic3RyKDUsIDIpKTtcblxuXHRcdHJldHVybiAncmdiKCcgKyByICsgZyArIGIgKyAnKSc7XG5cdH1gXG4pO1xuXG5Db2xvcnMudG9SR0JBID0gVXRpbHMuZnVuY3Rpb25TdHJpbmcoXG4gIGBmdW5jdGlvbiAocmdiLCBhbHBoYSkge1xuXHRcdHJldHVybiByZ2IucmVwbGFjZSgncmdiJywgJ3JnYmEnKS5yZXBsYWNlKCcpJywgJywgJyArIGFscGhhICsgJyknKTtcblx0fWBcbik7XG5cbkNvbG9ycy5nZXRBbHBoYUNvbG9yRm4gPSBVdGlscy5mdW5jdGlvblN0cmluZyhcbiAgYGZ1bmN0aW9uIChjb2xvciwgb3BhY2l0eSkge1xuXHRcdC8vIFRPRE86IHJldmlldyB0aGlzIGZhbGxiYWNrIHRvICdibGFjaycgY29sb3IuXG5cdFx0Y29sb3IgPSBjb2xvciB8fCAnIzAwMCc7XG4gICAgdmFyIHRvUkdCQSA9ICR7Qy50b1JHQkF9O1xuXHRcdGlmICggJHtDLl9pc1JHQkF9KGNvbG9yKSApIHtcblx0XHRcdHJldHVybiBjb2xvcjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoICR7Qy5faXNIZXh9KGNvbG9yKSApIHtcblx0XHRcdFx0cmV0dXJuIHRvUkdCQSggJHtDLnRvUkdCfSggJHtDLnRvU2l4SGV4fShjb2xvcikgKSwgb3BhY2l0eSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICR7Qy5faXNSR0J9KGNvbG9yKSApIHtcblx0XHRcdFx0cmV0dXJuIHRvUkdCQShjb2xvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9YFxuKTtcblxuQ29sb3JzLmdldEFscGhhQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIG9wYWNpdHkpIHtcbiAgaWYgKGNvbG9yICYmIHR5cGVvZiBvcGFjaXR5ICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBVdGlscy5mdW5jdGlvblN0cmluZyhcbiAgICAgIGBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9wID0gJHtvcGFjaXR5fSgpO1xuICAgICAgICAgIHJldHVybiAke0MuZ2V0QWxwaGFDb2xvckZufSgke2NvbG9yfSgpLCB0eXBlb2Ygb3AgPT09IFwibnVtYmVyXCIgPyBvcCA6IDEpO1xuICAgICAgfWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbG9yO1xufTtcbiIsInZhciBHZW9tID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IEdlb207XG5cbkdlb20ucHgyTWV0ZXJzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBgZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbCA9ICgke2ZufSgpKTtcbiAgXHRcdHJldHVybiB2YWwgKiAkbWV0ZXJzX3Blcl9waXhlbDtcbiAgXHR9YC5yZXBsYWNlKC8oXFx0KS9nLCAnJyk7XG59O1xuIiwiaW1wb3J0IFIgZnJvbSAncmFtZGEnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBUYW5ncmFtUmVmZXJlbmNlIGZyb20gJy4uL3V0aWxzL3JlZmVyZW5jZSc7XG5pbXBvcnQgQ29sb3JzIGZyb20gJy4uL3N0eWxlL2NvbG9ycyc7XG5cblxuLypcbiAgSU5URVJOQUwgUkVGRVJFTkNFIEZVTkNUSU9OU1xuICovXG5cbmNvbnN0IGN1cnJ5Q29tcCA9IFV0aWxzLmN1cnJ5Q29tcG9zZTM7XG5cbi8qXG4gIFJFRkVSRU5DRSBIRUxQRVJcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZURlZmF1bHRGcm9tUmVmID0gZnVuY3Rpb24oUmVmLCBwcm9wKSB7XG5cdHJldHVybiB7IGpzOiBVdGlscy5nZW5lcmF0ZURlZmF1bHQoYFwiJHtSZWZbcHJvcF1bJ2RlZmF1bHQtdmFsdWUnXX1cImApIH07XG59O1xuXG5jb25zdCBnZXREZWZQcm9wID0gUi5jdXJyeSgocHJvcCwgcmVmKSA9PiB7XG4gIHJldHVybiBnZW5lcmF0ZURlZmF1bHRGcm9tUmVmKHJlZiwgcHJvcCk7XG59KTtcblxuLy8gcmVmID0gJ3N0cm9rZS1vcGFjaXR5JyAtPiBnZXQge3N0cm9rZS1vcGFjaXR5OiB7Y3NzOiAnbGluZS1vcGFjaXR5J319IC0+IGxpbmUtb3BhY2l0eTtcbi8vIHJlZlsnbGluZS1vcGFjaXR5J107XG5jb25zdCBnZXRQcm9wID0gUi5jdXJyeSgocHJvcCwgcmVmLCBjM3NzKSA9PiB7XG4gIHJldHVybiBVdGlscy5waWNrKFV0aWxzLnBpY2socHJvcCArICcuY3NzJywgcmVmKSwgYzNzcyk7XG59KTtcblxuY29uc3QgZ2V0UHJvcE9yRGVmID0gUi5laXRoZXIoZ2V0UHJvcCwgZ2V0RGVmUHJvcCk7XG5cblxuY29uc3QgZ2V0UHJvcGVydHlGbiA9IGN1cnJ5Q29tcChSLmNvbXBvc2UoXG4gIFV0aWxzLmJ1aWxkQ0NTU0ZuLFxuICBSLnByb3AoJ2pzJyksIC8vIGdldCBwcm9wZXJ0eSBqcyBmcm9tIG9iamVjdFxuICBnZXRQcm9wXG4pKTtcblxuY29uc3QgZ2V0UHJvcGVydHlGblNhZmUgPSBSLmlmRWxzZShcbiAgZ2V0UHJvcCxcbiAgZ2V0UHJvcGVydHlGbixcbiAgKCkgPT4gdm9pZCAwXG4pO1xuXG5jb25zdCBnZXRQcm9wZXJ0eU9yRGVmRm4gPSBjdXJyeUNvbXAoUi5jb21wb3NlKFxuICBVdGlscy5idWlsZENDU1NGbixcbiAgUi5wcm9wKCdqcycpLFxuICBnZXRQcm9wT3JEZWZcbikpO1xuXG5jb25zdCBnZXRFaXRoZXJQcm9wID0gKHByb3BBLCBwcm9wQiwgcmVmKSA9PiBSLmVpdGhlcihcbiAgZ2V0UHJvcGVydHlGblNhZmUocHJvcEEsIHJlZiksXG4gIGdldFByb3BlcnR5T3JEZWZGbihwcm9wQiwgcmVmKVxuKTtcblxuY29uc3QgZ2V0RXhlY3V0ZWRGbiA9IGN1cnJ5Q29tcChSLmNvbXBvc2UoXG4gIFV0aWxzLmJ1aWxkQW5kRXhlY3V0ZUZuLFxuICBSLnByb3AoJ2pzJyksXG4gIGdldFByb3BPckRlZlxuKSk7XG5cbmNvbnN0IGdldEJsZW5kRm4gPSBSLmN1cnJ5KChyZWYsIGMzc3MpID0+IFIuY29tcG9zZShcbiAgUi5kZWZhdWx0VG8oJ292ZXJsYXknKSxcbiAgVGFuZ3JhbVJlZmVyZW5jZS5jaGVja1R5cGUocmVmWydjb21wLW9wJ10pLFxuICBnZXRFeGVjdXRlZEZuKCdjb21wLW9wJylcbikocmVmLCBjM3NzKSk7XG5cbmNvbnN0IGdldENvbG9yRm4gPSAoZmlsbCwgYWxwaGEpID0+IHtcbiAgcmV0dXJuIFIuY29tcG9zZShcbiAgICBSLmFwcGx5KENvbG9ycy5nZXRBbHBoYUNvbG9yKSxcbiAgICBSLnZhbHVlcyxcbiAgICBSLmFwcGx5U3BlYyh7XG4gICAgICBmaWxsOiBmaWxsLFxuICAgICAgYWxwaGE6IGFscGhhXG4gICAgfSlcbiAgKTtcbn07XG5cbmV4cG9ydCB7XG4gIGdlbmVyYXRlRGVmYXVsdEZyb21SZWYsXG4gIGdldERlZlByb3AsXG4gIGdldFByb3AsXG4gIGdldFByb3BPckRlZixcbiAgZ2V0UHJvcGVydHlGbixcbiAgZ2V0UHJvcGVydHlGblNhZmUsXG4gIGdldFByb3BlcnR5T3JEZWZGbixcbiAgZ2V0RWl0aGVyUHJvcCxcbiAgZ2V0RXhlY3V0ZWRGbixcbiAgZ2V0QmxlbmRGbixcbiAgZ2V0Q29sb3JGblxufTtcbiIsImltcG9ydCBSIGZyb20gJ3JhbWRhJztcbmltcG9ydCByZWZlcmVuY2UgZnJvbSAndGFuZ3JhbS1yZWZlcmVuY2UnO1xuXG5jb25zdCBSZWYgPSByZWZlcmVuY2UubG9hZCgnMS4wLjAnKTtcblxudmFyIFRhbmdyYW1SZWZlcmVuY2UgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgVGFuZ3JhbVJlZmVyZW5jZTtcblxuY29uc3QgZ2V0UHJvcGVydHkgPSBSLmN1cnJ5KGZ1bmN0aW9uICh0eXBlLCBwcm9wKSB7XG5cdGNvbnN0IG9iaiA9IFJlZi5zeW1ib2xpemVyc1t0eXBlXTtcblx0cmV0dXJuIHByb3AgPyBvYmpbcHJvcF0gOiBvYmo7XG59KTtcblxuVGFuZ3JhbVJlZmVyZW5jZS5nZXRQb2ludCA9IGdldFByb3BlcnR5KCdtYXJrZXJzJyk7XG5cblRhbmdyYW1SZWZlcmVuY2UuZ2V0TGluZSA9IGdldFByb3BlcnR5KCdsaW5lJyk7XG5cblRhbmdyYW1SZWZlcmVuY2UuZ2V0UG9seWdvbiA9IGdldFByb3BlcnR5KCdwb2x5Z29uJyk7XG5cblRhbmdyYW1SZWZlcmVuY2UuZ2V0VGV4dCA9IGdldFByb3BlcnR5KCd0ZXh0Jyk7XG5cblRhbmdyYW1SZWZlcmVuY2UuZ2V0UG9seWdvblBhdHRlcm4gPSBnZXRQcm9wZXJ0eSgncG9seWdvbi1wYXR0ZXJuJyk7XG5cblRhbmdyYW1SZWZlcmVuY2UuY2hlY2tTeW1ib2xpemVyID0gUi5jdXJyeShmdW5jdGlvbihzeW0sIGMzc3MpIHtcblx0cmV0dXJuIGMzc3Muc3ltYm9saXplcnMuaW5kZXhPZihzeW0pICE9PSAtMSA/IGMzc3MgOiBudWxsO1xufSk7XG5cblRhbmdyYW1SZWZlcmVuY2UuY2hlY2tUeXBlID0gUi5jdXJyeShmdW5jdGlvbihyZWYsIHZhbCkge1xuXHRyZXR1cm4gcmVmLnR5cGUuaW5kZXhPZih2YWwpICE9PSAtMSA/IHZhbCA6IG51bGw7XG59KTtcbiIsImltcG9ydCBSIGZyb20gJ3JhbWRhJztcblxudmFyIFV0aWxzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxzO1xuXG5jb25zdCByZXBsYWNlID0gUi5jdXJyeShSLnJlcGxhY2UpO1xuXG5jb25zdCBnZW9tZXRyaWVzID0ge1xuICAnMSc6ICdcInBvaW50XCInLFxuICAnMic6ICdcImxpbmVcIicsXG4gICczJzogJ1wicG9seWdvblwiJ1xufTtcblxuVXRpbHMuY3VycnlDb21wb3NlMyA9IGZ1bmN0aW9uIChjb21wb3NlKSB7XG4gIHJldHVybiBSLmN1cnJ5KChhLGIsYykgPT4gY29tcG9zZShhLGIsYykpO1xufTtcblxuVXRpbHMud3JhcENvZGVJbkZ1bmN0aW9uID0gZnVuY3Rpb24oaW5uZXJDb2RlLCBhdHRyID0gWycgJ10pIHtcblx0YXR0ciA9IGF0dHIuam9pbignLCcpO1xuXG5cdHJldHVybiBgZnVuY3Rpb24gKCR7YXR0cn0pIHtcblx0XHRcdFx0dmFyIF92YWx1ZSA9IG51bGw7XG5cdFx0XHRcdCR7aW5uZXJDb2RlfVxuXHRcdFx0XHRyZXR1cm4gX3ZhbHVlO1xuXHRcdFx0fWAucmVwbGFjZSgvKFxcdCkvZywgJycpO1xufTtcblxuVXRpbHMuZnVuY3Rpb25TdHJpbmcgPSBmdW5jdGlvbihmbikge1xuXHRsZXQgYXJncyA9IGZuXG5cdFx0XHQuc3Vic3RyaW5nKCBmbi5pbmRleE9mKCcoJykgKyAxLCBmbi5pbmRleE9mKCcpJykgKVxuXHRcdFx0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cblx0YXJncyA9IGFyZ3MgPyBhcmdzLnNwbGl0KCcsJykgOiBbXTtcblxuXHRsZXQgYm9keSA9IGZuLnN1YnN0cmluZyggZm4uaW5kZXhPZigneycpICsgMSwgZm4ubGFzdEluZGV4T2YoJ30nKSk7XG5cdGxldCBmdW5jID0gbmV3IEZ1bmN0aW9uKC4uLmFyZ3MsIGJvZHkpO1xuXG5cdGZ1bmMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm47XG5cdH07XG5cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG5cblV0aWxzLnRyYW5zcGlsZTJUYW5ncmFtID0gUi5jb21wb3NlKFxuICByZXBsYWNlKC9jdHguem9vbS9nLCAnJHpvb20nKSxcbiAgcmVwbGFjZSgvZGF0YVxcWy9nLCAnZmVhdHVyZVsnKSxcbiAgcmVwbGFjZSgvZGF0YVxcWydtYXBuaWs6Omdlb21ldHJ5X3R5cGUnXFxdID09PSAoXFxkKS9nLCAoJDAsICQxKSA9PiB7XG4gICAgcmV0dXJuICckZ2VvbWV0cnkgPT09ICcgKyBnZW9tZXRyaWVzWyQxXTtcbiAgfSlcbik7XG5cblV0aWxzLmJ1aWxkQ0NTU0ZuID0gZnVuY3Rpb24oanMsIGF0dHIpIHtcblx0bGV0IGZuID0gJyc7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBqcy5sZW5ndGg7IGkrKykge1xuXHRcdGZuICs9IFV0aWxzLnRyYW5zcGlsZTJUYW5ncmFtKGpzW2ldKTtcblx0fVxuXG5cdHJldHVybiBVdGlscy5mdW5jdGlvblN0cmluZyhVdGlscy53cmFwQ29kZUluRnVuY3Rpb24oZm4sIGF0dHIpKTtcbn07XG5cblV0aWxzLmJ1aWxkQW5kRXhlY3V0ZUZuID0gIGZ1bmN0aW9uIChqcykge1xuICByZXR1cm4gVXRpbHMuYnVpbGRDQ1NTRm4oanMsIFsnJHpvb20nXSkoMTApO1xufTtcblxuVXRpbHMuZ2VuZXJhdGVEZWZhdWx0ID0gZnVuY3Rpb24odmFsKSB7XG5cdHJldHVybiBgcmV0dXJuICR7dmFsfTtgO1xufTtcblxuVXRpbHMucGljayA9IFIuY3VycnkoKHBhdGgsIG9iaikgPT4ge1xuICByZXR1cm4gUi5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBrZXkpID0+IHtcbiAgICByZXR1cm4gYWNjdW11bGF0b3Jba2V5XTtcbiAgfSwgb2JqLCBSLnNwbGl0KCcuJywgcGF0aCkpO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsInZhciBjaGFyZW5jID0ge1xuICAvLyBVVEYtOCBlbmNvZGluZ1xuICB1dGY4OiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBjaGFyZW5jLmJpbi5zdHJpbmdUb0J5dGVzKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGNoYXJlbmMuYmluLmJ5dGVzVG9TdHJpbmcoYnl0ZXMpKSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIEJpbmFyeSBlbmNvZGluZ1xuICBiaW46IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgc3RyID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0ci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pKTtcbiAgICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoYXJlbmM7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247IiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTsiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTsiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59OyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTsiLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBiYXNlNjRtYXBcbiAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLFxuXG4gIGNyeXB0ID0ge1xuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIGxlZnRcbiAgICByb3RsOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgYikgfCAobiA+Pj4gKDMyIC0gYikpO1xuICAgIH0sXG5cbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiByaWdodFxuICAgIHJvdHI6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCAoMzIgLSBiKSkgfCAobiA+Pj4gYik7XG4gICAgfSxcblxuICAgIC8vIFN3YXAgYmlnLWVuZGlhbiB0byBsaXR0bGUtZW5kaWFuIGFuZCB2aWNlIHZlcnNhXG4gICAgZW5kaWFuOiBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBJZiBudW1iZXIgZ2l2ZW4sIHN3YXAgZW5kaWFuXG4gICAgICBpZiAobi5jb25zdHJ1Y3RvciA9PSBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0LnJvdGwobiwgOCkgJiAweDAwRkYwMEZGIHwgY3J5cHQucm90bChuLCAyNCkgJiAweEZGMDBGRjAwO1xuICAgICAgfVxuXG4gICAgICAvLyBFbHNlLCBhc3N1bWUgYXJyYXkgYW5kIHN3YXAgYWxsIGl0ZW1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspXG4gICAgICAgIG5baV0gPSBjcnlwdC5lbmRpYW4obltpXSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuXG4gICAgLy8gR2VuZXJhdGUgYW4gYXJyYXkgb2YgYW55IGxlbmd0aCBvZiByYW5kb20gYnl0ZXNcbiAgICByYW5kb21CeXRlczogZnVuY3Rpb24obikge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXTsgbiA+IDA7IG4tLSlcbiAgICAgICAgYnl0ZXMucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYmlnLWVuZGlhbiAzMi1iaXQgd29yZHNcbiAgICBieXRlc1RvV29yZHM6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciB3b3JkcyA9IFtdLCBpID0gMCwgYiA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKywgYiArPSA4KVxuICAgICAgICB3b3Jkc1tiID4+PiA1XSB8PSBieXRlc1tpXSA8PCAoMjQgLSBiICUgMzIpO1xuICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGJpZy1lbmRpYW4gMzItYml0IHdvcmRzIHRvIGEgYnl0ZSBhcnJheVxuICAgIHdvcmRzVG9CeXRlczogZnVuY3Rpb24od29yZHMpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGIgPSAwOyBiIDwgd29yZHMubGVuZ3RoICogMzI7IGIgKz0gOClcbiAgICAgICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgaGV4IHN0cmluZ1xuICAgIGJ5dGVzVG9IZXg6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBoZXggPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSAmIDB4RikudG9TdHJpbmcoMTYpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZXguam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBoZXggc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGhleFRvQnl0ZXM6IGZ1bmN0aW9uKGhleCkge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYyA9IDA7IGMgPCBoZXgubGVuZ3RoOyBjICs9IDIpXG4gICAgICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cihjLCAyKSwgMTYpKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICAgIGJ5dGVzVG9CYXNlNjQ6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBiYXNlNjQgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlc1tpXSA8PCAxNikgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgYnl0ZXNbaSArIDJdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgICBpZiAoaSAqIDggKyBqICogNiA8PSBieXRlcy5sZW5ndGggKiA4KVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goYmFzZTY0bWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gNiAqICgzIC0gaikpICYgMHgzRikpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKCc9Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZTY0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYmFzZS02NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgYmFzZTY0VG9CeXRlczogZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgICAvLyBSZW1vdmUgbm9uLWJhc2UtNjQgY2hhcmFjdGVyc1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnJlcGxhY2UoL1teQS1aMC05K1xcL10vaWcsICcnKTtcblxuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgaSA9IDAsIGltb2Q0ID0gMDsgaSA8IGJhc2U2NC5sZW5ndGg7XG4gICAgICAgICAgaW1vZDQgPSArK2kgJSA0KSB7XG4gICAgICAgIGlmIChpbW9kNCA9PSAwKSBjb250aW51ZTtcbiAgICAgICAgYnl0ZXMucHVzaCgoKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSAtIDEpKVxuICAgICAgICAgICAgJiAoTWF0aC5wb3coMiwgLTIgKiBpbW9kNCArIDgpIC0gMSkpIDw8IChpbW9kNCAqIDIpKVxuICAgICAgICAgICAgfCAoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpKSkgPj4+ICg2IC0gaW1vZDQgKiAyKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGNyeXB0O1xufSkoKTtcbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIihmdW5jdGlvbigpe1xyXG4gIHZhciBjcnlwdCA9IHJlcXVpcmUoJ2NyeXB0JyksXHJcbiAgICAgIHV0ZjggPSByZXF1aXJlKCdjaGFyZW5jJykudXRmOCxcclxuICAgICAgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKSxcclxuICAgICAgYmluID0gcmVxdWlyZSgnY2hhcmVuYycpLmJpbixcclxuXHJcbiAgLy8gVGhlIGNvcmVcclxuICBtZDUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgLy8gQ29udmVydCB0byBieXRlIGFycmF5XHJcbiAgICBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiaW5hcnknKVxyXG4gICAgICAgIG1lc3NhZ2UgPSBiaW4uc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1lc3NhZ2UgPSB1dGY4LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XHJcbiAgICBlbHNlIGlmIChpc0J1ZmZlcihtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UsIDApO1xyXG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpXHJcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnRvU3RyaW5nKCk7XHJcbiAgICAvLyBlbHNlLCBhc3N1bWUgYnl0ZSBhcnJheSBhbHJlYWR5XHJcblxyXG4gICAgdmFyIG0gPSBjcnlwdC5ieXRlc1RvV29yZHMobWVzc2FnZSksXHJcbiAgICAgICAgbCA9IG1lc3NhZ2UubGVuZ3RoICogOCxcclxuICAgICAgICBhID0gIDE3MzI1ODQxOTMsXHJcbiAgICAgICAgYiA9IC0yNzE3MzM4NzksXHJcbiAgICAgICAgYyA9IC0xNzMyNTg0MTk0LFxyXG4gICAgICAgIGQgPSAgMjcxNzMzODc4O1xyXG5cclxuICAgIC8vIFN3YXAgZW5kaWFuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbVtpXSA9ICgobVtpXSA8PCAgOCkgfCAobVtpXSA+Pj4gMjQpKSAmIDB4MDBGRjAwRkYgfFxyXG4gICAgICAgICAgICAgKChtW2ldIDw8IDI0KSB8IChtW2ldID4+PiAgOCkpICYgMHhGRjAwRkYwMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYWRkaW5nXHJcbiAgICBtW2wgPj4+IDVdIHw9IDB4ODAgPDwgKGwgJSAzMik7XHJcbiAgICBtWygoKGwgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbDtcclxuXHJcbiAgICAvLyBNZXRob2Qgc2hvcnRjdXRzXHJcbiAgICB2YXIgRkYgPSBtZDUuX2ZmLFxyXG4gICAgICAgIEdHID0gbWQ1Ll9nZyxcclxuICAgICAgICBISCA9IG1kNS5faGgsXHJcbiAgICAgICAgSUkgPSBtZDUuX2lpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcclxuXHJcbiAgICAgIHZhciBhYSA9IGEsXHJcbiAgICAgICAgICBiYiA9IGIsXHJcbiAgICAgICAgICBjYyA9IGMsXHJcbiAgICAgICAgICBkZCA9IGQ7XHJcblxyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDcsIC02ODA4NzY5MzYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgNF0sICA3LCAtMTc2NDE4ODk3KTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDhdLCAgNywgIDE3NzAwMzU0MTYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE3LCAtNDIwNjMpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsxMl0sICA3LCAgMTgwNDYwMzY4Mik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xyXG5cclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgMV0sICA1LCAtMTY1Nzk2NTEwKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgNl0sICA5LCAtMTA2OTUwMTYzMik7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krIDVdLCAgNSwgLTcwMTU1ODY5MSk7XHJcbiAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBtW2krMTBdLCAgOSwgIDM4MDE2MDgzKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgOV0sICA1LCAgNTY4NDQ2NDM4KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxNF0sICA5LCAtMTAxOTgwMzY5MCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKzEzXSwgIDUsIC0xNDQ0NjgxNDY3KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgMl0sICA5LCAtNTE0MDM3ODQpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XHJcblxyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA1XSwgIDQsIC0zNzg1NTgpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTRdLCAyMywgLTM1MzA5NTU2KTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsgMV0sICA0LCAtMTUzMDk5MjA2MCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsxM10sICA0LCAgNjgxMjc5MTc0KTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsgNl0sIDIzLCAgNzYwMjkxODkpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA5XSwgIDQsIC02NDAzNjQ0ODcpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xyXG5cclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgMF0sICA2LCAtMTk4NjMwODQ0KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krMTJdLCAgNiwgIDE3MDA0ODU1NzEpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE1LCAtMTA1MTUyMyk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyA4XSwgIDYsICAxODczMzEzMzU5KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDRdLCAgNiwgLTE0NTUyMzA3MCk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xyXG5cclxuICAgICAgYSA9IChhICsgYWEpID4+PiAwO1xyXG4gICAgICBiID0gKGIgKyBiYikgPj4+IDA7XHJcbiAgICAgIGMgPSAoYyArIGNjKSA+Pj4gMDtcclxuICAgICAgZCA9IChkICsgZGQpID4+PiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcnlwdC5lbmRpYW4oW2EsIGIsIGMsIGRdKTtcclxuICB9O1xyXG5cclxuICAvLyBBdXhpbGlhcnkgZnVuY3Rpb25zXHJcbiAgbWQ1Ll9mZiAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBjIHwgfmIgJiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9nZyAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBkIHwgYyAmIH5kKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9oaCAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG4gIG1kNS5faWkgID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuXHJcbiAgLy8gUGFja2FnZSBwcml2YXRlIGJsb2Nrc2l6ZVxyXG4gIG1kNS5fYmxvY2tzaXplID0gMTY7XHJcbiAgbWQ1Ll9kaWdlc3RzaXplID0gMTY7XHJcblxyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIGlmIChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGFyZ3VtZW50ICcgKyBtZXNzYWdlKTtcclxuXHJcbiAgICB2YXIgZGlnZXN0Ynl0ZXMgPSBjcnlwdC53b3Jkc1RvQnl0ZXMobWQ1KG1lc3NhZ2UsIG9wdGlvbnMpKTtcclxuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNCeXRlcyA/IGRpZ2VzdGJ5dGVzIDpcclxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPyBiaW4uYnl0ZXNUb1N0cmluZyhkaWdlc3RieXRlcykgOlxyXG4gICAgICAgIGNyeXB0LmJ5dGVzVG9IZXgoZGlnZXN0Ynl0ZXMpO1xyXG4gIH07XHJcblxyXG59KSgpO1xyXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTAuMFxudmFyIER1bXBlciwgSW5saW5lLCBVdGlscztcblxuVXRpbHMgPSByZXF1aXJlKCcuL1V0aWxzJyk7XG5cbklubGluZSA9IHJlcXVpcmUoJy4vSW5saW5lJyk7XG5cbkR1bXBlciA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRHVtcGVyKCkge31cblxuICBEdW1wZXIuaW5kZW50YXRpb24gPSA0O1xuXG4gIER1bXBlci5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uKGlucHV0LCBpbmxpbmUsIGluZGVudCwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RW5jb2Rlcikge1xuICAgIHZhciBpLCBrZXksIGxlbiwgb3V0cHV0LCBwcmVmaXgsIHZhbHVlLCB3aWxsQmVJbmxpbmVkO1xuICAgIGlmIChpbmxpbmUgPT0gbnVsbCkge1xuICAgICAgaW5saW5lID0gMDtcbiAgICB9XG4gICAgaWYgKGluZGVudCA9PSBudWxsKSB7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgIH1cbiAgICBpZiAoZXhjZXB0aW9uT25JbnZhbGlkVHlwZSA9PSBudWxsKSB7XG4gICAgICBleGNlcHRpb25PbkludmFsaWRUeXBlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmplY3RFbmNvZGVyID09IG51bGwpIHtcbiAgICAgIG9iamVjdEVuY29kZXIgPSBudWxsO1xuICAgIH1cbiAgICBvdXRwdXQgPSAnJztcbiAgICBwcmVmaXggPSAoaW5kZW50ID8gVXRpbHMuc3RyUmVwZWF0KCcgJywgaW5kZW50KSA6ICcnKTtcbiAgICBpZiAoaW5saW5lIDw9IDAgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgVXRpbHMuaXNFbXB0eShpbnB1dCkpIHtcbiAgICAgIG91dHB1dCArPSBwcmVmaXggKyBJbmxpbmUuZHVtcChpbnB1dCwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RW5jb2Rlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlucHV0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgICAgICB3aWxsQmVJbmxpbmVkID0gaW5saW5lIC0gMSA8PSAwIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgVXRpbHMuaXNFbXB0eSh2YWx1ZSk7XG4gICAgICAgICAgb3V0cHV0ICs9IHByZWZpeCArICctJyArICh3aWxsQmVJbmxpbmVkID8gJyAnIDogXCJcXG5cIikgKyB0aGlzLmR1bXAodmFsdWUsIGlubGluZSAtIDEsICh3aWxsQmVJbmxpbmVkID8gMCA6IGluZGVudCArIHRoaXMuaW5kZW50YXRpb24pLCBleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3RFbmNvZGVyKSArICh3aWxsQmVJbmxpbmVkID8gXCJcXG5cIiA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICB2YWx1ZSA9IGlucHV0W2tleV07XG4gICAgICAgICAgd2lsbEJlSW5saW5lZCA9IGlubGluZSAtIDEgPD0gMCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IFV0aWxzLmlzRW1wdHkodmFsdWUpO1xuICAgICAgICAgIG91dHB1dCArPSBwcmVmaXggKyBJbmxpbmUuZHVtcChrZXksIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdEVuY29kZXIpICsgJzonICsgKHdpbGxCZUlubGluZWQgPyAnICcgOiBcIlxcblwiKSArIHRoaXMuZHVtcCh2YWx1ZSwgaW5saW5lIC0gMSwgKHdpbGxCZUlubGluZWQgPyAwIDogaW5kZW50ICsgdGhpcy5pbmRlbnRhdGlvbiksIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdEVuY29kZXIpICsgKHdpbGxCZUlubGluZWQgPyBcIlxcblwiIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIER1bXBlcjtcblxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEdW1wZXI7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTAuMFxudmFyIEVzY2FwZXIsIFBhdHRlcm47XG5cblBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcblxuRXNjYXBlciA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGNoO1xuXG4gIGZ1bmN0aW9uIEVzY2FwZXIoKSB7fVxuXG4gIEVzY2FwZXIuTElTVF9FU0NBUEVFUyA9IFsnXFxcXCcsICdcXFxcXFxcXCcsICdcXFxcXCInLCAnXCInLCBcIlxceDAwXCIsIFwiXFx4MDFcIiwgXCJcXHgwMlwiLCBcIlxceDAzXCIsIFwiXFx4MDRcIiwgXCJcXHgwNVwiLCBcIlxceDA2XCIsIFwiXFx4MDdcIiwgXCJcXHgwOFwiLCBcIlxceDA5XCIsIFwiXFx4MGFcIiwgXCJcXHgwYlwiLCBcIlxceDBjXCIsIFwiXFx4MGRcIiwgXCJcXHgwZVwiLCBcIlxceDBmXCIsIFwiXFx4MTBcIiwgXCJcXHgxMVwiLCBcIlxceDEyXCIsIFwiXFx4MTNcIiwgXCJcXHgxNFwiLCBcIlxceDE1XCIsIFwiXFx4MTZcIiwgXCJcXHgxN1wiLCBcIlxceDE4XCIsIFwiXFx4MTlcIiwgXCJcXHgxYVwiLCBcIlxceDFiXCIsIFwiXFx4MWNcIiwgXCJcXHgxZFwiLCBcIlxceDFlXCIsIFwiXFx4MWZcIiwgKGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZSkoMHgwMDg1KSwgY2goMHgwMEEwKSwgY2goMHgyMDI4KSwgY2goMHgyMDI5KV07XG5cbiAgRXNjYXBlci5MSVNUX0VTQ0FQRUQgPSBbJ1xcXFxcXFxcJywgJ1xcXFxcIicsICdcXFxcXCInLCAnXFxcXFwiJywgXCJcXFxcMFwiLCBcIlxcXFx4MDFcIiwgXCJcXFxceDAyXCIsIFwiXFxcXHgwM1wiLCBcIlxcXFx4MDRcIiwgXCJcXFxceDA1XCIsIFwiXFxcXHgwNlwiLCBcIlxcXFxhXCIsIFwiXFxcXGJcIiwgXCJcXFxcdFwiLCBcIlxcXFxuXCIsIFwiXFxcXHZcIiwgXCJcXFxcZlwiLCBcIlxcXFxyXCIsIFwiXFxcXHgwZVwiLCBcIlxcXFx4MGZcIiwgXCJcXFxceDEwXCIsIFwiXFxcXHgxMVwiLCBcIlxcXFx4MTJcIiwgXCJcXFxceDEzXCIsIFwiXFxcXHgxNFwiLCBcIlxcXFx4MTVcIiwgXCJcXFxceDE2XCIsIFwiXFxcXHgxN1wiLCBcIlxcXFx4MThcIiwgXCJcXFxceDE5XCIsIFwiXFxcXHgxYVwiLCBcIlxcXFxlXCIsIFwiXFxcXHgxY1wiLCBcIlxcXFx4MWRcIiwgXCJcXFxceDFlXCIsIFwiXFxcXHgxZlwiLCBcIlxcXFxOXCIsIFwiXFxcXF9cIiwgXCJcXFxcTFwiLCBcIlxcXFxQXCJdO1xuXG4gIEVzY2FwZXIuTUFQUElOR19FU0NBUEVFU19UT19FU0NBUEVEID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCBqLCBtYXBwaW5nLCByZWY7XG4gICAgbWFwcGluZyA9IHt9O1xuICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBFc2NhcGVyLkxJU1RfRVNDQVBFRVMubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgIG1hcHBpbmdbRXNjYXBlci5MSVNUX0VTQ0FQRUVTW2ldXSA9IEVzY2FwZXIuTElTVF9FU0NBUEVEW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGluZztcbiAgfSkoKTtcblxuICBFc2NhcGVyLlBBVFRFUk5fQ0hBUkFDVEVSU19UT19FU0NBUEUgPSBuZXcgUGF0dGVybignW1xcXFx4MDAtXFxcXHgxZl18XFx4YzJcXHg4NXxcXHhjMlxceGEwfFxceGUyXFx4ODBcXHhhOHxcXHhlMlxceDgwXFx4YTknKTtcblxuICBFc2NhcGVyLlBBVFRFUk5fTUFQUElOR19FU0NBUEVFUyA9IG5ldyBQYXR0ZXJuKEVzY2FwZXIuTElTVF9FU0NBUEVFUy5qb2luKCd8Jykuc3BsaXQoJ1xcXFwnKS5qb2luKCdcXFxcXFxcXCcpKTtcblxuICBFc2NhcGVyLlBBVFRFUk5fU0lOR0xFX1FVT1RJTkcgPSBuZXcgUGF0dGVybignW1xcXFxzXFwnXCI6e31bXFxcXF0sJiojP118XlstP3w8Pj0hJUBgXScpO1xuXG4gIEVzY2FwZXIucmVxdWlyZXNEb3VibGVRdW90aW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5QQVRURVJOX0NIQVJBQ1RFUlNfVE9fRVNDQVBFLnRlc3QodmFsdWUpO1xuICB9O1xuXG4gIEVzY2FwZXIuZXNjYXBlV2l0aERvdWJsZVF1b3RlcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXN1bHQgPSB0aGlzLlBBVFRFUk5fTUFQUElOR19FU0NBUEVFUy5yZXBsYWNlKHZhbHVlLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLk1BUFBJTkdfRVNDQVBFRVNfVE9fRVNDQVBFRFtzdHJdO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gICAgcmV0dXJuICdcIicgKyByZXN1bHQgKyAnXCInO1xuICB9O1xuXG4gIEVzY2FwZXIucmVxdWlyZXNTaW5nbGVRdW90aW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5QQVRURVJOX1NJTkdMRV9RVU9USU5HLnRlc3QodmFsdWUpO1xuICB9O1xuXG4gIEVzY2FwZXIuZXNjYXBlV2l0aFNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFwiJ1wiICsgdmFsdWUucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG4gIH07XG5cbiAgcmV0dXJuIEVzY2FwZXI7XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXNjYXBlcjtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMC4wXG52YXIgRHVtcEV4Y2VwdGlvbixcbiAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbkR1bXBFeGNlcHRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoRHVtcEV4Y2VwdGlvbiwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gRHVtcEV4Y2VwdGlvbihtZXNzYWdlLCBwYXJzZWRMaW5lLCBzbmlwcGV0KSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnBhcnNlZExpbmUgPSBwYXJzZWRMaW5lO1xuICAgIHRoaXMuc25pcHBldCA9IHNuaXBwZXQ7XG4gIH1cblxuICBEdW1wRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgodGhpcy5wYXJzZWRMaW5lICE9IG51bGwpICYmICh0aGlzLnNuaXBwZXQgIT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiAnPER1bXBFeGNlcHRpb24+ICcgKyB0aGlzLm1lc3NhZ2UgKyAnIChsaW5lICcgKyB0aGlzLnBhcnNlZExpbmUgKyAnOiBcXCcnICsgdGhpcy5zbmlwcGV0ICsgJ1xcJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJzxEdW1wRXhjZXB0aW9uPiAnICsgdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRHVtcEV4Y2VwdGlvbjtcblxufSkoRXJyb3IpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1bXBFeGNlcHRpb247XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTAuMFxudmFyIFBhcnNlRXhjZXB0aW9uLFxuICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuUGFyc2VFeGNlcHRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoUGFyc2VFeGNlcHRpb24sIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIFBhcnNlRXhjZXB0aW9uKG1lc3NhZ2UsIHBhcnNlZExpbmUsIHNuaXBwZXQpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMucGFyc2VkTGluZSA9IHBhcnNlZExpbmU7XG4gICAgdGhpcy5zbmlwcGV0ID0gc25pcHBldDtcbiAgfVxuXG4gIFBhcnNlRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgodGhpcy5wYXJzZWRMaW5lICE9IG51bGwpICYmICh0aGlzLnNuaXBwZXQgIT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiAnPFBhcnNlRXhjZXB0aW9uPiAnICsgdGhpcy5tZXNzYWdlICsgJyAobGluZSAnICsgdGhpcy5wYXJzZWRMaW5lICsgJzogXFwnJyArIHRoaXMuc25pcHBldCArICdcXCcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICc8UGFyc2VFeGNlcHRpb24+ICcgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQYXJzZUV4Y2VwdGlvbjtcblxufSkoRXJyb3IpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlRXhjZXB0aW9uO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEwLjBcbnZhciBEdW1wRXhjZXB0aW9uLCBFc2NhcGVyLCBJbmxpbmUsIFBhcnNlRXhjZXB0aW9uLCBQYXR0ZXJuLCBVbmVzY2FwZXIsIFV0aWxzLFxuICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cblBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcblxuVW5lc2NhcGVyID0gcmVxdWlyZSgnLi9VbmVzY2FwZXInKTtcblxuRXNjYXBlciA9IHJlcXVpcmUoJy4vRXNjYXBlcicpO1xuXG5VdGlscyA9IHJlcXVpcmUoJy4vVXRpbHMnKTtcblxuUGFyc2VFeGNlcHRpb24gPSByZXF1aXJlKCcuL0V4Y2VwdGlvbi9QYXJzZUV4Y2VwdGlvbicpO1xuXG5EdW1wRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9FeGNlcHRpb24vRHVtcEV4Y2VwdGlvbicpO1xuXG5JbmxpbmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIElubGluZSgpIHt9XG5cbiAgSW5saW5lLlJFR0VYX1FVT1RFRF9TVFJJTkcgPSAnKD86XCIoPzpbXlwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXCJcXFxcXFxcXF0qKSopXCJ8XFwnKD86W15cXCddKig/OlxcJ1xcJ1teXFwnXSopKilcXCcpJztcblxuICBJbmxpbmUuUEFUVEVSTl9UUkFJTElOR19DT01NRU5UUyA9IG5ldyBQYXR0ZXJuKCdeXFxcXHMqIy4qJCcpO1xuXG4gIElubGluZS5QQVRURVJOX1FVT1RFRF9TQ0FMQVIgPSBuZXcgUGF0dGVybignXicgKyBJbmxpbmUuUkVHRVhfUVVPVEVEX1NUUklORyk7XG5cbiAgSW5saW5lLlBBVFRFUk5fVEhPVVNBTkRfTlVNRVJJQ19TQ0FMQVIgPSBuZXcgUGF0dGVybignXigtfFxcXFwrKT9bMC05LF0rKFxcXFwuWzAtOV0rKT8kJyk7XG5cbiAgSW5saW5lLlBBVFRFUk5fU0NBTEFSX0JZX0RFTElNSVRFUlMgPSB7fTtcblxuICBJbmxpbmUuc2V0dGluZ3MgPSB7fTtcblxuICBJbmxpbmUuY29uZmlndXJlID0gZnVuY3Rpb24oZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcikge1xuICAgIGlmIChleGNlcHRpb25PbkludmFsaWRUeXBlID09IG51bGwpIHtcbiAgICAgIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAob2JqZWN0RGVjb2RlciA9PSBudWxsKSB7XG4gICAgICBvYmplY3REZWNvZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZXR0aW5ncy5leGNlcHRpb25PbkludmFsaWRUeXBlID0gZXhjZXB0aW9uT25JbnZhbGlkVHlwZTtcbiAgICB0aGlzLnNldHRpbmdzLm9iamVjdERlY29kZXIgPSBvYmplY3REZWNvZGVyO1xuICB9O1xuXG4gIElubGluZS5wYXJzZSA9IGZ1bmN0aW9uKHZhbHVlLCBleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3REZWNvZGVyKSB7XG4gICAgdmFyIGNvbnRleHQsIHJlc3VsdDtcbiAgICBpZiAoZXhjZXB0aW9uT25JbnZhbGlkVHlwZSA9PSBudWxsKSB7XG4gICAgICBleGNlcHRpb25PbkludmFsaWRUeXBlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmplY3REZWNvZGVyID09IG51bGwpIHtcbiAgICAgIG9iamVjdERlY29kZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNldHRpbmdzLmV4Y2VwdGlvbk9uSW52YWxpZFR5cGUgPSBleGNlcHRpb25PbkludmFsaWRUeXBlO1xuICAgIHRoaXMuc2V0dGluZ3Mub2JqZWN0RGVjb2RlciA9IG9iamVjdERlY29kZXI7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFsdWUgPSBVdGlscy50cmltKHZhbHVlKTtcbiAgICBpZiAoMCA9PT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBleGNlcHRpb25PbkludmFsaWRUeXBlOiBleGNlcHRpb25PbkludmFsaWRUeXBlLFxuICAgICAgb2JqZWN0RGVjb2Rlcjogb2JqZWN0RGVjb2RlcixcbiAgICAgIGk6IDBcbiAgICB9O1xuICAgIHN3aXRjaCAodmFsdWUuY2hhckF0KDApKSB7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVNlcXVlbmNlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgKytjb250ZXh0Lmk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneyc6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VNYXBwaW5nKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgKytjb250ZXh0Lmk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVNjYWxhcih2YWx1ZSwgbnVsbCwgWydcIicsIFwiJ1wiXSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICh0aGlzLlBBVFRFUk5fVFJBSUxJTkdfQ09NTUVOVFMucmVwbGFjZSh2YWx1ZS5zbGljZShjb250ZXh0LmkpLCAnJykgIT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ1VuZXhwZWN0ZWQgY2hhcmFjdGVycyBuZWFyIFwiJyArIHZhbHVlLnNsaWNlKGNvbnRleHQuaSkgKyAnXCIuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgSW5saW5lLmR1bXAgPSBmdW5jdGlvbih2YWx1ZSwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RW5jb2Rlcikge1xuICAgIHZhciByZWYsIHJlc3VsdCwgdHlwZTtcbiAgICBpZiAoZXhjZXB0aW9uT25JbnZhbGlkVHlwZSA9PSBudWxsKSB7XG4gICAgICBleGNlcHRpb25PbkludmFsaWRUeXBlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmplY3RFbmNvZGVyID09IG51bGwpIHtcbiAgICAgIG9iamVjdEVuY29kZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdEVuY29kZXIgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgPSBvYmplY3RFbmNvZGVyKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnIHx8IChyZXN1bHQgIT0gbnVsbCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kdW1wT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuICh2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH1cbiAgICBpZiAoVXRpbHMuaXNEaWdpdHModmFsdWUpKSB7XG4gICAgICByZXR1cm4gKHR5cGUgPT09ICdzdHJpbmcnID8gXCInXCIgKyB2YWx1ZSArIFwiJ1wiIDogU3RyaW5nKHBhcnNlSW50KHZhbHVlKSkpO1xuICAgIH1cbiAgICBpZiAoVXRpbHMuaXNOdW1lcmljKHZhbHVlKSkge1xuICAgICAgcmV0dXJuICh0eXBlID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsdWUgKyBcIidcIiA6IFN0cmluZyhwYXJzZUZsb2F0KHZhbHVlKSkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT09IEluZmluaXR5ID8gJy5JbmYnIDogKHZhbHVlID09PSAtSW5maW5pdHkgPyAnLS5JbmYnIDogKGlzTmFOKHZhbHVlKSA/ICcuTmFOJyA6IHZhbHVlKSkpO1xuICAgIH1cbiAgICBpZiAoRXNjYXBlci5yZXF1aXJlc0RvdWJsZVF1b3RpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gRXNjYXBlci5lc2NhcGVXaXRoRG91YmxlUXVvdGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEVzY2FwZXIucmVxdWlyZXNTaW5nbGVRdW90aW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIEVzY2FwZXIuZXNjYXBlV2l0aFNpbmdsZVF1b3Rlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICgnJyA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiAnXCJcIic7XG4gICAgfVxuICAgIGlmIChVdGlscy5QQVRURVJOX0RBVEUudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHZhbHVlICsgXCInXCI7XG4gICAgfVxuICAgIGlmICgocmVmID0gdmFsdWUudG9Mb3dlckNhc2UoKSkgPT09ICdudWxsJyB8fCByZWYgPT09ICd+JyB8fCByZWYgPT09ICd0cnVlJyB8fCByZWYgPT09ICdmYWxzZScpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHZhbHVlICsgXCInXCI7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBJbmxpbmUuZHVtcE9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlLCBleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3RTdXBwb3J0KSB7XG4gICAgdmFyIGosIGtleSwgbGVuMSwgb3V0cHV0LCB2YWw7XG4gICAgaWYgKG9iamVjdFN1cHBvcnQgPT0gbnVsbCkge1xuICAgICAgb2JqZWN0U3VwcG9ydCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBvdXRwdXQgPSBbXTtcbiAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSB2YWx1ZS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgdmFsID0gdmFsdWVbal07XG4gICAgICAgIG91dHB1dC5wdXNoKHRoaXMuZHVtcCh2YWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnWycgKyBvdXRwdXQuam9pbignLCAnKSArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gW107XG4gICAgICBmb3IgKGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YWwgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvdXRwdXQucHVzaCh0aGlzLmR1bXAoa2V5KSArICc6ICcgKyB0aGlzLmR1bXAodmFsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3snICsgb3V0cHV0LmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9O1xuXG4gIElubGluZS5wYXJzZVNjYWxhciA9IGZ1bmN0aW9uKHNjYWxhciwgZGVsaW1pdGVycywgc3RyaW5nRGVsaW1pdGVycywgY29udGV4dCwgZXZhbHVhdGUpIHtcbiAgICB2YXIgaSwgam9pbmVkRGVsaW1pdGVycywgbWF0Y2gsIG91dHB1dCwgcGF0dGVybiwgcmVmLCByZWYxLCBzdHJwb3MsIHRtcDtcbiAgICBpZiAoZGVsaW1pdGVycyA9PSBudWxsKSB7XG4gICAgICBkZWxpbWl0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0cmluZ0RlbGltaXRlcnMgPT0gbnVsbCkge1xuICAgICAgc3RyaW5nRGVsaW1pdGVycyA9IFsnXCInLCBcIidcIl07XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGUgPT0gbnVsbCkge1xuICAgICAgZXZhbHVhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICBjb250ZXh0ID0ge1xuICAgICAgICBleGNlcHRpb25PbkludmFsaWRUeXBlOiB0aGlzLnNldHRpbmdzLmV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsXG4gICAgICAgIG9iamVjdERlY29kZXI6IHRoaXMuc2V0dGluZ3Mub2JqZWN0RGVjb2RlcixcbiAgICAgICAgaTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgaSA9IGNvbnRleHQuaTtcbiAgICBpZiAocmVmID0gc2NhbGFyLmNoYXJBdChpKSwgaW5kZXhPZi5jYWxsKHN0cmluZ0RlbGltaXRlcnMsIHJlZikgPj0gMCkge1xuICAgICAgb3V0cHV0ID0gdGhpcy5wYXJzZVF1b3RlZFNjYWxhcihzY2FsYXIsIGNvbnRleHQpO1xuICAgICAgaSA9IGNvbnRleHQuaTtcbiAgICAgIGlmIChkZWxpbWl0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgdG1wID0gVXRpbHMubHRyaW0oc2NhbGFyLnNsaWNlKGkpLCAnICcpO1xuICAgICAgICBpZiAoIShyZWYxID0gdG1wLmNoYXJBdCgwKSwgaW5kZXhPZi5jYWxsKGRlbGltaXRlcnMsIHJlZjEpID49IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKCdVbmV4cGVjdGVkIGNoYXJhY3RlcnMgKCcgKyBzY2FsYXIuc2xpY2UoaSkgKyAnKS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWRlbGltaXRlcnMpIHtcbiAgICAgICAgb3V0cHV0ID0gc2NhbGFyLnNsaWNlKGkpO1xuICAgICAgICBpICs9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgIHN0cnBvcyA9IG91dHB1dC5pbmRleE9mKCcgIycpO1xuICAgICAgICBpZiAoc3RycG9zICE9PSAtMSkge1xuICAgICAgICAgIG91dHB1dCA9IFV0aWxzLnJ0cmltKG91dHB1dC5zbGljZSgwLCBzdHJwb3MpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pbmVkRGVsaW1pdGVycyA9IGRlbGltaXRlcnMuam9pbignfCcpO1xuICAgICAgICBwYXR0ZXJuID0gdGhpcy5QQVRURVJOX1NDQUxBUl9CWV9ERUxJTUlURVJTW2pvaW5lZERlbGltaXRlcnNdO1xuICAgICAgICBpZiAocGF0dGVybiA9PSBudWxsKSB7XG4gICAgICAgICAgcGF0dGVybiA9IG5ldyBQYXR0ZXJuKCdeKC4rPykoJyArIGpvaW5lZERlbGltaXRlcnMgKyAnKScpO1xuICAgICAgICAgIHRoaXMuUEFUVEVSTl9TQ0FMQVJfQllfREVMSU1JVEVSU1tqb2luZWREZWxpbWl0ZXJzXSA9IHBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gcGF0dGVybi5leGVjKHNjYWxhci5zbGljZShpKSkpIHtcbiAgICAgICAgICBvdXRwdXQgPSBtYXRjaFsxXTtcbiAgICAgICAgICBpICs9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKCdNYWxmb3JtZWQgaW5saW5lIFlBTUwgc3RyaW5nICgnICsgc2NhbGFyICsgJykuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBvdXRwdXQgPSB0aGlzLmV2YWx1YXRlU2NhbGFyKG91dHB1dCwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQuaSA9IGk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICBJbmxpbmUucGFyc2VRdW90ZWRTY2FsYXIgPSBmdW5jdGlvbihzY2FsYXIsIGNvbnRleHQpIHtcbiAgICB2YXIgaSwgbWF0Y2gsIG91dHB1dDtcbiAgICBpID0gY29udGV4dC5pO1xuICAgIGlmICghKG1hdGNoID0gdGhpcy5QQVRURVJOX1FVT1RFRF9TQ0FMQVIuZXhlYyhzY2FsYXIuc2xpY2UoaSkpKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKCdNYWxmb3JtZWQgaW5saW5lIFlBTUwgc3RyaW5nICgnICsgc2NhbGFyLnNsaWNlKGkpICsgJykuJyk7XG4gICAgfVxuICAgIG91dHB1dCA9IG1hdGNoWzBdLnN1YnN0cigxLCBtYXRjaFswXS5sZW5ndGggLSAyKTtcbiAgICBpZiAoJ1wiJyA9PT0gc2NhbGFyLmNoYXJBdChpKSkge1xuICAgICAgb3V0cHV0ID0gVW5lc2NhcGVyLnVuZXNjYXBlRG91YmxlUXVvdGVkU3RyaW5nKG91dHB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IFVuZXNjYXBlci51bmVzY2FwZVNpbmdsZVF1b3RlZFN0cmluZyhvdXRwdXQpO1xuICAgIH1cbiAgICBpICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICBjb250ZXh0LmkgPSBpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgSW5saW5lLnBhcnNlU2VxdWVuY2UgPSBmdW5jdGlvbihzZXF1ZW5jZSwgY29udGV4dCkge1xuICAgIHZhciBlLCBlcnJvciwgaSwgaXNRdW90ZWQsIGxlbiwgb3V0cHV0LCByZWYsIHZhbHVlO1xuICAgIG91dHB1dCA9IFtdO1xuICAgIGxlbiA9IHNlcXVlbmNlLmxlbmd0aDtcbiAgICBpID0gY29udGV4dC5pO1xuICAgIGkgKz0gMTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29udGV4dC5pID0gaTtcbiAgICAgIHN3aXRjaCAoc2VxdWVuY2UuY2hhckF0KGkpKSB7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgIG91dHB1dC5wdXNoKHRoaXMucGFyc2VTZXF1ZW5jZShzZXF1ZW5jZSwgY29udGV4dCkpO1xuICAgICAgICAgIGkgPSBjb250ZXh0Lmk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIG91dHB1dC5wdXNoKHRoaXMucGFyc2VNYXBwaW5nKHNlcXVlbmNlLCBjb250ZXh0KSk7XG4gICAgICAgICAgaSA9IGNvbnRleHQuaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaXNRdW90ZWQgPSAoKHJlZiA9IHNlcXVlbmNlLmNoYXJBdChpKSkgPT09ICdcIicgfHwgcmVmID09PSBcIidcIik7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlU2NhbGFyKHNlcXVlbmNlLCBbJywnLCAnXSddLCBbJ1wiJywgXCInXCJdLCBjb250ZXh0KTtcbiAgICAgICAgICBpID0gY29udGV4dC5pO1xuICAgICAgICAgIGlmICghaXNRdW90ZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAodmFsdWUuaW5kZXhPZignOiAnKSAhPT0gLTEgfHwgdmFsdWUuaW5kZXhPZihcIjpcXG5cIikgIT09IC0xKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlTWFwcGluZygneycgKyB2YWx1ZSArICd9Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBlID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAtLWk7XG4gICAgICB9XG4gICAgICArK2k7XG4gICAgfVxuICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignTWFsZm9ybWVkIGlubGluZSBZQU1MIHN0cmluZyAnICsgc2VxdWVuY2UpO1xuICB9O1xuXG4gIElubGluZS5wYXJzZU1hcHBpbmcgPSBmdW5jdGlvbihtYXBwaW5nLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbmUsIGksIGtleSwgbGVuLCBvdXRwdXQsIHNob3VsZENvbnRpbnVlV2hpbGVMb29wLCB2YWx1ZTtcbiAgICBvdXRwdXQgPSB7fTtcbiAgICBsZW4gPSBtYXBwaW5nLmxlbmd0aDtcbiAgICBpID0gY29udGV4dC5pO1xuICAgIGkgKz0gMTtcbiAgICBzaG91bGRDb250aW51ZVdoaWxlTG9vcCA9IGZhbHNlO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb250ZXh0LmkgPSBpO1xuICAgICAgc3dpdGNoIChtYXBwaW5nLmNoYXJBdChpKSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgY29udGV4dC5pID0gaTtcbiAgICAgICAgICBzaG91bGRDb250aW51ZVdoaWxlTG9vcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQ29udGludWVXaGlsZUxvb3ApIHtcbiAgICAgICAgc2hvdWxkQ29udGludWVXaGlsZUxvb3AgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBrZXkgPSB0aGlzLnBhcnNlU2NhbGFyKG1hcHBpbmcsIFsnOicsICcgJywgXCJcXG5cIl0sIFsnXCInLCBcIidcIl0sIGNvbnRleHQsIGZhbHNlKTtcbiAgICAgIGkgPSBjb250ZXh0Lmk7XG4gICAgICBkb25lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjb250ZXh0LmkgPSBpO1xuICAgICAgICBzd2l0Y2ggKG1hcHBpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXF1ZW5jZShtYXBwaW5nLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGkgPSBjb250ZXh0Lmk7XG4gICAgICAgICAgICBpZiAob3V0cHV0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZU1hcHBpbmcobWFwcGluZywgY29udGV4dCk7XG4gICAgICAgICAgICBpID0gY29udGV4dC5pO1xuICAgICAgICAgICAgaWYgKG91dHB1dFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNjYWxhcihtYXBwaW5nLCBbJywnLCAnfSddLCBbJ1wiJywgXCInXCJdLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGkgPSBjb250ZXh0Lmk7XG4gICAgICAgICAgICBpZiAob3V0cHV0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAtLWk7XG4gICAgICAgIH1cbiAgICAgICAgKytpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignTWFsZm9ybWVkIGlubGluZSBZQU1MIHN0cmluZyAnICsgbWFwcGluZyk7XG4gIH07XG5cbiAgSW5saW5lLmV2YWx1YXRlU2NhbGFyID0gZnVuY3Rpb24oc2NhbGFyLCBjb250ZXh0KSB7XG4gICAgdmFyIGNhc3QsIGRhdGUsIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIGZpcnN0Q2hhciwgZmlyc3RTcGFjZSwgZmlyc3RXb3JkLCBvYmplY3REZWNvZGVyLCByYXcsIHNjYWxhckxvd2VyLCBzdWJWYWx1ZSwgdHJpbW1lZFNjYWxhcjtcbiAgICBzY2FsYXIgPSBVdGlscy50cmltKHNjYWxhcik7XG4gICAgc2NhbGFyTG93ZXIgPSBzY2FsYXIudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHNjYWxhckxvd2VyKSB7XG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgIGNhc2UgJyc6XG4gICAgICBjYXNlICd+JzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdmYWxzZSc6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgJy5pbmYnOlxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICBjYXNlICcubmFuJzpcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIGNhc2UgJy0uaW5mJzpcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmlyc3RDaGFyID0gc2NhbGFyTG93ZXIuY2hhckF0KDApO1xuICAgICAgICBzd2l0Y2ggKGZpcnN0Q2hhcikge1xuICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgZmlyc3RTcGFjZSA9IHNjYWxhci5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgICBpZiAoZmlyc3RTcGFjZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZmlyc3RXb3JkID0gc2NhbGFyTG93ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaXJzdFdvcmQgPSBzY2FsYXJMb3dlci5zbGljZSgwLCBmaXJzdFNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RXb3JkKSB7XG4gICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdFNwYWNlICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMucGFyc2VTY2FsYXIoc2NhbGFyLnNsaWNlKDIpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICBjYXNlICchc3RyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMubHRyaW0oc2NhbGFyLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgY2FzZSAnISFzdHInOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5sdHJpbShzY2FsYXIuc2xpY2UoNSkpO1xuICAgICAgICAgICAgICBjYXNlICchIWludCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMucGFyc2VTY2FsYXIoc2NhbGFyLnNsaWNlKDUpKSk7XG4gICAgICAgICAgICAgIGNhc2UgJyEhYm9vbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnBhcnNlQm9vbGVhbih0aGlzLnBhcnNlU2NhbGFyKHNjYWxhci5zbGljZSg2KSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgY2FzZSAnISFmbG9hdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5wYXJzZVNjYWxhcihzY2FsYXIuc2xpY2UoNykpKTtcbiAgICAgICAgICAgICAgY2FzZSAnISF0aW1lc3RhbXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5zdHJpbmdUb0RhdGUoVXRpbHMubHRyaW0oc2NhbGFyLnNsaWNlKDExKSkpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGU6IHRoaXMuc2V0dGluZ3MuZXhjZXB0aW9uT25JbnZhbGlkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0RGVjb2RlcjogdGhpcy5zZXR0aW5ncy5vYmplY3REZWNvZGVyLFxuICAgICAgICAgICAgICAgICAgICBpOiAwXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3REZWNvZGVyID0gY29udGV4dC5vYmplY3REZWNvZGVyLCBleGNlcHRpb25PbkludmFsaWRUeXBlID0gY29udGV4dC5leGNlcHRpb25PbkludmFsaWRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3REZWNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICB0cmltbWVkU2NhbGFyID0gVXRpbHMucnRyaW0oc2NhbGFyKTtcbiAgICAgICAgICAgICAgICAgIGZpcnN0U3BhY2UgPSB0cmltbWVkU2NhbGFyLmluZGV4T2YoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFNwYWNlID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0RGVjb2Rlcih0cmltbWVkU2NhbGFyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YlZhbHVlID0gVXRpbHMubHRyaW0odHJpbW1lZFNjYWxhci5zbGljZShmaXJzdFNwYWNlICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdWJWYWx1ZS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN1YlZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0RGVjb2Rlcih0cmltbWVkU2NhbGFyLnNsaWNlKDAsIGZpcnN0U3BhY2UpLCBzdWJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb25PbkludmFsaWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ0N1c3RvbSBvYmplY3Qgc3VwcG9ydCB3aGVuIHBhcnNpbmcgYSBZQU1MIGZpbGUgaGFzIGJlZW4gZGlzYWJsZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICBpZiAoJzB4JyA9PT0gc2NhbGFyLnNsaWNlKDAsIDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBVdGlscy5oZXhEZWMoc2NhbGFyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNEaWdpdHMoc2NhbGFyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gVXRpbHMub2N0RGVjKHNjYWxhcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzTnVtZXJpYyhzY2FsYXIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHNjYWxhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNEaWdpdHMoc2NhbGFyKSkge1xuICAgICAgICAgICAgICByYXcgPSBzY2FsYXI7XG4gICAgICAgICAgICAgIGNhc3QgPSBwYXJzZUludChyYXcpO1xuICAgICAgICAgICAgICBpZiAocmF3ID09PSBTdHJpbmcoY2FzdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FzdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzTnVtZXJpYyhzY2FsYXIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHNjYWxhcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuUEFUVEVSTl9USE9VU0FORF9OVU1FUklDX1NDQUxBUi50ZXN0KHNjYWxhcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc2NhbGFyLnJlcGxhY2UoJywnLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhcjtcbiAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIGlmIChVdGlscy5pc0RpZ2l0cyhzY2FsYXIuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgIGlmICgnMCcgPT09IHNjYWxhci5jaGFyQXQoMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLVV0aWxzLm9jdERlYyhzY2FsYXIuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhdyA9IHNjYWxhci5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBjYXN0ID0gcGFyc2VJbnQocmF3KTtcbiAgICAgICAgICAgICAgICBpZiAocmF3ID09PSBTdHJpbmcoY2FzdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtY2FzdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIC1yYXc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzTnVtZXJpYyhzY2FsYXIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHNjYWxhcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuUEFUVEVSTl9USE9VU0FORF9OVU1FUklDX1NDQUxBUi50ZXN0KHNjYWxhcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc2NhbGFyLnJlcGxhY2UoJywnLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhcjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGRhdGUgPSBVdGlscy5zdHJpbmdUb0RhdGUoc2NhbGFyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNOdW1lcmljKHNjYWxhcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc2NhbGFyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5QQVRURVJOX1RIT1VTQU5EX05VTUVSSUNfU0NBTEFSLnRlc3Qoc2NhbGFyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzY2FsYXIucmVwbGFjZSgnLCcsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbmxpbmU7XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5saW5lO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEwLjBcbnZhciBJbmxpbmUsIFBhcnNlRXhjZXB0aW9uLCBQYXJzZXIsIFBhdHRlcm4sIFV0aWxzO1xuXG5JbmxpbmUgPSByZXF1aXJlKCcuL0lubGluZScpO1xuXG5QYXR0ZXJuID0gcmVxdWlyZSgnLi9QYXR0ZXJuJyk7XG5cblV0aWxzID0gcmVxdWlyZSgnLi9VdGlscycpO1xuXG5QYXJzZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vRXhjZXB0aW9uL1BhcnNlRXhjZXB0aW9uJyk7XG5cblBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgUGFyc2VyLnByb3RvdHlwZS5QQVRURVJOX0ZPTERFRF9TQ0FMQVJfQUxMID0gbmV3IFBhdHRlcm4oJ14oPzooPzx0eXBlPiFbXlxcXFx8Pl0qKVxcXFxzKyk/KD88c2VwYXJhdG9yPlxcXFx8fD4pKD88bW9kaWZpZXJzPlxcXFwrfFxcXFwtfFxcXFxkK3xcXFxcK1xcXFxkK3xcXFxcLVxcXFxkK3xcXFxcZCtcXFxcK3xcXFxcZCtcXFxcLSk/KD88Y29tbWVudHM+ICsjLiopPyQnKTtcblxuICBQYXJzZXIucHJvdG90eXBlLlBBVFRFUk5fRk9MREVEX1NDQUxBUl9FTkQgPSBuZXcgUGF0dGVybignKD88c2VwYXJhdG9yPlxcXFx8fD4pKD88bW9kaWZpZXJzPlxcXFwrfFxcXFwtfFxcXFxkK3xcXFxcK1xcXFxkK3xcXFxcLVxcXFxkK3xcXFxcZCtcXFxcK3xcXFxcZCtcXFxcLSk/KD88Y29tbWVudHM+ICsjLiopPyQnKTtcblxuICBQYXJzZXIucHJvdG90eXBlLlBBVFRFUk5fU0VRVUVOQ0VfSVRFTSA9IG5ldyBQYXR0ZXJuKCdeXFxcXC0oKD88bGVhZHNwYWNlcz5cXFxccyspKD88dmFsdWU+Lis/KSk/XFxcXHMqJCcpO1xuXG4gIFBhcnNlci5wcm90b3R5cGUuUEFUVEVSTl9BTkNIT1JfVkFMVUUgPSBuZXcgUGF0dGVybignXiYoPzxyZWY+W14gXSspICooPzx2YWx1ZT4uKiknKTtcblxuICBQYXJzZXIucHJvdG90eXBlLlBBVFRFUk5fQ09NUEFDVF9OT1RBVElPTiA9IG5ldyBQYXR0ZXJuKCdeKD88a2V5PicgKyBJbmxpbmUuUkVHRVhfUVVPVEVEX1NUUklORyArICd8W14gXFwnXCJcXFxce1xcXFxbXS4qPykgKlxcXFw6KFxcXFxzKyg/PHZhbHVlPi4rPykpP1xcXFxzKiQnKTtcblxuICBQYXJzZXIucHJvdG90eXBlLlBBVFRFUk5fTUFQUElOR19JVEVNID0gbmV3IFBhdHRlcm4oJ14oPzxrZXk+JyArIElubGluZS5SRUdFWF9RVU9URURfU1RSSU5HICsgJ3xbXiBcXCdcIlxcXFxbXFxcXHtdLio/KSAqXFxcXDooXFxcXHMrKD88dmFsdWU+Lis/KSk/XFxcXHMqJCcpO1xuXG4gIFBhcnNlci5wcm90b3R5cGUuUEFUVEVSTl9ERUNJTUFMID0gbmV3IFBhdHRlcm4oJ1xcXFxkKycpO1xuXG4gIFBhcnNlci5wcm90b3R5cGUuUEFUVEVSTl9JTkRFTlRfU1BBQ0VTID0gbmV3IFBhdHRlcm4oJ14gKycpO1xuXG4gIFBhcnNlci5wcm90b3R5cGUuUEFUVEVSTl9UUkFJTElOR19MSU5FUyA9IG5ldyBQYXR0ZXJuKCcoXFxuKikkJyk7XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5QQVRURVJOX1lBTUxfSEVBREVSID0gbmV3IFBhdHRlcm4oJ15cXFxcJVlBTUxbOiBdW1xcXFxkXFxcXC5dKy4qXFxuJyk7XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5QQVRURVJOX0xFQURJTkdfQ09NTUVOVFMgPSBuZXcgUGF0dGVybignXihcXFxcIy4qP1xcbikrJyk7XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5QQVRURVJOX0RPQ1VNRU5UX01BUktFUl9TVEFSVCA9IG5ldyBQYXR0ZXJuKCdeXFxcXC1cXFxcLVxcXFwtLio/XFxuJyk7XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5QQVRURVJOX0RPQ1VNRU5UX01BUktFUl9FTkQgPSBuZXcgUGF0dGVybignXlxcXFwuXFxcXC5cXFxcLlxcXFxzKiQnKTtcblxuICBQYXJzZXIucHJvdG90eXBlLlBBVFRFUk5fRk9MREVEX1NDQUxBUl9CWV9JTkRFTlRBVElPTiA9IHt9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuQ09OVEVYVF9OT05FID0gMDtcblxuICBQYXJzZXIucHJvdG90eXBlLkNPTlRFWFRfU0VRVUVOQ0UgPSAxO1xuXG4gIFBhcnNlci5wcm90b3R5cGUuQ09OVEVYVF9NQVBQSU5HID0gMjtcblxuICBmdW5jdGlvbiBQYXJzZXIob2Zmc2V0KSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQgIT0gbnVsbCA/IG9mZnNldCA6IDA7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudExpbmVOYiA9IC0xO1xuICAgIHRoaXMuY3VycmVudExpbmUgPSAnJztcbiAgICB0aGlzLnJlZnMgPSB7fTtcbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih2YWx1ZSwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcikge1xuICAgIHZhciBhbGlhcywgYWxsb3dPdmVyd3JpdGUsIGJsb2NrLCBjLCBjb250ZXh0LCBkYXRhLCBlLCBlcnJvciwgZXJyb3IxLCBlcnJvcjIsIGZpcnN0LCBpLCBpbmRlbnQsIGlzUmVmLCBqLCBrLCBrZXksIGwsIGxhc3RLZXksIGxlbiwgbGVuMSwgbGVuMiwgbGVuMywgbGluZUNvdW50LCBtLCBtYXRjaGVzLCBtZXJnZU5vZGUsIG4sIG5hbWUsIHBhcnNlZCwgcGFyc2VkSXRlbSwgcGFyc2VyLCByZWYsIHJlZjEsIHJlZjIsIHJlZk5hbWUsIHJlZlZhbHVlLCB2YWwsIHZhbHVlcztcbiAgICBpZiAoZXhjZXB0aW9uT25JbnZhbGlkVHlwZSA9PSBudWxsKSB7XG4gICAgICBleGNlcHRpb25PbkludmFsaWRUeXBlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmplY3REZWNvZGVyID09IG51bGwpIHtcbiAgICAgIG9iamVjdERlY29kZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRMaW5lTmIgPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRMaW5lID0gJyc7XG4gICAgdGhpcy5saW5lcyA9IHRoaXMuY2xlYW51cCh2YWx1ZSkuc3BsaXQoXCJcXG5cIik7XG4gICAgZGF0YSA9IG51bGw7XG4gICAgY29udGV4dCA9IHRoaXMuQ09OVEVYVF9OT05FO1xuICAgIGFsbG93T3ZlcndyaXRlID0gZmFsc2U7XG4gICAgd2hpbGUgKHRoaXMubW92ZVRvTmV4dExpbmUoKSkge1xuICAgICAgaWYgKHRoaXMuaXNDdXJyZW50TGluZUVtcHR5KCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoXCJcXHRcIiA9PT0gdGhpcy5jdXJyZW50TGluZVswXSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ0EgWUFNTCBmaWxlIGNhbm5vdCBjb250YWluIHRhYnMgYXMgaW5kZW50YXRpb24uJywgdGhpcy5nZXRSZWFsQ3VycmVudExpbmVOYigpICsgMSwgdGhpcy5jdXJyZW50TGluZSk7XG4gICAgICB9XG4gICAgICBpc1JlZiA9IG1lcmdlTm9kZSA9IGZhbHNlO1xuICAgICAgaWYgKHZhbHVlcyA9IHRoaXMuUEFUVEVSTl9TRVFVRU5DRV9JVEVNLmV4ZWModGhpcy5jdXJyZW50TGluZSkpIHtcbiAgICAgICAgaWYgKHRoaXMuQ09OVEVYVF9NQVBQSU5HID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKCdZb3UgY2Fubm90IGRlZmluZSBhIHNlcXVlbmNlIGl0ZW0gd2hlbiBpbiBhIG1hcHBpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0ID0gdGhpcy5DT05URVhUX1NFUVVFTkNFO1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodmFsdWVzLnZhbHVlICE9IG51bGwpICYmIChtYXRjaGVzID0gdGhpcy5QQVRURVJOX0FOQ0hPUl9WQUxVRS5leGVjKHZhbHVlcy52YWx1ZSkpKSB7XG4gICAgICAgICAgaXNSZWYgPSBtYXRjaGVzLnJlZjtcbiAgICAgICAgICB2YWx1ZXMudmFsdWUgPSBtYXRjaGVzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHZhbHVlcy52YWx1ZSAhPSBudWxsKSB8fCAnJyA9PT0gVXRpbHMudHJpbSh2YWx1ZXMudmFsdWUsICcgJykgfHwgVXRpbHMubHRyaW0odmFsdWVzLnZhbHVlLCAnICcpLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMaW5lTmIgPCB0aGlzLmxpbmVzLmxlbmd0aCAtIDEgJiYgIXRoaXMuaXNOZXh0TGluZVVuSW5kZW50ZWRDb2xsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgIGMgPSB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCkgKyAxO1xuICAgICAgICAgICAgcGFyc2VyID0gbmV3IFBhcnNlcihjKTtcbiAgICAgICAgICAgIHBhcnNlci5yZWZzID0gdGhpcy5yZWZzO1xuICAgICAgICAgICAgZGF0YS5wdXNoKHBhcnNlci5wYXJzZSh0aGlzLmdldE5leHRFbWJlZEJsb2NrKG51bGwsIHRydWUpLCBleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3REZWNvZGVyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCgocmVmID0gdmFsdWVzLmxlYWRzcGFjZXMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSAmJiAobWF0Y2hlcyA9IHRoaXMuUEFUVEVSTl9DT01QQUNUX05PVEFUSU9OLmV4ZWModmFsdWVzLnZhbHVlKSkpIHtcbiAgICAgICAgICAgIGMgPSB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCk7XG4gICAgICAgICAgICBwYXJzZXIgPSBuZXcgUGFyc2VyKGMpO1xuICAgICAgICAgICAgcGFyc2VyLnJlZnMgPSB0aGlzLnJlZnM7XG4gICAgICAgICAgICBibG9jayA9IHZhbHVlcy52YWx1ZTtcbiAgICAgICAgICAgIGluZGVudCA9IHRoaXMuZ2V0Q3VycmVudExpbmVJbmRlbnRhdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0TGluZUluZGVudGVkKGZhbHNlKSkge1xuICAgICAgICAgICAgICBibG9jayArPSBcIlxcblwiICsgdGhpcy5nZXROZXh0RW1iZWRCbG9jayhpbmRlbnQgKyB2YWx1ZXMubGVhZHNwYWNlcy5sZW5ndGggKyAxLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucHVzaChwYXJzZXIucGFyc2UoYmxvY2ssIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMucGFyc2VWYWx1ZSh2YWx1ZXMudmFsdWUsIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKHZhbHVlcyA9IHRoaXMuUEFUVEVSTl9NQVBQSU5HX0lURU0uZXhlYyh0aGlzLmN1cnJlbnRMaW5lKSkgJiYgdmFsdWVzLmtleS5pbmRleE9mKCcgIycpID09PSAtMSkge1xuICAgICAgICBpZiAodGhpcy5DT05URVhUX1NFUVVFTkNFID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKCdZb3UgY2Fubm90IGRlZmluZSBhIG1hcHBpbmcgaXRlbSB3aGVuIGluIGEgc2VxdWVuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0ID0gdGhpcy5DT05URVhUX01BUFBJTkc7XG4gICAgICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lLmNvbmZpZ3VyZShleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3REZWNvZGVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBrZXkgPSBJbmxpbmUucGFyc2VTY2FsYXIodmFsdWVzLmtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZSA9IGVycm9yO1xuICAgICAgICAgIGUucGFyc2VkTGluZSA9IHRoaXMuZ2V0UmVhbEN1cnJlbnRMaW5lTmIoKSArIDE7XG4gICAgICAgICAgZS5zbmlwcGV0ID0gdGhpcy5jdXJyZW50TGluZTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnPDwnID09PSBrZXkpIHtcbiAgICAgICAgICBtZXJnZU5vZGUgPSB0cnVlO1xuICAgICAgICAgIGFsbG93T3ZlcndyaXRlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoKChyZWYxID0gdmFsdWVzLnZhbHVlKSAhPSBudWxsID8gcmVmMS5pbmRleE9mKCcqJykgOiB2b2lkIDApID09PSAwKSB7XG4gICAgICAgICAgICByZWZOYW1lID0gdmFsdWVzLnZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmc1tyZWZOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignUmVmZXJlbmNlIFwiJyArIHJlZk5hbWUgKyAnXCIgZG9lcyBub3QgZXhpc3QuJywgdGhpcy5nZXRSZWFsQ3VycmVudExpbmVOYigpICsgMSwgdGhpcy5jdXJyZW50TGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZWYWx1ZSA9IHRoaXMucmVmc1tyZWZOYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmVmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignWUFNTCBtZXJnZSBrZXlzIHVzZWQgd2l0aCBhIHNjYWxhciB2YWx1ZSBpbnN0ZWFkIG9mIGFuIG9iamVjdC4nLCB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCkgKyAxLCB0aGlzLmN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZWYWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWZWYWx1ZS5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlZlZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW25hbWUgPSBTdHJpbmcoaSldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoa2V5IGluIHJlZlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZWZWYWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgodmFsdWVzLnZhbHVlICE9IG51bGwpICYmIHZhbHVlcy52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0TmV4dEVtYmVkQmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCkgKyAxO1xuICAgICAgICAgICAgcGFyc2VyID0gbmV3IFBhcnNlcihjKTtcbiAgICAgICAgICAgIHBhcnNlci5yZWZzID0gdGhpcy5yZWZzO1xuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VyLnBhcnNlKHZhbHVlLCBleGNlcHRpb25PbkludmFsaWRUeXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ1lBTUwgbWVyZ2Uga2V5cyB1c2VkIHdpdGggYSBzY2FsYXIgdmFsdWUgaW5zdGVhZCBvZiBhbiBvYmplY3QuJywgdGhpcy5nZXRSZWFsQ3VycmVudExpbmVOYigpICsgMSwgdGhpcy5jdXJyZW50TGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VkIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgZm9yIChsID0gMCwgbGVuMSA9IHBhcnNlZC5sZW5ndGg7IGwgPCBsZW4xOyBsKyspIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRJdGVtID0gcGFyc2VkW2xdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkSXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignTWVyZ2UgaXRlbXMgbXVzdCBiZSBvYmplY3RzLicsIHRoaXMuZ2V0UmVhbEN1cnJlbnRMaW5lTmIoKSArIDEsIHBhcnNlZEl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSBtID0gMCwgbGVuMiA9IHBhcnNlZEl0ZW0ubGVuZ3RoOyBtIDwgbGVuMjsgaSA9ICsrbSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlZEl0ZW1baV07XG4gICAgICAgICAgICAgICAgICAgIGsgPSBTdHJpbmcoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFba10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwYXJzZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VkSXRlbVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlZFtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKHZhbHVlcy52YWx1ZSAhPSBudWxsKSAmJiAobWF0Y2hlcyA9IHRoaXMuUEFUVEVSTl9BTkNIT1JfVkFMVUUuZXhlYyh2YWx1ZXMudmFsdWUpKSkge1xuICAgICAgICAgIGlzUmVmID0gbWF0Y2hlcy5yZWY7XG4gICAgICAgICAgdmFsdWVzLnZhbHVlID0gbWF0Y2hlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VOb2RlKSB7XG5cbiAgICAgICAgfSBlbHNlIGlmICghKHZhbHVlcy52YWx1ZSAhPSBudWxsKSB8fCAnJyA9PT0gVXRpbHMudHJpbSh2YWx1ZXMudmFsdWUsICcgJykgfHwgVXRpbHMubHRyaW0odmFsdWVzLnZhbHVlLCAnICcpLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghKHRoaXMuaXNOZXh0TGluZUluZGVudGVkKCkpICYmICEodGhpcy5pc05leHRMaW5lVW5JbmRlbnRlZENvbGxlY3Rpb24oKSkpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd092ZXJ3cml0ZSB8fCBkYXRhW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBkYXRhW2tleV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjID0gdGhpcy5nZXRSZWFsQ3VycmVudExpbmVOYigpICsgMTtcbiAgICAgICAgICAgIHBhcnNlciA9IG5ldyBQYXJzZXIoYyk7XG4gICAgICAgICAgICBwYXJzZXIucmVmcyA9IHRoaXMucmVmcztcbiAgICAgICAgICAgIHZhbCA9IHBhcnNlci5wYXJzZSh0aGlzLmdldE5leHRFbWJlZEJsb2NrKCksIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpO1xuICAgICAgICAgICAgaWYgKGFsbG93T3ZlcndyaXRlIHx8IGRhdGFba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gdGhpcy5wYXJzZVZhbHVlKHZhbHVlcy52YWx1ZSwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcik7XG4gICAgICAgICAgaWYgKGFsbG93T3ZlcndyaXRlIHx8IGRhdGFba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lQ291bnQgPSB0aGlzLmxpbmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKDEgPT09IGxpbmVDb3VudCB8fCAoMiA9PT0gbGluZUNvdW50ICYmIFV0aWxzLmlzRW1wdHkodGhpcy5saW5lc1sxXSkpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gSW5saW5lLnBhcnNlKHRoaXMubGluZXNbMF0sIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgZSA9IGVycm9yMTtcbiAgICAgICAgICAgIGUucGFyc2VkTGluZSA9IHRoaXMuZ2V0UmVhbEN1cnJlbnRMaW5lTmIoKSArIDE7XG4gICAgICAgICAgICBlLnNuaXBwZXQgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIGZpcnN0ID0gdmFsdWVbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgJiYgZmlyc3QuaW5kZXhPZignKicpID09PSAwKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChuID0gMCwgbGVuMyA9IHZhbHVlLmxlbmd0aDsgbiA8IGxlbjM7IG4rKykge1xuICAgICAgICAgICAgICAgIGFsaWFzID0gdmFsdWVbbl07XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMucmVmc1thbGlhcy5zbGljZSgxKV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKChyZWYyID0gVXRpbHMubHRyaW0odmFsdWUpLmNoYXJBdCgwKSkgPT09ICdbJyB8fCByZWYyID09PSAneycpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIElubGluZS5wYXJzZSh2YWx1ZSwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICBlID0gZXJyb3IyO1xuICAgICAgICAgICAgZS5wYXJzZWRMaW5lID0gdGhpcy5nZXRSZWFsQ3VycmVudExpbmVOYigpICsgMTtcbiAgICAgICAgICAgIGUuc25pcHBldCA9IHRoaXMuY3VycmVudExpbmU7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ1VuYWJsZSB0byBwYXJzZS4nLCB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCkgKyAxLCB0aGlzLmN1cnJlbnRMaW5lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZikge1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdGhpcy5yZWZzW2lzUmVmXSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0S2V5ID0gbnVsbDtcbiAgICAgICAgICBmb3IgKGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBsYXN0S2V5ID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlZnNbaXNSZWZdID0gZGF0YVtsYXN0S2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoVXRpbHMuaXNFbXB0eShkYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmdldFJlYWxDdXJyZW50TGluZU5iID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExpbmVOYiArIHRoaXMub2Zmc2V0O1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuZ2V0Q3VycmVudExpbmVJbmRlbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMaW5lLmxlbmd0aCAtIFV0aWxzLmx0cmltKHRoaXMuY3VycmVudExpbmUsICcgJykubGVuZ3RoO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuZ2V0TmV4dEVtYmVkQmxvY2sgPSBmdW5jdGlvbihpbmRlbnRhdGlvbiwgaW5jbHVkZVVuaW5kZW50ZWRDb2xsZWN0aW9uKSB7XG4gICAgdmFyIGRhdGEsIGluZGVudCwgaXNJdFVuaW5kZW50ZWRDb2xsZWN0aW9uLCBuZXdJbmRlbnQsIHJlbW92ZUNvbW1lbnRzLCByZW1vdmVDb21tZW50c1BhdHRlcm4sIHVuaW5kZW50ZWRFbWJlZEJsb2NrO1xuICAgIGlmIChpbmRlbnRhdGlvbiA9PSBudWxsKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlVW5pbmRlbnRlZENvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgaW5jbHVkZVVuaW5kZW50ZWRDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubW92ZVRvTmV4dExpbmUoKTtcbiAgICBpZiAoaW5kZW50YXRpb24gPT0gbnVsbCkge1xuICAgICAgbmV3SW5kZW50ID0gdGhpcy5nZXRDdXJyZW50TGluZUluZGVudGF0aW9uKCk7XG4gICAgICB1bmluZGVudGVkRW1iZWRCbG9jayA9IHRoaXMuaXNTdHJpbmdVbkluZGVudGVkQ29sbGVjdGlvbkl0ZW0odGhpcy5jdXJyZW50TGluZSk7XG4gICAgICBpZiAoISh0aGlzLmlzQ3VycmVudExpbmVFbXB0eSgpKSAmJiAwID09PSBuZXdJbmRlbnQgJiYgIXVuaW5kZW50ZWRFbWJlZEJsb2NrKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignSW5kZW50YXRpb24gcHJvYmxlbS4nLCB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCkgKyAxLCB0aGlzLmN1cnJlbnRMaW5lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3SW5kZW50ID0gaW5kZW50YXRpb247XG4gICAgfVxuICAgIGRhdGEgPSBbdGhpcy5jdXJyZW50TGluZS5zbGljZShuZXdJbmRlbnQpXTtcbiAgICBpZiAoIWluY2x1ZGVVbmluZGVudGVkQ29sbGVjdGlvbikge1xuICAgICAgaXNJdFVuaW5kZW50ZWRDb2xsZWN0aW9uID0gdGhpcy5pc1N0cmluZ1VuSW5kZW50ZWRDb2xsZWN0aW9uSXRlbSh0aGlzLmN1cnJlbnRMaW5lKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbWVudHNQYXR0ZXJuID0gdGhpcy5QQVRURVJOX0ZPTERFRF9TQ0FMQVJfRU5EO1xuICAgIHJlbW92ZUNvbW1lbnRzID0gIXJlbW92ZUNvbW1lbnRzUGF0dGVybi50ZXN0KHRoaXMuY3VycmVudExpbmUpO1xuICAgIHdoaWxlICh0aGlzLm1vdmVUb05leHRMaW5lKCkpIHtcbiAgICAgIGluZGVudCA9IHRoaXMuZ2V0Q3VycmVudExpbmVJbmRlbnRhdGlvbigpO1xuICAgICAgaWYgKGluZGVudCA9PT0gbmV3SW5kZW50KSB7XG4gICAgICAgIHJlbW92ZUNvbW1lbnRzID0gIXJlbW92ZUNvbW1lbnRzUGF0dGVybi50ZXN0KHRoaXMuY3VycmVudExpbmUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzSXRVbmluZGVudGVkQ29sbGVjdGlvbiAmJiAhdGhpcy5pc1N0cmluZ1VuSW5kZW50ZWRDb2xsZWN0aW9uSXRlbSh0aGlzLmN1cnJlbnRMaW5lKSAmJiBpbmRlbnQgPT09IG5ld0luZGVudCkge1xuICAgICAgICB0aGlzLm1vdmVUb1ByZXZpb3VzTGluZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ3VycmVudExpbmVCbGFuaygpKSB7XG4gICAgICAgIGRhdGEucHVzaCh0aGlzLmN1cnJlbnRMaW5lLnNsaWNlKG5ld0luZGVudCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVDb21tZW50cyAmJiB0aGlzLmlzQ3VycmVudExpbmVDb21tZW50KCkpIHtcbiAgICAgICAgaWYgKGluZGVudCA9PT0gbmV3SW5kZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbmRlbnQgPj0gbmV3SW5kZW50KSB7XG4gICAgICAgIGRhdGEucHVzaCh0aGlzLmN1cnJlbnRMaW5lLnNsaWNlKG5ld0luZGVudCkpO1xuICAgICAgfSBlbHNlIGlmIChVdGlscy5sdHJpbSh0aGlzLmN1cnJlbnRMaW5lKS5jaGFyQXQoMCkgPT09ICcjJykge1xuXG4gICAgICB9IGVsc2UgaWYgKDAgPT09IGluZGVudCkge1xuICAgICAgICB0aGlzLm1vdmVUb1ByZXZpb3VzTGluZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignSW5kZW50YXRpb24gcHJvYmxlbS4nLCB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCkgKyAxLCB0aGlzLmN1cnJlbnRMaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuam9pbihcIlxcblwiKTtcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLm1vdmVUb05leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudExpbmVOYiA+PSB0aGlzLmxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50TGluZSA9IHRoaXMubGluZXNbKyt0aGlzLmN1cnJlbnRMaW5lTmJdO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUubW92ZVRvUHJldmlvdXNMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jdXJyZW50TGluZSA9IHRoaXMubGluZXNbLS10aGlzLmN1cnJlbnRMaW5lTmJdO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCBleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3REZWNvZGVyKSB7XG4gICAgdmFyIGUsIGVycm9yLCBlcnJvcjEsIGZvbGRlZEluZGVudCwgbWF0Y2hlcywgbW9kaWZpZXJzLCBwb3MsIHJlZiwgcmVmMSwgdmFsO1xuICAgIGlmICgwID09PSB2YWx1ZS5pbmRleE9mKCcqJykpIHtcbiAgICAgIHBvcyA9IHZhbHVlLmluZGV4T2YoJyMnKTtcbiAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDEsIHBvcyAtIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlZnNbdmFsdWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXhjZXB0aW9uKCdSZWZlcmVuY2UgXCInICsgdmFsdWUgKyAnXCIgZG9lcyBub3QgZXhpc3QuJywgdGhpcy5jdXJyZW50TGluZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZWZzW3ZhbHVlXTtcbiAgICB9XG4gICAgaWYgKG1hdGNoZXMgPSB0aGlzLlBBVFRFUk5fRk9MREVEX1NDQUxBUl9BTEwuZXhlYyh2YWx1ZSkpIHtcbiAgICAgIG1vZGlmaWVycyA9IChyZWYgPSBtYXRjaGVzLm1vZGlmaWVycykgIT0gbnVsbCA/IHJlZiA6ICcnO1xuICAgICAgZm9sZGVkSW5kZW50ID0gTWF0aC5hYnMocGFyc2VJbnQobW9kaWZpZXJzKSk7XG4gICAgICBpZiAoaXNOYU4oZm9sZGVkSW5kZW50KSkge1xuICAgICAgICBmb2xkZWRJbmRlbnQgPSAwO1xuICAgICAgfVxuICAgICAgdmFsID0gdGhpcy5wYXJzZUZvbGRlZFNjYWxhcihtYXRjaGVzLnNlcGFyYXRvciwgdGhpcy5QQVRURVJOX0RFQ0lNQUwucmVwbGFjZShtb2RpZmllcnMsICcnKSwgZm9sZGVkSW5kZW50KTtcbiAgICAgIGlmIChtYXRjaGVzLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICBJbmxpbmUuY29uZmlndXJlKGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpO1xuICAgICAgICByZXR1cm4gSW5saW5lLnBhcnNlU2NhbGFyKG1hdGNoZXMudHlwZSArICcgJyArIHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIElubGluZS5wYXJzZSh2YWx1ZSwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGUgPSBlcnJvcjtcbiAgICAgIGlmICgoKHJlZjEgPSB2YWx1ZS5jaGFyQXQoMCkpID09PSAnWycgfHwgcmVmMSA9PT0gJ3snKSAmJiBlIGluc3RhbmNlb2YgUGFyc2VFeGNlcHRpb24gJiYgdGhpcy5pc05leHRMaW5lSW5kZW50ZWQoKSkge1xuICAgICAgICB2YWx1ZSArPSBcIlxcblwiICsgdGhpcy5nZXROZXh0RW1iZWRCbG9jaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBJbmxpbmUucGFyc2UodmFsdWUsIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICBlID0gZXJyb3IxO1xuICAgICAgICAgIGUucGFyc2VkTGluZSA9IHRoaXMuZ2V0UmVhbEN1cnJlbnRMaW5lTmIoKSArIDE7XG4gICAgICAgICAgZS5zbmlwcGV0ID0gdGhpcy5jdXJyZW50TGluZTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLnBhcnNlZExpbmUgPSB0aGlzLmdldFJlYWxDdXJyZW50TGluZU5iKCkgKyAxO1xuICAgICAgICBlLnNuaXBwZXQgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9sZGVkU2NhbGFyID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBpbmRpY2F0b3IsIGluZGVudGF0aW9uKSB7XG4gICAgdmFyIGlzQ3VycmVudExpbmVCbGFuaywgaiwgbGVuLCBsaW5lLCBtYXRjaGVzLCBuZXdUZXh0LCBub3RFT0YsIHBhdHRlcm4sIHJlZiwgdGV4dDtcbiAgICBpZiAoaW5kaWNhdG9yID09IG51bGwpIHtcbiAgICAgIGluZGljYXRvciA9ICcnO1xuICAgIH1cbiAgICBpZiAoaW5kZW50YXRpb24gPT0gbnVsbCkge1xuICAgICAgaW5kZW50YXRpb24gPSAwO1xuICAgIH1cbiAgICBub3RFT0YgPSB0aGlzLm1vdmVUb05leHRMaW5lKCk7XG4gICAgaWYgKCFub3RFT0YpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaXNDdXJyZW50TGluZUJsYW5rID0gdGhpcy5pc0N1cnJlbnRMaW5lQmxhbmsoKTtcbiAgICB0ZXh0ID0gJyc7XG4gICAgd2hpbGUgKG5vdEVPRiAmJiBpc0N1cnJlbnRMaW5lQmxhbmspIHtcbiAgICAgIGlmIChub3RFT0YgPSB0aGlzLm1vdmVUb05leHRMaW5lKCkpIHtcbiAgICAgICAgdGV4dCArPSBcIlxcblwiO1xuICAgICAgICBpc0N1cnJlbnRMaW5lQmxhbmsgPSB0aGlzLmlzQ3VycmVudExpbmVCbGFuaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoMCA9PT0gaW5kZW50YXRpb24pIHtcbiAgICAgIGlmIChtYXRjaGVzID0gdGhpcy5QQVRURVJOX0lOREVOVF9TUEFDRVMuZXhlYyh0aGlzLmN1cnJlbnRMaW5lKSkge1xuICAgICAgICBpbmRlbnRhdGlvbiA9IG1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZW50YXRpb24gPiAwKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5QQVRURVJOX0ZPTERFRF9TQ0FMQVJfQllfSU5ERU5UQVRJT05baW5kZW50YXRpb25dO1xuICAgICAgaWYgKHBhdHRlcm4gPT0gbnVsbCkge1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oJ14geycgKyBpbmRlbnRhdGlvbiArICd9KC4qKSQnKTtcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5QQVRURVJOX0ZPTERFRF9TQ0FMQVJfQllfSU5ERU5UQVRJT05baW5kZW50YXRpb25dID0gcGF0dGVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub3RFT0YgJiYgKGlzQ3VycmVudExpbmVCbGFuayB8fCAobWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyh0aGlzLmN1cnJlbnRMaW5lKSkpKSB7XG4gICAgICAgIGlmIChpc0N1cnJlbnRMaW5lQmxhbmspIHtcbiAgICAgICAgICB0ZXh0ICs9IHRoaXMuY3VycmVudExpbmUuc2xpY2UoaW5kZW50YXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgKz0gbWF0Y2hlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90RU9GID0gdGhpcy5tb3ZlVG9OZXh0TGluZSgpKSB7XG4gICAgICAgICAgdGV4dCArPSBcIlxcblwiO1xuICAgICAgICAgIGlzQ3VycmVudExpbmVCbGFuayA9IHRoaXMuaXNDdXJyZW50TGluZUJsYW5rKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vdEVPRikge1xuICAgICAgdGV4dCArPSBcIlxcblwiO1xuICAgIH1cbiAgICBpZiAobm90RU9GKSB7XG4gICAgICB0aGlzLm1vdmVUb1ByZXZpb3VzTGluZSgpO1xuICAgIH1cbiAgICBpZiAoJz4nID09PSBzZXBhcmF0b3IpIHtcbiAgICAgIG5ld1RleHQgPSAnJztcbiAgICAgIHJlZiA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgbGluZSA9IHJlZltqXTtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICBuZXdUZXh0ID0gVXRpbHMucnRyaW0obmV3VGV4dCwgJyAnKSArIGxpbmUgKyBcIlxcblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1RleHQgKz0gbGluZSArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dCA9IG5ld1RleHQ7XG4gICAgfVxuICAgIGlmICgnKycgIT09IGluZGljYXRvcikge1xuICAgICAgdGV4dCA9IFV0aWxzLnJ0cmltKHRleHQpO1xuICAgIH1cbiAgICBpZiAoJycgPT09IGluZGljYXRvcikge1xuICAgICAgdGV4dCA9IHRoaXMuUEFUVEVSTl9UUkFJTElOR19MSU5FUy5yZXBsYWNlKHRleHQsIFwiXFxuXCIpO1xuICAgIH0gZWxzZSBpZiAoJy0nID09PSBpbmRpY2F0b3IpIHtcbiAgICAgIHRleHQgPSB0aGlzLlBBVFRFUk5fVFJBSUxJTkdfTElORVMucmVwbGFjZSh0ZXh0LCAnJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaXNOZXh0TGluZUluZGVudGVkID0gZnVuY3Rpb24oaWdub3JlQ29tbWVudHMpIHtcbiAgICB2YXIgRU9GLCBjdXJyZW50SW5kZW50YXRpb24sIHJldDtcbiAgICBpZiAoaWdub3JlQ29tbWVudHMgPT0gbnVsbCkge1xuICAgICAgaWdub3JlQ29tbWVudHMgPSB0cnVlO1xuICAgIH1cbiAgICBjdXJyZW50SW5kZW50YXRpb24gPSB0aGlzLmdldEN1cnJlbnRMaW5lSW5kZW50YXRpb24oKTtcbiAgICBFT0YgPSAhdGhpcy5tb3ZlVG9OZXh0TGluZSgpO1xuICAgIGlmIChpZ25vcmVDb21tZW50cykge1xuICAgICAgd2hpbGUgKCFFT0YgJiYgdGhpcy5pc0N1cnJlbnRMaW5lRW1wdHkoKSkge1xuICAgICAgICBFT0YgPSAhdGhpcy5tb3ZlVG9OZXh0TGluZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoIUVPRiAmJiB0aGlzLmlzQ3VycmVudExpbmVCbGFuaygpKSB7XG4gICAgICAgIEVPRiA9ICF0aGlzLm1vdmVUb05leHRMaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChFT0YpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuZ2V0Q3VycmVudExpbmVJbmRlbnRhdGlvbigpID4gY3VycmVudEluZGVudGF0aW9uKSB7XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLm1vdmVUb1ByZXZpb3VzTGluZSgpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5pc0N1cnJlbnRMaW5lRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJpbW1lZExpbmU7XG4gICAgdHJpbW1lZExpbmUgPSBVdGlscy50cmltKHRoaXMuY3VycmVudExpbmUsICcgJyk7XG4gICAgcmV0dXJuIHRyaW1tZWRMaW5lLmxlbmd0aCA9PT0gMCB8fCB0cmltbWVkTGluZS5jaGFyQXQoMCkgPT09ICcjJztcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmlzQ3VycmVudExpbmVCbGFuayA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyA9PT0gVXRpbHMudHJpbSh0aGlzLmN1cnJlbnRMaW5lLCAnICcpO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaXNDdXJyZW50TGluZUNvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbHRyaW1tZWRMaW5lO1xuICAgIGx0cmltbWVkTGluZSA9IFV0aWxzLmx0cmltKHRoaXMuY3VycmVudExpbmUsICcgJyk7XG4gICAgcmV0dXJuIGx0cmltbWVkTGluZS5jaGFyQXQoMCkgPT09ICcjJztcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBjb3VudCwgaSwgaW5kZW50LCBqLCBsLCBsZW4sIGxlbjEsIGxpbmUsIGxpbmVzLCByZWYsIHJlZjEsIHJlZjIsIHNtYWxsZXN0SW5kZW50LCB0cmltbWVkVmFsdWU7XG4gICAgaWYgKHZhbHVlLmluZGV4T2YoXCJcXHJcIikgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KFwiXFxyXFxuXCIpLmpvaW4oXCJcXG5cIikuc3BsaXQoXCJcXHJcIikuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgY291bnQgPSAwO1xuICAgIHJlZiA9IHRoaXMuUEFUVEVSTl9ZQU1MX0hFQURFUi5yZXBsYWNlQWxsKHZhbHVlLCAnJyksIHZhbHVlID0gcmVmWzBdLCBjb3VudCA9IHJlZlsxXTtcbiAgICB0aGlzLm9mZnNldCArPSBjb3VudDtcbiAgICByZWYxID0gdGhpcy5QQVRURVJOX0xFQURJTkdfQ09NTUVOVFMucmVwbGFjZUFsbCh2YWx1ZSwgJycsIDEpLCB0cmltbWVkVmFsdWUgPSByZWYxWzBdLCBjb3VudCA9IHJlZjFbMV07XG4gICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLm9mZnNldCArPSBVdGlscy5zdWJTdHJDb3VudCh2YWx1ZSwgXCJcXG5cIikgLSBVdGlscy5zdWJTdHJDb3VudCh0cmltbWVkVmFsdWUsIFwiXFxuXCIpO1xuICAgICAgdmFsdWUgPSB0cmltbWVkVmFsdWU7XG4gICAgfVxuICAgIHJlZjIgPSB0aGlzLlBBVFRFUk5fRE9DVU1FTlRfTUFSS0VSX1NUQVJULnJlcGxhY2VBbGwodmFsdWUsICcnLCAxKSwgdHJpbW1lZFZhbHVlID0gcmVmMlswXSwgY291bnQgPSByZWYyWzFdO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5vZmZzZXQgKz0gVXRpbHMuc3ViU3RyQ291bnQodmFsdWUsIFwiXFxuXCIpIC0gVXRpbHMuc3ViU3RyQ291bnQodHJpbW1lZFZhbHVlLCBcIlxcblwiKTtcbiAgICAgIHZhbHVlID0gdHJpbW1lZFZhbHVlO1xuICAgICAgdmFsdWUgPSB0aGlzLlBBVFRFUk5fRE9DVU1FTlRfTUFSS0VSX0VORC5yZXBsYWNlKHZhbHVlLCAnJyk7XG4gICAgfVxuICAgIGxpbmVzID0gdmFsdWUuc3BsaXQoXCJcXG5cIik7XG4gICAgc21hbGxlc3RJbmRlbnQgPSAtMTtcbiAgICBmb3IgKGogPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgbGluZSA9IGxpbmVzW2pdO1xuICAgICAgaWYgKFV0aWxzLnRyaW0obGluZSwgJyAnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbmRlbnQgPSBsaW5lLmxlbmd0aCAtIFV0aWxzLmx0cmltKGxpbmUpLmxlbmd0aDtcbiAgICAgIGlmIChzbWFsbGVzdEluZGVudCA9PT0gLTEgfHwgaW5kZW50IDwgc21hbGxlc3RJbmRlbnQpIHtcbiAgICAgICAgc21hbGxlc3RJbmRlbnQgPSBpbmRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzbWFsbGVzdEluZGVudCA+IDApIHtcbiAgICAgIGZvciAoaSA9IGwgPSAwLCBsZW4xID0gbGluZXMubGVuZ3RoOyBsIDwgbGVuMTsgaSA9ICsrbCkge1xuICAgICAgICBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIGxpbmVzW2ldID0gbGluZS5zbGljZShzbWFsbGVzdEluZGVudCk7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmlzTmV4dExpbmVVbkluZGVudGVkQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGN1cnJlbnRJbmRlbnRhdGlvbikge1xuICAgIHZhciBub3RFT0YsIHJldDtcbiAgICBpZiAoY3VycmVudEluZGVudGF0aW9uID09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRJbmRlbnRhdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50SW5kZW50YXRpb24gPT0gbnVsbCkge1xuICAgICAgY3VycmVudEluZGVudGF0aW9uID0gdGhpcy5nZXRDdXJyZW50TGluZUluZGVudGF0aW9uKCk7XG4gICAgfVxuICAgIG5vdEVPRiA9IHRoaXMubW92ZVRvTmV4dExpbmUoKTtcbiAgICB3aGlsZSAobm90RU9GICYmIHRoaXMuaXNDdXJyZW50TGluZUVtcHR5KCkpIHtcbiAgICAgIG5vdEVPRiA9IHRoaXMubW92ZVRvTmV4dExpbmUoKTtcbiAgICB9XG4gICAgaWYgKGZhbHNlID09PSBub3RFT0YpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuZ2V0Q3VycmVudExpbmVJbmRlbnRhdGlvbigpID09PSBjdXJyZW50SW5kZW50YXRpb24gJiYgdGhpcy5pc1N0cmluZ1VuSW5kZW50ZWRDb2xsZWN0aW9uSXRlbSh0aGlzLmN1cnJlbnRMaW5lKSkge1xuICAgICAgcmV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5tb3ZlVG9QcmV2aW91c0xpbmUoKTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaXNTdHJpbmdVbkluZGVudGVkQ29sbGVjdGlvbkl0ZW0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50TGluZSA9PT0gJy0nIHx8IHRoaXMuY3VycmVudExpbmUuc2xpY2UoMCwgMikgPT09ICctICc7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcblxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTAuMFxudmFyIFBhdHRlcm47XG5cblBhdHRlcm4gPSAoZnVuY3Rpb24oKSB7XG4gIFBhdHRlcm4ucHJvdG90eXBlLnJlZ2V4ID0gbnVsbDtcblxuICBQYXR0ZXJuLnByb3RvdHlwZS5yYXdSZWdleCA9IG51bGw7XG5cbiAgUGF0dGVybi5wcm90b3R5cGUuY2xlYW5lZFJlZ2V4ID0gbnVsbDtcblxuICBQYXR0ZXJuLnByb3RvdHlwZS5tYXBwaW5nID0gbnVsbDtcblxuICBmdW5jdGlvbiBQYXR0ZXJuKHJhd1JlZ2V4LCBtb2RpZmllcnMpIHtcbiAgICB2YXIgX2NoYXIsIGNhcHR1cmluZ0JyYWNrZXROdW1iZXIsIGNsZWFuZWRSZWdleCwgaSwgbGVuLCBtYXBwaW5nLCBuYW1lLCBwYXJ0LCBzdWJDaGFyO1xuICAgIGlmIChtb2RpZmllcnMgPT0gbnVsbCkge1xuICAgICAgbW9kaWZpZXJzID0gJyc7XG4gICAgfVxuICAgIGNsZWFuZWRSZWdleCA9ICcnO1xuICAgIGxlbiA9IHJhd1JlZ2V4Lmxlbmd0aDtcbiAgICBtYXBwaW5nID0gbnVsbDtcbiAgICBjYXB0dXJpbmdCcmFja2V0TnVtYmVyID0gMDtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgX2NoYXIgPSByYXdSZWdleC5jaGFyQXQoaSk7XG4gICAgICBpZiAoX2NoYXIgPT09ICdcXFxcJykge1xuICAgICAgICBjbGVhbmVkUmVnZXggKz0gcmF3UmVnZXguc2xpY2UoaSwgKyhpICsgMSkgKyAxIHx8IDllOSk7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoX2NoYXIgPT09ICcoJykge1xuICAgICAgICBpZiAoaSA8IGxlbiAtIDIpIHtcbiAgICAgICAgICBwYXJ0ID0gcmF3UmVnZXguc2xpY2UoaSwgKyhpICsgMikgKyAxIHx8IDllOSk7XG4gICAgICAgICAgaWYgKHBhcnQgPT09ICcoPzonKSB7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjbGVhbmVkUmVnZXggKz0gcGFydDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcoPzwnKSB7XG4gICAgICAgICAgICBjYXB0dXJpbmdCcmFja2V0TnVtYmVyKys7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBuYW1lID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgICAgICAgc3ViQ2hhciA9IHJhd1JlZ2V4LmNoYXJBdChpICsgMSk7XG4gICAgICAgICAgICAgIGlmIChzdWJDaGFyID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICBjbGVhbmVkUmVnZXggKz0gJygnO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFwcGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG1hcHBpbmdbbmFtZV0gPSBjYXB0dXJpbmdCcmFja2V0TnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IHN1YkNoYXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhbmVkUmVnZXggKz0gX2NoYXI7XG4gICAgICAgICAgICBjYXB0dXJpbmdCcmFja2V0TnVtYmVyKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFuZWRSZWdleCArPSBfY2hhcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW5lZFJlZ2V4ICs9IF9jaGFyO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB0aGlzLnJhd1JlZ2V4ID0gcmF3UmVnZXg7XG4gICAgdGhpcy5jbGVhbmVkUmVnZXggPSBjbGVhbmVkUmVnZXg7XG4gICAgdGhpcy5yZWdleCA9IG5ldyBSZWdFeHAodGhpcy5jbGVhbmVkUmVnZXgsICdnJyArIG1vZGlmaWVycy5yZXBsYWNlKCdnJywgJycpKTtcbiAgICB0aGlzLm1hcHBpbmcgPSBtYXBwaW5nO1xuICB9XG5cbiAgUGF0dGVybi5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBpbmRleCwgbWF0Y2hlcywgbmFtZSwgcmVmO1xuICAgIHRoaXMucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICBtYXRjaGVzID0gdGhpcy5yZWdleC5leGVjKHN0cik7XG4gICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcHBpbmcgIT0gbnVsbCkge1xuICAgICAgcmVmID0gdGhpcy5tYXBwaW5nO1xuICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICBpbmRleCA9IHJlZltuYW1lXTtcbiAgICAgICAgbWF0Y2hlc1tuYW1lXSA9IG1hdGNoZXNbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfTtcblxuICBQYXR0ZXJuLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdGhpcy5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB0aGlzLnJlZ2V4LnRlc3Qoc3RyKTtcbiAgfTtcblxuICBQYXR0ZXJuLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oc3RyLCByZXBsYWNlbWVudCkge1xuICAgIHRoaXMucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UodGhpcy5yZWdleCwgcmVwbGFjZW1lbnQpO1xuICB9O1xuXG4gIFBhdHRlcm4ucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbihzdHIsIHJlcGxhY2VtZW50LCBsaW1pdCkge1xuICAgIHZhciBjb3VudDtcbiAgICBpZiAobGltaXQgPT0gbnVsbCkge1xuICAgICAgbGltaXQgPSAwO1xuICAgIH1cbiAgICB0aGlzLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgY291bnQgPSAwO1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4LnRlc3Qoc3RyKSAmJiAobGltaXQgPT09IDAgfHwgY291bnQgPCBsaW1pdCkpIHtcbiAgICAgIHRoaXMucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHRoaXMucmVnZXgsICcnKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBbc3RyLCBjb3VudF07XG4gIH07XG5cbiAgcmV0dXJuIFBhdHRlcm47XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0dGVybjtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMC4wXG52YXIgUGF0dGVybiwgVW5lc2NhcGVyLCBVdGlscztcblxuVXRpbHMgPSByZXF1aXJlKCcuL1V0aWxzJyk7XG5cblBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcblxuVW5lc2NhcGVyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBVbmVzY2FwZXIoKSB7fVxuXG4gIFVuZXNjYXBlci5QQVRURVJOX0VTQ0FQRURfQ0hBUkFDVEVSID0gbmV3IFBhdHRlcm4oJ1xcXFxcXFxcKFswYWJ0XFx0bnZmcmUgXCJcXFxcL1xcXFxcXFxcTl9MUF18eFswLTlhLWZBLUZdezJ9fHVbMC05YS1mQS1GXXs0fXxVWzAtOWEtZkEtRl17OH0pJyk7XG5cbiAgVW5lc2NhcGVyLnVuZXNjYXBlU2luZ2xlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFwnXFwnL2csICdcXCcnKTtcbiAgfTtcblxuICBVbmVzY2FwZXIudW5lc2NhcGVEb3VibGVRdW90ZWRTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl91bmVzY2FwZUNhbGxiYWNrID09IG51bGwpIHtcbiAgICAgIHRoaXMuX3VuZXNjYXBlQ2FsbGJhY2sgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy51bmVzY2FwZUNoYXJhY3RlcihzdHIpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLlBBVFRFUk5fRVNDQVBFRF9DSEFSQUNURVIucmVwbGFjZSh2YWx1ZSwgdGhpcy5fdW5lc2NhcGVDYWxsYmFjayk7XG4gIH07XG5cbiAgVW5lc2NhcGVyLnVuZXNjYXBlQ2hhcmFjdGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgY2g7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIHN3aXRjaCAodmFsdWUuY2hhckF0KDEpKSB7XG4gICAgICBjYXNlICcwJzpcbiAgICAgICAgcmV0dXJuIGNoKDApO1xuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIHJldHVybiBjaCg3KTtcbiAgICAgIGNhc2UgJ2InOlxuICAgICAgICByZXR1cm4gY2goOCk7XG4gICAgICBjYXNlICd0JzpcbiAgICAgICAgcmV0dXJuIFwiXFx0XCI7XG4gICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgIHJldHVybiBcIlxcdFwiO1xuICAgICAgY2FzZSAnbic6XG4gICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgY2FzZSAndic6XG4gICAgICAgIHJldHVybiBjaCgxMSk7XG4gICAgICBjYXNlICdmJzpcbiAgICAgICAgcmV0dXJuIGNoKDEyKTtcbiAgICAgIGNhc2UgJ3InOlxuICAgICAgICByZXR1cm4gY2goMTMpO1xuICAgICAgY2FzZSAnZSc6XG4gICAgICAgIHJldHVybiBjaCgyNyk7XG4gICAgICBjYXNlICcgJzpcbiAgICAgICAgcmV0dXJuICcgJztcbiAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuICdcIic7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXR1cm4gJ1xcXFwnO1xuICAgICAgY2FzZSAnTic6XG4gICAgICAgIHJldHVybiBjaCgweDAwODUpO1xuICAgICAgY2FzZSAnXyc6XG4gICAgICAgIHJldHVybiBjaCgweDAwQTApO1xuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIHJldHVybiBjaCgweDIwMjgpO1xuICAgICAgY2FzZSAnUCc6XG4gICAgICAgIHJldHVybiBjaCgweDIwMjkpO1xuICAgICAgY2FzZSAneCc6XG4gICAgICAgIHJldHVybiBVdGlscy51dGY4Y2hyKFV0aWxzLmhleERlYyh2YWx1ZS5zdWJzdHIoMiwgMikpKTtcbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgICByZXR1cm4gVXRpbHMudXRmOGNocihVdGlscy5oZXhEZWModmFsdWUuc3Vic3RyKDIsIDQpKSk7XG4gICAgICBjYXNlICdVJzpcbiAgICAgICAgcmV0dXJuIFV0aWxzLnV0ZjhjaHIoVXRpbHMuaGV4RGVjKHZhbHVlLnN1YnN0cigyLCA4KSkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVW5lc2NhcGVyO1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuZXNjYXBlcjtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMC4wXG52YXIgUGF0dGVybiwgVXRpbHM7XG5cblBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcblxuVXRpbHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFV0aWxzKCkge31cblxuICBVdGlscy5SRUdFWF9MRUZUX1RSSU1fQllfQ0hBUiA9IHt9O1xuXG4gIFV0aWxzLlJFR0VYX1JJR0hUX1RSSU1fQllfQ0hBUiA9IHt9O1xuXG4gIFV0aWxzLlJFR0VYX1NQQUNFUyA9IC9cXHMrL2c7XG5cbiAgVXRpbHMuUkVHRVhfRElHSVRTID0gL15cXGQrJC87XG5cbiAgVXRpbHMuUkVHRVhfT0NUQUwgPSAvW14wLTddL2dpO1xuXG4gIFV0aWxzLlJFR0VYX0hFWEFERUNJTUFMID0gL1teYS1mMC05XS9naTtcblxuICBVdGlscy5QQVRURVJOX0RBVEUgPSBuZXcgUGF0dGVybignXicgKyAnKD88eWVhcj5bMC05XVswLTldWzAtOV1bMC05XSknICsgJy0oPzxtb250aD5bMC05XVswLTldPyknICsgJy0oPzxkYXk+WzAtOV1bMC05XT8pJyArICcoPzooPzpbVHRdfFsgXFx0XSspJyArICcoPzxob3VyPlswLTldWzAtOV0/KScgKyAnOig/PG1pbnV0ZT5bMC05XVswLTldKScgKyAnOig/PHNlY29uZD5bMC05XVswLTldKScgKyAnKD86XFwuKD88ZnJhY3Rpb24+WzAtOV0qKSk/JyArICcoPzpbIFxcdF0qKD88dHo+WnwoPzx0el9zaWduPlstK10pKD88dHpfaG91cj5bMC05XVswLTldPyknICsgJyg/OjooPzx0el9taW51dGU+WzAtOV1bMC05XSkpPykpPyk/JyArICckJywgJ2knKTtcblxuICBVdGlscy5MT0NBTF9USU1FWk9ORV9PRkZTRVQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDA7XG5cbiAgVXRpbHMudHJpbSA9IGZ1bmN0aW9uKHN0ciwgX2NoYXIpIHtcbiAgICB2YXIgcmVnZXhMZWZ0LCByZWdleFJpZ2h0O1xuICAgIGlmIChfY2hhciA9PSBudWxsKSB7XG4gICAgICBfY2hhciA9ICdcXFxccyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIHJlZ2V4TGVmdCA9IHRoaXMuUkVHRVhfTEVGVF9UUklNX0JZX0NIQVJbX2NoYXJdO1xuICAgIGlmIChyZWdleExlZnQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5SRUdFWF9MRUZUX1RSSU1fQllfQ0hBUltfY2hhcl0gPSByZWdleExlZnQgPSBuZXcgUmVnRXhwKCdeJyArIF9jaGFyICsgJycgKyBfY2hhciArICcqJyk7XG4gICAgfVxuICAgIHJlZ2V4TGVmdC5sYXN0SW5kZXggPSAwO1xuICAgIHJlZ2V4UmlnaHQgPSB0aGlzLlJFR0VYX1JJR0hUX1RSSU1fQllfQ0hBUltfY2hhcl07XG4gICAgaWYgKHJlZ2V4UmlnaHQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5SRUdFWF9SSUdIVF9UUklNX0JZX0NIQVJbX2NoYXJdID0gcmVnZXhSaWdodCA9IG5ldyBSZWdFeHAoX2NoYXIgKyAnJyArIF9jaGFyICsgJyokJyk7XG4gICAgfVxuICAgIHJlZ2V4UmlnaHQubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhMZWZ0LCAnJykucmVwbGFjZShyZWdleFJpZ2h0LCAnJyk7XG4gIH07XG5cbiAgVXRpbHMubHRyaW0gPSBmdW5jdGlvbihzdHIsIF9jaGFyKSB7XG4gICAgdmFyIHJlZ2V4TGVmdDtcbiAgICBpZiAoX2NoYXIgPT0gbnVsbCkge1xuICAgICAgX2NoYXIgPSAnXFxcXHMnO1xuICAgIH1cbiAgICByZWdleExlZnQgPSB0aGlzLlJFR0VYX0xFRlRfVFJJTV9CWV9DSEFSW19jaGFyXTtcbiAgICBpZiAocmVnZXhMZWZ0ID09IG51bGwpIHtcbiAgICAgIHRoaXMuUkVHRVhfTEVGVF9UUklNX0JZX0NIQVJbX2NoYXJdID0gcmVnZXhMZWZ0ID0gbmV3IFJlZ0V4cCgnXicgKyBfY2hhciArICcnICsgX2NoYXIgKyAnKicpO1xuICAgIH1cbiAgICByZWdleExlZnQubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhMZWZ0LCAnJyk7XG4gIH07XG5cbiAgVXRpbHMucnRyaW0gPSBmdW5jdGlvbihzdHIsIF9jaGFyKSB7XG4gICAgdmFyIHJlZ2V4UmlnaHQ7XG4gICAgaWYgKF9jaGFyID09IG51bGwpIHtcbiAgICAgIF9jaGFyID0gJ1xcXFxzJztcbiAgICB9XG4gICAgcmVnZXhSaWdodCA9IHRoaXMuUkVHRVhfUklHSFRfVFJJTV9CWV9DSEFSW19jaGFyXTtcbiAgICBpZiAocmVnZXhSaWdodCA9PSBudWxsKSB7XG4gICAgICB0aGlzLlJFR0VYX1JJR0hUX1RSSU1fQllfQ0hBUltfY2hhcl0gPSByZWdleFJpZ2h0ID0gbmV3IFJlZ0V4cChfY2hhciArICcnICsgX2NoYXIgKyAnKiQnKTtcbiAgICB9XG4gICAgcmVnZXhSaWdodC5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdleFJpZ2h0LCAnJyk7XG4gIH07XG5cbiAgVXRpbHMuaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICF2YWx1ZSB8fCB2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICcwJyB8fCAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDApO1xuICB9O1xuXG4gIFV0aWxzLnN1YlN0ckNvdW50ID0gZnVuY3Rpb24oc3RyaW5nLCBzdWJTdHJpbmcsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICB2YXIgYywgaSwgaiwgbGVuLCByZWYsIHN1YmxlbjtcbiAgICBjID0gMDtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgICBzdWJTdHJpbmcgPSAnJyArIHN1YlN0cmluZztcbiAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBzdWJsZW4gPSBzdWJTdHJpbmcubGVuZ3RoO1xuICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBsZW47IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgaWYgKHN1YlN0cmluZyA9PT0gc3RyaW5nLnNsaWNlKGksIHN1YmxlbikpIHtcbiAgICAgICAgYysrO1xuICAgICAgICBpICs9IHN1YmxlbiAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIFV0aWxzLmlzRGlnaXRzID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB0aGlzLlJFR0VYX0RJR0lUUy5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB0aGlzLlJFR0VYX0RJR0lUUy50ZXN0KGlucHV0KTtcbiAgfTtcblxuICBVdGlscy5vY3REZWMgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHRoaXMuUkVHRVhfT0NUQUwubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcGFyc2VJbnQoKGlucHV0ICsgJycpLnJlcGxhY2UodGhpcy5SRUdFWF9PQ1RBTCwgJycpLCA4KTtcbiAgfTtcblxuICBVdGlscy5oZXhEZWMgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHRoaXMuUkVHRVhfSEVYQURFQ0lNQUwubGFzdEluZGV4ID0gMDtcbiAgICBpbnB1dCA9IHRoaXMudHJpbShpbnB1dCk7XG4gICAgaWYgKChpbnB1dCArICcnKS5zbGljZSgwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgaW5wdXQgPSAoaW5wdXQgKyAnJykuc2xpY2UoMik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCgoaW5wdXQgKyAnJykucmVwbGFjZSh0aGlzLlJFR0VYX0hFWEFERUNJTUFMLCAnJyksIDE2KTtcbiAgfTtcblxuICBVdGlscy51dGY4Y2hyID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBjaDtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgaWYgKDB4ODAgPiAoYyAlPSAweDIwMDAwMCkpIHtcbiAgICAgIHJldHVybiBjaChjKTtcbiAgICB9XG4gICAgaWYgKDB4ODAwID4gYykge1xuICAgICAgcmV0dXJuIGNoKDB4QzAgfCBjID4+IDYpICsgY2goMHg4MCB8IGMgJiAweDNGKTtcbiAgICB9XG4gICAgaWYgKDB4MTAwMDAgPiBjKSB7XG4gICAgICByZXR1cm4gY2goMHhFMCB8IGMgPj4gMTIpICsgY2goMHg4MCB8IGMgPj4gNiAmIDB4M0YpICsgY2goMHg4MCB8IGMgJiAweDNGKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoKDB4RjAgfCBjID4+IDE4KSArIGNoKDB4ODAgfCBjID4+IDEyICYgMHgzRikgKyBjaCgweDgwIHwgYyA+PiA2ICYgMHgzRikgKyBjaCgweDgwIHwgYyAmIDB4M0YpO1xuICB9O1xuXG4gIFV0aWxzLnBhcnNlQm9vbGVhbiA9IGZ1bmN0aW9uKGlucHV0LCBzdHJpY3QpIHtcbiAgICB2YXIgbG93ZXJJbnB1dDtcbiAgICBpZiAoc3RyaWN0ID09IG51bGwpIHtcbiAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsb3dlcklucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgIGlmIChsb3dlcklucHV0ID09PSAnbm8nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXJJbnB1dCA9PT0gJzAnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlcklucHV0ID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlcklucHV0ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICEhaW5wdXQ7XG4gIH07XG5cbiAgVXRpbHMuaXNOdW1lcmljID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB0aGlzLlJFR0VYX1NQQUNFUy5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgIWlzTmFOKGlucHV0KSAmJiBpbnB1dC5yZXBsYWNlKHRoaXMuUkVHRVhfU1BBQ0VTLCAnJykgIT09ICcnO1xuICB9O1xuXG4gIFV0aWxzLnN0cmluZ1RvRGF0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBkYXRlLCBkYXksIGZyYWN0aW9uLCBob3VyLCBpbmZvLCBtaW51dGUsIG1vbnRoLCBzZWNvbmQsIHR6X2hvdXIsIHR6X21pbnV0ZSwgdHpfb2Zmc2V0LCB5ZWFyO1xuICAgIGlmICghKHN0ciAhPSBudWxsID8gc3RyLmxlbmd0aCA6IHZvaWQgMCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpbmZvID0gdGhpcy5QQVRURVJOX0RBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHllYXIgPSBwYXJzZUludChpbmZvLnllYXIsIDEwKTtcbiAgICBtb250aCA9IHBhcnNlSW50KGluZm8ubW9udGgsIDEwKSAtIDE7XG4gICAgZGF5ID0gcGFyc2VJbnQoaW5mby5kYXksIDEwKTtcbiAgICBpZiAoaW5mby5ob3VyID09IG51bGwpIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgaG91ciA9IHBhcnNlSW50KGluZm8uaG91ciwgMTApO1xuICAgIG1pbnV0ZSA9IHBhcnNlSW50KGluZm8ubWludXRlLCAxMCk7XG4gICAgc2Vjb25kID0gcGFyc2VJbnQoaW5mby5zZWNvbmQsIDEwKTtcbiAgICBpZiAoaW5mby5mcmFjdGlvbiAhPSBudWxsKSB7XG4gICAgICBmcmFjdGlvbiA9IGluZm8uZnJhY3Rpb24uc2xpY2UoMCwgMyk7XG4gICAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykge1xuICAgICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgICB9XG4gICAgICBmcmFjdGlvbiA9IHBhcnNlSW50KGZyYWN0aW9uLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWN0aW9uID0gMDtcbiAgICB9XG4gICAgaWYgKGluZm8udHogIT0gbnVsbCkge1xuICAgICAgdHpfaG91ciA9IHBhcnNlSW50KGluZm8udHpfaG91ciwgMTApO1xuICAgICAgaWYgKGluZm8udHpfbWludXRlICE9IG51bGwpIHtcbiAgICAgICAgdHpfbWludXRlID0gcGFyc2VJbnQoaW5mby50el9taW51dGUsIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR6X21pbnV0ZSA9IDA7XG4gICAgICB9XG4gICAgICB0el9vZmZzZXQgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwO1xuICAgICAgaWYgKCctJyA9PT0gaW5mby50el9zaWduKSB7XG4gICAgICAgIHR6X29mZnNldCAqPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuICAgIGlmICh0el9vZmZzZXQpIHtcbiAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIHR6X29mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xuICB9O1xuXG4gIFV0aWxzLnN0clJlcGVhdCA9IGZ1bmN0aW9uKHN0ciwgbnVtYmVyKSB7XG4gICAgdmFyIGksIHJlcztcbiAgICByZXMgPSAnJztcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG51bWJlcikge1xuICAgICAgcmVzICs9IHN0cjtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBVdGlscy5nZXRTdHJpbmdGcm9tRmlsZSA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEsIGZzLCBqLCBsZW4xLCBuYW1lLCByZWYsIHJlcSwgeGhyO1xuICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIHhociA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICByZWYgPSBbXCJNc3htbDIuWE1MSFRUUC42LjBcIiwgXCJNc3htbDIuWE1MSFRUUC4zLjBcIiwgXCJNc3htbDIuWE1MSFRUUFwiLCBcIk1pY3Jvc29mdC5YTUxIVFRQXCJdO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgIG5hbWUgPSByZWZbal07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHhociA9IG5ldyBBY3RpdmVYT2JqZWN0KG5hbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHVuZGVmaW5lZCkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeGhyICE9IG51bGwpIHtcbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDAgfHwgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB4aHIuc2VuZChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCBmYWxzZSk7XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVxID0gcmVxdWlyZTtcbiAgICAgIGZzID0gcmVxKCdmcycpO1xuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFN0cmluZyhkYXRhKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCk7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVXRpbHM7XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTAuMFxudmFyIER1bXBlciwgUGFyc2VyLCBVdGlscywgWWFtbDtcblxuUGFyc2VyID0gcmVxdWlyZSgnLi9QYXJzZXInKTtcblxuRHVtcGVyID0gcmVxdWlyZSgnLi9EdW1wZXInKTtcblxuVXRpbHMgPSByZXF1aXJlKCcuL1V0aWxzJyk7XG5cbllhbWwgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFlhbWwoKSB7fVxuXG4gIFlhbWwucGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcikge1xuICAgIGlmIChleGNlcHRpb25PbkludmFsaWRUeXBlID09IG51bGwpIHtcbiAgICAgIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iamVjdERlY29kZXIgPT0gbnVsbCkge1xuICAgICAgb2JqZWN0RGVjb2RlciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUGFyc2VyKCkucGFyc2UoaW5wdXQsIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpO1xuICB9O1xuXG4gIFlhbWwucGFyc2VGaWxlID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2ssIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdERlY29kZXIpIHtcbiAgICB2YXIgaW5wdXQ7XG4gICAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUgPT0gbnVsbCkge1xuICAgICAgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqZWN0RGVjb2RlciA9PSBudWxsKSB7XG4gICAgICBvYmplY3REZWNvZGVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBVdGlscy5nZXRTdHJpbmdGcm9tRmlsZShwYXRoLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfdGhpcy5wYXJzZShpbnB1dCwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gVXRpbHMuZ2V0U3RyaW5nRnJvbUZpbGUocGF0aCk7XG4gICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShpbnB1dCwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgWWFtbC5kdW1wID0gZnVuY3Rpb24oaW5wdXQsIGlubGluZSwgaW5kZW50LCBleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3RFbmNvZGVyKSB7XG4gICAgdmFyIHlhbWw7XG4gICAgaWYgKGlubGluZSA9PSBudWxsKSB7XG4gICAgICBpbmxpbmUgPSAyO1xuICAgIH1cbiAgICBpZiAoaW5kZW50ID09IG51bGwpIHtcbiAgICAgIGluZGVudCA9IDQ7XG4gICAgfVxuICAgIGlmIChleGNlcHRpb25PbkludmFsaWRUeXBlID09IG51bGwpIHtcbiAgICAgIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iamVjdEVuY29kZXIgPT0gbnVsbCkge1xuICAgICAgb2JqZWN0RW5jb2RlciA9IG51bGw7XG4gICAgfVxuICAgIHlhbWwgPSBuZXcgRHVtcGVyKCk7XG4gICAgeWFtbC5pbmRlbnRhdGlvbiA9IGluZGVudDtcbiAgICByZXR1cm4geWFtbC5kdW1wKGlucHV0LCBpbmxpbmUsIDAsIGV4Y2VwdGlvbk9uSW52YWxpZFR5cGUsIG9iamVjdEVuY29kZXIpO1xuICB9O1xuXG4gIFlhbWwucmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVxdWlyZV9oYW5kbGVyO1xuICAgIHJlcXVpcmVfaGFuZGxlciA9IGZ1bmN0aW9uKG1vZHVsZSwgZmlsZW5hbWUpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IFlBTUwucGFyc2VGaWxlKGZpbGVuYW1lKTtcbiAgICB9O1xuICAgIGlmICgodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVxdWlyZSAhPT0gbnVsbCA/IHJlcXVpcmUuZXh0ZW5zaW9ucyA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgcmVxdWlyZS5leHRlbnNpb25zWycueW1sJ10gPSByZXF1aXJlX2hhbmRsZXI7XG4gICAgICByZXR1cm4gcmVxdWlyZS5leHRlbnNpb25zWycueWFtbCddID0gcmVxdWlyZV9oYW5kbGVyO1xuICAgIH1cbiAgfTtcblxuICBZYW1sLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKGlucHV0LCBpbmxpbmUsIGluZGVudCwgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RW5jb2Rlcikge1xuICAgIHJldHVybiB0aGlzLmR1bXAoaW5wdXQsIGlubGluZSwgaW5kZW50LCBleGNlcHRpb25PbkludmFsaWRUeXBlLCBvYmplY3RFbmNvZGVyKTtcbiAgfTtcblxuICBZYW1sLmxvYWQgPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaywgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcikge1xuICAgIHJldHVybiB0aGlzLnBhcnNlRmlsZShwYXRoLCBjYWxsYmFjaywgZXhjZXB0aW9uT25JbnZhbGlkVHlwZSwgb2JqZWN0RGVjb2Rlcik7XG4gIH07XG5cbiAgcmV0dXJuIFlhbWw7XG5cbn0pKCk7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICB3aW5kb3cuWUFNTCA9IFlhbWw7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHdpbmRvdyA9PT0gbnVsbCkge1xuICB0aGlzLllBTUwgPSBZYW1sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFlhbWw7XG4iLCJpbXBvcnQgVEMgZnJvbSAnLi90YW5ncmFtJztcblxubW9kdWxlLmV4cG9ydHMgPSBUQztcbiIsImltcG9ydCBDQ1NTIGZyb20gJ3RhbmdyYW0tY2FydG9jc3MnO1xuaW1wb3J0IHlhbWwgZnJvbSAnLi95YW1sJztcbmltcG9ydCBtZDUgZnJvbSAnbWQ1JztcblxudmFyIFNPVVJDRVMgPSB7XG4gICAgbWFwbmlrOiB7XG4gICAgICAgIHR5cGU6ICdNVlQnXG4gICAgfVxufTtcblxudmFyIGdlbmVyYXRlU291cmNlcyA9IGZ1bmN0aW9uIGdlbmVyYXRlU291cmNlcyh1cmwpIHtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGR5bmFtaWMgaWYgaXQgaXMgbmVjY2Vzc2FyeVxuICB2YXIgc291cmNlID0gU09VUkNFU1snbWFwbmlrJ107XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBzb3VyY2UudHlwZSxcbiAgICB1cmw6IHVybFxuICB9O1xufTtcblxudmFyIFRDID0gZnVuY3Rpb24gKG1hcCkge1xuICBsZXQgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2NlbmUgPSBUYW5ncmFtLmxlYWZsZXRMYXllcih7XG4gICAgc2NlbmU6IHlhbWwuZ2V0QmFzZUZpbGUoKVxuICB9KS5hZGRUbyhtYXApLnNjZW5lO1xuXG4gIHRoaXMuc2NlbmUuc3Vic2NyaWJlKHtcbiAgICBsb2FkOiAoZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2NlbmUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5zY2VuZS51cGRhdGVDb25maWcoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2NlbmUudXBkYXRlQ29uZmlnKCksIDUwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuVEMucHJvdG90eXBlID0ge1xuICBvbkxvYWRlZDogZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy5zY2VuZS5zdWJzY3JpYmUoe1xuICAgICAgdmlld19jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIGkpIHtcbiAgICBsZXQgY29uZmlnID0gQ0NTUy5jYXJ0bzJEcmF3KGxheWVyLm1ldGEuY2FydG9jc3MsIGkpO1xuXG4gICAgY29uZmlnLmZvckVhY2gobCA9PiB7XG4gICAgICBsZXQgbHkgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBsYXllcjogbGF5ZXIuaWQsXG4gICAgICAgICAgc291cmNlOiAnQ2FydG9EQidcbiAgICAgICAgfSxcbiAgICAgICAgZHJhdzogbC5kcmF3LFxuICAgICAgICB2aXNpYmxlOiBsYXllci52aXNpYmxlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBsYXllck5hbWUgPSBtZDUobGF5ZXIuaWQgKyBsLm5hbWUpO1xuXG4gICAgICB0aGlzLnNjZW5lLmNvbmZpZy5sYXllcnNbbGF5ZXJOYW1lXSA9IGx5O1xuXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB0aGlzLnNjZW5lLmNvbmZpZy5zdHlsZXMsXG4gICAgICAgIGwuc3R5bGVzXG4gICAgICApO1xuXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB0aGlzLnNjZW5lLmNvbmZpZy50ZXh0dXJlcyxcbiAgICAgICAgbC50ZXh0dXJlc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMuc2NlbmUudXBkYXRlQ29uZmlnKHtyZWJ1aWxkOiB0cnVlfSk7XG4gIH0sXG5cbiAgYWRkRGF0YVNvdXJjZTogZnVuY3Rpb24gKHVybCkge1xuICAgIHRoaXMuc2NlbmUuc2V0RGF0YVNvdXJjZSgnQ2FydG9EQicsIGdlbmVyYXRlU291cmNlcyh1cmwpKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVEM7XG4iLCJpbXBvcnQgeWFtbGpzIGZyb20gJ3lhbWxqcyc7XG5cbmNvbnN0IFNPVVJDRVMgPSB7XG4gICAgbWFwbmlrOiB7XG4gICAgICAgIHR5cGU6ICdNVlQnLFxuICAgICAgICB1cmw6IGZ1bmN0aW9uKCB1cmwgKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoJ3tsYXllckluZGV4ZXN9JywgJ21hcG5paycpLnJlcGxhY2UoJy5wbmcnLCAnLm12dCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgZ2V0QmFzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBnZXRCYXNlUHJvcGVydGllcygpIHtcbiAgcmV0dXJuIHtcbiAgICBnbG9iYWw6IHtcbiAgICAgIGxhbmd1YWdlOiAnZW4nXG4gICAgfSxcbiAgICBmb250czoge1xuICAgICAgTW9udHNlcnJhdDoge1xuICAgICAgICB1cmw6ICdodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tL3MvbW9udHNlcnJhdC92Ny96aGN6LV9XaWhqU1FDMG9ISjlUQ1lMM2hwdzNwZ3kyZ0FpLUlwN1dQTWkwLndvZmYnXG4gICAgICB9XG4gICAgfSxcbiAgICBsYXllcnM6IHt9LFxuICAgIHN0eWxlczoge1xuICAgICAgICBwb2x5Z29uc19ibGVuZDoge1xuICAgICAgICAgICAgYmFzZTogJ3BvbHlnb25zJyxcbiAgICAgICAgICAgIGJsZW5kOiAnb3ZlcmxheSdcbiAgICAgICAgfSxcbiAgICAgICAgbGluZXNfYmxlbmQ6IHtcbiAgICAgICAgICAgIGJhc2U6ICdsaW5lcycsXG4gICAgICAgICAgICBibGVuZDogJ292ZXJsYXknXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50c19ibGVuZDoge1xuICAgICAgICAgICAgYmFzZTogJ3BvaW50cycsXG4gICAgICAgICAgICBibGVuZDogJ292ZXJsYXknXG4gICAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBnZW5lcmF0ZVlBTUwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB5YW1sanMuc3RyaW5naWZ5KCBnZXRCYXNlUHJvcGVydGllcygpLCAzKTtcbn07XG5cbmNvbnN0IGdldEJhc2VGaWxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTCggbmV3IEJsb2IoIFsgZ2VuZXJhdGVZQU1MKCkgXSApICk7XG59O1xuXG52YXIgeWFtbDtcbmV4cG9ydCBkZWZhdWx0IHlhbWwgPSB7XG4gIGdldEJhc2VGaWxlXG59O1xuIl19
